
================
DOM DEBUG OUTPUT
================

PAR Elektronische Gesundheitskarte und Telematikinfrastruktur
PAR Spezifikation des Card Operating System (COS)
PAR Elektrische Schnittstelle


TABLE(rows=6,cols=0+0)->
TR-> TD(0,0/1/1)->PAR Version TD(0,1/1/1)->PAR 3.12.0
TR-> TD(1,0/1/1)->PAR Revision TD(1,1/1/1)->PAR 548770
TR-> TD(2,0/1/1)->PAR Stand TD(2,1/1/1)->PAR 21.05.2019
TR-> TD(3,0/1/1)->PAR Status TD(3,1/1/1)->PAR Freigegeben für interne QS
TR-> TD(4,0/1/1)->PAR Klassifizierung TD(4,1/1/1)->PAR öffentlich
TR-> TD(5,0/1/1)->PAR Referenzierung TD(5,1/1/1)->PAR gemSpec_COS



METADATA: 
  Version: 3.12.0
  Revision: 548770
  Stand: 21.05.2019
  Status: Freigegeben für interne QS
  Klassifizierung: öffentlich
  Referenzierung: gemSpec_COS

PAR -HEADING(ids=Dokumentinformationen)Dokumentinformationen
PAR Es handelt sich hier um eine veränderte Fassung des Dokumentes für Karten der Generation 2.2.
PAR Die wichtigsten Änderungen gegenüber der Betriebssystemspezifikation der Generation 2.1 sind:

ORDERED-LIST->
LITEM->PAR Das Kommando GET RANDOM ist nicht länger an die Option_logische_Kanäle gebunden, sondern verpflichtend.LITEM->PAR Die Algorithmen rsaDecipherPKCS1_V1_5 und rsaEncipherPKCS1_V1_5 wurden aus dem normativen Funktionsumfang entfernt. Für Ver- und Entschlüsselung mittels RSA-Kryptographie steht nach wie vor rsaEncipherOaep und rsaDecipherOaep zur Verfügung und die Ver- und Entschlüsselung mittels elliptischer Kurven ist von dieser Änderung nicht betroffen.LITEM->PAR Die Priorisierung der Trailer wurde für die Kommandos in 14.6 so geändert, dass die Blockade eines Passwortobjekt auch bei bestehendem Transportschutz zuverlässig erkannt wird.LITEM->PAR Die Funktionspakete zu Option_DES und Option_RSA_CV wurden mitsamt den davon abhängigen Anforderungen entfernt.LITEM->PAR Die Performanzvorgaben wurden aktualisiert.
PAR Die wichtigsten Änderungen gegenüber der Betriebssystemspezifikation der Generation 2 sind:

ORDERED-LIST->
LITEM->PAR Der DES Algorithmus wurde aus dem normativen Umfang in ein optionales Funktionspaket verschoben, siehe (N000.030), entsprechende Performanzvorgaben wurden entfernt.

ORDERED-LIST->
LITEM->PAR CV-Zertifikate basierend auf dem RSA Algorithmus wurden in ein optionales Funktionspaket verschoben, siehe (N000.032) entsprechende Performanzvorgaben wurden entfernt.LITEM->PAR Performanzvorgaben angepasst, das bedeutet:
ORDERED-LIST->
LITEM->PAR Dort, wo die zugelassenen G2 COS deutlich performanter sind, wurden strengere Werte gesetzt undLITEM->PAR dort, wo die Performanzvorgaben viel zu streng waren, wurden sie an den Stand der Technik angepasst.LITEM->PAR Anforderungen zur Kürzung von keyReferenceList im Kommando LIST PUBLIC KEY präzisiert.LITEM->PAR Die RSA Schlüsselgenerierung wurde aus dem normativen Umfang in ein optionales Funktionspaket verschoben, siehe (N000.034).
PAR Die wichtigsten Änderungen gegenüber den Betriebssystemspezifikationen der Generation 1 sind:

ORDERED-LIST->
LITEM->PAR Alle Betriebssystemspezifikationen der Generation 1 wurden in diesem Dokument zusammengefasst.LITEM->PAR Alle SRQs zu den Betriebssystemspezifikationen wurden integriert.LITEM->PAR Die kontaktlose Datenübertragung und die Datenübertragung gemäß [ISO/IEC 7816-12] wurden aufgenommen.LITEM->PAR Die Kryptographie gemäß [FIPS 197] (AES) und [BSI-TR-03111] (elliptische Kurven) wurden dem normativen Teil hinzugefügt.LITEM->PAR Für RSA-Schlüssel ist die Moduluslänge von 3072 bit zu unterstützen.
PAR Dokumentenhistorie

TABLE(rows=22,cols=45+50+35+241+73)->
TR-> TH(0,0/1/1)->PAR Version TH(0,1/1/1)->PAR Stand TH(0,2/1/1)->PAR Kap./ Seite TH(0,3/1/1)->PAR Grund der Änderung, besondere Hinweise TH(0,4/1/1)->PAR Bearbeitung
TR-> TD(1,0/1/1)->PAR 2.2.0 TD(1,1/1/1)->PAR R 0.5.2<br>R 0.5.3 TD(1,2/1/1)-> TD(1,3/1/1)->PAR Die Dokumentenhistorie zu freigegebenen Dokumenten im Release 0.5.2 bzw. 0.5.3 und Vorgängerversionen ist in den dort gültigen Dokumenten ausführlich dargestellt. TD(1,4/1/1)->PAR gematik
TR-> TD(2,0/1/1)->PAR 3.0.0 TD(2,1/1/1)->PAR 20.09.12 TD(2,2/1/1)-> TD(2,3/1/1)->PAR Zusammenfügen aller Generation 1 Betriebssystemspezifikationen<br>Einarbeitung aller SRQs zu Betriebssystemspezifikationen der Generation 1<br>Einarbeitung der Generation 2 Anforderungen, unter anderem: Kontaktlose Datenübertragung, Datenübertragung gemäß [ISO/IEC 7816-12], AES, elliptische Kurven, RSA Moduluslänge 3072 bit TD(2,4/1/1)->PAR gematik
TR-> TD(3,0/1/1)->PAR 3.1.0 TD(3,1/1/1)->PAR 30.01.13 TD(3,2/1/1)-> TD(3,3/1/1)->PAR Anpassung des normativen Umfangs, Fehlerkorrekturen TD(3,4/1/1)->PAR gematik
TR-> TD(4,0/1/1)-> TD(4,1/1/1)->PAR 16.05.13 TD(4,2/1/1)-> TD(4,3/1/1)->PAR Fehlerkorrekturen TD(4,4/1/1)->PAR PL P71
TR-> TD(5,0/1/1)-> TD(5,1/1/1)->PAR 20.09.13 TD(5,2/1/1)-> TD(5,3/1/1)->PAR Präzisierung PACE<br>Einarbeitung von Kommentaren TD(5,4/1/1)->PAR PL P71
TR-> TD(6,0/1/1)->PAR 3.2.0 TD(6,1/1/1)->PAR 22.10.13 TD(6,2/1/1)-> TD(6,3/1/1)->PAR Einarbeitung von Kommentaren TD(6,4/1/1)->PAR gematik
TR-> TD(7,0/1/1)->PAR 3.2.1 TD(7,1/1/1)->PAR 11.12.13 TD(7,2/1/1)-> TD(7,3/1/1)->PAR LIST PUBLIC KEY Kommando, Cachen von importierten Schlüsseln, Einarbeitung Kommentare TD(7,4/1/1)->PAR gematik
TR-> TD(8,0/1/1)->PAR 3.4.0 TD(8,1/1/1)->PAR 21.02.14 TD(8,2/1/1)-> TD(8,3/1/1)->PAR Fehlerkorrekturen TD(8,4/1/1)->PAR gematik
TR-> TD(9,0/1/1)->PAR 3.5.0 TD(9,1/1/1)->PAR 01.04.14 TD(9,2/1/1)-> TD(9,3/1/1)->PAR Fehlerbereinigung TD(9,4/1/1)->PAR gematik
TR-> TD(10,0/1/1)->PAR 3.6.0 TD(10,1/1/1)->PAR 06.06.14 TD(10,2/1/1)-> TD(10,3/1/1)->PAR Öffentliche RSA 3072 aus normativem Umfang entfernt, Fehlerbereinigungen TD(10,4/1/1)->PAR gematik
TR-> TD(11,0/1/1)->PAR 3.7.0 TD(11,1/1/1)->PAR 26.08.14 TD(11,2/1/1)-> TD(11,3/1/1)->PAR Einarbeitung Iteration 4 TD(11,4/1/1)->PAR gematik
TR-> TD(12,0/1/1)->PAR 3.8.0 TD(12,1/1/1)->PAR 17.07.15 TD(12,2/1/1)-> TD(12,3/1/1)->PAR Folgende Errata eingearbeitet:    <br>R1.4.2 TD(12,4/1/1)->PAR Technik / SPE
TR-> TD(13,0/1/1)->PAR 3.9.0 TD(13,1/1/1)->PAR 24.08.16 TD(13,2/1/1)-> TD(13,3/1/1)->PAR Anpassungen zum Online-Produktivbetrieb (Stufe 1) TD(13,4/1/1)->PAR gematik
TR-> TD(14,0/1/1)-> TD(14,1/1/1)->PAR 02.03.17 TD(14,2/1/1)-> TD(14,3/1/1)->PAR DES aus dem normativen Umfang entfernt TD(14,4/1/1)->PAR gematik
TR-> TD(15,0/1/1)->PAR 3.10.0 TD(15,1/1/1)->PAR 21.04.17 TD(15,2/1/1)-> TD(15,3/1/1)->PAR freigegeben TD(15,4/1/1)->PAR gematik
TR-> TD(16,0/1/1)->PAR 3.11.0 TD(16,1/1/1)->PAR 14.05.18 TD(16,2/1/1)-> TD(16,3/1/1)->PAR RSA Schlüsselgenerierung aus normativem Umfang entfernt  TD(16,4/1/1)->PAR gematik
TR-> TD(17,0/1/1)->PAR 3.12.0 CC TD(17,1/1/1)->PAR 01.03.19 TD(17,2/1/1)-> TD(17,3/1/1)->PAR Einarbeitung C_6725, GET RANDOM TD(17,4/1/1)->PAR gematik
TR-> TD(18,0/1/1)-> TD(18,1/1/1)->PAR 12.03.19 TD(18,2/1/1)-> TD(18,3/1/1)->PAR rsaDecipherPKCS1_V1_5 und rsaEncipherPKCS1_V1_5 entfernt TD(18,4/1/1)->PAR TEC/TN afi
TR-> TD(19,0/1/1)-> TD(19,1/1/1)->PAR 27.03.19 TD(19,2/1/1)-> TD(19,3/1/1)->PAR PasswordBlocked höher priorisiert TD(19,4/1/1)->PAR TEC/TN afi
TR-> TD(20,0/1/1)->PAR 3.12.0 TD(20,1/1/1)->PAR 15.05.19 TD(20,2/1/1)-> TD(20,3/1/1)->PAR freigegeben TD(20,4/1/1)->PAR gematik
TR-> TD(21,0/1/1)->PAR 3.12.1 TD(21,1/1/1)->PAR TODO TD(21,2/1/1)-> TD(21,3/1/1)->PAR TODO TD(21,4/1/1)->PAR TEC/TN afi
PAR -HEADING(ids=Inhaltsverzeichnis)Inhaltsverzeichnis

<PLACEHOLDER>

PAR -HEADING(ids=1)1 CosK_c31 Einordnung des Dokuments (informativ)
PAR -HEADING(ids=1.1)1.1 CosK_c52 Zielsetzung
PAR Diese Spezifikation definiert die Anforderungen an die Funktionalität einer Betriebssystemplattform (COS-Plattform) für elektronische Karten im Gesundheitswesen (eGK, HBA, …), die internationalen Standards entsprechen und die internationale sowie europäische Interoperabilität sicherstellen.
PAR Im Einzelnen werden auf der Basis von [ISO/IEC 7816-4], [ISO/IEC 7816-8] und [ISO/IEC 7816-9] Kommandos und Optionen beschrieben, die vom COS zu unterstützen sind.
PAR Der Aufbau dieses Dokumentes gliedert sich wie folgt:

LIST->

LIST->
LITEM->PAR CosK_c31 Einordnung des Dokuments enthält Aussagen zum Umgang mit diesem Dokument.LITEM->PAR CosK_70a Optionen beschreibt und listet Funktionspakete, die nicht zwingend in allen Kartentypen vorhanden sind. wird in einer späteren Version Eingangsanforderungen enthalten, welche die Basis für die normativen Aussagen in späteren Kapiteln bilden werden.LITEM->PAR CosK_c19 Systemüberblick wird in einer späteren Version Grundlagen zu Betriebssystemen für Smartcards enthalten, die auf der Normenreihe ISO/IEC 7816 basieren.LITEM->PAR CosK_91f Lebenszyklus von Karte und Applikation grenzt den Gültigkeitsbereich der Spezifikation aus zeitlicher Sicht ab.LITEM->PAR CosK_2b8 Datentypen und Datenkonvertierung definiert einige grundlegende Datentypen, welche die normativen Beschreibungen in späteren Kapiteln vereinfachen.LITEM->PAR CosK_ab0 Kryptographische Algorithmen definiert einige grundlegende kryptographische Funktionen, welche die normativen Beschreibungen in späteren Kapiteln vereinfachen.LITEM->PAR CosK_81a CV-Zertifikat beschreibt Zertifikate, welche zu nutzen sind, um öffentliche Schlüssel in eine Smartcard zu importieren.LITEM->PAR CosK_f55 Objekte enthält eine Art Klassendiagramm in textueller Form. Die dort definierten Objekte und Attribute vereinfachen die normativen Beschreibungen in nachfolgenden Kapiteln.LITEM->PAR CosK_e16 Objektsystem beschreibt, wie sich Informationen persistent auf einer Smartcard hierarchisch speichern lassen.LITEM->PAR CosK_893 Zugriffskontrolle beschreibt den Schutz von Informationen auf einer Smartcard vor unberechtigtem Zugriff.LITEM->PAR CosK_581 Kommunikation beschreibt, wie die Smartcard Informationen mit anderen Systemen austauscht.LITEM->PAR CosK_d0b Kanalkontext beschreibt die Informationen, welche volatil und kanalspezifisch (zu logischen Kanälen siehe auch [ISO/IEC 7816-4]) von der Smartcard gespeichert werden.LITEM->PAR CosK_2ff Gesicherte Kommunikation beschreibt, wie die Smartcard Informationen kryptographisch geschützt mit anderen Systemen austauscht.LITEM->PAR CosK_3a7 Kommandos enthält normative Aussagen zu Kommandos, welche an eine Smartcard geschickt werden und normative Aussagen, wie diese Kommandos von der Smartcard zu bearbeiten sind. Im Wesentlichen ist dies das wichtigste Kapitel des Dokumentes, weil es die äußere Sichtweise auf das Verhalten der Smartcard an der elektrischen Schnittstelle am umfassendsten beschreibt.LITEM->PAR CosK_8e4 Authentisierungsprotokolle beschreibt Sequenzen, die aus mehr als einem Kommando bestehen.LITEM->PAR CosK_b1b Verschiedenes spezifiziert konkrete Werte für eine Reihe von Platzhaltern.LITEM->PAR CosK_9b0 Vorgaben zur Performanz enthält Anforderungen an einen Performanztest.
PAR Das Dokument ist "bottom up" aufgebaut, das bedeutet, Artefakte werden zunächst beschrieben und definiert, bevor sie verwendet werden. Für eine "top down" Herangehensweise empfiehlt es sich, mit CosK_3a7 zu beginnen. Dort werden, wenn möglich, Verweise auf andere Kapitel gesetzt, wenn Dinge dort ausführlicher beschrieben werden. Wegen der besonderen Bedeutung von CosK_3a7 wird dessen Aufbau im Folgenden näher beleuchtet:
PAR CosK_3a7enthält alle in der Normenreihe ISO/IEC 7816 standardisierten Kommandos. Der besseren Übersichtlichkeit halber ist CosK_3a7 unterteilt in die Abschnitte Management des Objektsystems, Zugriff auf Daten in transparenten EF, Zugriff auf strukturierte Daten, Benutzerverifikation, Komponentenauthentisierung, kryptographische Operationen und Verschiedenes. Jeder Abschnitt enthält eine Reihe von Unterabschnitten mit Kommandos in alphabetischer Reihenfolge.
PAR -HEADING(ids=1.2)1.2 CosK_ec4 Zielgruppe
PAR Das Dokument richtet sich an Hersteller von Smartcard-Betriebssystemen und an Hersteller von Anwendungen, welche unmittelbar mit einer Smartcard kommunizieren.
PAR -HEADING(ids=1.3)1.3 CosK_a38 Geltungsbereich
PAR Dieses Dokument enthält normative Festlegungen zur Telematikinfrastruktur des deutschen Gesundheitswesens. Der Gültigkeitszeitraum der vorliegenden Version und deren Anwendung in Zulassungs- oder Abnahmeverfahren wird durch die gematik GmbH in gesonderten Dokumenten (z.B. Dokumentenlandkarte, Produkttypsteckbrief, Leistungsbeschreibung) festgelegt und bekannt gegeben.
PAR Der Inhalt des Dokumentes ist verbindlich für die Erstellung elektronischer Karten im Gesundheitswesen.
PAR Schutzrechts-/Patentrechtshinweis
PAR Die nachfolgende Spezifikation ist von der gematik allein unter technischen Gesichtspunkten erstellt worden. Im Einzelfall kann nicht ausgeschlossen werden, dass die Implementierung der Spezifikation in technische Schutzrechte Dritter eingreift. Es ist allein Sache des Anbieters oder Herstellers, durch geeignete Maßnahmen dafür Sorge zu tragen, dass von ihm aufgrund der Spezifikation angebotene Produkte und/oder Leistungen nicht gegen Schutzrechte Dritter verstoßen und sich ggf. die erforderlichen Erlaubnisse/Lizenzen von den betroffenen Schutzrechtsinhabern einzuholen. Die gematik GmbH übernimmt insofern keinerlei Gewährleistungen.
PAR -HEADING(ids=1.4)1.4 CosK_4d2 Abgrenzung des Dokuments
PAR Dieses Dokument spezifiziert das Verhalten an der elektrischen Schnittstelle zu einem Smartcard-Betriebssystem (Card Operating System, COS). Dieses Dokument spezifiziert NICHT die Architektur des COS. Der einfacheren Darstellung wegen, wird in diesem Dokument von einer modularen Aufteilung des COS ausgegangen. Die hier beschriebene Aufteilung ist nicht verpflichtend. Es wird aber empfohlen, sich an dieser Aufteilung zu orientieren, weil bei künftigen Ergänzungen und Erweiterungen die hier beschriebene Aufteilung zu Grunde gelegt wird.
PAR Die Konfiguration einer Smartcard, also die Festlegung, welche Applikationen, Ordner, Dateien, Schlüssel und Passwörter etwa auf einer Versicherten- Leistungserbringer, Geräte oder sonstigen Karte finden sind, ist nicht Gegenstand dieses Dokumentes. Diese finden sich den kartenspezifischen Festlegungen zum Objektsystem (z. B. in [gemSpec_eGK_ObjSys], [gemSpec_HBA_ObjSys], [gemSpec_SMC-B_ObjSys]).
PAR In Absprache mit den Verantwortlichen des Dokumentes [gemSpec_Krypt] werden in diesem Dokument bewusst Redundanzen zum vorgenannten Dokument akzeptiert. Trotzdem ist [gemSpec_Krypt] relevant für eine konkrete Karte, da dort, anders als in diesem Dokument, normative Vorgaben für die Nutzungsdauer gewisser kryptographischer Verfahren getroffen werden, die hier beschrieben werden.
PAR -HEADING(ids=1.5)1.5 Methodik
PAR -HEADING(ids=1.5.1)1.5.1 Nomenklatur der Präfixe
PAR (ids=Tabelle-1,-CosT_1e0)Tabelle 1, CosT_1e0: Präfixe, die auf Vielfachen von Zehnerpotenzen beruhen:

TABLE(rows=9,cols=48+62+220+258)->
TR-> TH(0,0/1/1)->PAR Name TH(0,1/1/1)->PAR Symbol TH(0,2/1/1)->PAR Wert gemäß SI TH(0,3/1/1)->PAR nächstliegende Zweierpotenz
TR-> TD(1,0/1/1)->PAR kilo TD(1,1/1/1)->PAR k TD(1,2/1/1)->PAR 10<sup>3</sup>  = 1.000 TD(1,3/1/1)->PAR 2<sup>10</sup> = 1.024
TR-> TD(2,0/1/1)->PAR mega TD(2,1/1/1)->PAR M TD(2,2/1/1)->PAR 10<sup>6</sup>  = 1.000.000 TD(2,3/1/1)->PAR 2<sup>20</sup> = 1.048.576
TR-> TD(3,0/1/1)->PAR giga TD(3,1/1/1)->PAR G TD(3,2/1/1)->PAR 10<sup>9</sup>  = 1.000.000.000 TD(3,3/1/1)->PAR 2<sup>30</sup> = 1.073.741.824
TR-> TD(4,0/1/1)->PAR tera TD(4,1/1/1)->PAR T TD(4,2/1/1)->PAR 10<sup>12</sup> = 1.000.000.000.000 TD(4,3/1/1)->PAR 2<sup>40</sup> = 1.099.511.627.776
TR-> TD(5,0/1/1)->PAR peta TD(5,1/1/1)->PAR P TD(5,2/1/1)->PAR 10<sup>15</sup> = 1.000.000.000.000.000 TD(5,3/1/1)->PAR 2<sup>50</sup> = 1.125.899.906.842.624
TR-> TD(6,0/1/1)->PAR exa TD(6,1/1/1)->PAR E TD(6,2/1/1)->PAR 10<sup>18</sup> TD(6,3/1/1)->PAR 2<sup>60</sup>
TR-> TD(7,0/1/1)->PAR zetta TD(7,1/1/1)->PAR Z TD(7,2/1/1)->PAR 10<sup>21</sup> TD(7,3/1/1)->PAR 2<sup>70</sup>
TR-> TD(8,0/1/1)->PAR yotta TD(8,1/1/1)->PAR Y TD(8,2/1/1)->PAR 10<sup>24</sup> TD(8,3/1/1)->PAR 2<sup>80</sup>
PAR Die folgende Tabelle basiert auf [BinPrefix].
PAR (ids=Tabelle-2,-CosT_c5e)Tabelle 2, CosT_c5e: Präfixe, die auf Vielfachen von Zweierpotenzen beruhen:

TABLE(rows=9,cols=49+60+484)->
TR-> TH(0,0/1/1)->PAR Name TH(0,1/1/1)->PAR Symbol TH(0,2/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR kibi TD(1,1/1/1)->PAR Ki TD(1,2/1/1)->PAR 2<sup>10</sup> = 1024<sup>1</sup> = 1.024
TR-> TD(2,0/1/1)->PAR mebi TD(2,1/1/1)->PAR Mi TD(2,2/1/1)->PAR 2<sup>20</sup> = 1024<sup>2</sup> = 1.048.576
TR-> TD(3,0/1/1)->PAR gibi TD(3,1/1/1)->PAR Gi TD(3,2/1/1)->PAR 2<sup>30</sup> = 1024<sup>3</sup> = 1.073.741.824
TR-> TD(4,0/1/1)->PAR tebi TD(4,1/1/1)->PAR Ti TD(4,2/1/1)->PAR 2<sup>40</sup> = 1024<sup>4</sup> = 1.099.511.627.776
TR-> TD(5,0/1/1)->PAR pebi TD(5,1/1/1)->PAR Pi TD(5,2/1/1)->PAR 2<sup>50</sup> = 1024<sup>5</sup> = 1.125.899.906.842.624
TR-> TD(6,0/1/1)->PAR exbi TD(6,1/1/1)->PAR Ei TD(6,2/1/1)->PAR 2<sup>60</sup> = 1024<sup>6</sup> = 1.152.921.504.606.846.976
TR-> TD(7,0/1/1)->PAR zebi TD(7,1/1/1)->PAR Zi TD(7,2/1/1)->PAR 2<sup>70</sup> = 1024<sup>7</sup> = 1.180.591.620.717.411.303.424
TR-> TD(8,0/1/1)->PAR yobi TD(8,1/1/1)->PAR Yi TD(8,2/1/1)->PAR 2<sup>80</sup> = 1024<sup>8</sup> = 1.208.925.819.614.629.174.706.176
PAR Hinweis CosH_3d9: Beispiel: 300 GB ≈ 279,4 GiB, sprich 300 Gigabyte sind ungefähr 279,4 Gibibyte.
PAR -HEADING(ids=1.5.2)1.5.2 Nomenklatur Verschiedenes
PAR In diesem Dokument wird eine objektorientierte Sichtweise verfolgt. Dazu werden etwa die Artefakte Datei (EF in der Nomenklatur nach [ISO/IEC 7816-4]) oder Schlüssel als Objekte aufgefasst und die Eigenschaften als Attribute des Objektes. Wenn Attribute eines Objektes angesprochen werden, dann wird die Notation obj.attribute verwendet. Wenn das Attribut wieder ein Objekt mit weiteren Attributen ist, dann sind auch längere Bezeichnungen möglich.
PAR (ids=Tabelle-3,-CosT_9f7)Tabelle 3, CosT_9f7: Abkürzungen und Definitionen

TABLE(rows=7,cols=76+671)->
TR-> TD(0,0/1/1)->PAR G1 TD(0,1/1/1)->PAR Abkürzung für Generation 1, bezeichnet ältere Versionen des Dokumentes
TR-> TD(1,0/1/1)->PAR G2 TD(1,1/1/1)->PAR Abkürzung für Generation 2, bezeichnet aktuelle Versionen des Dokumentes
TR-> TD(2,0/1/1)->PAR '1D' TD(2,1/1/1)->PAR Hexadezimale Zahlen und Oktettstrings werden in Hochkommata eingeschlossen.
TR-> TD(3,0/1/1)->PAR 'XX' TD(3,1/1/1)->PAR Ein Oktett mit beliebigem Inhalt. Obwohl für das obere und untere Nibble dasselbe Symbol verwendet wird ist es möglich, dass die Nibble unterschiedlich sind.
TR-> TD(4,0/1/1)->PAR 'XX…XX' TD(4,1/1/1)->PAR Ein Oktettstring beliebiger Länge und beliebigen Inhalts.
TR-> TD(5,0/1/1)->PAR x || y TD(5,1/1/1)->PAR Das Symbol || steht für die Konkatenierung von Oktettstrings oder Bitstrings    <br>'1234'   ||   '5678'   ==   '12345678'
TR-> TD(6,0/1/1)->PAR y = x TD(6,1/1/1)->PAR Der Variablen y wird der Wert von x zugewiesen (Standardnotation in gängigen Programmiersprachen).
PAR Diese Dokumentenversion wurde mit Polarion statt mit Word erstellt. Das hat folgende Auswirkungen:

ORDERED-LIST->
LITEM->PAR In der Normenreihe ISO/IEC 7816 ist es üblich Kommandonamen mit Kapitälchen darzustellen. Weil dieses Feature in Polarion nicht verfügbar ist werden Kommandonamen in einem anderen Font dargestellt, beispielsweise READ BINARY, PSO Compute Digital Signature.LITEM->PAR Die N-Nummern enthalten oft eine Untergliederung in Unterpunkte, Unter-Unterpunkte, etc. Die Numerierung erfolgt in Word und Polarion teilsweise unterschiedlich:
ORDERED-LIST->
LITEM->PAR Die erste Gliederungsstufe ist sowohl in Word, als auch in Polarion alphabetisch: a, b, c, d, ...
ORDERED-LIST->
LITEM->PAR Die zweite Gliederungsstufe erfolgt numerisch mit arabischen Ziffern (Word: 1, 2, ...) bzw kleinen römischen Ziffern (Polarion: i, ii, iii, iv, v, ...)
ORDERED-LIST->
LITEM->PAR Die dritte Gliederungsstufe erfolgt in Word numerisch mit kleinen römischen Ziffern (i, ii, iii, iv, v, vi, ...) und in Polarion alphabetisch mit Großbuchstaben (A, B, C, ...).
ORDERED-LIST->
LITEM->PAR Die vierte Gliederungsstufe erfolgt in Word alphabetisch mit Großbuchstaben (A, B, C, ...) und in Polarion numerisch mit großen römischen Ziffern (I, II, III, IV, V, VI, ...)
ORDERED-LIST->
LITEM->PAR Weitere Gliederungsebenen werden in diesem Dokument in Anforderungen nicht verwendet.LITEM->PAR Daraus folgt, dass Referenzen auf N-Nummern sich von der Word-Version hin zur Polarion-Version möglicherweise unterscheiden, aber ineinander umrechenbar sind. Zudem ist erkennbar, falls in der Polarion-Version die Umrechnung unterblieb. Beispiel: Eine Referenz auf (N654.321)a.7.ii.D ist eine Word-Version, die in Polarion so lautet: (N654.321)a.vii.B.IV. Abgesehen von dieser anderen Art der Darstellung von N-Nummern auf tieferen Gliederungsebenen sind die N-Nummern in Polarion identisch zu den N-Nummern in der Word-Version.LITEM->PAR Automatische Referenzierungen wie in Word (beispielsweise siehe Kapitel 3.5.8, oder siehe Tabelle 4711) sind in Polarion nicht möglich. Ersatzweise werden händisch gepflegte Label nach folgendem Schema verwendet:
ORDERED-LIST->
LITEM->PAR CosA_xxx für Abbildungen,LITEM->PAR CosH_xxx für Hinweise,LITEM->PAR CosK_xxx für Kapitel, Unterkapitel, Unter-Unterkapitel, ...LITEM->PAR CosT_xxx für TabellenLITEM->PAR wobei xxx eine dreistellige Folge hexadezimaler Ziffern ist.
PAR -HEADING(ids=1.5.3)1.5.3 Normative und informative Abschnitte
PAR Abschnitte mit normativen Inhalten tragen hinter der Kapitelüberschrift den Hinweis:
PAR (normativ)
PAR Generell gilt, dass lediglich die Gliederungen, welche durch eine Nummer (N4711) gekennzeichnet sind, zulassungsrelevante Eigenschaften enthalten SOLLEN und somit im Rahmen der Zulassung getestet werden SOLLEN. Falls dies in einem speziellen Fall nicht so ist, handelt es sich höchstwahrscheinlich um einen editorischen Fehler.
PAR -HEADING(ids=1.5.4)1.5.4 Komponentenspezifische Anforderungen
PAR Da es sich beim vorliegenden Dokument um die Spezifikation einer Schnittstelle zwischen mehreren Komponenten handelt, ist es unvermeidlich, dass dieses Dokument Anforderungen für jede der Komponenten enthält. Die normativen Abschnitte tragen deshalb eine Kennzeichnung, auf welche Komponente sich die Anwendung primär bezieht. Dabei gelten natürlicherweise folgende Zusammenhänge:

LIST->
LITEM->PAR Alle normativen Anforderungen an die Komponenten K_Anwendungsspezifikation und K_externeWelt sind auch normative Anforderungen an diejenigen Komponenten, die in den jeweiligen Mengenklammern genannt sind.LITEM->PAR Für eine in der Mengenklammer aufgeführte Komponente ist es zulässig, mehr zu unterstützen als durch K_Anwendungsspezifikation oder K_externeWelt gefordert.LITEM->PAR Für eine in der Mengenklammer aufgeführte Komponente ist es zulässig, die Unterstützung von Dingen abzulehnen, die durch K_Anwendungsspezifikation oder K_externeWelt nicht gefordert werden.
PAR Die obigen Aussagen werden im Folgenden durch Beispiele verdeutlicht:

LIST->
LITEM->PAR In (N007.900) wird von K_Anwendungsspezifikation {K_Karte} gefordert, nur bestimmte seIdentifier zu verwenden, wenn die Anwendungsspezifikation für die Komponente K_COS bestimmt ist. Damit ist auch die maximale Anzahl von möglichen Security Environments in der Anwendung beschränkt. Einer Anwendungsspezifikation ist es nicht erlaubt, mehr SEs zu verwenden. Für das COS der Komponente K_COS bedeutet dies, dass es mindestens diese maximale Anzahl an SE zu unterstützen hat. Für das COS der Komponente K_COS ist es sowohl zulässig, mehr SEs zu unterstützen als auch zusätzliche SEs abzulehnen.LITEM->PAR In CosK_05a und CosK_1f5 werden im Zusammenhang mit dem Kommando READ BINARY Anforderungen an K_externeWelt {K_Karte} gestellt. Für die externe Welt ist es unzulässig, andere READ BINARY-Varianten zu verwenden. Für das COS bedeutet dies, dass es mindestens diese Varianten zu unterstützen hat. Für das COS ist es sowohl zulässig. mehr READ BINARY-Varianten zu unterstützen als auch zusätzliche READ BINARY-Varianten abzulehnen.
PAR (ids=Tabelle-4,-CosT_485)Tabelle 4, CosT_485: Liste der Komponenten, an welche dieses Dokument Anforderungen stellt

TABLE(rows=8,cols=191+556)->
TR-> TH(0,0/1/1)->PAR Komponente TH(0,1/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR K_Anwendungsspezifikation {…} TD(1,1/1/1)->PAR Instanz, welche eine Anwendung spezifiziert; damit gilt diese Anforderung auch für jede Anwen-dungsspezifikation, die für eine in der Mengenklammer genannte Komponente bestimmt ist
TR-> TD(2,0/1/1)->PAR K_COS TD(2,1/1/1)->PAR Betriebssystem einer Smartcard
TR-> TD(3,0/1/1)->PAR K_COS_G1 TD(3,1/1/1)->PAR Betriebssystem einer Smartcard in der Generation 1, es ist denkbar, dass derartig gekennzeichnete Anforderungen in späteren Versionen dieses Dokumentes entfallen
TR-> TD(4,0/1/1)->PAR K_IC TD(4,1/1/1)->PAR Das IC einer Smartcard
TR-> TD(5,0/1/1)->PAR K_Karte TD(5,1/1/1)->PAR beliebiger Kartentyp, Oberbegriff für die Menge {eGK, HBA, …}
TR-> TD(6,0/1/1)->PAR K_externeWelt {…} TD(6,1/1/1)->PAR Instanz, welche Nachrichten generiert, um diese an eine in der Mengenklammer genannte Komponente zu senden
TR-> TD(7,0/1/1)->PAR K_TST TD(7,1/1/1)->PAR Komponente funktionaler Zulassungstest
PAR -HEADING(ids=1.5.5)1.5.5 Verwendung von Schlüsselworten
PAR Anforderungen als Ausdruck normativer Festlegungen werden durch eine eindeutige ID in Klammern sowie die dem [RFC2119] entsprechenden, in Großbuchstaben geschriebenen deutschen Schlüsselworte MUSS, DARF NICHT, SOLL, SOLL NICHT, KANN gekennzeichnet. AbwandlungenKonjugationen von "MUSS" zu "MÜSSEN" etc. sind der Grammatik geschuldet. Falls in einem speziellen Fall die Verben müssen, dürfen, sollen, können ohne einen einzigen Großbuchstaben verwendet werden, handelt es sich höchstwahrscheinlich um einen editorischen Fehler.
PAR Da im Beispielsatz "Eine leere Liste DARF NICHT ein Element besitzen." die Phrase "DARF NICHT" semantisch irreführend wäre (wenn nicht ein, dann vielleicht zwei?), wird stattdessen "Eine leere Liste DARF KEIN Element besitzen." verwendet.
PAR In dieser Version wird das Verb "kann" in normativen Festlegungen nur noch für optionale Funktionspakete verwendet, aber nicht länger im Sinne von "zulässigen Implementierungsvarianten" oder "herstellerspezifischen Erweiterungen". Beispiel alt: (N002.200) Das COS KANN weitere Moduluslängen unterstützen oder ablehnen. Die gematik betrachtet normative Festlegungen mit dem Verb "kann" als Implementierungsvarianten und erfragt bei Herstellern welche konkrete Ausprägung gewählt wurde. Das ist im gezeigten Beispiel sinnlos. Deshalb wird die etwa in (N002.200) an einen Hersteller gerichtete Erlaubnis bestimmte Erweiterungen vorzunehmen oder zu unterlassen methodenkonform angepasst.
PAR In diesem Dokument werden Aussagen mit dem Schlüsselwort KANN generell sowohl positiv als auch negativ formuliert. (N002.200) ist im Zusammenhang mit (N002.100)a dafür ein gutes Beispiel. In (N002.100)a wird eine normative Forderung erhoben, die offen lässt, ob zusätzliche Werte fakultativ verboten sind oder nicht. Diese Lücke wird durch (N002.200) geschlossen.
PAR -HEADING(ids=2)2 CosK_70a Optionen (normativ)
PAR Dieses Unterkapitel listet Funktionspakete auf, die nicht zwingend erforderlich sind für eine Zulassung des COS im Sinne dieses Dokumentes.
REQ(ids=A_13543)<b>A_13543 - (N000.020) K_IC {K_Karte}, Option_USB_Schnittstelle</b>
PAR a. Das IC und das COS einer Smartcard KÖNNEN die Option_USB_Schnittstelle unterstützen.<br>b. Wenn das IC und das COS einer Smartcard die Option_USB_Schnittstelle

ORDERED-LIST->
LITEM->PAR unterstützen, dann sindMÜSSEN zusätzlich zu allen nicht gekennzeichneten Anforderungen auch alle Anforderungen zu erfüllen, die mit Option_USB_Schnittstelle gekennzeichnet sind.LITEM->PAR nicht unterstützen, dann sindDÜRFEN NICHT mit Option_USB_Schnittstelle gekennzeichnete Anforderung irrelevant für funktionale Tests sein.
PAR <b>[<=]</b>

REQ(ids=A_13546)<b>A_13546 - (N000.022) K_IC {K_Karte}, Option_kontaktlose_Schnittstelle</b>
PAR a. Das IC und das COS einer Smartcard KÖNNEN die Option_kontaktlose_Schnittstelle unterstützen.<br>b. Wenn das IC und das COS einer Smartcard die Option_kontaktlose_Schnittstelle

ORDERED-LIST->
LITEM->PAR unterstützen, dann sindMÜSSEN zusätzlich zu allen nicht gekennzeichneten Anforderungen auch alle Anforderungen zu erfüllen, die mit Option_kontaktlose_Schnittstelle gekennzeichnet sind.LITEM->PAR nicht unterstützt, dann sindDÜRFEN NICHT mit Option_kontaktlose_Schnittstelle gekennzeichnete Anforderung irrelevant für funktionale Tests sein.
PAR <b>[<=]</b>

REQ(ids=A_13549)<b>A_13549 - (N000.024) K_COS {K_Karte}, Option_logische_Kanäle</b>
PAR a. Das COS KANN die Option_logische_Kanäle unterstützen.<br>b. Wenn das COS die Option_logische_Kanäle

ORDERED-LIST->
LITEM->PAR unterstützt, dann sindMÜSSEN zusätzlich zu allen nicht gekennzeichneten Anforderungen auch alle Anforderungen zu erfüllen, die mit Option_logische_Kanäle gekennzeichnet sind.LITEM->PAR nicht unterstützt, dann sindDÜRFEN NICHT mit Option_logische_Kanäle gekennzeichnete Anforderung irrelevant für funktionale Tests sein.
PAR <b>[<=]</b>

REQ(ids=A_13552)<b>A_13552 - (N000.026) K_COS {K_Karte}, Option_Kryptobox</b>
PAR a. Das COS KANN die Option_Kryptobox unterstützen.<br>b. Wenn das COS die Option_Kryptobox

ORDERED-LIST->
LITEM->PAR unterstützt, dann sindMÜSSEN zusätzlich zu allen nicht gekennzeichneten Anforderungen auch alle Anforderungen zu erfüllen, die mit Option_Kryptobox gekennzeichnet sind.LITEM->PAR nicht unterstützt, dann sindDÜRFEN NICHT mit Option_Kryptobox gekennzeichnete Anforderung irrelevant für funktionale Tests sein.
PAR <b>[<=]</b>

REQ(ids=A_13555)<b>A_13555 - (N000.028) K_COS {K_Karte}, Option_PACE_PCD</b>
PAR a. Das COS KANN die Option_PACE_PCD unterstützen.<br>b. Wenn das COS die Option_PACE_PCD

ORDERED-LIST->
LITEM->PAR unterstützt, dann sindMÜSSEN zusätzlich zu allen nicht gekennzeichneten Anforderungen auch alle Anforderungen zu erfüllen, die mit Option_PACE_PCD gekennzeichnet sind.LITEM->PAR nicht unterstützt, dann sindDÜRFEN NICHT mit Option_PACE_PCD gekennzeichnete Anforderung irrelevant für funktionale Tests sein.
PAR <b>[<=]</b>

PAR Die folgenden Anforderungen sind absichtlich leer: (N000.030), (N000.032).
REQ(ids=A_13558)<b>A_13558 - (N000.030) K_COS {Karte}, Option_DES</b>
PAR a. Das COS KANN die Option_DES unterstützen.<br>b. Wenn das COS die Option_DES

ORDERED-LIST->
LITEM->PAR unterstützt, dann sindMÜSSEN zusätzlich zu allen nicht gekennzeichneten Anforderungen auch alle Anforderungen zu erfüllen, die mit Option_DES und Option_RSA_CVC gekennzeichnet sind.LITEM->PAR nicht unterstützt, dann sindDÜRFEN NICHT mit Option_DES gekennzeichnete Anforderung irrelevant für funktionale Tests.
PAR <b>[<=]</b>

PAR Hinweis CosH_032: Die Option_DES wird derzeit lediglich zur Implementierung von Karten der Generation 1 verwendet, also eGK G1 und eGK G1+. Die Option_DES ist für Karten der Generation 2 und später irrelevant.
REQ(ids=A_13561)<b>A_13561 - (N000.032) K_COS {Karte}, Option_RSA_CVC</b>
PAR a. Das COS KANN die Option_RSA_CVC unterstützen.<br>b. Wenn das COS die Option_RSA_CVC

ORDERED-LIST->
LITEM->PAR unterstützt, dann sindMÜSSEN zusätzlich zu allen nicht gekennzeichneten Anforderungen auch alle Anforderungen zu erfüllen, die mit Option_RSA_CVC gekennzeichnet sind.LITEM->PAR nicht unterstützt, dann sindDÜRFEN NICHT mit Option_RSA_CVC gekennzeichnete Anforderung irrelevant für funktionale Tests.
PAR <b>[<=]</b>

PAR Hinweis CosH_14c: Die Option_RSA_CVC wird derzeit zur Implementierung folgender Karten benötigt:<br>                            a. Karten der Generaion 1, also eGK G1 und eGK G1+,<br>                            b.HBA und SMC-B der Generation 2 und Generation G2.1.
REQ(ids=A_13564)<b>A_13564 - (N000.034) K_COS {Karte}, Option_RSA_KeyGeneration</b>
PAR a. Das COS KANN die Option_RSA_KeyGeneration unterstützen.<br>b. Wenn das COS die Option_RSA_KeyGeneration

ORDERED-LIST->
LITEM->PAR unterstützt, dann sind zusätzlich zu allen nicht gekennzeichneten Anforderungen auch alle Anforderungen zu erfüllen, die mit Option_RSA_KeyGeneration gekennzeichnet sind.LITEM->PAR nicht unterstützt, dann sind mit Option_RSA_KeyGeneration gekennzeichneten Anforderung irrelevant für funktionale Tests.
PAR <b>[<=]</b>

PAR Hinweis CosH_84b: Die Option_RSA_KeyGeneration wird derzeit lediglich im Rahmen der Personalisierung von Karten der Typen HBA und SMC-B sowie bei der Umsetzung der Option_lange_Lebensdauer verwendet.
PAR -HEADING(ids=3)3 CosK_c19 Systemüberblick (informativ)

ORDERED-LIST->
LITEM->PAR Smartcards sind sichere Datenspeicher.
ORDERED-LIST->
LITEM->PAR Smartcards speichern Daten in Dateien oder Rekords.LITEM->PAR Smartcards speichern personenbezogene Schlüssel für IAS-Services.LITEM->PAR Smartcards kontrollieren den Zugriff mittels Zugriffsregeln.
ORDERED-LIST->
LITEM->PAR Ein personenbezogener Zugriff wird durch Passwörter ermöglicht.LITEM->PAR Ein rollenbezogener Zugriff wird durch Authentisierungsschlüssel ermöglicht.LITEM->PAR Eine sichere Kommunikation wird durch "Trusted Channel" ermöglicht.LITEM->PAR Eine Smartcard kann sowohl als Start- als auch als Endpunkt eines Trusted Channels fungieren. D. h. diese Smartcard kann einerseits Sessionkeys im Applikationslayer für PSO-Kommandos verwenden, als auch im Secure Messaging Layer. Wo genau hängt von der algId bei der gegenseitigen Authentisierung ab.
PAR -HEADING(ids=4)4 CosK_91f Lebenszyklus von Karte und Applikation (informativ)
PAR In der Literatur finden sich verschiedene Beschreibungen für den Lebenszyklus von Karten. Dieses Kapitel stellt eine vereinfachte Sicht dar und legt dabei einen Gültigkeitsbereich für diese Spezifikation fest. Grob lässt sich der Lebenszyklus einer Karte in drei Phasen einteilen:

ORDERED-LIST->
LITEM->PAR Vorbereitungsphase: Diese Phase umfasst aus Sicht der Produktion alle Schritte, die erforderlich sind, um eine Karte für die Nutzungsphase vorzubereiten. Dazu zählen im Wesentlichen die Entwicklung des Betriebssystems, dessen Test, Abnahme und gegebenenfalls auch Evaluierung und Zulassung. Entsprechende Chips werden anschließend produziert, initialisiert und personalisiert. Die Chips werden in einen Kartenkörper implantiert und an einen Kartennutzer ausgeliefert. Die Reihenfolge der Produktionsschritte weicht unter bestimmten Umständen von der genannten Reihenfolge ab und ist hier lediglich beispielhaft skizziert. Dieses Dokument gilt nicht für die Vorbereitungsphase der Karte. Die Vorbereitungsphase der Karte endet spätestens mit der Übergabe der Karte an einen Kartennutzer. Dann beginnt die Nutzungsphase der Karte.LITEM->PAR Nutzungsphase: Diese Phase umfasst den elektrischen Gebrauch der Karte. Dieses Dokument gilt für die Nutzungsphase der elektrischen Kartenschnittstelle. Die Nutzungsphase der Karte endet, wenn sämtliche Business Use Cases irreversibel gesperrt sind, mithin also auch, wenn die Karte physikalisch zerstört wird.LITEM->PAR Terminierungsphase: Befindet sich die Karte in der Terminierungsphase, dann sind typischerweise alle intendierten Nutzungen der Karte irreversibel gesperrt. In der Regel lassen sich also weder Daten auslesen noch speichern und es ist keine Benutzerverifikation und auch keine Komponentenauthentisierung mehr möglich. Dies ist erreichbar durch eine physikalische Zerstörung des Chips, oder etwa auch durch die Unterstützung des Kommandos TERMINATE CARD USAGE (siehe (N048.700)). Da nach Ausführung eines solchen Kommandos herstellerspezifisch noch gewisse Kommandos möglich sind (etwa SELECT, GET CHALLENGE, …) oder die Übertragungsschicht T=1 möglicherweise noch aktiv ist, ist es nicht möglich, hier von einer Karte zu sprechen, die völlig inaktiv ist.
PAR Analog zu den Phasen einer Karte ist es möglich, auch für Applikationen oder deren Bestandteile (Dateien, Passwörter, Schlüssel, …) die Phasen Vorbereitung, Nutzung und Terminierung zu definieren. Die Aussagen zur physikalischen Zerstörung der Karte gehen dann über in ein Löschen der Applikation oder deren Bestandteile.
PAR Dieses Dokument gilt nicht für die Vorbereitungsphase von Applikationen oder deren Bestandteile. Sie beschreibt lediglich den Zustand des Objektsystems in der Nutzungsphase.
PAR Die Nutzungsphase einer Applikation oder eines Applikationsbestandteils beginnt, sobald sich ein derartiges Objekt, wie in der Spezifikation der Anwendung definiert, verwenden lässt. Die Nutzungsphase einer Applikation oder eines Applikationsbestandteils endet, wenn das entsprechende Objekt gelöscht wird.
PAR -HEADING(ids=5)5 CosK_2b8 Datentypen und Datenkonvertierung (normativ)
PAR Dieses Dokument verwendet die folgenden Datentypen äquivalent zu [BSI-TR-03111#3]:

ORDERED-LIST->
LITEM->PAR Oktettstring (OS),LITEM->PAR Bitstring (BS),LITEM->PAR Integer (I),LITEM->PAR Körperelement (Field Element FE) undLITEM->PAR elliptischen Kurvenpunkt (ECP).
PAR Definition: Das höchstwertige Bit (most significant bit, MSBit) eines Bitstrings ist das am weitesten links stehende.
PAR Definition: Das niedrigstwertige Bit (least significant bit, LSBit) eines Bitstrings ist das am weitesten rechts stehende.
PAR Definition: Das höchstwertige Oktett (most significant byte, MSByte) eines Oktettstrings ist das am weitesten links stehende.
PAR Definition: Das niedrigstwertige Oktett (least significant byte, LSByte) eines Oktettstrings ist das am weitesten rechts stehende.
PAR Dieses Dokument verwendet die folgenden Konvertierungsfunktionen äquivalent zum Dokument [BSI-TR-03111#3.1]:

ORDERED-LIST->
LITEM->PAR Bitstring nach Oktettstring BS2OS,LITEM->PAR Oktettstring nach Bitstring OS2BS,LITEM->PAR Körperelement nach Oktettstring FE2OS,LITEM->PAR Oktettstring nach Körperelement OS2FE.
PAR -HEADING(ids=5.1)5.1 BitLength Anzahl Bit in einem Bitstring
PAR Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird die hier beschriebene Funktion wie folgt verwendet:
REQ(ids=A_18235)<b>A_18235 - (N000.080) K_COS</b>
PAR (ids=Tabelle-5-,-CosT_89d)Tabelle 5 , CosT_89d: Definition der Funktion BitLength(...)

TABLE(rows=4,cols=98+55+589)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR in TD(0,2/1/1)->PAR Bitstring mit beliebigem Inhalt und beliebiger Länge
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR out TD(1,2/1/1)->PAR Integer, Anzahl der Bits aus denen in besteht
TR-> TD(2,0/1/1)->PAR Errors: TD(2,1/1/1)->PAR – TD(2,2/1/1)->PAR Keine
TR-> TD(3,0/1/1)->PAR Notation: TD(3,1/1/1)-> TD(3,2/1/1)->PAR out = BitLength( in )
PAR Das COS MUSS in out die Anzahl Bits von in zurückmelden.
PAR <b>[<=]</b>

PAR Hinweis CosH_fca: Beispiele:<br>            a. BitLength(     '' ) = 0<br>            b. BitLength(   '0' ) = 1,    BitLength(   '1' ) = 1,<br>            c. BitLength( '00' ) = 2,    BitLength( '01' ) = 2,<br>            d. BitLength( '10' ) = 2,    BitLength( '11' ) = 2, …
PAR -HEADING(ids=5.2)5.2 OctetLength Anzahl Oktett in einem Oktettstring
PAR Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird die hier beschriebene Funktion wie folgt verwendet:
REQ(ids=A_18234)<b>A_18234 - (N000.090) K_COS</b>
PAR (ids=Tabelle-6-,-CosT_f2b)Tabelle 6 , CosT_f2b: Definition der Funktion OctetLength(...)

TABLE(rows=4,cols=97+54+593)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR in TD(0,2/1/1)->PAR Oktettstring mit beliebigem Inhalt und beliebiger Länge, oder<br>nicht–negative ganze Zahl
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR out TD(1,2/1/1)->PAR Integer, Anzahl der Oktette aus denen in besteht, oder<br>Anzahl Oktette, die mindestens nötig sind, um eine nicht–negative ganze Zahl zu codieren.
TR-> TD(2,0/1/1)->PAR Errors: TD(2,1/1/1)->PAR – TD(2,2/1/1)->PAR Keine
TR-> TD(3,0/1/1)->PAR Notation: TD(3,1/1/1)-> TD(3,2/1/1)->PAR out = OctetLength( in )
PAR a. Wenn in ein Oktettstring ist, dann MUSS das COS in out die Anzahl der Oktett in in in zurückmelden.<br>b. Wenn in eine nicht-negative ganze Zahl ist, dann MUSS das COS in out die Mindestanzahl an Oktetten zurückmelden, die notwendig ist um in hexadezimal darzustellen.
PAR <b>[<=]</b>

PAR Hinweis CosH_f1b: Beispiele:<br>            a. OctetLength( '' )         = 0<br>            b. OctetLength( '0034' ) = 2<br>            c. OctetLength( 0 )        = 1, weil die Zahl 0 in einem Oktett codierbar ist, 0 = '00'.<br>            d. OctetLength( 127 )    = 1, weil 127 = '7F`<br>            e. OctetLength( 255 )    = 1, weil 255 = 'FF'<br>            f. OctetLength( 256 )     = 2, weil 256 = '0100'.
PAR Hinweis CosH_3cb, ACHTUNG: Der Oktettstring '0000FFFF' lässt sich als Repräsentant der Zahl 65535 interpretieren. Ohne führende Nullen lautet die hexadezimale Repräsentation der Zahl 65535='FFFF'. Daraus folgt:   OctetLength( '0000FFFF' ) = 4, aber OctetLength(65535) = 2.
PAR -HEADING(ids=5.3)5.3 I2OS Integer nach Oktettstring
PAR Dieser Abschnitt beschreibt die Konvertierung einer nicht-negativen ganzen Zahl in einen Oktettstring. Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird diese Konvertierung als Funktion wie folgt verwendet:
REQ(ids=A_13586)<b>A_13586 - (N000.100) K_COS</b>
PAR (ids=Tabelle-7,-CosT_042)Tabelle 7, CosT_042: Definition der Funktion I2OS(...)

TABLE(rows=5,cols=98+55+590)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR x TD(0,2/1/1)->PAR Integer, nicht-negative ganze Zahl
TR-> TD(1,1/1/1)->PAR n TD(1,2/1/1)->PAR Integer, nicht-negative ganze Zahl, Anzahl der Oktette in out,<br>n darf null sein, dann ist out leer
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR out TD(2,2/1/1)->PAR Oktettstring der Länge n Oktett
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine<br>ACHTUNG: Im Unterschied zu [BSI-TR-03111#3.1.2] wird hier keine Fehlermeldung erzeugt, falls x größer gleich 256<sup> n</sup> ist
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR out = I2OS( x, n )
PAR Das Prinzip ist, die nicht-negative ganze Zahl
PAR x
PAR als Ziffernfolge zur Basis 256 zu notieren und dann nur die niedrigwertigsten
PAR n
PAR Ziffern für die Ausgabe zu verwenden
PAR . Das COS MUSS dabei folgenden Algorithmus ausführen:
PAR a. Schritt 1:         
PAR x
PAR    = 256
PAR <sup>0</sup>
PAR x
PAR <sub>0</sub>
PAR + 256
PAR <sup>1</sup>
PAR x
PAR <sub>1</sub>
PAR + 256
PAR <sup>2</sup>
PAR x
PAR <sub>2</sub>
PAR + … + 256
PAR <sup>i</sup>
PAR x<sub>i</sub>
PAR + …
PAR b. Schritt 2:        
PAR M<sub>i</sub>
PAR   =
PAR x<sub>i</sub>
PAR .    
PAR                          
PAR AnmerkungHinweis CosH_bfc: Jede Ziffer x<sub>i</sub> wird vorzeichenlos in einem Oktett M<sub>i</sub> codiert.
PAR c. Schritt 3:         
PAR out
PAR =
PAR M<sub>n</sub><sub>–</sub>
PAR <sub>1</sub>
PAR   ||  
PAR M<sub>n</sub><sub>–2</sub>
PAR   ||   …   ||  
PAR M<sub>2</sub>
PAR   ||  
PAR M<sub>1</sub>
PAR   ||  
PAR M<sub>0</sub>
PAR .
PAR <b>[<=]</b>

PAR Hinweis CosH_7e6: In gewissen Grenzen ist dies die Umkehrfunktion zu (N000.200).
PAR Hinweis CosH_ff7: Beispiele:<br>            a. I2OS(30010, 1) = '3A',<br>            b. I2OS(30010, 2) = '753A',<br>            c. I2OS(30010, 3) = '00753A'.
PAR -HEADING(ids=5.4)5.4 OS2I Oktettstring nach Integer
PAR Dieser Abschnitt beschreibt die Konvertierung eines Oktettstrings in eine nicht–negative ganze Zahl. Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird diese Konvertierung als Funktion wie folgt verwendet:
REQ(ids=A_13587)<b>A_13587 - (N000.200) K_COS</b>
PAR (ids=Tabelle-8-,-CosT_c6a)Tabelle 8 , CosT_c6a: Definition der Funktion OS2I(...)

TABLE(rows=4,cols=94+53+595)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR in TD(0,2/1/1)->PAR Oktettstring beliebiger Länge und beliebigen Inhalts
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR out TD(1,2/1/1)->PAR Integer, nicht–negative ganze Zahl
TR-> TD(2,0/1/1)->PAR Errors: TD(2,1/1/1)->PAR – TD(2,2/1/1)->PAR Keine
TR-> TD(3,0/1/1)->PAR Notation: TD(3,1/1/1)-> TD(3,2/1/1)->PAR out = OS2I( in )
PAR Das Prinzip ist, jedes Oktett als Ziffer zur Basis 256 einer nicht-negativen ganzen Zahl im Big-Endian-Format aufzufassen.
PAR Das COS MUSS dabei folgenden Algorithmus ausführen:
PAR a. Schritt 1: 
PAR n
PAR  = OctetLength(
PAR in
PAR )
PAR b. Wenn
PAR n
PAR gleich null ist,
PAR     1. dann ist
PAR out
PAR = 0.
PAR     2. sonst wähle
PAR out
PAR so, dass I2OS(
PAR out
PAR ,
PAR n
PAR ) identisch zu
PAR in
PAR ist.
PAR <b>[<=]</b>

PAR Hinweis CosH_07c: In gewissen Grenzen ist dies die Umkehrfunktion zu (N000.100).
PAR -HEADING(ids=5.5)5.5 OS2P Oktettstring nach Punkt (uncompressed encoding)
PAR Dieser Abschnitt beschreibt die Konvertierung eines Oktettstrings in einen Punkt auf einer elliptischen Kurve. Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird diese Konvertierung als Funktion wie folgt verwendet:
REQ(ids=G2_N000.300)<b>G2_N000.300 - (N000.300) K_COS</b>
PAR (ids=Tabelle-9-,-CosT_3e0)Tabelle 9 , CosT_3e0: Definition der Funktion OS2P(...)

TABLE(rows=5,cols=98+85+559)->
TR-> TD(0,0/2/1)->PAR nput: TD(0,1/1/1)->PAR PO TD(0,2/1/1)->PAR Oktettstring, codiert einen Punkt auf einer elliptischen Kurve
TR-> TD(1,1/1/1)->PAR dP TD(1,2/1/1)->PAR Domainparameter gemäß (N008.600)
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR P TD(2,2/1/1)->PAR Punkt auf einer elliptischen Kurve mit den Koordinaten P = ( x, y )
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR ERROR TD(3,2/1/1)->PAR Wenn PO nicht im Format "uncompressed encoding" vorliegt
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR P = OS2P( PO, dP )
PAR Das COS MUSS die Decodierung von
PAR PO
PAR gemäß [BSI-TR-03111#3.2.1] durchführen:
PAR a. Schritt 1: Wenn OctetLength(
PAR PO
PAR ) ungleich (2
PAR dP.L
PAR + 1) ist,
PAR                   dann gebe den Fehler
PAR "ERROR"
PAR zurück und beende diesen Algorithmus.
PAR b. Schritt 2: Teile
PAR PO
PAR auf gemäß:
PAR                  
PAR PO
PAR   ==
PAR PC
PAR   ||  
PAR X
PAR   ||  
PAR Y
PAR ,
PAR                    1     == OctetLength(
PAR PC
PAR ),
PAR                   
PAR dp.L
PAR == OctetLength(
PAR X
PAR ) == OctetLength(
PAR Y
PAR ).
PAR c. Schritt 3: Wenn
PAR PC
PAR ungleich '04' ist,
PAR                   dann gebe den Fehler
PAR "ERROR"
PAR zurück und beende diesen Algorithmus.
PAR d. Schritt 4: Setze
PAR P
PAR  = (
PAR x
PAR ,
PAR y
PAR ) = ( OS2I(
PAR X
PAR ) mod
PAR dP.p
PAR , OS2I(
PAR Y
PAR ) mod
PAR dP.p
PAR ).
PAR e. Schritt 5: Wenn
PAR P
PAR nicht auf der durch
PAR dP
PAR definierten Kurve liegt,
PAR                   dann gebe den Fehler "
PAR ERROR
PAR " zurück und beende diesen Algorithmus.
PAR <b>[<=]</b>

PAR -HEADING(ids=5.6)5.6 P2OS Endlicher Punkt nach Oktettstring
PAR Dieser Abschnitt beschreibt die Konvertierung eines Punktes auf einer elliptischen Kurve in einen Oktettstring. Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird diese Konvertierung als Funktion wie folgt verwendet:
REQ(ids=A_13588)<b>A_13588 - (N000.400) K_COS</b>
PAR (ids=Tabelle-10-,-CosT_e43)Tabelle 10 , CosT_e43: Definition der Funktion P2OS(...)

TABLE(rows=5,cols=98+56+588)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR P TD(0,2/1/1)->PAR Punkt auf einer elliptischen Kurve mit den Koordinaten P = ( x, y )
TR-> TD(1,1/1/1)->PAR n TD(1,2/1/1)->PAR Integer, positive ganze Zahl, Anzahl Oktette pro Koordinate
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR PO TD(2,2/1/1)->PAR Oktettstring, codiert einen Punkt auf einer elliptischen Kurve
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR PO = P2OS( P, n )
PAR Das COS MUSS die Codierung von
PAR P
PAR gemäß [BSI-TR-03111#3.2.1] vornehmen:
PAR          
PAR PO
PAR = '04'   ||   I2OS(
PAR x
PAR ,
PAR n
PAR )   ||   I2OS(
PAR y
PAR ,
PAR n
PAR ).
PAR <b>[<=]</b>

PAR -HEADING(ids=5.7)5.7 Extrahiere führende Elemente
PAR -HEADING(ids=5.7.1)5.7.1 Extrahiere führende Bits
PAR Dieser Abschnitt beschreibt, wie aus einem Bitstring oder Oktettstring führende Bits extrahiert werden.
REQ(ids=A_18230)<b>A_18230 - (N000.500) K_COS</b>
PAR Das COS MUSS beim Aufruf dieser Funktion sicherstellen, dass n kleiner gleich s ist. <b>[<=]</b>

REQ(ids=A_18231)<b>A_18231 - (N000.600) K_COS</b>
PAR (ids=Tabelle-11-,-CosT_638)Tabelle 11 , CosT_638: Definition der Funktion Extract_MSBit(...)

TABLE(rows=5,cols=97+55+590)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR in TD(0,2/1/1)->PAR Entweder Bitstring der Länge s Bit, oder Oktettstring der Länge s Bit
TR-> TD(1,1/1/1)->PAR n TD(1,2/1/1)->PAR Integer, Anzahl der zu extrahierenden Bit
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR out TD(2,2/1/1)->PAR Bitstring der Länge n Bit
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR out = Extract_MSBit( in, n )
PAR Das COS MUSS in den
PAR Bitstring
PAR out
PAR die
PAR n
PAR MSBit von
PAR in
PAR einstellen.
PAR <b>[<=]</b>

PAR -HEADING(ids=5.7.2)5.7.2 Extrahiere führende Oktette
PAR Dieser Abschnitt beschreibt, wie aus einem Oktettstring führende Oktette extrahiert werden.
REQ(ids=A_18232)<b>A_18232 - (N000.700) K_COS</b>
PAR Das COS MUSS beim Aufruf dieser Funktion sicherstellen, dass n kleiner gleich s ist. <b>[<=]</b>

REQ(ids=A_18233)<b>A_18233 - (N000.800) K_COS</b>
PAR (ids=Tabelle-12-,-CosT_1ff)Tabelle 12 , CosT_1ff: Definition der Funktion Extract_MSByte(...)

TABLE(rows=5,cols=97+55+590)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR in TD(0,2/1/1)->PAR Oktettstring der Länge s Oktett
TR-> TD(1,1/1/1)->PAR n TD(1,2/1/1)->PAR Integer, Anzahl der zu extrahierenden OktetteElemente
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR out TD(2,2/1/1)->PAR Oktettstring der Länge n Oktett
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR out = Extract_MSByte( in, n )
PAR Das COS MUSS in den
PAR Oktettstring
PAR out
PAR die
PAR n
PAR MSByte von
PAR in
PAR einstellen.
PAR <b>[<=]</b>

PAR -HEADING(ids=5.8)5.8 PaddingIso
PAR Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Es wird gemäß [ISO/IEC 7816-4#10.2.3.1] Abschnitt "Sequential stage" Spiegelstrich 2 gepadded. Im Rahmen diverser interner Operationen im Betriebssystem wird die hier beschriebene Funktion wie folgt verwendet:
REQ(ids=A_13589)<b>A_13589 - (N000.900) K_COS</b>
PAR (ids=Tabelle-13-,-CosT_552)Tabelle 13 , CosT_552: Definition der Funktion PaddingIso(...)

TABLE(rows=5,cols=97+55+590)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR in TD(0,2/1/1)->PAR Oktettstring mit beliebigem Inhalt und beliebiger Länge
TR-> TD(1,1/1/1)->PAR n TD(1,2/1/1)->PAR Integer, positive ganze Zahl, gibt die Blocklänge an, auf die out zu padden ist
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR out TD(2,2/1/1)->PAR Oktettstring mit einer Anzahl Oktette, die Vielfaches von n ist
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR out = PaddingIso( in, n )
PAR Das COS MUSS
PAR folgende Aktion durchführen:
PAR a. Schritt 1:  
PAR out
PAR  =
PAR in
PAR    ||   '80'.
PAR b. Schritt 2: Wenn 0 == OctetLength(
PAR out
PAR ) mod
PAR n
PAR ,
PAR                  dann gebe
PAR out
PAR zurück und beende den Algorithmus,
PAR                   sonst fahre mit Schritt 3 fort.
PAR c. Schritt 3:  
PAR out
PAR =
PAR out
PAR   ||   '00'.
PAR d. Schritt 4: Fahre mit Schritt 2 fort.
PAR <b>[<=]</b>

PAR Hinweis CosH_cc1: Dies ist die Umkehrfunktion zu (N001.000).
PAR -HEADING(ids=5.9)5.9 TruncateIso
PAR Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird die hier beschriebene Funktion wie folgt verwendet:
REQ(ids=A_13590)<b>A_13590 - (N001.000) K_COS</b>
PAR (ids=Tabelle-14-,-CosT_9fb)Tabelle 14 , CosT_9fb: Definition der Funktion TruncateIso(...)

TABLE(rows=5,cols=97+83+563)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR in TD(0,2/1/1)->PAR Oktettstring mit beliebigem Inhalt und einer Anzahl Oktette, die Vielfaches von n ist
TR-> TD(1,1/1/1)->PAR n TD(1,2/1/1)->PAR Integer, gibt die Blocklänge in Oktett an, auf die gepadded wurde
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR out TD(2,2/1/1)->PAR Oktettstring mit beliebigem Inhalt und beliebiger Länge
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR paddingError TD(3,2/1/1)->PAR Die Länge von in ist kein Vielfaches von n, oder<br>es ist kein Bit im Oktettstring in gesetzt, oder<br>der Okettstring in ist falsch gepadded, oder<br>es sind zu viele Paddingbits vorhanden
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR out = TruncateIso( in, n )
PAR Das COS MUSS
PAR folgende Aktion durchführen:
PAR a. Schritt 1: Setze
PAR len
PAR = OctetLength(
PAR in
PAR ).
PAR                   Wenn
PAR len
PAR kein Vielfaches von
PAR n
PAR ist,
PAR                   dann breche diesen Algorithmus mit der Fehlermeldung
PAR paddingError
PAR ab.
PAR b. Schritt 2: Wenn 
PAR OctetLength( in ) len
PAR gleich null ist, dann
PAR                   breche diesen Algorithmus mit der Fehlermeldung
PAR paddingError
PAR ab.
PAR c. Schritt 3: Wenn LSByte von
PAR in
PAR den Wert '00' hat,
PAR                   dann setze
PAR in
PAR   = Extract_MSByte(
PAR in
PAR , OctetLength(
PAR in
PAR ) – 1)    
PAR                   und fahre mit Schritt 2 fort.
PAR d. Schritt 4: Wenn LSByte von
PAR in
PAR nicht den Wert '80' hat,
PAR                   dann breche diesen Algorithmus mit der Fehlermeldung
PAR paddingError
PAR ab.
PAR e. Schritt 5: 
PAR out
PAR  = Extract_MSByte(
PAR in
PAR , OctetLength(
PAR in
PAR ) – 1)
PAR f.  Schritt 6: Wenn (
PAR len
PAR – OctetLength(
PAR out
PAR ) ) größer als
PAR n
PAR ist,
PAR                   dann breche diesen Algorithmus mit der Fehlermeldung
PAR paddingError
PAR ab.
PAR <b>[<=]</b>

PAR Hinweis CosH_523: Dies ist die Umkehrfunktion zu (N000.900).
PAR -HEADING(ids=5.10)5.10 MGF Mask Generation Function
PAR Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird die hier beschriebene Funktion wie folgt verwendet:
REQ(ids=G2_N001.100)<b>G2_N001.100 - (N001.100) K_COS</b>
PAR Tabelle 15 , CosT_24c: Definition der Funktion MGF(...)

TABLE(rows=6,cols=98+57+589)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR Z TD(0,2/1/1)->PAR Bitstring mit beliebigem Inhalt und beliebiger Länge
TR-> TD(1,1/1/1)->PAR L<sub>N</sub> TD(1,2/1/1)->PAR Integer, gibt die Bitlänge von N an
TR-> TD(2,1/1/1)->PAR i TD(2,2/1/1)->PAR Integer, Startwert der Iteration
TR-> TD(3,0/1/1)->PAR Output: TD(3,1/1/1)->PAR N TD(3,2/1/1)->PAR Bitstring, Ergebnis der Mask Generation Function
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR error TD(4,2/1/1)->PAR Gemäß [ISO/IEC 9796-2#C.3.2] Punkt 1 ist ein Fehler zu werfen, falls Z zu lang, oder L<sub>N</sub> zu groß ist.<br>Hinweis CosH_ff6: Dieser Fehler ist für Smartcards derzeit nicht praxisrelevant, da er erst dann auftritt, wenn Z oder N oberhalb mehrerer Gigabyte liegen.
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR N = MGF( Z, L<sub>N</sub> , i )
PAR Das COS MUSS bei der Berechung von
PAR N
PAR aus
PAR Z
PAR ,
PAR L<sub>N</sub>
PAR und
PAR i
PAR folgenden Algorithmus ausführen:
PAR a. Schritt 1: Setze            
PAR n
PAR     = '',     (Anmerkung: Leerer Oktettstring).
PAR b. Schritt 2: Setze            
PAR n
PAR     =
PAR n
PAR    ||   SHA_256( BS2OS(
PAR Z
PAR ) || I2OS(
PAR i
PAR , 4 ) ).
PAR c. Schritt 3: Wenn die Hash-Operation mit einem Fehler terminierte,
PAR                   dann breche diesen Algorithmus mit der Fehlermeldung
PAR error
PAR ab.
PAR d. Schritt 4: Setze             
PAR i
PAR     =
PAR i
PAR + 1.
PAR e. Schritt 5: Wenn
PAR i
PAR größer gleich 2
PAR <sup>32</sup>
PAR = '1 0000 0000' ist,
PAR                  dann breche diesen Algorithmus mit der Fehlermeldung
PAR error
PAR ab.
PAR f.  Schritt 6: Wenn das Achtfache von OctetLength(
PAR n
PAR ) kleiner als
PAR L<sub>N</sub>
PAR ist,
PAR                   dann setze diesen Algorithmus mit Schritt 2 fort.
PAR g. Schritt 7: Setze             
PAR N
PAR     = Extract_MSBit(
PAR n
PAR ,
PAR L<sub>N</sub>
PAR ).
PAR <b>[<=]</b>

PAR Hinweis CosH_e55: Wenn diese Funktion mit i gleich 0 aufgerufen wird, dann ist das Ergebnis konform zu<br>            a. [ISO/IEC 9796-2#C], und<br>            b. [PKCS#1#B.2.1].
PAR Hinweis CosH_e90: Wenn diese Funktion mit i gleich 1 aufgerufen wird, dann ist das Ergebnis konform zu<br>            a. [ANSI X9.63#5.6.3], falls dort der optionale Parameter SharedInfo leer ist, und<br>            b. [BSI-TR-03111#4.3.3], allerdings wird dort das Schlüsselmaterial anders aus N extrahiert.
PAR -HEADING(ids=5.11)5.11 RAND Zufälliger Oktettstring
PAR Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird die hier beschriebene Funktion wie folgt verwendet:
REQ(ids=A_13591)<b>A_13591 - (N001.200) K_COS</b>
PAR (ids=Tabelle-16-,-CosT_7d4)Tabelle 16 , CosT_7d4: Definition der Funktion RAND(...)

TABLE(rows=4,cols=98+57+589)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR n TD(0,2/1/1)->PAR Positive ganze Zahl, welche die Anzahl Oktette in out angibt
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR out TD(1,2/1/1)->PAR Zufälliger Oktettstring der Länge n Oktett
TR-> TD(2,0/1/1)->PAR Errors: TD(2,1/1/1)->PAR – TD(2,2/1/1)->PAR Keine
TR-> TD(3,0/1/1)->PAR Notation: TD(3,1/1/1)-> TD(3,2/1/1)->PAR out = RAND( n )
PAR Das COS MUSS folgende Aktion durchführen: Erzeuge einen Oktettstring
PAR out
PAR der Länge
PAR n
PAR , wobei jedes Bit von
PAR out
PAR zufällig erzeugt wird.
PAR <b>[<=]</b>

PAR -HEADING(ids=5.12)5.12 ceiling, Aufrunden einer reellen Zahl
PAR Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird die hier beschriebene Funktion wie folgt verwendet:
REQ(ids=A_13592)<b>A_13592 - (N001.210) K_COS</b>
PAR (ids=Tabelle-17-,-CosT_c0e)Tabelle 17 , CosT_c0e: Definition der Funktion ceiling(...)

TABLE(rows=4,cols=97+56+589)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR x TD(0,2/1/1)->PAR beliebige reelle Zahl, negativ, null oder positiv
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR n TD(1,2/1/1)->PAR kleinste ganze Zahl, die nicht kleiner ist als x
TR-> TD(2,0/1/1)->PAR Errors: TD(2,1/1/1)->PAR – TD(2,2/1/1)->PAR Keine
TR-> TD(3,0/1/1)->PAR Notation: TD(3,1/1/1)-> TD(3,2/1/1)->PAR n = ceiling( x )
PAR Das COS MUSS
PAR folgende Aktion durchführen: Zu
PAR x
PAR wird die kleinste ganze Zahl
PAR n
PAR bestimmt, die nicht kleiner ist als
PAR x
PAR , das heißt:        ceiling(
PAR x
PAR ) = min {
PAR n
PAR є Z |
PAR n
PAR ≥
PAR x
PAR }.
PAR <b>[<=]</b>

PAR -HEADING(ids=5.13)5.13 floor, Abrunden einer reellen Zahl
PAR Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird die hier beschriebene Funktion wie folgt verwendet:
REQ(ids=A_13593)<b>A_13593 - (N001.220) K_COS</b>
PAR (ids=Tabelle-18-,-CosT_6ed)Tabelle 18 , CosT_6ed: Definition der Funktion floor(...)

TABLE(rows=4,cols=97+56+589)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR x TD(0,2/1/1)->PAR beliebige reelle Zahl, negativ, null oder positiv
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR n TD(1,2/1/1)->PAR größte ganze Zahl, die nicht größer ist als x
TR-> TD(2,0/1/1)->PAR Errors: TD(2,1/1/1)->PAR – TD(2,2/1/1)->PAR Keine
TR-> TD(3,0/1/1)->PAR Notation: TD(3,1/1/1)-> TD(3,2/1/1)->PAR n = floor( x )
PAR Das COS MUSS folgende Aktion durchführen:Zu
PAR x
PAR wird die größte ganze Zahl
PAR n
PAR bestimmt, die nicht größer ist als
PAR x
PAR , das heißt:        floor(
PAR x
PAR ) = max {
PAR n
PAR є Z |
PAR n
PAR ≤
PAR x
PAR }.
PAR <b>[<=]</b>

PAR -HEADING(ids=6)6 CosK_ab0 Kryptographische Algorithmen (normativ)
PAR -HEADING(ids=6.1)6.1 CosK_0bb Hash-Algorithmen
PAR Ein Hash-Algorithmus errechnet zu einer beliebigen Folge von Bits, von (beinahe) unbegrenzter Länge, einen Bitstring fester Länge. Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird ein Hash-Algorithmus als Funktion, wie in den folgenden Unterkapiteln gezeigt, verwendet.
PAR -HEADING(ids=6.1.1)6.1.1 SHA-1
REQ(ids=A_13594)<b>A_13594 - (N001.290) K_COS</b>
PAR (ids=Tabelle-19-,-CosT_12c)Tabelle 19 , CosT_12c: Definition der Funktion SHA_1(...)

TABLE(rows=4,cols=72+93+526)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR M TD(0,2/1/1)->PAR Beliebiger Oktettstring, der zu hashen ist
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR H TD(1,2/1/1)->PAR Oktettstring, Hash-Wert der Länge 20 Oktett = 160 Bit
TR-> TD(2,0/1/1)->PAR Errors: TD(2,1/1/1)->PAR "M too long" TD(2,2/1/1)->PAR Zu hashende Nachricht M enthält zu viele Bits. Dies ist der Fall wenn die Nachricht M länger ist als 2<sup>64</sup> bit = 2 EiB.<br> Hinweis CosH_613: Dieser Fehler ist für Smartcards nicht praxisrelevant. Um eine Nachricht mit einer Länge von 2<sup>64</sup> Bit innerhalb von 10 Jahren zu hashen, wäre der Hash-Algorithmus mit einer Geschwindigkeit von 6,8 GiB pro Sekunde auszuführen.
TR-> TD(3,0/1/1)->PAR Notation: TD(3,1/1/1)-> TD(3,2/1/1)->PAR H = SHA_1( M )
PAR Das COS MUSS
PAR H
PAR gemäß [FIPS 180-4#6.1] aus
PAR M
PAR berechnen.
PAR <b>[<=]</b>

PAR -HEADING(ids=6.1.2)6.1.2 SHA-256
REQ(ids=A_13595)<b>A_13595 - (N001.300) K_COS</b>
PAR (ids=Tabelle-20-,-CosT_159)Tabelle 20 , CosT_159: Definition der Funktion SHA_256(...)

TABLE(rows=4,cols=65+95+487)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR M TD(0,2/1/1)->PAR Beliebiger Oktettstring, der zu hashen ist
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR H TD(1,2/1/1)->PAR Oktettstring, Hash-Wert der Länge 32 Oktett = 256 Bit
TR-> TD(2,0/1/1)->PAR Errors: TD(2,1/1/1)->PAR "M too long" TD(2,2/1/1)->PAR Zu hashende Nachricht M enthält zu viele Bits. Dies ist der Fall wenn die Nachricht M länger ist als 2<sup>64</sup> bit = 2 EiB<br> Hinweis CosH_de3: Dieser Fehler ist für Smartcards nicht praxisrelevant. Um eine Nachricht mit einer Länge von 2<sup>64</sup> Bit innerhalb von 10 Jahren zu hashen, wäre der Hash-Algorithmus mit einer Geschwindigkeit von 6,8 GiB pro Sekunde auszuführen.
TR-> TD(3,0/1/1)->PAR Notation: TD(3,1/1/1)-> TD(3,2/1/1)->PAR H = SHA_256( M )
PAR Das COS MUSS
PAR H
PAR gemäß [FIPS 180-4#6.2] aus
PAR M
PAR berechnen.
PAR <b>[<=]</b>

PAR -HEADING(ids=6.1.3)6.1.3 SHA-384
REQ(ids=A_13596)<b>A_13596 - (N001.310) K_COS</b>
PAR (ids=Tabelle-21-,-CosT_a9f)Tabelle 21 , CosT_a9f: Definition der Funktion SHA_384(...)

TABLE(rows=4,cols=62+99+489)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR M TD(0,2/1/1)->PAR Beliebiger Oktettstring, der zu hashen ist
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR H TD(1,2/1/1)->PAR Oktettstring, Hash-Wert der Länge 48 Oktette = 384 bit
TR-> TD(2,0/1/1)->PAR Errors: TD(2,1/1/1)->PAR "M too long" TD(2,2/1/1)->PAR Zu hashende Nachricht M enthält zu viele Bits. Dies ist der Fall wenn die Nachricht M länger ist als 2<sup>128</sup> bit = 2<sup>125</sup> Byte<br>Hinweis CosH_f8b: Dieser Fehler ist für Smartcards weniger relevant, als der unter CosH_de3 beschriebene.
TR-> TD(3,0/1/1)->PAR Notation: TD(3,1/1/1)-> TD(3,2/1/1)->PAR H = SHA_384( M )
PAR Das COS MUSS
PAR H
PAR gemäß [FIPS 180-4#6.5] aus
PAR M
PAR berechnen.
PAR <b>[<=]</b>

PAR -HEADING(ids=6.1.4)6.1.4 SHA-512
REQ(ids=A_13597)<b>A_13597 - (N001.320) K_COS</b>
PAR (ids=Tabelle-22-,-CosT_676)Tabelle 22 , CosT_676: Definition der Funktion SHA_512(...)

TABLE(rows=4,cols=63+107+481)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR M TD(0,2/1/1)->PAR Beliebiger Oktettstring, der zu hashen ist
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR H TD(1,2/1/1)->PAR Oktettstring, Hash-Wert der Länge 64 Oktette = 512 Bit
TR-> TD(2,0/1/1)->PAR Errors: TD(2,1/1/1)->PAR "M too long" TD(2,2/1/1)->PAR Zu hashende Nachricht M enthält zu viele Bits. Dies ist der Fall wenn die Nachricht M länger ist als 2<sup>128</sup> Bit = 2<sup>125</sup> Byte <br>Hinweis CosH_7b2: Dieser Fehler ist für Smartcards weniger relevant, als der unter CosH_de3 beschriebene.
TR-> TD(3,0/1/1)->PAR Notation: TD(3,1/1/1)-> TD(3,2/1/1)->PAR H = SHA_512( M )
PAR Das COS MUSS
PAR H
PAR gemäß [FIPS 180-4#6.4] aus
PAR M
PAR berechnen.
PAR <b>[<=]</b>

PAR -HEADING(ids=6.2)6.2 Schlüsselvereinbarung
PAR In diesem Abschnitt wird eine Funktion beschrieben, die aus einem Eingabewert Schlüsselmaterial für symmetrische Algorithmen berechnet. Derartiges Schlüsselmaterial wird vorwiegend im Rahmen von sicherer Transportverschlüsselung eingesetzt. Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird eine Schlüsselvereinbarung als Funktion, wie in den folgenden Unterkapiteln gezeigt, verwendet.
PAR -HEADING(ids=6.2.1)6.2.1 Verhalten für 3TDES-Schlüssel, Option_DES
PAR (N001.400) ist absichtlich leer.
PAR Tabelle 23, CosT_084: Definition der Funktion KeyDerivation_3TDES(...)

TABLE(rows=7,cols=56+35+652)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR KD TD(0,2/1/1)->PAR Oktettstring, Key Derivation Data, Ausgangsmaterial zur Schlüsselvereinbarung. Prinzipiell handelt es sich um einen Oktettstring beliebiger Länge und beliebigen Inhalts
TR-> TD(1,0/4/1)->PAR Output: TD(1,1/1/1)->PAR K<sub>enc</sub> TD(1,2/1/1)->PAR Oktettstring der Länge 24 Oktette, der als 3TDES-Schlüssel für Ver- und Entschlüsselung verwendet wird
TR-> TD(2,1/1/1)->PAR T<sub>1</sub> TD(2,2/1/1)->PAR Nicht-negative ganze Zahl, die im Zusammenhang mit K<sub>enc</sub> als Send Sequence Counter verwendet wird (siehe CosT_20c und CosT_ef0)
TR-> TD(3,1/1/1)->PAR K<sub>mac</sub> TD(3,2/1/1)->PAR Oktettstring der Länge 24 Oktette, der als 3TDES-Schlüssel für MAC-Generierung und MAC-Prüfung verwendet wird
TR-> TD(4,1/1/1)->PAR T<sub>2</sub> TD(4,2/1/1)->PAR Nicht-negative ganze Zahl, die im Zusammenhang mit K<sub>mac</sub> als Send Sequence Counter verwendet (siehe (N032.800) und (N034.100))
TR-> TD(5,0/1/1)->PAR Errors: TD(5,1/1/1)->PAR – TD(5,2/1/1)->PAR Keine
TR-> TD(6,0/1/1)->PAR Notation: TD(6,1/1/1)-> TD(6,2/1/1)->PAR ( K<sub>enc</sub>, T<sub>1</sub>, K<sub>mac</sub>, T<sub>2</sub> ) = KeyDerivation_3TDES( KD )
REQ(ids=A_13598)<b>A_13598 - (N001.400) K_COS_G1, Option_DES</b>
PAR Das COS MUSS ( K<sub>enc</sub>, T<sub>1</sub>, K<sub>mac</sub>, T<sub>2</sub> ) gemäß [ANSI X9.63#5.6.3] wie folgt aus KD berechnen.<br>a. Schritt 1:        km = BS2OS( MGF( OS2BS( KD ), 512, 1 )).<br>b. Schritt 2: Teile km so auf K<sub>enc</sub>, t<sub>1</sub>, K<sub>mac</sub> und t<sub>2</sub> auf, dass gilt:<br>    1. OctetLength( K<sub>enc</sub> )   ==   OctetLength( K<sub>mac</sub> )   ==   24<br>    2. OctetLength( t<sub>1</sub> )       ==   OctetLength( t<sub>2</sub> )       ==     8<br>    3. km == K<sub>enc</sub>   ||   t<sub>1</sub>   ||   K<sub>mac</sub>   ||   t<sub>2</sub><br>c. Schritt 3:        T<sub>1</sub> = OS2I( t<sub>1</sub> )   und   T<sub>2</sub> = OS2I( t<sub>2</sub> ) <b>[<=]</b>

PAR -HEADING(ids=6.2.2)6.2.2 Vereinbarung von AES-128-Schlüsseln
REQ(ids=A_13599)<b>A_13599 - (N001.500) K_COS</b>
PAR (ids=Tabelle-24-,-CosT_7f9)Tabelle 24 , CosT_7f9: Definition der Funktion KeyDerivation_AES128(...)

TABLE(rows=6,cols=55+40+648)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR KD TD(0,2/1/1)->PAR Oktettstring, Key Derivation Data, Ausgangsmaterial zur Schlüsselvereinbarung. Prinzipiell handelt es sich um einen Oktettstring beliebiger Länge und beliebigen Inhalts
TR-> TD(1,0/3/1)->PAR Output: TD(1,1/1/1)->PAR K<sub>enc</sub> TD(1,2/1/1)->PAR Oktettstring der Länge 16 Oktette, der als AES-128-Schlüssel für Ver- und Entschlüsselung verwendet wird
TR-> TD(2,1/1/1)->PAR K<sub>mac</sub> TD(2,2/1/1)->PAR Oktettstring der Länge 16 Oktette, der als AES-128-Schlüssel für MAC-Generierung und MAC-Prüfung verwendet wird
TR-> TD(3,1/1/1)->PAR T<sub>2</sub> TD(3,2/1/1)->PAR Nicht-negative ganze Zahl, die im Zusammenhang mit K<sub>mac</sub> als Send Sequence Counter SSCmac verwendet wird (siehe (N032.800) und (N034.100))
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR – TD(4,2/1/1)->PAR keine
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR ( K<sub>enc</sub>, K<sub>mac</sub>, T<sub>2</sub> ) = KeyDerivation_AES128( KD )
PAR Das COS MUSS (
PAR K<sub>enc</sub>
PAR ,
PAR K<sub>mac</sub>
PAR ,
PAR T<sub>2</sub>
PAR ) analog zu [BSI-TR-03110-3#A.2.3.2] wie folgt aus
PAR KD
PAR berechnen:
PAR a.
PAR K<sub>enc</sub>
PAR     =
PAR Extract_MSByte
PAR (
PAR SHA_1
PAR (
PAR KD
PAR || '00000001'), 16)
PAR b.
PAR K<sub>mac</sub>
PAR    =
PAR Extract_MSByte
PAR (
PAR SHA_1
PAR (
PAR KD
PAR || '00000002'), 16)
PAR c.
PAR T<sub>2</sub>
PAR        = 0
PAR <b>[<=]</b>

PAR -HEADING(ids=6.2.3)6.2.3 Vereinbarung von AES-192-Schlüsseln
REQ(ids=A_13600)<b>A_13600 - (N001.510) K_COS</b>
PAR (ids=Tabelle-25-,-CosT_cae)Tabelle 25 , CosT_cae: Definition der Funktion KeyDerivation_AES192(...)

TABLE(rows=6,cols=55+38+651)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR KD TD(0,2/1/1)->PAR Oktettstring, Key Derivation Data, Ausgangsmaterial zur Schlüsselvereinbarung, prinzipiell handelt es sich um einen Oktettstring beliebiger Länge und beliebigen Inhalts
TR-> TD(1,0/3/1)->PAR Output: TD(1,1/1/1)->PAR K<sub>enc</sub> TD(1,2/1/1)->PAR Oktettstring der Länge 24 Oktette, der als AES-192-Schlüssel für Ver- und Entschlüsselung verwendet wird
TR-> TD(2,1/1/1)->PAR K<sub>mac</sub> TD(2,2/1/1)->PAR Oktettstring der Länge 24 Oktette, der als AES-192-Schlüssel für MAC-Generierung und MAC-Prüfung verwendet wird
TR-> TD(3,1/1/1)->PAR T<sub>2</sub> TD(3,2/1/1)->PAR Nicht-negative ganze Zahl, die im Zusammenhang mit K<sub>mac</sub> als Send Sequence Counter SSCmac verwendet wird (siehe (N032.800) und (N034.100))
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR – TD(4,2/1/1)->PAR keine
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR ( K<sub>enc</sub>, K<sub>mac</sub>, T<sub>2</sub> ) = KeyDerivation_AES192( KD )
PAR Das COS MUSS (
PAR K<sub>enc</sub>
PAR ,
PAR K<sub>mac</sub>
PAR ,
PAR T<sub>2</sub>
PAR ) analog zu [BSI-TR-03110-3#A.2.3.2] wie folgt aus
PAR KD
PAR berechnen:
PAR a.
PAR K<sub>enc</sub>
PAR     =
PAR Extract_MSByte
PAR (
PAR SHA_256
PAR (
PAR KD
PAR || '00000001'), 24)
PAR b.
PAR K<sub>mac</sub>
PAR    =
PAR Extract_MSByte
PAR (
PAR SHA_256
PAR (
PAR KD
PAR || '00000002'), 24)
PAR c.
PAR T<sub>2</sub>
PAR        = 0
PAR <b>[<=]</b>

PAR -HEADING(ids=6.2.4)6.2.4 Vereinbarung von AES-256-Schlüsseln
REQ(ids=A_13601)<b>A_13601 - (N001.520) K_COS</b>
PAR (ids=Tabelle-26-,-CosT_a21)Tabelle 26 , CosT_a21: Definition der Funktion KeyDerivation_AES256(...)

TABLE(rows=6,cols=55+43+646)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR KD TD(0,2/1/1)->PAR Oktettstring, Key Derivation Data, Ausgangsmaterial zur Schlüsselvereinbarung, prinzipiell handelt es sich um einen Oktettstring beliebiger Länge und beliebigen Inhalts
TR-> TD(1,0/3/1)->PAR Output: TD(1,1/1/1)->PAR K<sub>enc</sub> TD(1,2/1/1)->PAR Oktettstring der Länge 32 Oktette, der als AES-256-Schlüssel für Ver- und Entschlüsselung verwendet wird
TR-> TD(2,1/1/1)->PAR K<sub>mac</sub> TD(2,2/1/1)->PAR Oktettstring der Länge 32 Oktette, der als AES-256-Schlüssel für MAC-Generierung und MAC-Prüfung verwendet wird
TR-> TD(3,1/1/1)->PAR T<sub>2</sub> TD(3,2/1/1)->PAR Nicht-negative ganze Zahl, die im Zusammenhang mit K<sub>mac</sub> als Send Sequence Counter SSCmac verwendet wird (siehe (N032.800) und (N034.100))
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR – TD(4,2/1/1)->PAR keine
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR ( K<sub>enc</sub>, K<sub>mac</sub>, T<sub>2</sub> ) = KeyDerivation_AES256( KD )
PAR Das COS MUSS (
PAR K<sub>enc</sub>
PAR ,
PAR K<sub>mac</sub>
PAR ,
PAR T<sub>2</sub>
PAR ) analog zu [BSI-TR-03110-3#A.2.3.2] wie folgt aus
PAR KD
PAR berechnen:
PAR a.
PAR K<sub>enc</sub>
PAR     =
PAR SHA_256
PAR (
PAR KD
PAR || '00000001')
PAR b.
PAR K<sub>mac</sub>
PAR    =
PAR SHA_256
PAR (
PAR KD
PAR || '00000002')
PAR c.
PAR T<sub>2</sub>
PAR        = 0
PAR <b>[<=]</b>

PAR -HEADING(ids=6.2.5)6.2.5 Schlüsselableitung aus einer Card Access Number
REQ(ids=A_13602)<b>A_13602 - (N001.530) K_COS, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR (ids=Tabelle-27-,-CosT_f06)Tabelle 27 , CosT_f06: Definition der Funktion KDF(...)

TABLE(rows=6,cols=55+26+663)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR KD TD(0,2/1/1)->PAR Oktettstring, Key Derivation Data, Ausgangsmaterial zur Schlüsselableitung, prinzipiell handelt es sich um einen Oktettstring beliebiger Länge und beliebigen Inhalts
TR-> TD(1,1/1/1)->PAR n TD(1,2/1/1)->PAR natürliche Zahl, die bei der Schlüsselableitung berücksichtigt wird
TR-> TD(2,1/1/1)->PAR OID TD(2,2/1/1)->PAR Algorithmuskennung mit einem Wert aus einer Menge in (N102.440)
TR-> TD(3,0/1/1)->PAR Output: TD(3,1/1/1)->PAR K TD(3,2/1/1)->PAR Oktettstring, je nach OID mit einer Länge von 16 oder 24 oder 32 Oktette, der als AES-Schlüssel verwendet wird
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR – TD(4,2/1/1)->PAR keine
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR K = KDF( KD, n, OID )
PAR Das COS MUSS
PAR K
PAR analog zu [BSI-TR-03110-3#A.2.3] wie folgt aus
PAR KD
PAR ,
PAR n
PAR und
PAR OID
PAR berechnen: Wenn 
PAR OID
PAR aus der Menge
PAR a. {id-PACE-ECDH-GM-AES-CBC-CMAC-128, id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-128} ist,
PAR    dann gilt:          
PAR K
PAR = Extract_MSByte(SHA_1(
PAR KD
PAR || I2OS(
PAR n
PAR , 4) ), 16)
PAR b. {id-PACE-ECDH-GM-AES-CBC-CMAC-192, id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-192} ist,
PAR    dann gilt:          
PAR K
PAR = Extract_MSByte(SHA_256(
PAR KD
PAR || I2OS(
PAR n
PAR , 4) ), 24)
PAR c. {id-PACE-ECDH-GM-AES-CBC-CMAC-256, id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-256} ist,
PAR    dann gilt:         
PAR K
PAR = SHA_256(
PAR KD
PAR || I2OS(
PAR n
PAR , 4) )
PAR <b>[<=]</b>

PAR -HEADING(ids=6.3)6.3 Symmetrischer Basisalgorithmus für Vertraulichkeit
PAR Ein Verschlüsselungsalgorithmus berechnet zu einem beliebigen Oktettstring (plaintext) mit Hilfe eines geheimen Schlüssels ein Chiffrat (ciphertext). Ein entsprechender Entschlüsselungsalgorithmus berechnet zu einem Chiffrat (ciphertext) mit Hilfe desselben symmetrischen Schlüssels den ursprünglichen Oktettstring (plaintext). In diesem Kapitel wird lediglich die Bearbeitung eines Blocks mittels eines Blockverschlüsselungsalgorithmus behandelt. Die Behandlung von Inputdaten mit beliebiger Länge wird in CosK_d59 spezifiziert.
PAR -HEADING(ids=6.3.1)6.3.1 Symmetrische Verschlüsselung eines Datenblocks, Option_DES
PAR Die folgenden Anforderungen sind absichtlich leer: (N001.600), (N001.700), (N001.800), (N001.900).
PAR Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird eine Verschlüsselung als Funktion wie folgt verwendet:
PAR -HEADING(ids=6.3.1.1)6.3.1.1 Verschlüsselung mittels DES, Option_DES
PAR Tabelle 28, CosT_c71: Definition der Funktion DES_ENC(...)

TABLE(rows=5,cols=98+60+586)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR P<sub>j</sub> TD(0,2/1/1)->PAR Beliebiger Oktettstring der Länge 8 Oktett = 64 Bit, Klartext
TR-> TD(1,1/1/1)->PAR K TD(1,2/1/1)->PAR Beliebiger Oktettstring der Länge 8 Oktett = 64 Bit, der als Schlüssel verwendet wird
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR C<sub>j</sub> TD(2,2/1/1)->PAR Oktettstring, verschlüsselte Daten der Länge 8 Oktett
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR C<sub>j</sub> = DES_ENC( K, P<sub>j</sub> )
REQ(ids=A_13603)<b>A_13603 - (N001.600) K_COS_G1, Option_DES</b>
PAR Das COS MUSS C<sub>j</sub> mittels K gemäß [ANSI X3.92] aus P<sub>j</sub> berechnen. <b>[<=]</b>

PAR -HEADING(ids=6.3.1.2)6.3.1.2 Verschlüsselung mittels 3TDES, Option_DES
PAR Tabelle 29, CosT_01b: Definition der Funktion 3TDES_ENC(...)

TABLE(rows=5,cols=98+60+586)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR P<sub>j</sub> TD(0,2/1/1)->PAR Beliebiger Oktettstring der Länge 8 Oktett = 64 Bit, Klartext
TR-> TD(1,1/1/1)->PAR K TD(1,2/1/1)->PAR Beliebiger Oktettstring der Länge 24 Oktett = 192 Bit, der als Schlüssel verwendet wird. K setzt sich zusammen aus den drei Teilschlüsseln Ka, Kb, Kc und es gilt: K = Ka   ||   Kb   ||   Kc
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR C<sub>j</sub> TD(2,2/1/1)->PAR Oktettstring, verschlüsselte Daten der Länge 8 Oktett
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR C<sub>j</sub> = 3TDES_ENC( K, P<sub>j</sub> )
REQ(ids=A_13604)<b>A_13604 - (N001.700) K_COS_G1, Option_DES</b>
PAR Das COS MUSS C<sub>j</sub> mittels K wie folgt aus P<sub>j</sub> berechnen: C<sub>j</sub> = DES_ENC( Kc, DES_DEC( Kb, DES_ENC( Ka, P<sub>j</sub> ) ) ). <b>[<=]</b>

PAR -HEADING(ids=6.3.2)6.3.2 Symmetrische Entschlüsselung eines Datenblocks, Option_DES
PAR Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird eine Entschlüsselung als Funktion wie folgt verwendet:
PAR -HEADING(ids=6.3.2.1)6.3.2.1 Entschlüsselung mittels DES, Option_DES
PAR Tabelle 30, CosT_a36: Definition der Funktion DES_DEC(...)

TABLE(rows=5,cols=98+60+586)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR C<sub>j</sub> TD(0,2/1/1)->PAR Beliebiger Oktettstring der Länge 8 Oktett = 64 Bit, Chiffrat
TR-> TD(1,1/1/1)->PAR K TD(1,2/1/1)->PAR Beliebiger Oktettstring der Länge 8 Oktett = 64 Bit, der als Schlüssel verwendet wird
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR P<sub>j</sub> TD(2,2/1/1)->PAR Oktettstring, entschlüsselte Daten der Länge 8 Oktett
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR P<sub>j</sub> = DES_DEC( K, C<sub>j</sub> )
REQ(ids=A_13605)<b>A_13605 - (N001.800) K_COS_G1, Option_DES</b>
PAR Das COS MUSS P<sub>j</sub> mittels K gemäß [ANSI X3.92] aus C<sub>j</sub> berechnen. <b>[<=]</b>

PAR -HEADING(ids=6.3.2.2)6.3.2.2 Entschlüsselung mittels 3TDES, Option_DES
PAR Tabelle 31, CosT_478: Definition der Funktion 3TDES_DEC(...)

TABLE(rows=5,cols=98+60+586)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR C<sub>j</sub> TD(0,2/1/1)->PAR Beliebiger Oktettstring der Länge 8 Oktett = 64 Bit, Chiffrat
TR-> TD(1,1/1/1)->PAR K TD(1,2/1/1)->PAR Beliebiger Oktettstring der Länge 24 Oktett = 192 Bit, der als Schlüssel verwendet wird. K setzt sich zusammen aus den drei Teilschlüsseln Ka, Kb, Kc und es gilt: K = Ka   ||   Kb   ||   Kc
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR P<sub>j</sub> TD(2,2/1/1)->PAR Oktettstring, entschlüsselte Daten der Länge 8 Oktett
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR P<sub>j</sub> = 3TDES_DEC( K, C<sub>j</sub> )
REQ(ids=A_13606)<b>A_13606 - (N001.900 K_COS_G1, Option_DES</b>
PAR Das COS MUSS P<sub>j</sub> mittels K wie folgt aus C<sub>j</sub> berechnen: P<sub>i</sub> = DES_DEC( Ka, DES_ENC( Kb, DES_DEC( Kc, C<sub>i</sub> ) ) ). <b>[<=]</b>

PAR -HEADING(ids=6.3.3)6.3.3 Symmetrische Verschlüsselung eines Datenblocks, AES
PAR Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird eine Verschlüsselung als Funktion wie folgt verwendet:
REQ(ids=A_13607)<b>A_13607 - (N002.000) K_COS</b>
PAR (ids=Tabelle-32-,-CosT_ee7)Tabelle 32 , CosT_ee7: Definition der Funktion AES_ENC(...)

TABLE(rows=5,cols=98+60+586)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR P<sub>j</sub> TD(0,2/1/1)->PAR Beliebiger Oktettstring der Länge 16 Oktett = 128 Bit, Klartext
TR-> TD(1,1/1/1)->PAR K TD(1,2/1/1)->PAR Beliebiger Oktettstring der Länge 16 oder 24 oder 32 Oktett, der als Schlüssel verwendet wird
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR C<sub>j</sub> TD(2,2/1/1)->PAR Oktettstring, verschlüsselte Daten der Länge 16 Oktett
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR C<sub>j</sub> = AES_ENC( K, P<sub>j</sub> )
PAR Das COS MUSS
PAR C<sub>j</sub>
PAR mittels
PAR K
PAR so aus
PAR P<sub>j</sub>
PAR berechnen, dass sich derselbe funktionale Zusammenhang
PAR f<sub>K</sub>
PAR : 
PAR P<sub>j</sub>
PAR -> 
PAR C<sub>j</sub>
PAR ergibt wie in [FIPS 197#Figure 5].
PAR <b>[<=]</b>

PAR -HEADING(ids=6.3.4)6.3.4 Symmetrische Entschlüsselung eines Datenblocks, AES
PAR Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird eine Verschlüsselung als Funktion wie folgt verwendet:
REQ(ids=A_13608)<b>A_13608 - (N002.010) K_COS</b>
PAR (ids=Tabelle-33-,-CosT_bed)Tabelle 33 , CosT_bed: Definition der Funktion AES_DEC(...)

TABLE(rows=5,cols=98+60+586)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR C<sub>j</sub> TD(0,2/1/1)->PAR Oktettstring, verschlüsselte Daten der Länge 16 Oktett
TR-> TD(1,1/1/1)->PAR K TD(1,2/1/1)->PAR Beliebiger Oktettstring der Länge 16 oder 24 oder 32 Oktett, der als Schlüssel verwendet wird
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR P<sub>j</sub> TD(2,2/1/1)->PAR Beliebiger Oktettstring der Länge 16 Oktett = 128 Bit, Klartext
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR P<sub>j</sub> = AES_DEC( K, C<sub>j</sub> )
PAR Das COS MUSS
PAR P<sub>j</sub>
PAR mittels
PAR K
PAR so aus
PAR C<sub>j</sub>
PAR berechnen, dass sich derselbe funktionale Zusammenhang
PAR f<sub>K</sub>
PAR : 
PAR C<sub>j</sub>
PAR ->
PAR  
PAR P<sub>j</sub>
PAR ergibt, wie in [FIPS 197#Figure 12] oder [FIPS 197#Figure 15].
PAR <b>[<=]</b>

PAR -HEADING(ids=6.4)6.4 Asymmetrischer Basisalgorithmus RSA
PAR RSA ist ein im COS verwendeter Basisalgorithmus. Bezüglich des mathematischen Hintergrundes wird an dieser Stelle lediglich auf [PKCS#1] verwiesen.
REQ(ids=G2_N002.100)<b>G2_N002.100 - (N002.100) K_COS</b>
PAR Das COS MUSS mindestens RSA–Schlüssel mit<br>a. einer Moduluslänge modulusLength aus den Mengen<br>    1. {2048} Bit für private und öffentliche RSA-Schlüssel unterstützen und<br>    2. {3072} Bit, falls es sich um einen privaten RSA-Schlüssel handelt und<br>b. öffentlichen Exponenten e aus folgendem Intervall unterstützen:    <br>    [2<sup>16</sup>+1, 2<sup>32</sup>–1] = [65.537, 4.294.967.295] = ['0001 0001', 'FFFF FFFF']. <b>[<=]</b>

PAR (N002.200) Diese Anforderung ist absichtlich leer. Der ursprüngliche Text erlaubte auch andere Moduluslängen zu unterstützen. Dies wird nun in (N002.100) durch das Wort "mindestens" ausgedrückt.
PAR (N002.300) Diese Anforderung ist absichtlich leer. Der ursprüngliche Text erlaubte auch andere Werte für öffentliche Exponenten. Dies wird nun in (N002.100) durch das Wort "mindestens" ausgedrückt.
REQ(ids=A_13609)<b>A_13609 - (N002.400) COS</b>
PAR Das COS MUSS für die beiden Primfaktoren p und q des Modulus Intervalle unterstützen, die für die Zahl<br>epsilon = log<sub>2</sub>(q) – log<sub>2</sub> (p) mindestens Werte aus dem Intervall [1/10, 1/2] umfassen. <b>[<=]</b>

PAR Hinweis CosH_e24: Gemäß (N002.400) sind andere, beliebige Verhältnisse von p und q funktional zulässig. Insbesondere auch solche, die zu p > q gehören.
PAR Konform zu [PKCS#1] Kapitel 2 werden die RSA-Schlüsselparameter in diesem Dokument wie folgt dargestellt:
PAR (ids=Tabelle-34,-CosT_689)Tabelle 34, CosT_689: Liste der Schlüsselparameter eines RSA-Schlüssels

TABLE(rows=4,cols=79+216)->
TR-> TH(0,0/1/1)->PAR Parameter TH(0,1/1/1)->PAR Bedeutung
TR-> TD(1,0/1/1)->PAR n TD(1,1/1/1)->PAR RSA Modulus
TR-> TD(2,0/1/1)->PAR e TD(2,1/1/1)->PAR RSA öffentlicher Exponent
TR-> TD(3,0/1/1)->PAR d TD(3,1/1/1)->PAR RSA privater Exponent
PAR Hinweis CosH_e02: In diesem Dokument wird der Einfachheit halber nicht mit "chinese remainder theorem" Parametern gearbeitet. Wegen der größeren Performanz wird aber empfohlen, innerhalb des COS für Operationen mit dem privaten Schlüssel "chinese remainder theorem" Parameter zu verwenden.
PAR -HEADING(ids=6.5)6.5 Asymmetrischer Basisalgorithmus elliptische Kurven
PAR Kryptographie basierend auf elliptischen Kurven ist ein im COS verwendeter Basisalgorithmus. Bezüglich des mathematischen Hintergrundes wird an dieser Stelle lediglich auf [BSI-TR-03111] verwiesen. Die Domainparameter der im folgenden genannten Kurven finden sich auch in CosK_483.
REQ(ids=G2_N002.500.a.1)<b>G2_N002.500.a.1 - (N002.500)a.1 K_COS</b>
PAR Das COS MUSS die folgende elliptische Kurve unterstützen: [RFC5639#3.4, brainpoolP256r1], (siehe CosT_de0). <b>[<=]</b>

REQ(ids=G2_N002.500.a.2)<b>G2_N002.500.a.2 - (N002.500)a.2 K_COS</b>
PAR Das COS MUSS die folgende elliptische Kurve unterstützen: [ANSI X9.62#L.6.4.3, ansix9p256r1], (siehe CosT_f68). <b>[<=]</b>

REQ(ids=G2_N002.500.b.1)<b>G2_N002.500.b.1 - (N002.500)b.1 K_COS</b>
PAR Das COS MUSS die folgende elliptische Kurve unterstützen: [RFC5639#3.6, brainpoolP384r1], (siehe CosT_62f). <b>[<=]</b>

REQ(ids=G2_N002.500.b.2)<b>G2_N002.500.b.2 - (N002.500)b.2 K_COS</b>
PAR Das COS MUSS die folgende elliptische Kurve unterstützen: [ANSI X9.62#L6.5.2, ansix9p384r1], (siehe CosT_88a). <b>[<=]</b>

REQ(ids=G2_N002.500.c)<b>G2_N002.500.c - (N002.500)c K_COS</b>
PAR Das COS MUSS die folgende elliptische Kurve unterstützen: [RFC5639#3.7, brainpoolP512r1], (siehe CosT_198). <b>[<=]</b>

REQ(ids=A_13610)<b>A_13610 - (N002.609) K_TST</b>
PAR Das COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere ellipitsche Kurven<br>a. unterstützt oder<br>b. ablehnt. <b>[<=]</b>

PAR -HEADING(ids=6.6)6.6 Datenauthentisierung
PAR Im Rahmen einer Datenauthentisierung werden beliebigen Daten weitere Informationen derart hinzugefügt, dass die Integrität und Authentizität der Daten überprüfbar ist.
PAR -HEADING(ids=6.6.1)6.6.1 MAC-Generierung
PAR Die MAC-Generierung ist eine Datenauthentisierung, welche auf einem symmetrischen Basisalgorithmus basiert. Dabei wird zu einem Oktettstring beliebigen Inhalts und Länge ein MAC berechnet, dessen Länge lediglich vom Algorithmus abhängt, nicht aber vom Oktettstring. Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird eine MAC-Generierung als Funktion wie folgt verwendet:
PAR -HEADING(ids=6.6.1.1)6.6.1.1 Generierung Retail-MAC, Option_DES
PAR (N002.700) ist absichtlich leer.
PAR Tabelle 35, CosT_d3d: Definition der Funktion CALCULATE_Retail_MAC(...)

TABLE(rows=5,cols=98+55+591)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR M TD(0,2/1/1)->PAR Beliebiger Oktettstring beliebiger Länge für den ein MAC berechnet wird
TR-> TD(1,1/1/1)->PAR K TD(1,2/1/1)->PAR Beliebiger Oktettstring der Länge 24 Oktett = 192 Bit, der als Schlüssel verwendet wird. K setzt sich zusammen aus den drei Teilschlüsseln Ka, Kb, Kc und es gilt: K = Ka   ||   Kb   ||   Kc 
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR T TD(2,2/1/1)->PAR Oktettstring, der zur Prüfung der Integrität und Authentizität von M verwendbar ist
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR T = CALCULATE_Retail_MAC( K, M )
REQ(ids=A_13611)<b>A_13611 - (N002.700) K_COS_G1, Option_DES</b>
PAR Das COS MUSS T mittels K aus M berechnen. Dabei werden folgende Schritte durchgeführt:<br>a. Schritt 1: Berechne   X   = PaddingIso( M, 8 )<br>b. Schritt 2: Teile X auf in Blöcke mit jeweils 8 Oktett X = X<sub>1</sub>  ||  X<sub>2</sub>  ||  …  ||  X<sub>n</sub>.<br>c. Schritt 3: Setze        Y<sub>0</sub>  = '0000 0000 0000 0000'.<br>d. Schritt 4: Berechne   Y<sub>i</sub>  = DES_ENC( Ka, Y<sub>i</sub><sub>–1</sub> XOR X<sub>i</sub> ) für i = 1, …, n – 1.<br>e. Schritt 5: Berechne   T   = 3TDES_ENC( K, Y<sub>n</sub><sub>–1</sub> XOR X<sub>n</sub> ). <b>[<=]</b>

PAR Hinweis CosH_dc6: Im Rahmen von Secure Messaging wird ein von "null" verschiedener Initialisierungsvektor Y<sub>0</sub> bei der Konstruktion der Nachricht M berücksichtigt (siehe dazu (N032.800) und (N034.100)).
PAR -HEADING(ids=6.6.1.2)6.6.1.2 Generierung CMAC ohne internes Padding vor der CMAC-Berechnung
REQ(ids=A_13612)<b>A_13612 - (N002.810) K_COS</b>
PAR (ids=Tabelle-36-,-CosT_fd0)Tabelle 36 , CosT_fd0: Definition der Funktion CalculateCMAC_NoPadding(...)

TABLE(rows=5,cols=78+36+485)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR M TD(0,2/1/1)->PAR Beliebiger Oktettstring, für den ein MAC berechnet wird
TR-> TD(1,1/1/1)->PAR K TD(1,2/1/1)->PAR Beliebiger Oktettstring, der als Schlüssel verwendet wird. Die Länge von K beträgt 16 oder 24 oder 32 Oktett
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR T TD(2,2/1/1)->PAR Oktettstring, der zur Prüfung der Integrität und Authentizität von M verwendbar ist
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR T = CalculateCMAC_NoPadding( K, M )
PAR Das COS MUSS
PAR T
PAR mittels
PAR K
PAR gemäß [CMAC#6.2] aus
PAR M
PAR berechnen. Dabei werden folgende Schritte durchgeführt:
PAR a. Definitionen:     CIPH  = Block Cipher Algorithmus (siehe (N002.000))    
PAR                          
PAR b
PAR        = Blocklänge von CIPH in Bit hier gleich 128 Bit
PAR                          
PAR   M<sub>len</sub>  = OctetLength( M ).
PAR b. Schritt 1: Generiere Unterschlüssel
PAR K1
PAR und
PAR K2
PAR gemäß [CMAC#6.1].
PAR c. Schritt 2: Wenn
PAR M<sub>len</sub>
PAR gleich null ist,
PAR                  dann setze
PAR n
PAR = 1,
PAR                   sonst
PAR r
PAR =
PAR M<sub>len</sub>
PAR mod
PAR b
PAR und    
PAR                   wenn
PAR r
PAR == 0,
PAR                  dann  setze
PAR n
PAR =
PAR M<sub>len</sub>
PAR /
PAR b
PAR     
PAR                   sonst setze
PAR n
PAR = (
PAR M<sub>len</sub>
PAR –
PAR r
PAR ) /
PAR b
PAR + 1.
PAR d. Schritt 3: Teile
PAR M
PAR wie folgt in Blöcke auf:  
PAR M
PAR   ==
PAR M<sub>1</sub>
PAR   ||  
PAR M<sub>2</sub>
PAR   ||   …   ||  
PAR M<sub>n</sub><sub>–1</sub>
PAR   ||  
PAR M*<sub>n</sub>
PAR .    
PAR                   Die Blöcke
PAR M<sub>1</sub>
PAR bis
PAR M<sub>n</sub><sub>–1</sub>
PAR besitzen die Länge
PAR b
PAR . Der Block
PAR M*<sub>n</sub>
PAR besitzt eine Länge kleiner gleich
PAR b
PAR .
PAR e. Schritt 4: Wenn
PAR r
PAR == 0 ist,
PAR                   dann  setze
PAR M<sub>n</sub>
PAR =
PAR K1
PAR   XOR  
PAR M*<sub>n</sub>
PAR ,    
PAR                   sonst setze
PAR M<sub>n</sub>
PAR =
PAR K2
PAR   XOR   PaddingIso(
PAR M*<sub>n</sub>
PAR ,
PAR b / 8
PAR ).
PAR f.  Schritt 5:    
PAR C<sub>0</sub>
PAR  = I2OS( 0,
PAR b
PAR / 8 )
PAR g. Schritt 6:    
PAR C<sub>i</sub>
PAR   = AES_ENC(
PAR K
PAR ,
PAR C<sub>i</sub><sub>–1</sub>
PAR XOR
PAR M<sub>i</sub>
PAR ).
PAR h. Schritt 7:    
PAR T
PAR    = Extract_MSByte(
PAR C<sub>n</sub>
PAR , 8).
PAR <b>[<=]</b>

PAR -HEADING(ids=6.6.1.3)6.6.1.3 Generierung CMAC mit internem ISO-Padding vor der CMAC-Berechnung
REQ(ids=A_13613)<b>A_13613 - (N002.820) K_COS</b>
PAR (ids=Tabelle-37-,-CosT_245)Tabelle 37 , CosT_245: Definition der Funktion CalculateCMAC_IsoPadding(...)

TABLE(rows=5,cols=78+36+485)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR M TD(0,2/1/1)->PAR Beliebiger Oktettstring, für den ein MAC berechnet wird
TR-> TD(1,1/1/1)->PAR K TD(1,2/1/1)->PAR Beliebiger Oktettstring, der als Schlüssel verwendet wird. Die Länge von K beträgt 16 oder 24 oder 32 Oktett.
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR T TD(2,2/1/1)->PAR Oktettstring, der zur Prüfung der Integrität und Authentizität von M verwendbar ist
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR T = CalculateCMAC_IsoPadding( K, M )
PAR Das COS MUSS
PAR T
PAR mittels
PAR K
PAR gemäß [CMAC#6.2] aus
PAR M
PAR wie folgt berechnen.
PAR         
PAR T
PAR = CalculateCMAC_NoPadding(
PAR K
PAR , PaddingIso(
PAR M
PAR , 16 ) ).
PAR <b>[<=]</b>

PAR -HEADING(ids=6.6.2)6.6.2 MAC-Prüfung
PAR Die MAC-Prüfung prüft die Konsistenz zwischen Daten und den hinzugefügten Informationen der Datenauthentisierung. Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird eine MAC-Prüfung als Funktion wie folgt verwendet:
PAR -HEADING(ids=6.6.2.1)6.6.2.1 Prüfung Retail-MAC, Option_DES
PAR (N002.900) ist absichtlich leer.
PAR Tabelle 38, CosT_590: Definition der Funktion VERIFY_Retail_MAC(...)

TABLE(rows=6,cols=100+61+584)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR M TD(0,2/1/1)->PAR Beliebiger Oktettstring, der durch einen MAC geschützt ist
TR-> TD(1,1/1/1)->PAR T' TD(1,2/1/1)->PAR Oktettstring, der M zwecks Datenauthentisierung hinzugefügt wurde
TR-> TD(2,1/1/1)->PAR K TD(2,2/1/1)->PAR Beliebiger Oktettstring der Länge 24 Oktett = 192 Bit, der als Schlüssel verwendet wird. K setzt sich zusammen aus den drei Teilschlüsseln Ka, Kb, Kc und es gilt: K = Ka   ||   Kb   ||   Kc  
TR-> TD(3,0/1/1)->PAR Output: TD(3,1/1/1)->PAR out TD(3,2/1/1)->PAR Ergebnis der MAC-Prüfung, entweder VALID oder INVALID
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR – TD(4,2/1/1)->PAR Keine
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR out = VERIFY_Retail_MAC( K, T', M )
REQ(ids=A_13614)<b>A_13614 - (N002.900) K_COS_G1, Option_DES</b>
PAR Das COS MUSS die Integrität der Daten M mittels T' und K prüfen. Dabei werden folgende Schritte durchgeführt:<br>a. Schritt 1:     T = CALCULATE_Retail_MAC( K, M ).<br>b. Schritt 2:     Wenn T identisch zu T' ist, dann gebe VALID zurück sonst gebe INVALID zurück. <b>[<=]</b>

PAR -HEADING(ids=6.6.2.2)6.6.2.2 Prüfung CMAC ohne internes Padding vor der CMAC-Berechnung
REQ(ids=A_13615)<b>A_13615 - (N003.010) K_COS</b>
PAR (ids=Tabelle-39-,-CosT_fa6)Tabelle 39 , CosT_fa6: Definition der Funktion VerifyCMAC_NoPadding(...)

TABLE(rows=6,cols=78+36+485)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR M TD(0,2/1/1)->PAR Beliebiger Oktettstring, der durch einen MAC geschützt ist
TR-> TD(1,1/1/1)->PAR T' TD(1,2/1/1)->PAR Oktettstring, der M zwecks Datenauthentisierung hinzugefügt wurde
TR-> TD(2,1/1/1)->PAR K TD(2,2/1/1)->PAR Beliebiger Oktettstring, der als Schlüssel verwendet wird. Die Länge von K beträgt 16 oder 24 oder 32 Oktett
TR-> TD(3,0/1/1)->PAR Output: TD(3,1/1/1)->PAR out TD(3,2/1/1)->PAR Ergebnis der MAC-Prüfung, entweder VALID oder INVALID
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR – TD(4,2/1/1)->PAR Keine
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR out = VerifyCMAC_NoPadding( K, T', M )
PAR Das COS MUSS die Integrität der Daten
PAR M
PAR mittels
PAR T'
PAR und
PAR K
PAR gemäß [CMAC#6.3] prüfen. Dabei werden folgende Schritte durchgeführt:
PAR a. Schritt 1:     
PAR T
PAR = CalculateCMAC_NoPadding(
PAR K
PAR ,
PAR M
PAR ).
PAR b. Schritt 2:     Wenn
PAR T
PAR identisch zu
PAR T'
PAR ist, dann gebe
PAR VALID
PAR zurück sonst gebe
PAR INVALID
PAR zurück.
PAR <b>[<=]</b>

PAR -HEADING(ids=6.6.2.3)6.6.2.3 Prüfung CMAC mit internem Padding vor der CMAC Berechnung
REQ(ids=A_13616)<b>A_13616 - (N003.020) K_COS</b>
PAR (ids=Tabelle-40-,-CosT_2ad)Tabelle 40 , CosT_2ad: Definition der Funktion VerifyCMAC_IsoPadding(...)

TABLE(rows=6,cols=78+36+485)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR M TD(0,2/1/1)->PAR Beliebiger Oktettstring, der durch einen MAC geschützt ist
TR-> TD(1,1/1/1)->PAR T' TD(1,2/1/1)->PAR Oktettstring, der M zwecks Datenauthentisierung hinzugefügt wurde
TR-> TD(2,1/1/1)->PAR K TD(2,2/1/1)->PAR Beliebiger Oktettstring, der als Schlüssel verwendet wird. Die Länge von K beträgt 16 oder 24 oder 32 Oktett
TR-> TD(3,0/1/1)->PAR Output: TD(3,1/1/1)->PAR out TD(3,2/1/1)->PAR Ergebnis der MAC-Prüfung, entweder VALID oder INVALID
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR – TD(4,2/1/1)->PAR Keine
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR out = VerifyCMAC_IsoPadding( K, T', M )
PAR Das COS MUSS die Integrität der Daten
PAR M
PAR mittels
PAR T'
PAR und
PAR K
PAR gemäß [CMAC#6.3] prüfen. Dabei werden folgende Schritte durchgeführt:
PAR a. Schritt 1:     
PAR T
PAR = CalculateCMAC_IsoPadding(
PAR K
PAR ,
PAR M
PAR ).
PAR b. Schritt 2:     Wenn
PAR T
PAR identisch zu
PAR T'
PAR ist, dann gebe
PAR VALID
PAR zurück sonst gebe
PAR INVALID
PAR zurück.
PAR <b>[<=]</b>

PAR -HEADING(ids=6.6.3)6.6.3 Signaturberechnung
PAR Unter der Berechnung einer Signatur wird in diesem Dokument lediglich die mit dem privaten Schlüssel durchgeführte Operation verstanden.
PAR -HEADING(ids=6.6.3.1)6.6.3.1 Signaturberechnung mittels RSA
PAR -HEADING(ids=6.6.3.1.1)6.6.3.1.1 RSA, ISO9796–2, DS1, SIGN, Option_RSA_CVC
PAR (N003.100) ist absichtlich leer.
PAR Diese Funktionalität wird an der physikalischen Schnittstelle im Rahmen des Kommandos INTERNAL AUTHENTICATE sichtbar (siehe (N086.900)c und (N086.900)d). Sie wird wie folgt verwendet:
PAR Tabelle 41, CosT_533: Definition der Funktion RSA_ISO9796_2_DS1_SIGN

TABLE(rows=6,cols=78+48+474)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR PrK TD(0,2/1/1)->PAR Privater RSA-Schlüssel gemäß (N008.800)
TR-> TD(1,1/1/1)->PAR M TD(1,2/1/1)->PAR Beliebiger Oktettstring, der die zu signierende Nachricht repräsentiert
TR-> TD(2,0/2/1)->PAR Output: TD(2,1/1/1)->PAR sig TD(2,2/1/1)->PAR Oktettstring, welcher die Signatur repräsentiert
TR-> TD(3,1/1/1)->PAR M<sub>2</sub> TD(3,2/1/1)->PAR Oktettstring, welcher den "non recoverable part" der Nachricht M repräsentiert
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR – TD(4,2/1/1)->PAR –
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR ( sig, M<sub>2</sub> ) = RSA_ISO9796_2_DS1_SIGN( PrK, M )
REQ(ids=A_13617)<b>A_13617 - (N003.100) K_COS_G1, Option_RSA_CVC</b>
PAR Das COS MUSS folgende Aktionen gemäß [ISO/IEC 9796-2#7, 8] durchführen, wobei folgende Definitionen gelten:<br>          n = PrK.n,      d = PrK.d<br>a. Schritt 1: Message allocation:<br>                  Aufspalten der Nachricht M in M<sub>1</sub> und M<sub>2</sub> gemäß [ISO/IEC 9796-2#7.2.2].<br>b. Schritt 2: Message representative production:<br>                  Berechnen des Repräsentanten F der Nachricht M gemäß [ISO/IEC 9796-2#8.3],<br>                  wobei t = 1 gesetzt wird und als Hash-Funktion SHA-256 (siehe (N001.300)) verwendet wird.<br>c. Schritt 3: Signature production:<br>                  Gemäß [ISO/IEC 9796-2#7.2.4] und [ISO/IEC 9796-2#B.4] werden folgende Operationen ausgeführt:<br>    1. Schritt 3.1:          J   = OS2I( F )<br>    2. Schritt 3.2:          a   = J<sup>d</sup> mod n<br>     3. Schritt 3.3:          b   = n – a<br>     4. Schritt 3.4:          c   = min{ a, b }<br>    5. Schritt 3.5:          sig = I2OS( c, OctetLength( n ) ) <b>[<=]</b>

PAR -HEADING(ids=6.6.3.1.2)6.6.3.1.2 RSA, SSA, PKCS1–V1_5
PAR Diese Funktionalität wird an der physikalischen Schnittstelle im Rahmen des Kommandos PSO Compute Digital Signature sichtbar (siehe (N088.600)d). Sie wird wie folgt verwendet:
REQ(ids=A_13618)<b>A_13618 - (N003.200) K_COS</b>
PAR (ids=Tabelle-42-,-CosT_234)Tabelle 42 , CosT_234: Definition der Funktion RSASSA_PKCS1_V1_5_SIGN(...)

TABLE(rows=5,cols=92+125+527)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR digestInfo TD(0,2/1/1)->PAR Beliebiger Oktettstring, der als Digest Info verwendet wird (siehe [PKCS#1] Anhang A.2.4)
TR-> TD(1,1/1/1)->PAR PrK TD(1,2/1/1)->PAR Privater RSA-Schlüssel gemäß (N008.800) 
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR S TD(2,2/1/1)->PAR Oktettstring, welcher die Signatur repräsentiert
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR DigestInfoTooLong TD(3,2/1/1)->PAR Der Inputparameter digestInfo enthält zu viele Oktette
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR S = RSASSA_PKCS1_V1_5_SIGN( PrK, digestInfo )
PAR Das COS MUSS folgende Aktion gemäß [PKCS#1] Kapitel 8.2.1 und 9.2 durchführen, wobei folgende Definitionen gelten:   
PAR n
PAR =
PAR PrK.n
PAR ,      
PAR d
PAR =
PAR PrK.d
PAR a. Schritt 0: Wenn OctetLength(
PAR digestInfo
PAR ) > 0,4 OctetLength(
PAR n
PAR ) ist,
PAR                   dann breche diesen Algorithmus mit der Fehlermeldung
PAR DigestInfoTooLong
PAR ab.
PAR b. Schritt 1: Setze         
PAR EM
PAR  
PAR <--
PAR '00'   ||  
PAR digestInfo
PAR c. Schritt 2: Setze         
PAR EM
PAR  
PAR <--
PAR 'FF'   ||  
PAR EM
PAR d. Schritt 3: Wenn OctetLength(
PAR EM
PAR ) kleiner als OctetLength(
PAR n
PAR ) – 2 ist, dann fahre mit Schritt 2 fort.
PAR e. Schritt 4: Setze         
PAR EM
PAR  
PAR <--
PAR '01'   ||  
PAR EM
PAR f.  Schritt 5: Setze         
PAR m
PAR    
PAR <-
PAR - OS2I(
PAR EM
PAR )
PAR g. Schritt 6: Setze         
PAR s
PAR     
PAR <-
PAR -
PAR m<sup>d</sup>
PAR mod
PAR n
PAR h. Schritt 7: Setze         
PAR S
PAR     
PAR <--
PAR I2OS(
PAR s
PAR , OctetLength(
PAR n
PAR ) ).
PAR <b>[<=]</b>

PAR -HEADING(ids=6.6.3.1.3)6.6.3.1.3 RSA, SSA, PSS
PAR Diese Funktionalität ist an der physikalischen Schnittstelle nicht sichtbar. Sie wird im Rahmen interner Funktionen verwendet.
REQ(ids=G2_N003.300)<b>G2_N003.300 - (N003.300) K_COS</b>
PAR (ids=Tabelle-43-,-CosT_858)Tabelle 43 , CosT_858: Definition der Funktion RSA_PSS_SIGN(...)

TABLE(rows=6,cols=98+62+584)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR M<sub>1</sub> TD(0,2/1/1)->PAR Beliebiger Oktettstring, der den "recoverable part" der zu signierenden Nachricht M repräsentiert
TR-> TD(1,1/1/1)->PAR h(M<sub>2</sub>) TD(1,2/1/1)->PAR Beliebiger Oktettstring, der den Hash-Wert über den "non recoverable part" der zu signierenden Nachricht M enthält
TR-> TD(2,1/1/1)->PAR PrK TD(2,2/1/1)->PAR Privater RSA-Schlüssel gemäß (N008.800)
TR-> TD(3,0/1/1)->PAR Output: TD(3,1/1/1)->PAR sig TD(3,2/1/1)->PAR Oktettstring, welcher die Signatur repräsentiert
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR – TD(4,2/1/1)->PAR Keine
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR sig = RSA_PSS_SIGN( PrK, M<sub>1</sub>, h(M<sub>2</sub>) )
PAR Das COS MUSS folgende Aktionen gemäß [ISO/IEC 9796-2#7, 9] durchführen, wobei folgende Definitionen gelten:    
PAR n
PAR =
PAR PrK.n
PAR ,      
PAR d
PAR =
PAR PrK.d
PAR a. Schritt 1: Message representative production:
PAR                   Berechnen des Repräsentanten
PAR F
PAR der Nachricht
PAR M
PAR gemäß [ISO/IEC 9796-2#9.3], wobei
PAR                 
PAR t
PAR  = 1 und
PAR L<sub>s</sub>
PAR  = 
PAR L<sub>h</sub>
PAR gesetzt wird und als Hash-Funktion SHA-256 verwendet wird. Im einzelnen:
PAR     1. Setze           
PAR C
PAR   = I2OS( BitLength( OS2BS(
PAR M<sub>1</sub>
PAR ) ), 8)
PAR     2. Setze           
PAR S
PAR    = RAND( 32 )
PAR     3. Berechne     
PAR H
PAR   = SHA_256(
PAR C
PAR ||
PAR M<sub>1</sub>
PAR ||
PAR h(M<sub>2</sub>)
PAR ||
PAR S
PAR )
PAR     4. Berechne     
PAR F
PAR gemäß [ISO/IEC 9796-2#9.3.2].
PAR b. Schritt 2: Signature production: Gemäß [ISO/IEC 9796-2#7.2.4] und [ISO/IEC 9796-2#B.6] werden folgende Operationen ausgeführt:
PAR     1. Schritt 2.1:   
PAR J
PAR    = OS2I(
PAR F
PAR )
PAR     2. Schritt 2.2:   
PAR a
PAR    =
PAR J<sup>d</sup>
PAR mod
PAR n<br>   
PAR 3.
PAR Schritt 2.3:   
PAR sig
PAR  = I2OS(
PAR a
PAR , OctetLength(
PAR n
PAR ) )
PAR <b>[<=]</b>

PAR -HEADING(ids=6.6.3.1.4)6.6.3.1.4 RSA, ISO9796–2, DS2, SIGN
PAR Diese Funktionalität wird an der physikalischen Schnittstelle im Rahmen des Kommandos PSO Compute Digital Signature sichtbar (siehe (N088.600)b). Sie wird wie folgt verwendet:
REQ(ids=A_13619)<b>A_13619 - (N003.400) K_COS</b>
PAR (ids=Tabelle-44-,-CosT_ace)Tabelle 44 , CosT_ace: Definition der Funktion RSA_ISO9796_2_DS2_SIGN(...)

TABLE(rows=6,cols=98+62+584)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR M<sub>1</sub> TD(0,2/1/1)->PAR Beliebiger Oktettstring, der den "recoverable part" der zu signierenden Nachricht M repräsentiert
TR-> TD(1,1/1/1)->PAR h(M<sub>2</sub>) TD(1,2/1/1)->PAR Beliebiger Oktettstring, der den Hash-Wert  über den "non recoverable part" der zu signierenden Nachricht M enthält
TR-> TD(2,1/1/1)->PAR PrK TD(2,2/1/1)->PAR Privater RSA-Schlüssel gemäß (N008.800)
TR-> TD(3,0/1/1)->PAR Output: TD(3,1/1/1)->PAR sig TD(3,2/1/1)->PAR Oktettstring, welcher die Signatur repräsentiert
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR – TD(4,2/1/1)->PAR Keine
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR sig = RSA_ISO9796_2_DS2_SIGN( PrK, M<sub>1</sub>, h(M<sub>2</sub>) )
PAR Das COS MUSS folgende Aktionen gemäß [ISO/IEC 9796-2#7, 9] durchführen, wobei folgende Definition gilt: 
PAR n
PAR =
PAR PrK.n
PAR a. Schritt 1:  
PAR a
PAR    = OS2I( RSA_PSS_SIGN(
PAR PrK,
PAR M<sub>1</sub>
PAR ,
PAR h(M<sub>2</sub>)
PAR )).
PAR b. Schritt 2:   
PAR b
PAR    =
PAR n
PAR –
PAR a
PAR c. Schritt 3:   
PAR c
PAR    = min{
PAR a
PAR ,
PAR b
PAR }
PAR d. Schritt 4:   
PAR sig
PAR  = I2OS(
PAR c
PAR , OctetLength(
PAR n
PAR ) )
PAR <b>[<=]</b>

PAR -HEADING(ids=6.6.3.1.5)6.6.3.1.5 RSASSA–PSS–SIGN
PAR Diese Funktionalität wird an der physikalischen Schnittstelle im Rahmen der Kommandos INTERNAL AUTHENTICATE (siehe (N086.900)a) und PSO Compute Digital Signature sichtbar (siehe (N088.600)c). Sie wird wie folgt verwendet:
REQ(ids=A_13620)<b>A_13620 - (N003.500) K_COS</b>
PAR (ids=Tabelle-45-,-CosT_7cc)Tabelle 45 , CosT_7cc: Definition der Funktion RSASSA_PSS_SIGN(...)

TABLE(rows=5,cols=98+76+570)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR mHash TD(0,2/1/1)->PAR Beliebiger Oktettstring, der den Hash-Wert über die zu signierenden Nachricht M repräsentiert
TR-> TD(1,1/1/1)->PAR PrK TD(1,2/1/1)->PAR Privater RSA-Schlüssel gemäß (N008.800)
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR S TD(2,2/1/1)->PAR Oktettstring, welcher die Signatur repräsentiert
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR S = RSASSA_PSS_SIGN( PrK, mHash )
PAR Das COS MUSS folgende Aktion gemäß [PKCS#1#8.1.1, 9.1.1] durchführen:
PAR a. Schritt 1:  
PAR M<sub>1</sub>
PAR = '',     (Anmerkung:
PAR M<sub>1</sub>
PAR ist ein leerer Oktettstring)
PAR b. Schritt 2:  
PAR S
PAR   = RSA_PSS_SIGN(
PAR PrK,
PAR M<sub>1</sub>
PAR , mHash
PAR ).
PAR <b>[<=]</b>

PAR -HEADING(ids=6.6.3.2)6.6.3.2 Signaturberechnung mittels ELC
PAR Diese Funktionalität wird an der physikalischen Schnittstelle im Rahmen des Kommandos PSO Compute Digital Signature sichtbar (siehe (N088.600)c). Sie wird wie folgt verwendet:
REQ(ids=A_13621)<b>A_13621 - (N003.600) K_COS</b>
PAR (ids=Tabelle-46-,-CosT_78b)Tabelle 46 , CosT_78b: Definition der Funktion ELC_SIG(...)

TABLE(rows=6,cols=78+48+473)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR H TD(0,2/1/1)->PAR Oktettstring mit beliebigem Inhalt, der einen Hash-Wert repräsentiert
TR-> TD(1,1/1/1)->PAR PrK TD(1,2/1/1)->PAR Privater ELC–Schlüssel gemäß (N008.900) und (N009.000)
TR-> TD(2,0/2/1)->PAR Output: TD(2,1/1/1)->PAR R TD(2,2/1/1)->PAR Oktettstring, erster Teil der ECDSA-Signatur
TR-> TD(3,1/1/1)->PAR S TD(3,2/1/1)->PAR Oktettstring, zweiter Teil der ECDSA-Signatur
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR – TD(4,2/1/1)->PAR Keine
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR ( R, S ) = ELC_SIG( PrK, H )
PAR Das COS MUSS folgende Aktionen gemäß [BSI-TR-03111#4.2.1.1] durchführen, wobei folgende Definitionen gelten:
PAR d<sub>A</sub>
PAR =
PAR PrK.d
PAR ,
PAR G
PAR =
PAR PrK.domainParameter.G
PAR ,
PAR n
PAR =
PAR PrK.domainParameter.n
PAR ,
PAR t
PAR =
PAR PrK.domainParameter.
PAR t
PAR a. Schritt 0:  
PAR H
PAR <sub>t</sub>
PAR   = BS2OS( Extract_MSBit(
PAR H
PAR ,
PAR t
PAR ) ).
PAR b. Schritt 1:  
PAR k
PAR      = RNG( {1,2, …,
PAR n
PAR – 1} ), d.h. zufällig erzeugte ganze Zahl aus dem Intervall [1,
PAR n
PAR – 1].
PAR c. Schritt 2:  
PAR Q
PAR     = [
PAR k
PAR ]
PAR G
PAR     mit    
PAR Q
PAR = (
PAR x<sub>Q</sub>
PAR ,
PAR y<sub>Q</sub>
PAR ).
PAR d. Schritt 3:
PAR  r
PAR      = OS2I( FE2OS(
PAR x<sub>Q</sub><sub> </sub>
PAR ) ) mod
PAR n
PAR .      Wenn
PAR r
PAR gleich null ist, dann gehe zu Schritt 1.
PAR e. Schritt 4:  
PAR k<sub>inv</sub>
PAR =
PAR k
PAR <sup>–1</sup>
PAR mod
PAR n
PAR .
PAR f.  Schritt 5:  
PAR s
PAR      =
PAR k<sub>inv</sub>
PAR (
PAR r
PAR d<sub>A</sub>
PAR + OS2I(
PAR H
PAR <sub>t</sub>
PAR ) ) mod
PAR n
PAR . Wenn
PAR s
PAR gleich null ist, dann gehe zu Schritt 1.
PAR g. Schritt 6:  
PAR R
PAR    = I2OS(
PAR r
PAR ,  ceiling(
PAR t
PAR / 8) ).
PAR                   
PAR S
PAR     = I2OS(
PAR s
PAR , ceiling(
PAR t
PAR / 8) ).
PAR <b>[<=]</b>

PAR Hinweis CosH_b8f: In (N003.600)a wird ein möglicherweise zu langer Hash-Wert auf die Bitlänge von n reduziert, vergleiche dazu auch [BSI-TR-03111#4.2]. Bei den in diesem Dokument verwendeten Kombinationen aus Hash-Algorithmus und Kurvenlänge ist H<sub>t</sub> stets identisch zu H, sodass die Berechnung in (N003.600)a nicht praxisrelevant ist.
PAR -HEADING(ids=6.6.4)6.6.4 Signaturprüfung
PAR Unter der Prüfung einer Signatur wird in diesem Dokument lediglich die mit dem öffentlichen Schlüssel durchgeführte Operation verstanden. Diese Funktionalität wird an der physikalischen Schnittstelle nur teilweise sichtbar, je nach Schlüsseltyp. Im Rahmen diverser interner Operationen im Betriebssystem wird eine Signaturprüfung als Funktion wie folgt verwendet:
PAR -HEADING(ids=6.6.4.1)6.6.4.1 RSA, ISO9796–2, DS1, VERIFY, Option_RSA_CVC
PAR Die folgenden Anforderungen sind absichtlich leer: (N003.700).
PAR Tabelle 47, CosT_adc: Definition der Funktion RSA_ISO9796_2_DS1_VERIFY(...)

TABLE(rows=7,cols=78+48+473)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR PuK TD(0,2/1/1)->PAR Öffentlicher RSA-Schlüssel gemäß (N009.100), (N00.9110) und (N009.200)
TR-> TD(1,1/1/1)->PAR sig TD(1,2/1/1)->PAR Beliebiger Oktettstring, der eine Signatur repräsentiert
TR-> TD(2,1/1/1)->PAR M<sub>2</sub> TD(2,2/1/1)->PAR Beliebiger Oktettstring, der den "non recoverable part" der Nachricht M repräsentiert. Es ist möglich, dass M<sub>2</sub> leer ist.
TR-> TD(3,0/2/1)->PAR Output: TD(3,1/1/1)->PAR out TD(3,2/1/1)->PAR Boolean, True, falls die Signatur gültig ist, andernfalls False
TR-> TD(4,1/1/1)->PAR M TD(4,2/1/1)->PAR Oktettstring, die rekonstruierte Nachricht
TR-> TD(5,0/1/1)->PAR Errors: TD(5,1/1/1)->PAR – TD(5,2/1/1)->PAR Keine
TR-> TD(6,0/1/1)->PAR Notation: TD(6,1/1/1)-> TD(6,2/1/1)->PAR ( out, M ) = RSA_ISO9796_2_DS1_VERIFY( PuK, sig, M<sub>2</sub> )
REQ(ids=A_13622)<b>A_13622 - (N003.700) K_COS, Option_RSA_CVC</b>
PAR Das COS MUSS folgende Aktionen gemäß [ISO/IEC 9796-2#7.2] durchführen, wobei folgende Definitionen gelten:<br>       n = PuK.n,        e = PuK.e. <b>[<=]</b>

PAR (N003.700)a. Schritt 1: Signature opening: Gemäß [ISO/IEC 9796-2#B.5]:
REQ(ids=G2_N003.700.a.1)<b>G2_N003.700.a.1 - (N003.700)a.1 K_COS, Option_RSA_CVC</b>
PAR Schritt 1.1: Wenn die Bitlänge von sig ungleich der Bitlänge von n ist, dann MUSS das COS out = False zurückgeben und den Algorithmus abbrechen. <b>[<=]</b>

REQ(ids=G2_N003.700.a.2)<b>G2_N003.700.a.2 - (N003.700)a.2 K_COS, Option_RSA_CVC</b>
PAR Schritt 1.2: Wenn das höchstwertige Bit von sig den Wert 1 hat, dann MUSS das COS out = False zurückgeben und den Algorithmus abbrechen. <b>[<=]</b>

REQ(ids=G2_N003.700.a.3)<b>G2_N003.700.a.3 - (N003.700)a.3 K_COS, Option_RSA_CVC</b>
PAR Schritt 1.3: Das COS MUSS s aus sig wie folgt berechnen:        s     = OS2I( sig ) <b>[<=]</b>

REQ(ids=G2_N003.700.a.4)<b>G2_N003.700.a.4 - (N003.700)a.4 K_COS, Option_RSA_CVC</b>
PAR Schritt 1.4: Das COS MUSS J* aus s wie folgt berechnen:        J*    = s<sup>e</sup> mod n. <b>[<=]</b>

REQ(ids=G2_N003.700.a.5)<b>G2_N003.700.a.5 - (N003.700)a.5 K_COS, Option_RSA_CVC</b>
PAR Schritt 1.5: Das COS MUSS I* aus J* wie folgt berechnen: Wenn J* gerade ist, dann setze I* = J*, sonst setze I* = n – J*. <b>[<=]</b>

REQ(ids=G2_N003.700.a.6)<b>G2_N003.700.a.6 - (N003.700)a.6 K_COS, Option_RSA_CVC</b>
PAR Schritt 1.6: Wenn I* mod 256 ungleich 'BC' ist, dann MUSS das COS out = False und M = '' zurückgeben und den Algorithmus abbrechen. <b>[<=]</b>

REQ(ids=G2_N003.700.a.7)<b>G2_N003.700.a.7 - (N003.700)a.7 K_COS, Option_RSA_CVC</b>
PAR Schritt 1.7: Das COS MUSS F* aus I* wie folgt berechnen:      F*    = I2OS( I*, OctetLength( n ) ). <b>[<=]</b>

REQ(ids=G2_N003.700.a.8)<b>G2_N003.700.a.8 - (N003.700)a.8 K_COS, Option_RSA_CVC</b>
PAR Schritt 1.8: Wenn das höchstwertige Bit von F* den Wert 1 hat, dann MUSS das COS out = False und M = '' zurückgeben und den Algorithmus abbrechen. <b>[<=]</b>

PAR (N003.700)b. Schritt 2: Message recovery: Gemäß [ISO/IEC 9796-2#8.4]:
REQ(ids=G2_N003.700.b.1)<b>G2_N003.700.b.1 - (N003.700)b.1 K_COS, Option_RSA_CVC</b>
PAR Schritt 2.1: Wenn das zweithöchste Bit von F* den Wert 0 hat,dann MUSS das COS out = False und M = '' zurückgeben und den Algorithmus abbrechen. <b>[<=]</b>

REQ(ids=G2_N003.700.b.2)<b>G2_N003.700.b.2 - (N003.700)b.2 K_COS, Option_RSA_CVC</b>
PAR Schritt 2.2: Das COS MUSS H* und M<sub>1</sub>* gemäß [ISO/IEC 9796-2#8.4] berechnen. <b>[<=]</b>

REQ(ids=G2_N003.700.b.3)<b>G2_N003.700.b.3 - (N003.700)b.3 K_COS, Option_RSA_CVC</b>
PAR Schritt 2.3: Das COS MUSS m aus M<sub>1</sub>* und M<sub>2</sub> wie folgt berechnen: m  = M<sub>1</sub>*   ||   M<sub>2</sub>. <b>[<=]</b>

REQ(ids=G2_N003.700.b.4)<b>G2_N003.700.b.4 - (N003.700)b.4 K_COS, Option_RSA_CVC</b>
PAR Schritt 2.4: Das COS MUSS H aus m wie folgt berechen:                 H   = SHA_256( m ). <b>[<=]</b>

REQ(ids=G2_N003.700.b.5)<b>G2_N003.700.b.5 - (N003.700)b.5 K_COS, Option_RSA_CVC</b>
PAR Schritt 2.5: Das COS MUSS out und M wie folgt berechnen und dann zurückgeben:<br>                 Wenn H identisch ist zu H*, dann gilt out = True und M = m, sonst gilt out = False und M = ''. <b>[<=]</b>

PAR Hinweis CosH_6a8: ACHTUNG: In (N003.700)b.i ist F* ein Oktettstring. Aus diesem F* geht durch Abschneiden des "most significant bit" ein Bitstring hervor, der F* aus [ISO/IEC 9796-2#8.4] entspricht. Deshalb wird in (N003.700)b.i das zweithöchste Bit geprüft und in [ISO/IEC 9796-2#8.4] das "leftmost" Bit.
PAR -HEADING(ids=6.6.4.2)6.6.4.2 Signaturprüfung mittels elliptischer Kurven
REQ(ids=A_13623)<b>A_13623 - (N003.800) K_COS</b>
PAR (ids=Tabelle-48-,-CosT_b2b)Tabelle 48 , CosT_b2b: Definition der Funktion ELC_VER_SIG(...)

TABLE(rows=7,cols=78+48+473)->
TR-> TD(0,0/4/1)->PAR Input: TD(0,1/1/1)->PAR PuK TD(0,2/1/1)->PAR Öffentlicher ELC-Schlüssel gemäß (N009.300) und (N009.400)
TR-> TD(1,1/1/1)->PAR H TD(1,2/1/1)->PAR Beliebiger Oktettstring, der einen Hash-Wert repräsentiert
TR-> TD(2,1/1/1)->PAR R TD(2,2/1/1)->PAR Oktettstring, erster Teil der ECDSA-Signatur
TR-> TD(3,1/1/1)->PAR S TD(3,2/1/1)->PAR Oktettstring, zweiter Teil der ECDSA-Signatur
TR-> TD(4,0/1/1)->PAR Output: TD(4,1/1/1)->PAR out TD(4,2/1/1)->PAR Boolean, True, falls die Signatur gültig ist, andernfalls False
TR-> TD(5,0/1/1)->PAR Errors: TD(5,1/1/1)->PAR – TD(5,2/1/1)->PAR Keine
TR-> TD(6,0/1/1)->PAR Notation: TD(6,1/1/1)-> TD(6,2/1/1)->PAR out = ELC_VER_SIG( PuK, R, S, H )
PAR Das COS MUSS folgende Aktionen gemäß [BSI-TR-03111#4.2.1.2] durchführen, wobei folgende Definitionen gelten:
PAR P<sub>a</sub>
PAR =
PAR PuK.P
PAR ,  
PAR G
PAR =
PAR PuK.domainParameter.G
PAR , 
PAR n
PAR  =
PAR PuK.domainParameter.n
PAR ,
PAR t
PAR =
PAR PuK
PAR .
PAR domainParameter.
PAR t
PAR <b>[<=]</b>

REQ(ids=A_13624)<b>A_13624 - (N003.800)a K_COS</b>
PAR         Schritt 0:  H<sub>t</sub>  = BS2OS( Extract_MSBit( H, t ) ), siehe CosH_b8f    <br>                        r    = OS2I( R ).    <br>                        s    = OS2I( S ). <b>[<=]</b>

REQ(ids=G2_N003.800.b)<b>G2_N003.800.b - (N003.800)b K_COS</b>
PAR         Schritt 1:  Wenn r oder s nicht Element der Menge {1, 2, …, n – 1} sind,<br>                      dann gibt die Funktion out = False zurück und bricht diesen Algorithmus ab. <b>[<=]</b>

REQ(ids=A_17566)<b>A_17566 - (N003.800)c K_COS</b>
PAR         Schritt 2:  s<sub>inv</sub><sup> </sup>    = s<sup>–1</sup> mod n. <b>[<=]</b>

REQ(ids=A_17567)<b>A_17567 - (N003.800)d K_COS</b>
PAR         Schritt 3:  u<sub>1</sub>     = s<sub>inv</sub> OS2I (H<sub>t</sub> ) mod n.    <br>                       u<sub>2</sub>     = s<sub>inv</sub> r mod n. <b>[<=]</b>

REQ(ids=A_17568)<b>A_17568 - (N003.800)e K_COS</b>
PAR         Schritt 4:  Q     = [u<sub>1</sub>] G + [u<sub>2</sub>] P<sub>a</sub>     mit     Q = ( x<sub>Q</sub>, y<sub>Q</sub> ).<br>                       Wenn Q gleich dem unendlich fernen Punkt O entspricht,<br>                       dann gibt die Funktion out = False zurück und bricht diesen Algorithmus ab. <b>[<=]</b>

REQ(ids=A_17569)<b>A_17569 - (N003.800)f K_COS</b>
PAR         Schritt 5:  v     = OS2I ( FE2OS( x<sub>Q</sub> ) ) mod n. <b>[<=]</b>

REQ(ids=G2_N003.800.g)<b>G2_N003.800.g - (N003.800)g K_COS</b>
PAR         Schritt 6: Das COS MUSS als Ergebnis der Funktion out = True zurückgeben, falls v gleich r ist, andernfalls out = False. <b>[<=]</b>

PAR -HEADING(ids=6.7)6.7 CosK_d59 Vertraulichkeit von Daten, symmetrischer Fall
PAR -HEADING(ids=6.7.1)6.7.1 Symmetrische Verschlüsselung
PAR Die symmetrische Verschlüsselung überführt eine beliebige Nachricht plaintext (Oktettstring beliebigen Inhalts und Länge) in ein Chiffrat ciphertext. Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird eine symmetrische Verschlüsselung als Funktion wie folgt verwendet:
PAR -HEADING(ids=6.7.1.1)6.7.1.1 Verschlüsselung 3TDES, Option_DES
PAR (N003.900) ist absichtlich leer.
PAR Tabelle 49, CosT_20c: Definition der Funktion 3TDES_CBX_ENC(...)

TABLE(rows=6,cols=96+75+573)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR P TD(0,2/1/1)->PAR Oktettstring, Klartext (plaintext), beliebiger Oktettstring beliebiger Länge, der verschlüsselt wird
TR-> TD(1,1/1/1)->PAR K TD(1,2/1/1)->PAR Beliebiger Oktettstring der Länge 24 Oktett, der als Schlüssel verwendet wird
TR-> TD(2,1/1/1)->PAR T<sub>1</sub> TD(2,2/1/1)->PAR Beliebige nicht-negative Zahl, die als Startwert verwendet wird
TR-> TD(3,0/1/1)->PAR Output: TD(3,1/1/1)->PAR C TD(3,2/1/1)->PAR Oktettstring, Chiffrat (ciphertext)
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR lengthError TD(4,2/1/1)->PAR Die Länge von P ist kein ganzzahliges Vielfaches der Blocklänge
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR C = 3TDES_CBC_ENC( K, T<sub>1</sub>, P )
REQ(ids=A_13625)<b>A_13625 - (N003.900) K_COS_G1, Option_DES</b>
PAR Das COS MUSS C mittels K und T<sub>1</sub> wie folgt aus P berechnen. Dabei sind folgende Aktionen durchzuführen:<br>a. Schritt 1: Wenn OctetLength( P ) mod 8 ungleich 0 ist,<br>                 dann gebe den Fehler lengthError zurück und breche diesen Algorithmus ab.<br>b. Schritt 2: Teile P auf in Blöcke mit jeweils 64 Bit P == P<sub>1</sub>   ||   P<sub>2</sub>   ||   …   ||   P<sub>n</sub>.<br>c. Schritt 3: Setze          C<sub>0</sub>   = I2OS( T<sub>1</sub>, 8 )<br>d. Schritt 4: Berechne     C<sub>i</sub>   = 3TDES_ENC( K, C<sub>i</sub><sub>–1</sub>   XOR   P<sub>i</sub> ) für i = 1,…, n.<br>e. Schritt 5: Berechne     C    = C<sub>1</sub>   ||   C<sub>2</sub>   ||   …   ||   C<sub>n</sub><sub>–1</sub>   ||   C<sub>n</sub>. <b>[<=]</b>

PAR -HEADING(ids=6.7.1.2)6.7.1.2 Verschlüsselung AES
REQ(ids=A_13626)<b>A_13626 - (N004.000) K_COS</b>
PAR (ids=Tabelle-50-,-CosT_b34)Tabelle 50 , CosT_b34: Definition der Funktion AES_CBC_ENC(...)

TABLE(rows=6,cols=96+73+574)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR P TD(0,2/1/1)->PAR Oktettstring, Klartext (plaintext), beliebiger Oktettstring beliebiger Länge, der verschlüsselt wird
TR-> TD(1,1/1/1)->PAR K TD(1,2/1/1)->PAR Beliebiger Oktettstring der Länge 16, 24 oder 32 Oktett, der als Schlüssel verwendet wird
TR-> TD(2,1/1/1)->PAR T<sub>1</sub> TD(2,2/1/1)->PAR Beliebige nicht-negative Zahl, die als Startwert IV verwendet wird
TR-> TD(3,0/1/1)->PAR Output: TD(3,1/1/1)->PAR C TD(3,2/1/1)->PAR Oktettstring, Chiffrat (ciphertext), das dieselbe Länge wie P besitzt
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR lengthError TD(4,2/1/1)->PAR Die Länge von P ist kein ganzzahliges Vielfaches der Blocklänge
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR C = AES_CBC_ENC( K, T<sub>1</sub>, P )
PAR Das COS MUSS
PAR C
PAR mittels
PAR K
PAR und
PAR T<sub>1</sub>
PAR gemäß [NIST sp800-38a#6.2] aus
PAR P
PAR berechnen. Dabei sind folgende Aktionen durchzuführen:
PAR a. Schritt 1: Wenn OctetLength(
PAR P
PAR ) mod 16 ungleich 0 ist,
PAR                   dann gebe den Fehler
PAR lengthError
PAR zurück und breche diesen Algorithmus ab.
PAR b. Schritt 2: Teile
PAR P
PAR auf in Blöcke mit jeweils 128 Bit:
PAR P
PAR ==
PAR P<sub>1</sub>
PAR   ||  
PAR P<sub>2</sub>
PAR   ||   …   ||  
PAR P<sub>n</sub>
PAR .
PAR c. Schritt 3: Setze         
PAR C<sub>0</sub>
PAR  = I2OS(
PAR T<sub>1</sub>
PAR , 16 )
PAR d. Schritt 4: Berechne     
PAR C<sub>i</sub>
PAR  = AES_ENC(
PAR K
PAR ,
PAR C<sub>i</sub><sub>–1</sub>
PAR   XOR  
PAR P<sub>i</sub>
PAR ) für
PAR i
PAR = 1,…,
PAR n
PAR .
PAR e. Schritt 5: Berechne     
PAR C
PAR   =
PAR C<sub>1</sub>
PAR   ||  
PAR C<sub>2</sub>
PAR   ||   …   ||  
PAR C<sub>n</sub><sub>–1</sub>
PAR   ||  
PAR C<sub>n</sub>
PAR .
PAR <b>[<=]</b>

PAR -HEADING(ids=6.7.2)6.7.2 Symmetrische Entschlüsselung
PAR Die symmetrische Entschlüsselung überführt ein Chiffrat ciphertext (Oktettstring beliebigen Inhalts und Länge) in einen Klartext plaintext. Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird eine symmetrische Entschlüsselung als Funktion wie folgt verwendet:
PAR -HEADING(ids=6.7.2.1)6.7.2.1 Entschlüsselung 3TDES, Option_DES
PAR (N004.100) ist absichtlich leer.
PAR Tabelle 51, CosT_ef0: Definition der Funktion 3TDES_CBX_DEC(...)

TABLE(rows=6,cols=98+72+573)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR C TD(0,2/1/1)->PAR Beliebiger Oktettstring, Chiffrat (ciphertext), der entschlüsselt wird, die Länge ist ein ganzzahliges Vielfaches der Blocklänge
TR-> TD(1,1/1/1)->PAR K TD(1,2/1/1)->PAR Beliebiger Oktettstring der Länge 24 Oktett, der als Schlüssel verwendet wird
TR-> TD(2,1/1/1)->PAR T<sub>1</sub> TD(2,2/1/1)->PAR Beliebige nicht-negative Zahl, die als Startwert verwendet wird
TR-> TD(3,0/1/1)->PAR Output: TD(3,1/1/1)->PAR P TD(3,2/1/1)->PAR Oktettstring, Klartext (plaintext)
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR lengthError TD(4,2/1/1)->PAR Die Länge von C ist kein ganzzahliges Vielfaches der Blocklänge
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR P = 3TDES_CBC_DEC( K, T<sub>1</sub>, C )
REQ(ids=A_13627)<b>A_13627 - (N004.100) K_COS_G1, Option_DES</b>
PAR Das COS MUSS P mittels K und T<sub>1</sub> wie folgt aus C berechnen. Dabei sind folgende Aktionen durchzuführen:<br>a. Schritt 0: Wenn OctetLength( P ) mod 8 ungleich 0 ist,<br>                  dann gebe den Fehler lengthError zurück und breche diesen Algorithmus ab.<br>b. Schritt 1: Teile C auf in Blöcke mit jeweils 64 Bit C == C<sub>1</sub>   ||   C<sub>2</sub>   ||   …   ||   C<sub>n</sub>.<br>c. Schritt 2: Setze         C<sub>0</sub>  = I2OS( T<sub>1</sub>, 8)<br>d. Schritt 3: Berechne    P<sub>i</sub>   = 3TDES_DEC( K, C<sub>i</sub> )   XOR   C<sub>i</sub><sub>–1</sub> für i = 1,…,n.<br>e. Schritt 4: Berechne    P    = P<sub>1</sub>   ||   P<sub>2</sub>   ||   …   ||   P<sub>n</sub><sub>–1</sub>   ||   P<sub>n</sub>. <b>[<=]</b>

PAR -HEADING(ids=6.7.2.2)6.7.2.2 Entschlüsselung AES
REQ(ids=A_13628)<b>A_13628 - (N004.200) K_COS</b>
PAR (ids=Tabelle-52-,-CosT_b49)Tabelle 52 , CosT_b49: Definition der Funtion AES_CBC_DEC(...)

TABLE(rows=6,cols=96+72+575)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR C TD(0,2/1/1)->PAR Beliebiger Oktettstring, Chiffrat (ciphertext) beliebiger Länge, der entschlüsselt wird
TR-> TD(1,1/1/1)->PAR K TD(1,2/1/1)->PAR Beliebiger Oktettstring der Länge 16, 24 oder 32 Oktett, der als Schlüssel verwendet wird
TR-> TD(2,1/1/1)->PAR T<sub>1</sub> TD(2,2/1/1)->PAR Beliebige nicht-negative Zahl, die als Startwert IV verwendet wird
TR-> TD(3,0/1/1)->PAR Output: TD(3,1/1/1)->PAR P TD(3,2/1/1)->PAR Oktettstring, Klartext (plaintext), der dieselbe Länge wie C besitzt
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR lengthError TD(4,2/1/1)->PAR Die Länge von C ist kein ganzzahliges Vielfaches der Blocklänge
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR P = AES_CBC_DEC( K, T<sub>1</sub>, C )
PAR Das COS MUSS
PAR P
PAR mittels
PAR K
PAR und
PAR T<sub>1</sub>
PAR gemäß [NIST sp800-38a#6.2] aus
PAR C
PAR berechnen. Dabei sind folgende Aktionen durchzuführen:
PAR a. Schritt 0: Wenn OctetLength(
PAR P
PAR ) mod 16 ungleich 0 ist,
PAR                   dann gebe den Fehler
PAR lengthError
PAR zurück und breche diesen Algorithmus ab.
PAR b. Schritt 1: Teile
PAR C
PAR auf in Blöcke mit jeweils 128 Bit:
PAR C
PAR ==
PAR C<sub>1</sub>
PAR   ||  
PAR C<sub>2</sub>
PAR   ||   …   ||  
PAR C<sub>n</sub>
PAR .
PAR c. Schritt 2: Setze        
PAR C<sub>0</sub>
PAR  = I2OS(
PAR T<sub>1</sub>
PAR , 16)
PAR d. Schritt 3: Berechne   
PAR P<sub>i</sub>
PAR   = AES_DEC(
PAR K
PAR ,
PAR C<sub>i</sub>
PAR )   XOR  
PAR C<sub>i</sub><sub>–1</sub>
PAR für
PAR i
PAR = 1,…,
PAR n
PAR .
PAR e. Schritt 4: Berechne   
PAR P
PAR    =
PAR P<sub>1</sub>
PAR   ||  
PAR P<sub>2</sub>
PAR   ||   …   ||  
PAR P<sub>n</sub><sub>–1</sub>
PAR   ||  
PAR P<sub>n</sub>
PAR .
PAR <b>[<=]</b>

PAR -HEADING(ids=6.8)6.8 Vertraulichkeit von Daten, asymmetrischer Fall
PAR -HEADING(ids=6.8.1)6.8.1 Asymmetrische Verschlüsselung
PAR Die asymmetrische Verschlüsselung überführt eine Nachricht M (Oktettstring beliebigen Inhalts und Länge) in ein Chiffrat C. Diese Funktionalität wird an der physikalischen Schnittstelle nicht unmittelbar sichtbar. Im Rahmen diverser interner Operationen im Betriebssystem wird eine asymmetrische Verschlüsselung als Funktion wie folgt verwendet:
PAR -HEADING(ids=6.8.1.1)6.8.1.1 RSA, ES, PKCS1 V1.5
PAR Dieses Kapitel ist absichtlich leer.
PAR (N004.300) Diese Anforderung ist absichtlich leer., weil die Verschlüsselung gemäß RSAES_PKCS1_V1_5_ENCRYPT ersatzlos entfallen ist.
PAR -HEADING(ids=6.8.1.2)6.8.1.2 RSA, OAEP, Verschlüsselung
REQ(ids=G2_N004.400)<b>G2_N004.400 - (N004.400) K_COS</b>
PAR (ids=Tabelle-53,-CosT_089)Tabelle 53, CosT_089: Definition der Funktion RSAES_OAEP_ENCRYPT(...)

TABLE(rows=5,cols=77+71+435)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR PuK TD(0,2/1/1)->PAR Öffentlicher RSA-Schlüssel gemäß (N009.100), (N00.9110) und (N009.200)
TR-> TD(1,1/1/1)->PAR M TD(1,2/1/1)->PAR Beliebiger Oktettstring, zu verschlüsselnde Nachricht
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR C TD(2,2/1/1)->PAR Oktettstring, Chiffrat zur Nachricht M
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR ERROR TD(3,2/1/1)->PAR "message too long", falls M ist zu lang
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR C = RSAES_OAEP_ENCRYPT( PuK, M )
PAR Das COS MUSS
PAR C
PAR mittels
PAR PuK
PAR und
PAR M
PAR gemäß [PKCS#1] Kapitel 7.1.1 berechnen. Es gelten folgende Definitionen: 
PAR n
PAR =
PAR PuK.n
PAR ,
PAR e
PAR =
PAR PuK.e
PAR .
PAR a.  Schritt   1: Wenn OctetLength(
PAR M
PAR ) größer als OctetLength(
PAR n
PAR ) – 66 ist,
PAR                      dann breche diesen Algorithmus mit dem Fehler "ERROR" ab.
PAR b.  Schritt   2: Setze    
PAR L
PAR         = '',     (Anmerkung: leerer Oktettstring).
PAR c.  Schritt   3: Setze    
PAR lHash
PAR    = SHA_256(
PAR L
PAR ).
PAR d.  Schritt   4: Setze    
PAR Plen
PAR     = OctetLength(
PAR n
PAR ) – OctetLength(
PAR M
PAR ) – 66.
PAR e.  Schritt   5: Setze    
PAR PS
PAR        = I2OS( 0,
PAR Plen
PAR ).
PAR f.   Schritt   6: Setze    
PAR DB
PAR       =
PAR lHash
PAR   ||  
PAR PS
PAR   ||   '01'   ||  
PAR M
PAR .
PAR g.  Schritt   7: Setze    
PAR seed
PAR      = RAND( 32 ).
PAR h.  Schritt   8: Setze    
PAR dbMask
PAR = BS2OS( MGF( OS2BS(
PAR seed
PAR ), 8 (OctetLength(
PAR n
PAR ) – 33), 0)).
PAR i.   Schritt   9: Setze    
PAR maskedDB
PAR  =
PAR DB
PAR   XOR  
PAR dbMasked
PAR .
PAR j.   Schritt 10: Setze   
PAR seedMask
PAR   = BS2O2( MGF( OS2BS(
PAR maskedDB
PAR ), 8 OctetLength(
PAR lHash
PAR ),    0)).
PAR k.  Schritt 11: Setze    
PAR maskedSeed
PAR =
PAR seed
PAR   XOR  
PAR seedMask
PAR .
PAR l.   Schritt 12: Setze    
PAR EM
PAR  = '00'   ||  
PAR maskedSeed
PAR   ||  
PAR maskedDB
PAR .
PAR m. Schritt 13: Setze    
PAR m
PAR    = OS2I(
PAR EM
PAR ).
PAR n.  Schritt 14: Setze    
PAR c
PAR     =
PAR m<sup>e</sup>
PAR mod
PAR n
PAR .
PAR o.  Schritt 15: Setze    
PAR C
PAR    = I2OS(
PAR c
PAR , OctetLength(
PAR n
PAR )).
PAR <b>[<=]</b>

PAR -HEADING(ids=6.8.1.3)6.8.1.3 Elliptic Curve Key Agreement
PAR Die hier beschriebene Funktionalität ist an der physikalischen Schnittstelle nicht direkt sichtbar, wird aber im Rahmen verschiedener Funktionen mit elliptischen Kurven verwendet.
PAR Hinweis CosH_c0c: In einer früheren Dokumentenversion wurde in diesem Kapitel die Funktion ECKA(...) spezifiziert. In dieser Dokumentenversion wurde die Funktion ECKA(...) aufgespalten in ECKApoint(...) und ECKAvalue(...).
PAR -HEADING(ids=6.8.1.3.1)6.8.1.3.1 Elliptic Curve Key Agreement Point Sab
PAR Die hier beschriebene Funktionalität berechnet aus einem privaten und einem öffentlichen Schlüssel auf einer elliptischen Kurve einen Punkt, der als gemeinsames Geheimnis weiterverwendet wird.
PAR Hinweis CosH_261: Dies entspricht dem ersten Teil der Funktion ECKA(...) aus früheren Dokumentenversionen. Der übrige Teil der Funktion ECKA(...) ist in (N004.492) enthalten.
REQ(ids=G2_N004.490)<b>G2_N004.490 - (N004.490) K_COS</b>
PAR (ids=Tabelle-54-,-CosT_eb0)Tabelle 54 , CosT_eb0: Definition der Funktion ECKApoint(...)
PAR Das COS MUSS
PAR S<sub>AB</sub>
PAR mittels
PAR d
PAR ,
PAR P
PAR und
PAR dP
PAR berechnen, wobei die Schritte 1 bis 3 [BSI-TR-03111#4.3.1] entsprechen. Es gelten folgende Definitionen:
PAR h
PAR  =
PAR dP.h
PAR ,  
PAR n
PAR =
PAR dP.n
PAR ,  
PAR L
PAR =
PAR dP.L
PAR a. Schritt 1:
PAR l
PAR     =
PAR h
PAR <sup>–1</sup>
PAR mod
PAR n
PAR .
PAR b. Schritt 2:
PAR Q
PAR    = [
PAR h
PAR ]
PAR P
PAR .
PAR c. Schritt 3:
PAR S
PAR <sub>AB</sub>
PAR     = [
PAR d l
PAR mod
PAR n
PAR ]
PAR Q
PAR .
PAR                    Wenn
PAR S<sub>AB</sub>
PAR gleich dem unendlich fernen Punkt
PAR O
PAR der Kurve ist,
PAR                    dann gebe den Fehler "ERROR" zurück und beende diesen Algorithmus,
PAR                    sonst gebe
PAR S<sub>AB</sub>
PAR zurück.
PAR d. Dieser Punkt ist absichtlich leer. Er wurde nach (N004.492) verschoben.Schritt 4:        K<sub>AB</sub>     = I2OS( x<sub>S</sub>, L ).
PAR <b>[<=]</b>

PAR -HEADING(ids=6.8.1.3.2)6.8.1.3.2 Elliptic Curve Key Agreement Value Zab
PAR Die hier beschriebene Funktionalität wandelt einen Punkt auf einer elliptischen Kurve, der ein gemeinsames Geheimnis darstellt, in einen Oktettstring um.
PAR Hinweis CosH_35e: Dies entspricht dem zweitenTeil der Funktion ECKA(...) aus früheren Dokumentenversionen. Der erste Teil der Funktion ECKA(...) ist in (N004.490) enthalten.
REQ(ids=A_17556)<b>A_17556 - (N004.492) K_COS</b>
PAR (ids=Tabelle-55-,-CosT_e3a)Tabelle 55 , CosT_e3a: Definition der Funktion ECKAvalue(...)

TABLE(rows=6,cols=77+71+435)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR d TD(0,2/1/1)->PAR natürliche Zahl, die dem privaten Schlüssel PrK entspricht
TR-> TD(1,1/1/1)->PAR P TD(1,2/1/1)->PAR Punkt auf derselben elliptischen Kurve, wie der private Schlüssel PrK
TR-> TD(2,1/1/1)->PAR dP TD(2,2/1/1)->PAR Domainparameter gemäß (N008.600)
TR-> TD(3,0/1/1)->PAR Output: TD(3,1/1/1)->PAR Z<sub>AB</sub> TD(3,2/1/1)->PAR "gemeinsamer geheimer Oktettstring"
TR-> TD(4,0/1/1)->PAR Errors: TD(4,1/1/1)->PAR ERROR TD(4,2/1/1)->PAR Wenn die Funktion in Schritt 1 diesen Fehler meldet
TR-> TD(5,0/1/1)->PAR Notation: TD(5,1/1/1)-> TD(5,2/1/1)->PAR Z<sub>AB</sub> = ECKAvalue( d, P, dP )
PAR Das COS MUSS Z<sub>AB</sub> mittels d, P und dP berechnen, wobei dies Schritt 4 in [BSI-TR-03111#4.3.1] entspricht.<br>a. Schritt 4.a: S<sub>AB</sub> = ECKApoint( d, P, dP ).<br>                     Wenn der Aufruf der Funktion ECKApoint(...) mit der Fehlermeldung ERROR abbricht,<br>                     dann gebe ERROR zurück und beende diesen Algorithmus,<br>                     sonst fahre mit Schritt 4.b fort.
PAR b. Schritt 4.b: Z<sub>AB</sub> = I2OS( x<sub>s</sub>, dp.L ) mit x<sub>s</sub> == x-Komponente des Punktes S<sub>AB</sub>.
PAR <b>[<=]</b>

PAR -HEADING(ids=6.8.1.4)6.8.1.4 ELC Verschlüsselung
REQ(ids=G2_N004.500)<b>G2_N004.500 - (N004.500) K_COS</b>
PAR (ids=Tabelle-56-,-CosT_a09)Tabelle 56 , CosT_a09: Definition der Funktion ELC_ENC(...)

TABLE(rows=8,cols=100+91+553)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR M TD(0,2/1/1)->PAR Oktettstring, zu verschickende Nachricht mit beliebigem Inhalt und beliebiger Länge, die verschlüsselt wird
TR-> TD(1,1/1/1)->PAR PO<sub>B</sub> TD(1,2/1/1)->PAR Oktettstring, öffentlicher Punkt P<sub>B</sub> des Empfängers
TR-> TD(2,1/1/1)->PAR dP TD(2,2/1/1)->PAR Domainparameter gemäß (N008.600)
TR-> TD(3,0/3/1)->PAR Output: TD(3,1/1/1)->PAR PO<sub>A</sub> TD(3,2/1/1)->PAR Oktettstring, ephemer Punkt PE<sub>A</sub> des Senders
TR-> TD(4,1/1/1)->PAR C TD(4,2/1/1)->PAR Oktettstring, Chiffrat der Nachricht M
TR-> TD(5,1/1/1)->PAR T TD(5,2/1/1)->PAR Oktettstring, MAC über das Chiffrat C
TR-> TD(6,0/1/1)->PAR Errors: TD(6,1/1/1)->PAR ERROR TD(6,2/1/1)->PAR 1. Wenn in Schritt 0 ein Fehler auftritt<br>2. Wenn in ECKAvalue(...) ein Fehler auftritt
TR-> TD(7,0/1/1)->PAR Notation: TD(7,1/1/1)-> TD(7,2/1/1)->PAR ( PO<sub>A</sub>, C, T ) = ELC_ENC( M, PO<sub>B</sub>, dP )
PAR Das COS MUSS
PAR PO<sub>A</sub>
PAR ,
PAR C
PAR und
PAR T
PAR mittels
PAR M
PAR und
PAR PO<sub>B</sub>
PAR berechnen, wobei
PAR dies Schritt 3 in [BSI-TR-03111#4.3.1] entspricht und
PAR folgende Definitionen gelten:
PAR n
PAR =
PAR dP.n
PAR ,    
PAR h
PAR =
PAR dP.h
PAR ,    
PAR G
PAR =
PAR dP.G
PAR ,    
PAR L
PAR =
PAR dP.L
PAR a. Schritt 0: 
PAR P<sub>B</sub>
PAR   = OS2P(
PAR PO<sub>B</sub>
PAR ,
PAR dP
PAR ).    
PAR                   Wenn diese Funktion mit einem Fehler terminiert,
PAR                   dann gebe "ERROR" zurück und beende diesen Algorithmus.
PAR b. Schritt 1:
PAR d
PAR     = RNG({1, 2, …,
PAR n
PAR  – 1}), d.h. zufällig erzeugte ganze Zahl aus dem Intervall [1,
PAR n
PAR – 1].
PAR c. Schritt 2:
PAR PE<sub>A</sub>
PAR <sup> </sup>
PAR = [
PAR d
PAR ]
PAR G
PAR .
PAR d. Schritt 3:
PAR K<sub>AB</sub>
PAR = ECKA
PAR value
PAR (
PAR d
PAR ,
PAR P<sub>B</sub>
PAR ,
PAR dP
PAR ).    
PAR                   Wenn die Funktion ECKA
PAR value(...)
PAR einen Fehler meldet,
PAR                   dann gebe
PAR ERROR
PAR zurück und beende diesen Algorithmus.
PAR e. Schritt 4: Berechne abgeleitete Schlüssel gemäß (N001.520)
PAR     1. (
PAR K<sub>enc</sub>
PAR ,
PAR K<sub>mac</sub>
PAR ,
PAR T<sub>2</sub>
PAR ) = KeyDerivation_AES256(
PAR K<sub>AB</sub>
PAR ).
PAR     2. Setze:
PAR T<sub>1</sub>
PAR    = OS2I(AES_ENC(
PAR K<sub>enc</sub>
PAR , I2OS(
PAR T<sub>2</sub>
PAR , 16)))
PAR f.  Schritt 5:
PAR PO<sub>A</sub>
PAR = P2OS(
PAR PE<sub>A</sub>
PAR ,
PAR L
PAR ).
PAR g. Schritt 6: 
PAR C
PAR     = AES_CBC_ENC(
PAR K<sub>enc</sub>
PAR ,
PAR T<sub>1</sub>
PAR ,
PAR PaddingIso
PAR (
PAR M
PAR , 16)).
PAR h. Schritt 7: 
PAR T
PAR    = CalculateCMAC_IsoPadding(
PAR K<sub>mac</sub>
PAR ,
PAR C
PAR ).
PAR <b>[<=]</b>

PAR -HEADING(ids=6.8.2)6.8.2 Asymmetrische Entschlüsselung
PAR Die asymmetrische Entschlüsselung überführt ein Chiffrat C in eine Nachricht M.
PAR -HEADING(ids=6.8.2.1)6.8.2.1 RSA, ES, PKCS1 V1.5, Decrypt
PAR Dieses Kapitel ist absichtlich leer.
PAR (N004.600) Diese Anforderung  ist absichtlich leer.
PAR -HEADING(ids=6.8.2.2)6.8.2.2 RSA, OAEP, Decrypt
PAR Diese Funktionalität wird an der physikalischen Schnittstelle im Rahmen des Kommandos PSO Decipher sichtbar (siehe (N090.300)b).
REQ(ids=G2_N004.700)<b>G2_N004.700 - (N004.700) K_COS</b>
PAR (ids=Tabelle-57-,-CosT_c8a)Tabelle 57 , CosT_c8a: Definition der Funktion RSAES_OAEP_DECRYPT(...)

TABLE(rows=5,cols=58+100+586)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR PrK TD(0,2/1/1)->PAR Privater RSA-Schlüssel gemäß (N008.800)
TR-> TD(1,1/1/1)->PAR C TD(1,2/1/1)->PAR Beliebiger Oktettstring, Chiffrat der Nachricht M
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR M TD(2,2/1/1)->PAR Oktettstring, Klartextnachricht zum Chiffrat C
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR decryptionError TD(3,2/1/1)->PAR falls einer der folgenden Fälle eintritt:<br>C ist numerisch größer gleich dem Modulus von PrK
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR M = RSAES_OAEP_DECRYPT( PrK, C )
PAR Das COS MUSS
PAR M
PAR mittels
PAR PrK
PAR und
PAR C
PAR gemäß [PKCS#1#7.1.2] berechnen. Es gelten folgende Definitionen: 
PAR n
PAR =
PAR PrK.n
PAR ,
PAR d
PAR =
PAR PrK.d
PAR .
PAR a. Schritt   1: Setze       
PAR L
PAR      = '',     (Anmerkung: leerer Oktettstring).
PAR b. Schritt   2: Setze       
PAR c
PAR      = OS2I(
PAR C
PAR ).
PAR c. Schritt   3: Wenn
PAR c
PAR größer gleich
PAR n
PAR ist,
PAR                     dann breche diesen Algorithmus mit
PAR decryptionError
PAR ab.
PAR d. Schritt   4: Setze       
PAR m
PAR      =
PAR c<sup>d</sup>
PAR mod
PAR n
PAR .
PAR e. Schritt   5: Setze       
PAR EM
PAR    = I2OS(
PAR m
PAR , OctetLength(
PAR n
PAR ) ).
PAR f.  Schritt   6: Setze       
PAR lHash 
PAR = SHA_256(
PAR L
PAR ).
PAR g. Schritt   7: Teile
PAR EM
PAR wie folgt auf:
PAR     1. Schritt 7.1:      
PAR EM
PAR   ==
PAR Y
PAR   ||  
PAR maskedSeed
PAR   ||  
PAR maskedDB
PAR .
PAR     2. Schritt 7.2:        1    == OctetLength(
PAR Y
PAR ).
PAR     3. Schritt 7.3:      32    == OctetLength(
PAR maskedSeed
PAR ).
PAR h. Schritt   8: Setze
PAR seedMask
PAR = BS2OS(MGF( OS2BS(
PAR maskedDB
PAR ), 8 OctetLength(
PAR lHash
PAR ),       0)).
PAR i. Schritt   9: Setze   
PAR seed
PAR      =
PAR maskedSeed
PAR   XOR  
PAR seedMask
PAR .
PAR j. Schritt 10: Setze    
PAR dbMask
PAR   = BS2OS(MGF(OS2BS(
PAR seed
PAR ), 8 OctetLength(
PAR maskedDB
PAR ), 0)).
PAR k. Schritt 11: Setze       
PAR DB
PAR     =
PAR maskedDB
PAR   XOR  
PAR dbMask
PAR .
PAR l.  Schritt 12: Teile
PAR DB
PAR wie folgt auf:
PAR     1. Schritt 12.1:       
PAR DB
PAR   ==
PAR lHash’
PAR   ||  
PAR PS
PAR   ||   '01'   ||  
PAR M
PAR .
PAR     2. Schritt 12.2:       32    == OctetLength(
PAR lHash’
PAR ).
PAR     3. Schritt 12.3: Der möglicherweise leere Oktettstring
PAR PS
PAR enthält nur Oktette mit dem Wert '00'.
PAR m. Schritt 13: Breche diesen Algorithmus mit
PAR decryptionError
PAR ab, wenn
PAR      1.
PAR lHash’
PAR ungleich
PAR lHash
PAR ist, oder
PAR      2.
PAR Y
PAR nicht den Wert '00' besitzt, oder
PAR      3. kein Oktett mit dem Wert '01' existiert, welches
PAR PS
PAR von
PAR M
PAR trennt.
PAR n. Gebe
PAR M
PAR zurück.
PAR <b>[<=]</b>

PAR -HEADING(ids=6.8.2.3)6.8.2.3 ELC Entschlüsselung
PAR Diese Funktionalität wird an der physikalischen Schnittstelle im Rahmen des Kommandos PSO Decipher sichtbar (siehe (N090.300)c).
REQ(ids=G2_N004.800)<b>G2_N004.800 - (N004.800) K_COS</b>
PAR (ids=Tabelle-58-,-CosT_bb4)Tabelle 58 , CosT_bb4: Definition der Funktion ELC_DEC(...)

TABLE(rows=7,cols=58+61+625)->
TR-> TD(0,0/4/1)->PAR Input: TD(0,1/1/1)->PAR PrK TD(0,2/1/1)->PAR Privater ELC–Schlüssel gemäß (N008.900) und (N009.000)
TR-> TD(1,1/1/1)->PAR PO TD(1,2/1/1)->PAR Oktettstring, ephemerer Punkt PE<sub>A</sub> des Senders
TR-> TD(2,1/1/1)->PAR C TD(2,2/1/1)->PAR Oktettstring, Chiffrat der Nachricht M
TR-> TD(3,1/1/1)->PAR T' TD(3,2/1/1)->PAR Oktettstring, MAC über das Chiffrat C
TR-> TD(4,0/1/1)->PAR Output: TD(4,1/1/1)->PAR M TD(4,2/1/1)->PAR Oktettstring, Klartextnachricht zum Chiffrat C
TR-> TD(5,0/1/1)->PAR Errors: TD(5,1/1/1)->PAR ERROR TD(5,2/1/1)->PAR 1. Wenn PO nicht im Format "uncompressed encoding" vorliegt<br>2. Wenn PO einen Punkt bezeichnet, der nicht auf derselben Kurve liegt, wie PrK<br>3. Wenn die Funktion ECKAvalue(...) einen Fehler meldet<br>4. Wenn die MAC-Prüfung fehlschlägt
TR-> TD(6,0/1/1)->PAR Notation: TD(6,1/1/1)-> TD(6,2/1/1)->PAR M = ELC_DEC( PO, PrK, C, T' )
PAR Das COS MUSS
PAR M
PAR mittels
PAR PE<sub>A</sub>
PAR ,
PAR PrK
PAR ,
PAR C
PAR und
PAR T'
PAR berechnen, wobei
PAR Schritt 1 [BSI-TR-03111#4.3.1] entspricht. Es gelten
PAR folgende Definitionen gelten:
PAR d
PAR =
PAR PrK.d
PAR , 
PAR h
PAR =
PAR PrK.domainParameter.h
PAR , 
PAR n
PAR =
PAR PrK.domainParameter.n
PAR ,
PAR L
PAR =
PAR PrK.domainParameter.L
PAR a. Schritt 0:
PAR PE<sub>A</sub>
PAR     = OS2P(
PAR PO
PAR ,
PAR PrK.domainParameter
PAR ).
PAR                   Wenn diese Funktion mit einem Fehler terminiert,
PAR                   dann gebe
PAR ERROR
PAR zurück und beende diesen Algorithmus.
PAR b. Schritt 1:
PAR K<sub>AB</sub>
PAR     = ECKA
PAR value
PAR (
PAR d
PAR ,
PAR PE<sub>A</sub>
PAR ,
PAR PrK.domainParameter
PAR ).
PAR c. Schritt 2: Berechne abgeleitete Schlüssel gemäß (N001.520)
PAR     1. (
PAR K<sub>enc</sub>
PAR ,
PAR K<sub>mac</sub>
PAR ,
PAR T<sub>2</sub>
PAR )  = KeyDerivation_AES256(
PAR K<sub>AB</sub>
PAR )
PAR     2. Setze: 
PAR T<sub>1</sub>
PAR     = OS2I(AES_ENC (
PAR K<sub>enc</sub>
PAR , I2OS(
PAR T<sub>2</sub>
PAR , 16)))
PAR d. Schritt 3:
PAR out
PAR     = VerifyCMAC_IsoPadding(
PAR K<sub>mac</sub>, T', C
PAR ).
PAR                   Wenn
PAR out
PAR den Wert
PAR INVALID
PAR besitzt,
PAR                   dann gebe
PAR ERROR
PAR zurück und beende diesen Algorithmus.
PAR e. Schritt 4:
PAR M
PAR      = TruncateIso(AES_CBC_DEC(
PAR K<sub>enc</sub>,
PAR T<sub>1</sub>
PAR , C
PAR ), 16)
PAR <b>[<=]</b>

PAR -HEADING(ids=7)7 CosK_81a CV-Zertifikat (informativ)
PAR Die folgenden Anforderungen sind absichlich leer: (N004.900), (N005.000), (N005.100), (N005.200), (N005.300), (N005.400), (N005.500), (N005.600), (N005.700), (N005.800), (N005.900), (N006.000), (N006.100), (N006.200), N006.300), (N006.400), (N006.500), (N006.600).
PAR Bis zur Version 3.11.0 vom 14.5.2018 enthielten sie Anforderungen an CV-Zertifikate für RSA-Schlüssel. Seit dem 1.1.2019 werden derartige CV-Zertifikate in der Telematikinfrastruktur nicht mehr verwendet.
PAR In [ISO/IEC 7816-8] werden zwei kompakte Zertifikatsformate definiert, sogenannte Card Verifiable Certificate (CVC), die eine Prüfung und Analyse durch eine Smartcard erleichtern. Typischerweise enthalten CV-Zertifikate nur die Informationen, welche eine Smartcard notwendigerweise für einen bestimmten Use Case benötigt. Sie sind deshalb kompakter als andere Zertifikatsformate, was sich positiv auf die Performanz auswirkt.
PAR -HEADING(ids=7.1)7.1 CosK_069 CV-Zertifikat für RSA-Schlüssel
PAR In diesem Kapitel werden nur so genannte "nicht selbstbeschreibende" CV-Zertifikate betrachtet, welche eine Signatur mit "Message Recovery" gemäß [ISO/IEC 9796-2] DS1 enthalten.
PAR Technisch betrachtet ist ein derartiges Zertifikat eine mittels [ISO/IEC 9796-2] DS1 signierte Nachricht M. Die Nachricht M enthält unterschiedliche Daten, die ohne Strukturinformationen oder Trennzeichen konkateniert sind, daher die Bezeichnung "nicht selbstbeschreibend". Damit die enthaltenen Informationen eindeutig extrahierbar sind, wird das höchstwertige Oktett von M ausgewertet.
PAR -HEADING(ids=7.1.1)7.1.1 Bestandteile eines CV-Zertifikats für RSA-Schlüssel
PAR Alle in CosK_069 betrachteten signierten Nachrichten M enthalten die in den folgenden Unterkapiteln beschriebenen Informationen.
PAR -HEADING(ids=7.1.1.1)7.1.1.1 Certificate Profile Identifier (CPI)
PAR Der Certificate Profile Identifier (CPI) zeigt die im CV-Zertifikat verwendete Struktur an.
PAR -HEADING(ids=7.1.1.2)7.1.1.2 Certification Authority Reference (CAR)
PAR Die Certification Authority Reference (CAR) referenziert den Schlüssel der CA, welche das Zertifikat ausstellte. Typischerweise besitzt die CAR eine innere Struktur, welche sicherstellt, dass die CAR weltweit eineindeutig ist.
PAR Typischerweise besitzt die ausstellende CA wiederum ein CV-Zertifikat. Auf diese Weise wird eine baumartige PKI aufgespannt mit der Root-CA an der Wurzel.
PAR Der öffentliche Schlüssel der Root-CA wird oft als Sicherheitsanker bezeichnet und typischerweise in der Vorbereitungsphase (siehe CosK_91f) in einer Smartcard gespeichert. Deshalb ist es nicht notwendig, den Sicherheitsanker per Zertifikat zu importieren (Abbruch der Rekursion zum Zertifikatsimport).
PAR -HEADING(ids=7.1.1.3)7.1.1.3 Certificate Holder Reference (CHR)
PAR Die Certificate Holder Reference (CHR) wird dazu verwendet, dem im Zertifikat enthaltenen öffentlichen Schlüssel einen eindeutigen Identifier zuzuordnen. Typischerweise wird die ebenfalls eindeutige Seriennummer einer Smartcard (ICCSN) als Teil der CHR verwendet. Im Rahmen dieses Dokumentes ist es irrelevant, wie die CHR gebildet wird.
PAR -HEADING(ids=7.1.1.4)7.1.1.4 CosK_ec2 Certificate Holder Autorisation (CHA)
PAR Die Certificate Holder Autorisation (CHA) zeigt eine Rolle des Zertifikatsinhabers an. Typischerweise fordern Sicherheitskonzepte, dass zwei verschiedene Rollen unterhalb einer Root-CA nicht dieselbe CHA haben dürfen. Deshalb wird häufiger auch die Forderung erhoben, dass die CHA weltweit eineindeutig ist. Dann wird typischerweise ein Teil des eindeutigen Application Identifiers als Teil der CHA verwendet. Im Rahmen dieses Dokumentes ist es irrelevant, wie konkrete CHA-Werte festgelegt werden.
PAR -HEADING(ids=7.1.1.5)7.1.1.5 Object Identifier (OID)
PAR Der Object Identifier (OID) in einem CVC beschreibt den Algorithmus, welcher dem Schlüssel im Zertifikat zugeordnet ist. Im Rahmen dieser Spezifikation werden verschiedene Algorithmen für verschiedene Verwendungszwecke genutzt, so dass implizit durch den Algorithmus-OID auch der Verwendungszweck des im Zertifikat enthaltenen öffentlichen Schlüssels festgelegt wird. OIDs sind weltweit eineindeutig.
PAR Im Rahmen von CosK_069 werden nur folgende OID-Werte verwendet (siehe CosT_a91) :    <br>authS_ISO9796-2Withrsa_sha256_mutual und sigS_ISO9796-2Withrsa_sha256.
PAR -HEADING(ids=7.1.1.6)7.1.1.6 Öffentlicher Schlüssel
PAR Der öffentliche RSA-Schlüssel besteht aus den in den folgenden Unterkapiteln beschriebenen Teilen.
PAR -HEADING(ids=7.1.1.6.1)7.1.1.6.1 Modulus
PAR Der Modulus wird hexadezimal, vorzeichenlos im Big-Endian-Format codiert.
PAR -HEADING(ids=7.1.1.6.2)7.1.1.6.2 Öffentlicher Exponent
PAR Der öffentliche Exponent wird hexadezimal, vorzeichenlos im Big-Endian-Format codiert.
PAR -HEADING(ids=7.1.2)7.1.2 CosK_e9b Zertifikatsprofile für RSA-Schlüssel
PAR Dieses Kapitel listet die zu unterstützenden Zertifikatsprofile auf, die anhand des CPI identifiziert werden.
PAR -HEADING(ids=7.1.2.1)7.1.2.1 CosK_0d2 CV-Zertifikat für CA-Schlüssel
PAR In diesem Unterkapitel wird der Aufbau eines CV-Zertifikates beschrieben, welches den öffentlichen Schlüssel einer CA enthält. Dieser öffentliche Schlüssel ist wiederum geeignet, im Rahmen eines PSO Verify Certificate-Kommandos (siehe CosK_4ab) weitere öffentliche Schlüssel per CV-Zertifikat zu importieren. Für derartige CV-Zertifikate gilt:
REQ(ids=A_13697)<b>A_13697 - (N004.900) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Der CPI MUSS den Wert '21' haben. <b>[<=]</b>

REQ(ids=A_13698)<b>A_13698 - (N005.000) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Die OID MUSS den Wert sigS_ISO9796-2Withrsa_sha256 = '2B24 0304 0202 04' haben (siehe CosT_a91). <b>[<=]</b>

REQ(ids=A_13699)<b>A_13699 - (N005.100) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Die Länge des Modulus MUSS 2048 bit betragen. <b>[<=]</b>

REQ(ids=A_13700)<b>A_13700 - (N005.200) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Der öffentliche Exponent MUSS vier Oktett lang sein. <b>[<=]</b>

REQ(ids=A_13701)<b>A_13701 - (N005.300) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Die CHR MUSS acht Oktett lang sein. <b>[<=]</b>

REQ(ids=A_13702)<b>A_13702 - (N005.400) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Die CAR MUSS acht Oktett lang sein. <b>[<=]</b>

REQ(ids=A_13703)<b>A_13703 - (N005.500) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Für die zu signierende Nachricht M gilt:<br>    M = CPI   ||   Modulus   ||   öffentlicherExponent   ||   OID   ||   CHR   ||   CAR. <b>[<=]</b>

PAR Wenn (N002.100)a berücksichtigt wird und der Hash-Wert mit einer Funktion aus CosK_0bb gebildet wird, dann gehören CHR und CAR stets zum "non recoverable part" der signierten Nachricht und liegen somit stets im Klartext vor.
PAR -HEADING(ids=7.1.2.2)7.1.2.2 CosK_bc0 CV-Zertifikat für Authentisierungsschlüssel
PAR In diesem Unterkapitel wird der Aufbau eines CV-Zertifikats beschrieben, welches den öffentlichen Schlüssel einer Instanz enthält, welche diesen Schlüssel zu Authentisierungszwecken verwendet. Für derartige CV-Zertifikate gilt:
REQ(ids=A_13704)<b>A_13704 - (N005.600) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Der CPI MUSS den Wert '22' haben. <b>[<=]</b>

REQ(ids=A_13705)<b>A_13705 - (N005.700) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Die CHA MUSS sieben Oktett lang sein. <b>[<=]</b>

REQ(ids=A_13706)<b>A_13706 - (N005.800) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Die OID MUSS den Wert authS_ISO9796-2Withrsa_sha256_mutual = '2B24 0305 0204' haben (siehe CosT_a91). <b>[<=]</b>

REQ(ids=A_13707)<b>A_13707 - (N005.900) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Die Länge des Modulus MUSS 2048 bit betragen. <b>[<=]</b>

REQ(ids=A_13708)<b>A_13708 - (N006.000) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Der öffentliche Exponent MUSS vier Oktett lang sein. <b>[<=]</b>

REQ(ids=A_13709)<b>A_13709 - (N006.100) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Die CHR MUSS zwölf Oktett lang sein. <b>[<=]</b>

REQ(ids=A_13710)<b>A_13710 - (N006.200) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Die CAR MUSS acht Oktett lang sein. <b>[<=]</b>

REQ(ids=A_13711)<b>A_13711 - (N006.300) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Für die zu signierende Nachricht M gilt:<br>    M = CPI  ||  Modulus  ||  öffentlicherExponent   ||  OID  ||  CHA  ||  CHR  ||  CAR. <b>[<=]</b>

PAR Wenn (N002.100)a berücksichtigt wird und der Hash-Wert mit einer Funktion aus CosK_0bb gebildet wird, dann gehören CHA, CHR und CAR stets zum "non recoverable part" der signierten Nachricht und liegen damit stets im Klartext vor.
PAR -HEADING(ids=7.1.3)7.1.3 Struktur und Inhalt eines CV-Zertifikats für RSA-Schlüssel
PAR Die Inhalte eines Zertifikat-Datenobjektes werden wie folgt berechnet:
REQ(ids=A_13712)<b>A_13712 - (N006.400) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Schritt 1: Die Nachricht M MUSS gemäß (N005.500) oder (N006.300) erzeugt werden. <b>[<=]</b>

REQ(ids=A_13713)<b>A_13713 - (N006.500) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Schritt 2: Die Nachricht M MUSS mit einem privaten RSA-Schlüssel PrK signiert werden, dessen Moduluslänge 2048 bit beträgt. Als Signaturverfahren MUSS (N003.100) verwendet werden, so dass gilt:    <br>     ( SIG.CA, M<sub>2</sub> ) = RSA_ISO9796_2_DS1_SIGN( PrK, M ). <b>[<=]</b>

REQ(ids=A_13714)<b>A_13714 - (N006.600) K_Anwendungsspezifikation {K_Karte}, Option_RSA_CVC</b>
PAR Ein CV-Zertifikats-EF MUSS ein zusammengesetztes Zertifikat-Datenobjekt mit Tag = '7F21' (CV-Zertifikat) enthalten. Das Zertifikat-Datenobjekt MUSS genau zwei primitive Datenobjekte in der angegebenen Reihenfolge enthalten:<br>a. Datenelement SIG.CA als Wertfeld in einem Datenobjekt mit Tag = '5F37'.<br>b. Non-recoverable part M<sub>2</sub> als Wertfeld in einem Datenobjekt mit Tag = '5F38'. <b>[<=]</b>

PAR CV-Zertifikate für RSA-Schlüssel mit einer Moduluslänge von 2048 bit = 256 Oktett:
PAR Tabelle 59, CosT_ad5: CV-Zertifikat einer CA mit CPI = '21', SHA-256

TABLE(rows=5,cols=57+72+57+72+336)->
TR-> TH(0,0/1/1)->PAR Tag TH(0,1/1/1)->PAR L TH(0,2/1/3)->PAR Wert
TR-> TD(1,0/1/1)->PAR '7F21' TD(1,1/1/1)->PAR '820146' TD(1,2/1/3)->PAR CV-Zertifikat                    ('0146' = 326 Oktett)
TR-> TD(2,0/3/2)-> TD(2,2/1/1)->PAR Tag TD(2,3/1/1)->PAR L TD(2,4/1/1)->PAR Wert
TR-> TD(3,2/1/1)->PAR '5F37' TD(3,3/1/1)->PAR '820100' TD(3,4/1/1)->PAR Signatur SIG.CA              ('0100'  = 256 Oktett)
TR-> TD(4,2/1/1)->PAR '5F38' TD(4,3/1/1)->PAR '3E' TD(4,4/1/1)->PAR non recoverable part M<sub>2</sub>   ('003E' =   62 Oktett)
PAR Tabelle 60, CosT_6ea: CV-Zertifikat zur Authentisierung mit CPI = '22', SHA-256

TABLE(rows=5,cols=57+72+57+72+336)->
TR-> TH(0,0/1/1)->PAR Tag TH(0,1/1/1)->PAR L TH(0,2/1/3)->PAR Wert
TR-> TD(1,0/1/1)->PAR '7F21' TD(1,1/1/1)->PAR '820150' TD(1,2/1/3)->PAR CV-Zertifikat                    ('0150' = 336 Oktett)
TR-> TD(2,0/3/2)-> TD(2,2/1/1)->PAR Tag TD(2,3/1/1)->PAR L TD(2,4/1/1)->PAR Wert
TR-> TD(3,2/1/1)->PAR '5F37' TD(3,3/1/1)->PAR '820100' TD(3,4/1/1)->PAR Signatur SIG.CA              ('0100' = 256 Oktett)
TR-> TD(4,2/1/1)->PAR '5F38' TD(4,3/1/1)->PAR '48' TD(4,4/1/1)->PAR non recoverable part M<sub>2</sub>   ('0048' =   72 Oktett)
PAR Hinweis CosH_a67: Vorgaben für CV-Zertifikate für ELC-Schüssel finden sich in [gemSpec_PKI].
PAR -HEADING(ids=7.2)7.2 CV-Zertifikate für ELC-Schlüssel
PAR Normative Festlegungen zu CV-Zertifikaten für ELC-Schlüssel finden sich in [gemSpec_PKI].
PAR -HEADING(ids=8)8 CosK_f55 Objekte
PAR -HEADING(ids=8.1)8.1 Diverse Attribute (normativ)
PAR Dieses Unterkapitel beschreibt einige Attribute, die für mehrere Objekttypen gleichermaßen relevant sind.
PAR -HEADING(ids=8.1.1)8.1.1 CosK_6ab File Identifier
PAR Der Attributstyp fileIdentifier wird von den Objekttypen DF und Datei verwendet.
PAR Aus der Norm [ISO/IEC 7816-4] leiten sich folgende Regeln ab, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=G2_N006.700)<b>G2_N006.700 - (N006.700) K_Anwendungsspezifikation {K_Karte}</b>
PAR Der Wert von fileIdentifier MUSS eine ganze Zahl im Intervall ['1000', 'FEFF'] oder Element der Menge {'011C'} sein. <b>[<=]</b>

REQ(ids=A_13717)<b>A_13717 - (N006.800) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Objekt, das nicht root (siehe (N019.900)a) ist, DARF KEINEN fileIdentifier mit dem Wert '3F00' besitzen. <b>[<=]</b>

REQ(ids=A_13718)<b>A_13718 - (N006.900) K_Anwendungsspezifikation {K_Karte}</b>
PAR KEIN Objekt DARF einen fileIdentifier mit dem Wert '3FFF' besitzen. <b>[<=]</b>

PAR Hinweis CosH_596: Die Forderung (N006.700) ist strenger als [ISO/IEC 7816-4]. Dies lässt Raum für herstellerspezifische Ordner (DF) und Dateien (EF).
PAR -HEADING(ids=8.1.2)8.1.2 Short File Identifier
PAR Es ist möglich, dass der Attributstyp shortFileIdentifier von den Objekttypen Datei verwendet wird (siehe CosK_9e0).
PAR Aus der Norm [ISO/IEC 7816-4] leiten sich folgende Regeln ab, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=G2_N007.000)<b>G2_N007.000 - (N007.000) K_Anwendungsspezifikation {K_Karte}</b>
PAR Der Wert von shortFileIdentifier MUSS eine ganze Zahl im Intervall [1, 30] sein. <b>[<=]</b>

PAR -HEADING(ids=8.1.3)8.1.3 Life Cycle Status
PAR Der Attributstyp lifeCycleStatus wird von den Objekttypen Objektsystem, Ordner, Datei, Rekord, Passwort und Schlüssel zur Speicherung eines "physikalischen" Life Cycle Status (siehe (N020.500)) verwendet. Zusätzlich ist im Rahmen gewisser Operationen der "logische" Life Cycle Status (siehe (N020.600)) wichtig. Bei der Kommandobeschreibung wird darauf verwiesen, ob der "physikalische" oder der "logische" Life Cycle Status zu verwenden ist.
PAR Aus den Normen [ISO/IEC 7816-4#7.4.10] und [ISO/IEC 7816-9#Fig.1] leiten sich folgende Regeln ab, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=A_13719)<b>A_13719 - (N007.100)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Der Wert von lifeCycleStatus MUSS ein Element der Menge {<br>     "Operational state (active)",<br>     "Operational state (deactivated)",<br>     "Termination state"<br>} sein. <b>[<=]</b>

REQ(ids=A_13720)<b>A_13720 - (N007.100)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für lifeCycleStatus<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR -HEADING(ids=8.1.4)8.1.4 CosK_b03 Zugriffsregelliste
PAR Der Attributstyp interfaceDependentAccessRules wird von den Objekttypen verwendet, welche die Ausführung von Kommandos von der Erfüllung von Zugriffsregeln abhängig machen. Dabei handelt es sich um eine Ansammlung von Zugriffsregeln. Typischerweise werden einem Objekt mehr als eine Zugriffsregel zugeordnet, weil es dem COS dadurch möglich ist, situationsbezogen zu reagieren. So sind gewisse Leseoperationen typischerweise nur über eine kontaktbehaftete Schnittstelle zulässig, während sie für eine kontaktlose Schnittstelle verboten sind. Andererseits ist der Zugriff auf deaktivierte Objekte typischerweise stark eingeschränkt. Darüber hinaus werden Security Environments genutzt, um Abhängigkeiten der Zugriffsregel von der Einsatzumgebung auszudrücken.
PAR Akademisch betrachtet wäre eine dreidimensionale Matrix für interfaceDependentAccessRules angebracht, wo je nach Interface (kontaktbehaftet/kontaktlos = erste Dimension), Lebenszyklus (aktiviert/deaktiviert = zweite Dimension) und Einsatzumgebung (SE-Identifier = dritte Dimension) eine Zugriffsregel ausgewählt wird.
PAR In dieser Dokumentenversion beschränkt sich die erste Dimension auf die beiden Fälle kontaktlose Schnittstelle gemäß CosK_009 einerseits und kontaktbehaftete Schnittstelle gemäß CosK_36d oder CosK_70c andererseits und für die zweite Dimension ist es im deaktivierten oder terminierten Fall hinreichend, nur eine Einsatzumgebung vorzusehen. Deshalb werden in dieser Version des Dokumentes statt einer (mehrdimensionalen) Matrix zwei Listen verwendet.
REQ(ids=A_13721)<b>A_13721 - (N007.170)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Die Liste interfaceDependentAccessRules MUSS zwei Elemente umfassen. <b>[<=]</b>

REQ(ids=G2_N007.170.b)<b>G2_N007.170.b - (N007.170)b K_Anwendungsspezifikation {K_Karte}</b>
PAR Das erste Element der Liste MUSS eine accessRuleList gemäß (N007.200) bis (N007.500) sein und die Zugriffsregeln für eine kontaktbehaftete Kommunikation gemäß CosK_36d und CosK_70c beinhalten. <b>[<=]</b>

REQ(ids=G2_N007.170.c)<b>G2_N007.170.c - (N007.170)c K_Anwendungsspezifikation {K_Karte}</b>
PAR Das zweite Element der Liste MUSS eine accessRuleList gemäß (N007.200) bis (N007.500) sein und die Zugriffsregeln für eine kontaktlose Kommunikation gemäß CosK_009 beinhalten. <b>[<=]</b>

REQ(ids=A_13722)<b>A_13722 - (N007.170)d K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS interfaceDependentAccessRules mit mehr Elementen<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=A_13723)<b>A_13723 - (N007.170)e K_TST</b>
PAR Ein COS, Für die funktionale Eignung MUSS es zulässig sein, dass das COS, welches die Option_kontaktlose_Schnittstelle nicht anbietet, KANN das zweite Listenelement in interfaceDependentAccessRules<br>1. beachtet oder<br>2. ignoriert. <b>[<=]</b>

REQ(ids=G2_N007.200.a)<b>G2_N007.200.a - (N007.200)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Der Wert von accessRuleList MUSS eine Liste mit mindestens drei und maximal sechs Elementen sein. <b>[<=]</b>

REQ(ids=A_13724)<b>A_13724 - (N007.200)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS accessRuleList mit mehr als sechs Elementen<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N007.300.a)<b>G2_N007.300.a - (N007.300)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Listenelement in accessRuleList MUSS für den Wert der Variable lifeCycleStatus == "Operational state (deactivated)" (siehe (N007.100)a) verwendet werden. <b>[<=]</b>

REQ(ids=G2_N007.300.b)<b>G2_N007.300.b - (N007.300)b K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein weiteres Listenelement in accessRuleList MUSS für den Wert der Variable lifeCycleStatus == "Termination state" (siehe (N007.100)a) verwendet werden. <b>[<=]</b>

REQ(ids=G2_N007.400)<b>G2_N007.400 - (N007.400) K_Anwendungsspezifikation {K_Karte}</b>
PAR Die übrigen Listenelemente in accessRuleList MÜSSEN genau einem seIdentifier Wert gemäß (N007.900) zugeordnet werden. <b>[<=]</b>

REQ(ids=G2_N007.500)<b>G2_N007.500 - (N007.500) K_Anwendungsspezifikation {K_Karte}</b>
PAR Jedes Listenelement in accessRuleList MUSS genau eine Zugriffsregel gemäß CosK_3b4 enthalten. <b>[<=]</b>

PAR -HEADING(ids=8.1.5)8.1.5 CosK_6bf Rekord
PAR Der Objekttyp record wird von den Objekttypen linear variables, linear fixes und zyklisches Elementary File (EF) verwendet, siehe CosK_b94.
REQ(ids=G2_N007.600.a)<b>G2_N007.600.a - (N007.600)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein record MUSS eine Rekordnummer number mit einem ganzzahligen Wert aus dem Intervall [1, 254] besitzen. <b>[<=]</b>

REQ(ids=A_13725)<b>A_13725 - (N007.600)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS  Rekordnummern mit weiteren Werten<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N007.700.a)<b>G2_N007.700.a - (N007.700)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein record MUSS einen Oktettstring data mit einer Länge aus dem Intervall ['01', 'FF'] = [1, 255] besitzen. <b>[<=]</b>

REQ(ids=A_13726)<b>A_13726 - (N007.700)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Längen für record<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=A_13727)<b>A_13727 - (N007.800) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein record MUSS eine Liste mit Attributen vom Typ lifeCycleStatus (siehe (N007.100)a) unterstützen. <b>[<=]</b>

REQ(ids=G2_N007.800.a)<b>G2_N007.800.a - (N007.800)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Die Liste lifeCycleStatus MUSS entweder leer sein (der record hat keinen lifeCycleStatus und befindet sich implizit im Zustand "Operational state (active)") oder <b>[<=]</b>

REQ(ids=G2_N007.800.b)<b>G2_N007.800.b - (N007.800)b K_Anwendungsspezifikation {K_Karte}</b>
PAR die Liste lifeCycleStatus MUSS genau ein Element mit einem Wert aus der Menge {"Operational state (active)", "Operational state (deactivated)"} enthalten (der record hat genau einen lifeCycleStatus). <b>[<=]</b>

PAR Hinweis CosH_d67: Da es aus funktionaler Sicht keine Möglichkeit gibt den lifeCycleStatus eines record in den Zustand "Termination state" zu überführen, ist dieser Zustand für einen record irrelevant.
PAR -HEADING(ids=8.1.6)8.1.6 SE-Identifier
PAR Der Attributstyp seIdentifier ist eng mit dem Begriff Security Environment verknüpft (siehe CosK_48e). Aus dem gemäß [ISO/IEC 7816-4#10.3.3] erlaubten Wertebereich wird hier folgende Untermenge ausgewählt:
REQ(ids=G2_N007.900.a)<b>G2_N007.900.a - (N007.900)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Der Wert von seIdentifier MUSS eine ganze Zahl im Intervall [1, 4] sein. <b>[<=]</b>

REQ(ids=A_13728)<b>A_13728 - (N007.900)b K_TST</b>
PAR Das COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für seIdentifier<br>1. akzeptiert oder<br>2. ablehnt. <b>[<=]</b>

PAR -HEADING(ids=8.1.7)8.1.7 CosK_9f1 PIN
PAR Der Attributstyp pin wird im Zusammenhang mit der Benutzerverifikation verwendet. Es gilt:
REQ(ids=A_13729)<b>A_13729 - (N008.000)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein pin MUSS eine Folge von Ziffern aus dem Wertebereich {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} mit einer Länge aus dem Intervall [4, 12] sein. <b>[<=]</b>

REQ(ids=A_13732)<b>A_13732 - (N008.000)b K_TST</b>
PAR Das COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Zeichen oder weitere Längen für pin<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=A_13733)<b>A_13733 - (N008.100) K_Anwendungsspezifikation {K_Karte}</b>
PAR Für die Umwandlung des Attributtyps pin nach Format-2-PIN-Block MUSS gelten:<br>a. Der Format-2-PIN-Block ist ein Oktettstring mit acht Oktett = 16 Nibble.<br>b. Das erste Nibble hat den Wert '2'.<br>c. Das zweite Nibble codiert hexadezimal die Anzahl Ziffern in pin.<br>d. Das i+2–te Nibble codiert hexadezimal die i–te Ziffer von pin.<br>e. Alle anderen Nibble besitzen den Wert 'F'. <b>[<=]</b>

PAR -HEADING(ids=8.1.8)8.1.8 Datum
PAR Der Attributstyp date wird im Zusammenhang mit dem Gültigkeitszeitraum von Schlüsseln verwendet.
REQ(ids=A_13734)<b>A_13734 - (N008.120)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein date MUSS ein Datum in der Form YYMMDD in unkomprimierter BCD-Form enthalten. Beispiel: '010400050203' = 140523 = 23. Mai 2014. COS intern wird date als natürliche Zahl interpretiert. <b>[<=]</b>

REQ(ids=A_13735)<b>A_13735 - (N008.120)b K_TST</b>
PAR Das COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Codierungen für date<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR -HEADING(ids=8.2)8.2 Schlüsselmaterial (normativ)
PAR -HEADING(ids=8.2.1)8.2.1 CosK_d6b Symmetrische Schlüssel
PAR -HEADING(ids=8.2.1.1)8.2.1.1 3TDES-Schlüssel, Option_DES
PAR (N008.200) ist absichtlich leer.<br>(N008.300) ist absichtlich leer.
PAR Der Attributstyp 3TDES_Key dient der Speicherung von Schlüsselmaterial für einen 3TDES-Schlüssel, welcher aus drei Teilschlüsseln Ka, Kb und Kc besteht.
REQ(ids=G2_N008.200)<b>G2_N008.200 - (N008.200) K_Anwendungsspezifikation {K_Karte}, Option_DES</b>
PAR Der Wert von 3TDES_Key MUSS ein Oktettstring mit 24 Oktetten sein. <b>[<=]</b>

REQ(ids=A_13736)<b>A_13736 - (N008.300)a K_Anwendungsspezifikation {K_Karte}, Option_DES</b>
PAR Der Wert von 3TDES_Key MUSS beliebig wählbar sein <b>[<=]</b>

REQ(ids=A_13737)<b>A_13737 - (N008.300)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden eine inkorrekte Parität eines Oktettes in 3TDES_Key würde<br>1. akzeptiert oder<br>2. abgelehnt. <b>[<=]</b>

PAR Hinweis CosH_654: Aus Sicherheitsgründen sind die Teilschlüssel Ka, Kb und Kc eines 3TDES-Schlüssels paarweise verschieden zu wählen. Diese Anforderung richtet sich nicht an das COS, sondern an die externe Welt, welche derartige Schlüssel etwa im Rahmen der Personalisierung in die Smartcard einbringt.
PAR Hinweis CosH_afc: Aus Sicherheitsgründen sind Werte für die Teilschlüssel Ka, Kb oder Kc eines 3TDES-Schlüssels zu vermeiden, die einem schwachen oder halbschwachen DES-Schlüssel entsprechen (siehe Glossar). Diese Anforderung richtet sich nicht an das COS, sondern an die externe Welt, welche derartige Schlüssel etwa im Rahmen der Personalisierung in die Smartcard einbringt.
PAR -HEADING(ids=8.2.1.2)8.2.1.2 AES-128-Schlüssel
PAR Der Attributstyp aes128Key dient der Speicherung von Schlüsselmaterial für einen AES-128-Schlüssel.
REQ(ids=G2_N008.400)<b>G2_N008.400 - (N008.400) K_Anwendungsspezifikation {K_Karte}</b>
PAR Der Wert von aes128Key MUSS ein Oktettstring mit sechzehn Oktette sein. <b>[<=]</b>

REQ(ids=G2_N008.500)<b>G2_N008.500 - (N008.500) K_COS</b>
PAR Das COS MUSS beliebige Werte für aes128Key unterstützen. <b>[<=]</b>

PAR -HEADING(ids=8.2.1.3)8.2.1.3 AES-192-Schlüssel
PAR Der Attributstyp aes192Key dient der Speicherung von Schlüsselmaterial für einen AES-192-Schlüssel.
REQ(ids=G2_N008.520)<b>G2_N008.520 - (N008.520) K_Anwendungsspezifikation {K_Karte}</b>
PAR Der Wert von aes192Key MUSS ein Oktettstring mit 24 Oktette sein. <b>[<=]</b>

REQ(ids=G2_N008.525)<b>G2_N008.525 - (N008.525) K_KOS</b>
PAR Das COS MUSS beliebige Werte für aes192Key unterstützen. <b>[<=]</b>

PAR -HEADING(ids=8.2.1.4)8.2.1.4 AES-256-Schlüssel
PAR Der Attributstyp aes256Key dient der Speicherung von Schlüsselmaterial für einen AES-256-Schlüssel.
REQ(ids=G2_N008.540)<b>G2_N008.540 - (N008.540) K_Anwendungsspezifikation {K_Karte}</b>
PAR Der Wert von aes256Key MUSS ein Oktettstring mit 32 Oktette sein. <b>[<=]</b>

REQ(ids=G2_N008.545)<b>G2_N008.545 - (N008.545) K_COS</b>
PAR Das COS MUSS beliebige Werte für aes256Key unterstützen. <b>[<=]</b>

PAR -HEADING(ids=8.2.2)8.2.2 Domainparameter für elliptische Kurven
PAR Der Attributstyp domainParameter dient der Speicherung von Parametern, welche eine elliptische Kurve charakterisieren. Konform zu [BSI-TR-03111#Tabelle 2.1] werden die Domainparameter in diesem Dokument wie folgt dargestellt:
PAR (ids=Tabelle-61,-CosT_92d)Tabelle 61, CosT_92d: Liste der Domainparameter einer elliptischen Kurve

TABLE(rows=10,cols=79+517)->
TR-> TH(0,0/1/1)->PAR Parameter TH(0,1/1/1)->PAR Bedeutung
TR-> TD(1,0/1/1)->PAR p TD(1,1/1/1)->PAR Primzahl, welche die zugrunde liegende Gruppe F<sub>p</sub> beschreibt
TR-> TD(2,0/1/1)->PAR a TD(2,1/1/1)->PAR Erster Koeffizient der Weierstraßschen Gleichung
TR-> TD(3,0/1/1)->PAR b TD(3,1/1/1)->PAR Zweiter Koeffizient der Weierstraßschen Gleichung
TR-> TD(4,0/1/1)->PAR G TD(4,1/1/1)->PAR Ein Punkt auf der Kurve E(F<sub>p</sub>), Basispunkt
TR-> TD(5,0/1/1)->PAR n TD(5,1/1/1)->PAR Ordnung des Basispunktes G in E(F<sub>p</sub>)
TR-> TD(6,0/1/1)->PAR h TD(6,1/1/1)->PAR Cofaktor von G in E(F<sub>p</sub>),  wegen (N002.500) gilt h = 1 für alle verpflichtend zu unterstützenden Kurven
TR-> TD(7,0/1/1)->PAR L TD(7,1/1/1)->PAR siehe (N008.600)b
TR-> TD(8,0/1/1)->PAR t TD(8,1/1/1)->PAR siehe (N008.600)c
TR-> TD(9,0/1/1)->PAR OID TD(9,1/1/1)->PAR Object Identifier, der die elliptische Kurve referenziert, siehe (N008.600)d
PAR Bei der Spezifikation von Anwendungen sind folgende Regeln zu beachten, vergleiche CosT_92d:
REQ(ids=A_13747)<b>A_13747 - (N008.600) K_Anwendungsspezifikation {K_Karte}</b>
PAR Der Attributstyp domainParameter MUSS enthalten

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR alle Parameter aus Tabelle 7 [BSI-TR-03111#Tabelle 2.1] undLITEM->PAR eine Zahl L, welche die minimale Anzahl Oktette angibt, die nötig sind, um p als vorzeichenlose Zahl zu codieren. Dieser Parameter wurde der "offiziellen" Liste der Domainparameter [BSI-TR-03111#Tabelle 2.1] hinzugefügt, da dieser Parameter in diesem Dokument vielfach verwendet wird. Allgemein gilt L=ceiling(log<sub>256</sub> p). Wegen (N002.500) gilt:<br>1. L = 32 für brainpoolP256r1   und   ansix9p256r1.<br>2. L = 48 für brainpoolP384r1   und   ansix9p384r1.<br>3. L = 64 für brainpoolP512r1LITEM->PAR eine Zahl t, welche die Bitlänge von n angibt (siehe [BSI-TR-03111#Table 1.1], dort mit dem griechischen Buchstaben tau bezeichnet). Dieser Parameter wurde der "offiziellen" Liste der Domainparameter [BSI-TR-03111#Tabelle 2.1] hinzugefügt, da dieser Parameter in diesem Dokument vielfach verwendet wird. Allgemein gilt t=ceiling(log<sub>2</sub> n). Wegen (N002.500) gilt:<br>1. t = 256 für brainpoolP256r1   und   ansix9p256r1.<br>2. t = 384 für brainpoolP384r1   und   ansix9p384r1.<br>3. t = 512 für brainpoolP512r1.LITEM->PAR einen Oktettstring OID, durch den die Domainparameter (p, a, b, G, n, h) weltweit eindeutig bestimmt werden. Dieser Parameter wurde der "offiziellen" Liste der Domainparameter [BSI-TR-03111#Tabelle 2.1] hinzugefügt, da in diesem Dokument Domainparameter vielfach per OID referenziert werden. OID MUSS so aus CosT_a91 gewählt werden, dass damit eine elliptische Kurve gemäß (N002.500) referenziert wird.
PAR <b>[<=]</b>

PAR -HEADING(ids=8.2.3)8.2.3 CosK_1e2 Privater Schlüssel
PAR Der Attributstyp privateKey dient als Oberbegriff für privateRsaKey und privateElcKey.
PAR -HEADING(ids=8.2.3.1)8.2.3.1 Privater RSA-Schlüssel
PAR Der Attributstyp privateRsaKey dient der Speicherung des privaten Teils eines asymmetrischen RSA-Schlüsselpaares. Bei der Spezifikation von Anwendungen sind folgende Regeln zu beachten:
REQ(ids=A_13748)<b>A_13748 - (N008.700) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein privateRsaKey MUSS ein Attribut Modulus n mit einer Länge gemäß (N002.100)a besitzen. <b>[<=]</b>

REQ(ids=A_13750)<b>A_13750 - (N008.710) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein privateRsaKey MUSS ein Attribut modulusLength gemäß (N002.100)a besitzen. <b>[<=]</b>

REQ(ids=A_13751)<b>A_13751 - (N008.800) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein privateRsaKey MUSS die im Folgenden genannten Attribute besitzen wobei gilt:<br>a. Wenn das Attribut keyAvailable (siehe (N018.200)) den Wert<br>    1. False besitzt, dann besitzen alle Attribute den Wert AttributNotSet.<br>    2. True besitzt, dann sind alle Attribute ganze Zahlen mit den unten genannten Eigenschaften.<br>b. Attribut Modulus n mit   n = p q.<br>c. Attribut öffentlicher Exponent e mit gcd( e, (p – 1)(q – 1)) = 1.<br>d. Attribut privater Exponent d mit e d ≡ 1 mod lcm(p – 1, q – 1).<br>e. Attribut Primzahl p mit p ist prim und p < q.<br>f.  Attribut Primzahl q mit q ist prim.<br>g. Attrtibut CRT Exponent d<sub>P</sub> mit d<sub>P</sub> = d mod (p – 1).<br>h. Attrtibut CRT Exponent d<sub>q</sub> mit d<sub>q</sub> = d mod (q – 1).<br>i.  Attribut c mit c  = q<sup>-1</sup> mod p. <b>[<=]</b>

PAR -HEADING(ids=8.2.3.2)8.2.3.2 Privater ELC-Schlüssel
PAR Der Attributstyp privateElcKey dient der Speicherung des privaten Teils eines asymmetrischen ELC-Schlüsselpaares. Bei der Spezifikation von Anwendungen sind folgende Regeln zu beachten:
REQ(ids=A_13752)<b>A_13752 - (N008.900) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein privateElcKey MUSS ein Attribut domainParameter gemäß (N008.600) besitzen, das gemäß (N008.600)d per OID referenzierbar ist. <b>[<=]</b>

REQ(ids=A_13753)<b>A_13753 - (N009.000) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein privateElcKey MUSS ein Attribut d mit einem ganzzahligen Wert aus dem Intervall [1, domainParameter.n – 1] besitzen. <b>[<=]</b>

PAR -HEADING(ids=8.2.4)8.2.4 CosK_4a2 Öffentlicher Schlüssel
PAR Der Attributstyp publicKey dient als Oberbegriff für publicRsaKey und publicElcKey.
PAR -HEADING(ids=8.2.4.1)8.2.4.1 CosK_933 Öffentlicher RSA-Schlüssel
PAR Der Attributstyp publicRsaKey dient der Speicherung des öffentlichen Teils eines asymmetrischen RSA-Schlüsselpaares. Bei der Spezifikation von Anwendungen sind folgende Regeln zu beachten:
REQ(ids=A_13755)<b>A_13755 - (N009.100) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein publicRsaKey MUSS ein Attribut Modulus n mit einer Länge gemäß (N002.100)a besitzen <b>[<=]</b>

REQ(ids=A_13757)<b>A_13757 - (N009.110) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein publicRsaKey MUSS ein Attribut modulusLength gemäß (N002.100)a besitzen. <b>[<=]</b>

REQ(ids=A_13758)<b>A_13758 - (N009.200) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein publicRsaKey MUSS ein Attribut öffentlicher Exponent e gemäß (N002.100)b besitzen. <b>[<=]</b>

PAR -HEADING(ids=8.2.4.2)8.2.4.2 CosK_27b Öffentlicher ELC-Schlüssel
PAR Der Attributstyp publicElcKey dient der Speicherung des öffentlichen Teils eines asymmetrischen ELC-Schlüsselpaares. Bei der Spezifikation von Anwendungen sind folgende Regeln zu beachten:
REQ(ids=A_13759)<b>A_13759 - (N009.300) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein publicElcKey MUSS ein Attribut domainParameter gemäß (N008.600) besitzen, das gemäß (N008.600)d per OID referenzierbar ist. <b>[<=]</b>

REQ(ids=A_13760)<b>A_13760 - (N009.400) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein publicElcKey MUSS ein Attribut P besitzen, das einen vom unendliche fernen Punkt O verschiedenen Punkt auf der durch die Domainparameter vorgegebenen Kurve bezeichnet. <b>[<=]</b>

PAR -HEADING(ids=8.2.5)8.2.5 CosK_6b8 Transportschutz für ein Passwort
PAR Der Attributstyp transportStatus gibt an, ob ein Passwort mit einem Transportschutz versehen ist. Der Wert dieses Attributes gibt also an, ob ein VERIFY Kommando möglich ist (siehe (N082.800)) und welche Variante von CHANGE REFERENCE DATA anzuwenden ist. An der externen Schnittstelle des COS wird dieser Attributstyp im Rahmen des Kommandos GET PIN STATUS verwendet (siehe CosT_a97).
REQ(ids=G2_N009.500)<b>G2_N009.500 - (N009.500) K_Anwendungsspezifikation {K_Karte}</b>
PAR Für transportStatus gilt folgender Wertebereich:<br>a. regularPassword<br>b. Leer-PIN<br>c. Transport–PIN <b>[<=]</b>

REQ(ids=A_13762)<b>A_13762 - (N009.600)a K_COS</b>
PAR Das COS MUSS für transportStatus alle Werte aus (N009.500) unterstützen. <b>[<=]</b>

REQ(ids=A_18243)<b>A_18243 - (N009.600)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für transportStatus<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N009.700)<b>G2_N009.700 - (N009.700) K_externeWelt {K_Karte}</b>
PAR Wenn zur Aufhebung des Transportschutzes das Kommando CHANGE REFERENCE DATA verwendet wird (siehe CosK_f67), dann MUSS in Abhängigkeit des Wertes von transportStatus an der physikalischen Schnittstelle eine Variante gemäß CosT_16b verwendet werden. <b>[<=]</b>

REQ(ids=A_13763)<b>A_13763 - (N009.710) K_COS</b>
PAR Wenn oldSecret oder newSecret in CosT_16b als "beliebig" gekennzeichnet ist, so MUSS deren Inhalt im Rahmen von (N008.000) und (N008.100) beliebig wählbar sein.
PAR (ids=Tabelle-62-,-CosT_16b)Tabelle 62 , CosT_16b: Aufheben des Transportschutzes

TABLE(rows=4,cols=126+395)->
TR-> TH(0,0/1/1)->PAR Transportschutz TH(0,1/1/1)->PAR Parameter für CHANGE REFERENCE DATA
TR-> TD(1,0/1/1)->PAR regularPassword TD(1,1/1/1)->PAR P1 = '00', oldSecret und newSecret beliebig
TR-> TD(2,0/1/1)->PAR Leer-PIN TD(2,1/1/1)->PAR P1 = '01', oldSecret = '', das heißt leerer String, newSecret beliebig
TR-> TD(3,0/1/1)->PAR Transport-PIN TD(3,1/1/1)->PAR P1 = '00', oldSecret und newSecret beliebig
PAR <b>[<=]</b>

PAR Hinweis CosH_ab5: Auch das Kommando RESET RETRY COUNTER ist in der Lage, den Transportschutz aufzuheben (siehe Use Cases in (N079.300) und (N080.100), sowie (N081.200)b).
PAR -HEADING(ids=8.3)8.3 CosK_6aa File (normativ)
PAR Dieses Unterkapitel beschreibt file-orientierte Objekttypen. File wird in diesem Zusammenhang als Oberbegriff für Ordner (siehe CosK_fd2) und Datei (siehe CosK_9e0) verwendet.
PAR -HEADING(ids=8.3.1)8.3.1 CosK_fd2 Ordner
PAR Ordner dienen der hierarchischen Anordnung von Objekten in einem Objektsystem. In diesem Dokument wird Ordner als Oberbegriff für

LIST->
LITEM->PAR Applikationen (siehe CosK_ad6),LITEM->PAR Dedicated Files (siehe CosK_5a3) und    LITEM->PAR Application Dedicated Files (siehe CosK_356)
PAR verwendet. Gemäß der Norm [ISO/IEC 7816-4] gelten für einen Ordner folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=G2_N009.800)<b>G2_N009.800 - (N009.800) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Ordner MUSS genau ein Attribut vom Typ lifeCycleStatus (siehe (N007.100)a) besitzen. <b>[<=]</b>

REQ(ids=G2_N009.850)<b>G2_N009.850 - (N009.850)a K_Anwendungsspezifikation {K_Karte}, Option_logische_Kanäle</b>
PAR Ein Ordner MUSS genau ein Attribut shareable vom Typ Boolean mit einem Wert True besitzen, wodurch angezeigt wird, dass dieser Ordner in mehr als einem logischen Kanal als currentFolder verwendbar ist (siehe (N029.900)a). <b>[<=]</b>

REQ(ids=A_13765)<b>A_13765 - (N009.860) K_TST</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass das COS  weitere Werte für shareable<br>a  unterstützt oder<br>b. ablehnt. <b>[<=]</b>

REQ(ids=G2_N009.900)<b>G2_N009.900 - (N009.900) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Ordner MUSS genau ein Attribut accessRules vom Typ interfaceDependentAccessRules (siehe CosK_b03) besitzen. <b>[<=]</b>

REQ(ids=A_13771)<b>A_13771 - (N010.000) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Ordner MUSS eine (möglicherweise leere) Liste children mit Kindobjekten besitzen. <b>[<=]</b>

REQ(ids=G2_N010.000.a.1)<b>G2_N010.000.a.1 - (N010.000)a.1 K_Anwendungsspezifikation {K_Karte}</b>
PAR Unter Berücksichtigung der maximalen Schachtelungstiefe (siehe (N020.390)(N020.400)) MÜSSEN Listenelemente der folgenden Objekttypen unterstützt werden:<br>i.    Applikation (siehe CosK_ad6)<br>ii.   Dedicated File (siehe CosK_5a3)<br>iii.   Application Dedicated File (siehe CosK_356)<br>iv.   Datei (siehe CosK_9e0)<br>v.    Reguläres Passwort (siehe CosK_d13)<br>vi.   Multireferenz-Passwort (siehe CosK_7f0)<br>vii.  symmetrisches Authentisierungsobjekt (siehe CosK_5fa)<br>viii. Privates Schlüsselobjekt (siehe CosK_ab8) <b>[<=]</b>

REQ(ids=G2_N010.000.a.2)<b>G2_N010.000.a.2 - (N010.000)a.2 K_Anwendungsspezifikation {K_Karte}, Option_kontaktlose_Schnittstelle</b>
PAR Das Listenelement Symmetrisches Kartenverbindungsobjekt (siehe CosK_24a) MUSS unterstützt werden. <b>[<=]</b>

REQ(ids=A_13772)<b>A_13772 - (N010.000)b K_TST</b>
PAR Das COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Objekttypen als Listenelemente<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=A_13773)<b>A_13773 - (N010.000)c K_Anwendungsspezifikation {K_Karte}</b>
PAR Für alle Elemente der Liste children, welche die Kindobjekte eines Ordners enthält, gilt: In der List children eines Ordners DARF es KEINE Kindobjekte geben,<br>1. deren Attribut fileIdentifier (sofern vorhanden, siehe (N010.600) und (N010.800)) denselben Wert besitzt.<br>2. deren Attribut shortFileIdentifier (sofern vorhanden, siehe (N010.900)a) denselben Wert besitzt.<br>3. deren Attribut pwdIdentifier (sofern vorhanden, siehe (N015.000)a) denselben Wert besitzt.<br>4. deren Attribut keyIdentifier (sofern vorhanden, siehe (N016.400)a, (N017.020)a und (N017.100)a) denselben Wert besitzt. <b>[<=]</b>

PAR Bevor die folgenden Kommandos in der Lage sind mit dem Ordner zu arbeiten, ist er zu selektieren. Dies geschieht mittels SELECT-Kommando (siehe CosK_119).
REQ(ids=G2_N010.005.a)<b>G2_N010.005.a - (N010.005)a K_COS</b>
PAR Das COS MUSS für Ordner das Kommandos ACTIVATE (siehe (N034.800)) unterstützen. <b>[<=]</b>

REQ(ids=G2_N010.005.b)<b>G2_N010.005.b - (N010.005)b K_COS</b>
PAR Das COS MUSS für Ordner das Kommando DEACTIVATE (siehe (N036.000)) unterstützen. <b>[<=]</b>

REQ(ids=A_13774)<b>A_13774 - (N010.005)c K_COS</b>
PAR Das COS MUSS für Ordner das Kommando DELETE (siehe (N037.100)) unterstützen. <b>[<=]</b>

REQ(ids=A_13775)<b>A_13775 - (N010.005)d K_COS</b>
PAR Das COS MUSS für Ordner das Kommando FINGERPRINT (siehe (N096.454)) unterstützen. <b>[<=]</b>

REQ(ids=A_13776)<b>A_13776 - (N010.005)e K_COS</b>
PAR Das COS MUSS für Ordner das Kommando GET RANDOM (siehe (N099.322)) unterstützen. <b>[<=]</b>

REQ(ids=A_13777)<b>A_13777 - (N010.005)f K_COS</b>
PAR Das COS MUSS für Ordner das Kommando LOAD APPLICATION (siehe (N038.600) und (N038.800)) unterstützen. <b>[<=]</b>

REQ(ids=A_13778)<b>A_13778 - (N010.005)g K_COS</b>
PAR Das COS MUSS für Ordner das Kommando SELECT (siehe CosK_119) unterstützen. <b>[<=]</b>

REQ(ids=A_13779)<b>A_13779 - (N010.005)h K_COS</b>
PAR Das COS MUSS für Ordner das Kommando TERMINATE DF (siehe (N048.800)) unterstützen. <b>[<=]</b>

REQ(ids=A_13921)<b>A_13921 - (N010.010) K_TST</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass das COS für Ordner weitere Kommandos<br>a. unterstützt oder<br>b. ablehnt. <b>[<=]</b>

PAR Einem Ordner sind weitere, kanalspezifische Attribute zugeordnet, die typischerweise einem flüchtig (etwa im RAM) gespeicherten Kanalkontext (siehe (N030.000)) zugerechnet werden. Sie werden typischerweise im Rahmen einer Selektion des Ordners verändert.
PAR -HEADING(ids=8.3.1.1)8.3.1.1 CosK_ad6 Applikation
PAR Eine Applikation ist ein Ordner, der nur mittels AID selektierbar ist. Dies ist der Hauptunterschied zu einem DF (siehe CosK_5a3).
PAR Gemäß der Norm [ISO/IEC 7816-4] gelten für eine Applikation folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=A_13844)<b>A_13844 - (N010.100) K_Anwendungsspezifikation {K_Karte}</b>
PAR Eine Applikation ist eine Erweiterung von Ordner und MUSS deshalb den Anforderungen aus CosK_fd2 genügen. <b>[<=]</b>

REQ(ids=A_13845)<b>A_13845 - (N010.200) K_Anwendungsspezifikation {K_Karte}</b>
PAR Das Attribut applicationIdentifier (AID) MUSS ein Oktettstring sein. <b>[<=]</b>

REQ(ids=G2_N010.200.a)<b>G2_N010.200.a - (N010.200)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Die Länge von applicationIdentifier MUSS im Intervall [5, 16] liegen. <b>[<=]</b>

REQ(ids=A_13846)<b>A_13846 - (N010.200)b K_Anwendungsspezifikation {K_Karte}</b>
PAR Die Oktette in applicationIdentifier MÜSSEN beliebig wählbar sein. <b>[<=]</b>

REQ(ids=A_13847)<b>A_13847 - (N010.200)c K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS applicationIdentifier, welche gegen die in (N010.200){a, b} genannten Regeln verstoßen,<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N010.300)<b>G2_N010.300 - (N010.300) K_Anwendungsspezifikation {K_Karte}</b>
PAR Eine Applikation MUSS mindestens einen applicationIdentifier besitzen. <b>[<=]</b>

REQ(ids=G2_N010.400.a)<b>G2_N010.400.a - (N010.400)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Eine Applikation DARF NICHT mehr als zwei applicationIdentifier besitzen. <b>[<=]</b>

REQ(ids=A_13850)<b>A_13850 - (N010.400)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS mehr als die in (N010.400)a genannte Anzahl an applicationIdentifier<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR -HEADING(ids=8.3.1.2)8.3.1.2 CosK_5a3 Dedicated File
PAR Ein Dedicated File (DF) ist ein Ordner, der nur mittels fileIdentifier selektierbar ist. Dies ist der Hauptunterschied zu einer Applikation (siehe CosK_ad6).Gemäß der Norm [ISO/IEC 7816-4] gelten für ein DF folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=A_13851)<b>A_13851 - (N010.500) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein DF ist eine Erweiterung von Ordner und MUSS deshalb den Anforderungen aus CosK_fd2 genügen. <b>[<=]</b>

REQ(ids=G2_N010.600)<b>G2_N010.600 - (N010.600) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein DF MUSS genau ein Attribut vom Typ fileIdentifier (siehe CosK_6ab) besitzen. <b>[<=]</b>

PAR -HEADING(ids=8.3.1.3)8.3.1.3 CosK_356 Application Dedicated File
PAR Ein Application Dedicated File (ADF) ist ein Ordner, der sowohl mittels applicationIdentifier als auch fileIdentifier selektierbar ist. ADF wird in diesem Dokument also als "Vereinigungsmenge" von Applikation (siehe CosK_ad6) und DF (siehe CosK_5a3) gesehen. Dementsprechend gelten für ein ADF folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=A_17454)<b>A_17454 - (N010.700) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein ADF MUSS die Eigenschaften von Applikation und DF in sich vereinen. Deshalb MUSS es sowohl die Anforderungen aus CosK_ad6 als auch aus CosK_5a3 erfüllen. <b>[<=]</b>

PAR -HEADING(ids=8.3.2)8.3.2 CosK_9e0 Datei
PAR Eine Datei dient in diesem Dokument als Oberbegriff für transparente EF (siehe CosK_76c) und strukturierte EF (siehe CosK_b94).
PAR Gemäß der Norm [ISO/IEC 7816-4] gelten für eine Datei folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=G2_N010.800)<b>G2_N010.800 - (N010.800) K_Anwendungsspezifikation {K_Karte}</b>
PAR Eine Datei MUSS genau ein Attribut vom Typ fileIdentifier (siehe CosK_6ab) besitzen. <b>[<=]</b>

REQ(ids=A_13852)<b>A_13852 - (N010.900) K_KOS</b>
PAR Eine Datei MUSS eine Liste mit Elementen vom Typ shortFileIdentifier (siehe (N007.000)) unterstützen. <b>[<=]</b>

REQ(ids=G2_N010.900.a)<b>G2_N010.900.a - (N010.900)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Die Liste mit shortFileIdentifier MUSS entweder leer sein (die Datei hat keinen shortFileIdentifier), oder <b>[<=]</b>

REQ(ids=G2_N010.900.b)<b>G2_N010.900.b - (N010.900)b K_Anwendungsspezifikation {K_Karte}</b>
PAR die Liste mit shortFileIdentifier enthält genau ein Element (die Datei hat genau einen shortFileIdentifier). <b>[<=]</b>

REQ(ids=G2_N011.000)<b>G2_N011.000 - (N011.000) K_Anwendungsspezifikation {K_Karte}</b>
PAR Eine Datei MUSS genau ein Attribut vom Typ lifeCycleStatus (siehe (N007.100a)) besitzen. <b>[<=]</b>

REQ(ids=G2_N011.050)<b>G2_N011.050 - (N011.050) K_Anwendungsspezifikation {K_Karte}, Option_logische_Kanäle</b>
PAR Eine Datei MUSS genau ein Attribut shareable vom Typ Boolean mit dem Wert True besitzen,wodurch angezeigt wird, dass diese Datei in mehr als einem logischen Kanal als currentEF verwendbar ist (siehe (N029.900)m]). <b>[<=]</b>

REQ(ids=A_17582)<b>A_17582 - (N011.060) K_TST</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass das COS  weitere Werte für shareable<br>a  unterstützt oder<br>b. ablehnt. <b>[<=]</b>

REQ(ids=G2_N011.100)<b>G2_N011.100 - (N011.100) K_Anwendungsspezifikation {K_Karte}</b>
PAR Eine Datei MUSS genau ein Attribut accessRules vom Typ interfaceDependentAccessRules (siehe CosK_b03) besitzen. <b>[<=]</b>

REQ(ids=A_13855)<b>A_13855 - (N011.200)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Eine Datei MUSS ein Attribut flagTransactionMode vom Typ Boolean besitzen. <b>[<=]</b>

REQ(ids=A_13856)<b>A_13856 - (N011.200)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS pro Datei ein solches Attribut individuell verwaltet.<br> <b>[<=]</b>

REQ(ids=A_13857)<b>A_13857 - (N011.200)c K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS dieses Attribut für alle Dateien implizit auf True setzt. <b>[<=]</b>

REQ(ids=A_13858)<b>A_13858 - (N011.300)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Eine Datei MUSS ein Attribut flagChecksum vom Typ Boolean besitzen. <b>[<=]</b>

REQ(ids=A_13859)<b>A_13859 - (N011.300)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS pro Datei ein solches Attribut individuell verwaltet.<br> <b>[<=]</b>

REQ(ids=A_13860)<b>A_13860 - (N011.300)c K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS dieses Attribut für alle Dateien implizit auf True setzt. <b>[<=]</b>

PAR Hinweis CosH_249: Das Setzen des Flags flagTransactionMode verringert die Performanz bei Schreibzugriffen.
PAR Hinweis CosH_ad4: Das Setzen des Flags flagChecksum verringert die Performanz bei Schreib- und Lesezugriffen.
PAR -HEADING(ids=8.3.2.1)8.3.2.1 CosK_76c Transparentes Elementary File
PAR Ein transparentes Elementary File (transparentes EF) dient der Speicherung eines Oktettstrings, wobei beliebige Teile des Oktettstrings zugreifbar sind. Der Inhalt von Oktettstrings in transparenten EF, welche im Rahmen einer Anwendungsspezifikation definiert werden, wird von einem COS lediglich gespeichert, niemals aber interpretiert oder für karteninterne Prozesse verwendet. Der Oktettstring wird in "data units" unterteilt (siehe [ISO/IEC 7816-4]). Die "data units" werden über einen Offset referenziert.
PAR Gemäß der Norm [ISO/IEC 7816-4] gelten für ein transparentes EF folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=A_13861)<b>A_13861 - (N011.400) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein transparentes EF ist eine Erweiterung von Datei und MUSS deshalb den Anforderungen aus CosK_9e0 genügen. <b>[<=]</b>

REQ(ids=G2_N011.500.a)<b>G2_N011.500.a - (N011.500)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein transparentes EF MUSS genau ein Attribut numberOfOctet mit einem ganzzahligen Wert aus dem Intervall [1, 32.768] besitzen. <b>[<=]</b>

REQ(ids=A_13863)<b>A_13863 - (N011.500)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS  weitere Werte für numberOfOctet<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N011.510)<b>G2_N011.510 - (N011.510) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein transparentes EF MUSS genau ein Attribut positionLogicalEndOfFile mit einem ganzzahligen Wert aus dem Intervall [0, numberOfOctet] besitzen. <b>[<=]</b>

REQ(ids=G2_N011.600)<b>G2_N011.600 - (N011.600) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein transparentes EF MUSS ein Attribut body vom Typ Oktettstring besitzen. Die Anzahl der Oktette in body ist gleich numberOfOctet. <b>[<=]</b>

REQ(ids=G2_N011.700)<b>G2_N011.700 - (N011.700) K_COS</b>
PAR Die Größe einer "data unit" in body MUSS 1 Oktett betragen. <b>[<=]</b>

REQ(ids=G2_N011.800)<b>G2_N011.800 - (N011.800) K_COS</b>
PAR Für den Offset innerhalb von body MUSS gelten: Der Offset des ersten Oktetts in body ist null. Ist i der Offset des i–ten Oktetts, dann ist (i + 1) der Offset des nächsten Oktetts. <b>[<=]</b>

PAR Bevor eines der folgenden Kommandos in der Lage ist mit dem Oktettstring zu arbeiten, ist das transparente EF zu selektieren, sofern es nicht bereits currentEF ist. Dies geschieht entweder mittels SELECT-Kommando (siehe (N046.700) und (N047.300)), oder mittels shortFileIdentifier, der als Parameter dem zugreifenden Kommando mitgegeben wird.
REQ(ids=G2_N011.900.a)<b>G2_N011.900.a - (N011.900)a K_COS</b>
PAR Zusätzlich zu den in (N011.900)b gelisteten Kommandos MUSS ein transparentes EF auch die folgenden Kommandos unterstützen:<br>1. ERASE BINARY (siehe (N049.100) und (N049.400)),<br>2. READ BINARY (siehe (N051.100) und (N051.500)),<br>3. SET LOGICAL EOF (siehe (N052.932) und (N052.936)),<br>4. UPDATE BINARY (siehe (N053.200) und (N053.600)).<br>5. WRITE BINARY (siehe (N055.205) und (N055.226)). <b>[<=]</b>

PAR Bevor eines der folgenden Kommandos in der Lage ist mit dem Oktettstring zu arbeiten, ist das transparente EF zu selektieren, sofern es nicht bereits currentEF ist. Dies geschieht mittels SELECT-Kommando (siehe (N046.700) und (N047.300)).
REQ(ids=G2_N011.900.b)<b>G2_N011.900.b - (N011.900)b K_COS</b>
PAR Zusätzlich zu den in (N011.900)a gelisteten Kommandos MUSS ein transparentes EF auch die folgenden Kommandos unterstützen:<br>1. ACTIVATE (siehe (N034.800)),<br>2. DEACTIVATE (siehe (N036.000)),<br>3. DELETE (siehe (N037.100)).<br>4. TERMINATE (siehe (N048.903)). <b>[<=]</b>

REQ(ids=A_13865)<b>A_13865 - (N012.000) K_TST</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass das COS  für transparente EF weitere Kommandos<br>a. unterstützt oder<br>b. ablehnt. <b>[<=]</b>

PAR Hinweis CosH_34b: Das Konzept "logical End Of File" unterscheidet zwischen einer Dateigröße, die mittels UPDATE BINARY beschreibbar ist und einer "logischen" Dateigröße, die mittels READ BINARY auslesbar ist. Dies spiegelt sich in den Attributen numberOfOctet und positionLogicalEndOfFile wieder. Dabei entspricht numberOfOctet einer maximalen Dateigröße, die im Rahmen von UPDATE BINARY komplett adressierbar ist, und positionLogicalEndOfFile einer tatsächlichen Dateigröße, die im Rahmen von READ BINARY komplett adressierbar ist. Während der Wert von numberOfOctet unveränderlich ist, ist es möglich, dass sich der Wert von positionLogicalEndOfFile im Rahmen der Kommandos SET LOGICAL EOF, UPDATE BINARY oder WRITE BINARY ändert.
PAR -HEADING(ids=8.3.2.2)8.3.2.2 CosK_b94 Strukturiertes Elementary File
PAR Ein strukturiertes Elementary File (strukturiertes EF) dient der Speicherung einer Liste von Rekords (siehe CosK_6bf). Ein Zugriff auf beliebige Listenelemente ist möglich. Der Inhalt des Oktettstrings eines Rekords in strukturierten EF, welche im Rahmen einer Anwendungsspezifikation definiert werden, wird von einem COS lediglich gespeichert, niemals aber interpretiert oder für karteninterne Prozesse verwendet.
PAR Gemäß der Norm [ISO/IEC 7816-4] gelten für ein strukturiertes EF folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=A_13866)<b>A_13866 - (N012.100) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein strukturiertes EF ist eine Erweiterung von Datei und MUSS deshalb den Anforderungen aus CosK_9e0 genügen. <b>[<=]</b>

REQ(ids=A_13867)<b>A_13867 - (N012.200)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein strukturiertes EF MUSS ein Attribut recordList vom Typ Liste mit einer Anzahl der Listenelemente aus dem Intervall [0, 254 maximumNumberOfRecords] und vom Typ Rekord besitzen. <b>[<=]</b>

REQ(ids=A_13868)<b>A_13868 - (N012.200)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für die Anzahl von Listenelementen in recordList<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N012.300)<b>G2_N012.300 - (N012.300) K_COS</b>
PAR Das i-te Element in recordList MUSS die Rekordnummer i besitzen. <b>[<=]</b>

REQ(ids=G2_N012.400.a)<b>G2_N012.400.a - (N012.400)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein strukturiertes EF MUSS genau ein Attribut maximumNumberOfRecords mit einem ganzzahligen Wert aus dem Intervall [1, 254] besitzen. <b>[<=]</b>

REQ(ids=A_13870)<b>A_13870 - (N012.400)b K_TST</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass das COS  weitere Werte für maximumNumberOfRecords<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N012.500.a)<b>G2_N012.500.a - (N012.500)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein strukturiertes EF MUSS genau ein Attribut maximumRecordLength mit einem ganzzahligen Wert aus dem Intervall [1, 255] besitzen. <b>[<=]</b>

REQ(ids=A_13872)<b>A_13872 - (N012.500)b K_TST</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für maximumRecordLength<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=A_13873)<b>A_13873 - (N012.600) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein strukturiertes EF MUSS genau ein Attribut flagRecordLifeCycleStatus vom Typ Boolean besitzen. <b>[<=]</b>

REQ(ids=G2_N012.600.a)<b>G2_N012.600.a - (N012.600)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Wenn das Attribut flagRecordLifeCycleStatus True ist, dann MÜSSEN alle Elemente in recordList einen lifeCycleStatus besitzen (siehe (N007.800)). <b>[<=]</b>

REQ(ids=G2_N012.600.b)<b>G2_N012.600.b - (N012.600)b K_Anwendungsspezifikation {K_Karte}</b>
PAR Wenn das Attribut flagRecordLifeCycleStatus False ist, dann DARF KEIN Element in recordList einen lifeCycleStatus besitzen. <b>[<=]</b>

PAR Bevor eines der folgenden Kommandos in der Lage ist mit dem Oktettstring zu arbeiten, ist das strukturierte EF zu selektieren, sofern es nicht bereits currentEF ist. Dies geschieht entweder mittels SELECT-Kommando (siehe (N046.700) und (N047.300)), oder mittels shortFileIdentifier, der als Parameter dem zugreifenden Kommando mitgegeben wird.
REQ(ids=G2_N012.700.a)<b>G2_N012.700.a - (N012.700)a K_COS</b>
PAR Zusätzlich zu den in (N012.700)b gelisteten Kommandos MUSS ein sturkturiertes EF auch die folgenden Kommandos unterstützen:<br>1. ACTIVATE RECORD (siehe (N055.500), (N055.900), (N056.200) und (N056.600)),<br>2. APPEND RECORD (siehe (N058.400) und (N058.700)),<br>3. DEACTIVATE RECORD (siehe (N060.700), (N061.100), (N061.400) und (N061.800)),<br>4. DELETE RECORD (siehe (N063.422) und (N063.426)),<br>5. ERASE RECORD (siehe (N063.600) und (N063.900)),<br>6. READ RECORD (siehe (N065.700) und (N066.100)),<br>7. SEARCH RECORD (siehe (N067.900) und (N068.400)),<br>8. UPDATE RECORD (siehe (N070.300) und (N070.700)). <b>[<=]</b>

PAR Bevor eines der folgenden Kommandos in der Lage ist spezifikationsgemäß zu arbeiten, ist das strukturierte EF zu selektieren, sofern es nicht bereits currentEF ist. Dies geschieht mittels SELECT-Kommando (siehe (N046.700) und (N047.300)).
REQ(ids=G2_N012.700.b)<b>G2_N012.700.b - (N012.700)b K_COS</b>
PAR Zusätzlich zu den in (N012.700)a gelisteten Kommandos MUSS ein sturkturiertes EF auch die folgenden Kommandos unterstützen:<br>1. ACTIVATE (siehe (N034.800)),<br>2. DEACTIVATE (siehe (N036.000)),<br>3. DELETE (siehe (N037.100)).<br>4. TERMINATE (siehe (N048.903)). <b>[<=]</b>

REQ(ids=A_13874)<b>A_13874 - (N012.800) K_TST</b>
PAR Ein strukturiertes EF KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Kommandos<br>a. unterstützt oder<br>b. ablehnt. <b>[<=]</b>

PAR -HEADING(ids=8.3.2.2.1)8.3.2.2.1 CosK_5a6 Linear variables Elementary File
PAR Ein linear variables Elementary File (linear variables EF) dient der Speicherung einer Liste von Elementen des Typs record (siehe CosK_6bf), wobei es möglich ist, dass der Oktettstring eines jeden Listenelementes eine andere Anzahl von Oktette enthält.
PAR Gemäß der Norm [ISO/IEC 7816-4] gelten für ein linear variables EF folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=A_13892)<b>A_13892 - (N012.900) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein linear variables EF ist eine Erweiterung des strukturierten EF und MUSS deshalb den Anforderungen aus CosK_b94 genügen. <b>[<=]</b>

REQ(ids=G2_N013.000.a)<b>G2_N013.000.a - (N013.000)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein linear variables EF MUSS genau ein Attribut numberOfOctet mit einem ganzzahligen Wert aus dem Intervall [1, 64.770] besitzen. <b>[<=]</b>

REQ(ids=A_13894)<b>A_13894 - (N013.000)b K_TST</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für numberOfOctet<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=A_13895)<b>A_13895 - (N013.050) K_Anwendungsspezifikation {K_Karte}</b>
PAR KEIN record in recordList DARF mehr als maximumRecordLength Oktette besitzen. <b>[<=]</b>

REQ(ids=A_17463)<b>A_17463 - (N013.060) K_Anwendungsspezifikation {K_Karte}</b>
PAR Die Summe der Längen in Oktett aller Elemente in recordList MUSS kleiner gleich numberOfOctet sein. <b>[<=]</b>

REQ(ids=G2_N013.100)<b>G2_N013.100 - (N013.100) K_COS</b>
PAR Wenn mittels APPEND RECORD Kommando der Liste recordList ein neuer record hinzugefügt, dann MUSS das COS den neuen record am Ende der Liste eingefügen. <b>[<=]</b>

PAR -HEADING(ids=8.3.2.2.2)8.3.2.2.2 Linear fixes Elementary File
PAR Ein linear fixes Elementary File (linear fixes EF) dient der Speicherung einer Liste von Elementen des Typs record (siehe CosK_6bf), wobei der Oktettstring eines jeden Listenelementes dieselbe Anzahl von Oktette enthält.
PAR Gemäß der Norm [ISO/IEC 7816-4] gelten für ein linear fixes EF folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=A_13896)<b>A_13896 - (N013.200) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein linear fixes EF ist eine Erweiterung des strukturierten EF und MUSS deshalb den Anforderungen aus CosK_b94 genügen. <b>[<=]</b>

REQ(ids=G2_N013.300)<b>G2_N013.300 - (N013.300) K_Anwendungsspezifikation {K_Karte}</b>
PAR Jeder record in recordList MUSS maximumRecordLength Oktette besitzen. <b>[<=]</b>

REQ(ids=G2_N013.400)<b>G2_N013.400 - (N013.400) K_COS</b>
PAR Wenn mittels APPEND RECORD Kommando der Liste recordList ein neuer record hinzugefügt, dann MUSS das COS den neuen record am Ende der Liste eingefügen. <b>[<=]</b>

REQ(ids=G2_N013.410)<b>G2_N013.410 - (N013.410) K_Anwendungsspezifikation {K_Karte}</b>
PAR Das Produkt aus maximumNumberOfRecords und maximumRecordLength MUSS kleiner gleich 64.770 sein (vergleiche auch (N013.000)a). <b>[<=]</b>

PAR -HEADING(ids=8.3.2.2.3)8.3.2.2.3 Zyklisches Elementary File
PAR Ein zyklisches Elementary File (zyklisches EF) dient der Speicherung einer Liste von Elementen des Typs record (siehe CosK_6bf), wobei der Oktettstring eines jeden Listenelementes dieselbe Anzahl von Oktette enthält.
PAR Gemäß der Norm [ISO/IEC 7816-4] gelten für ein zyklisches EF folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=A_13897)<b>A_13897 - (N013.500) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein zyklisches EF ist eine Erweiterung des strukturierten EF und MUSS deshalb den Anforderungen aus CosK_b94 genügen. <b>[<=]</b>

REQ(ids=G2_N013.600)<b>G2_N013.600 - (N013.600) K_Anwendungsspezifikation {K_Karte}</b>
PAR Jeder record in recordList MUSS maximumRecordLength Oktette besitzen. <b>[<=]</b>

REQ(ids=G2_N013.700)<b>G2_N013.700 - (N013.700) K_COS</b>
PAR Wenn mittels APPEND RECORD Kommando der Liste recordList ein neuer record hinzugefügt, dann MUSS das COS den neuen record am Anfang der Liste eingefügen. <b>[<=]</b>

REQ(ids=G2_N013.800)<b>G2_N013.800 - (N013.800) K_Anwendungsspezifikation {K_Karte}</b>
PAR Zyklische Elementary Files MÜSSEN für das Attribut flagRecordLifeCycleStatus den Wert False verwenden. <b>[<=]</b>

REQ(ids=G2_N013.810)<b>G2_N013.810 - (N013.810) K_Anwendungsspezifikation {K_Karte}</b>
PAR Das Produkt aus maximumNumberOfRecords und maximumRecordLength MUSS kleiner gleich 64.770 sein (vergleiche auch (N013.000)a). <b>[<=]</b>

PAR -HEADING(ids=8.3.3)8.3.3 File Control Parameter
PAR Die File Control Parameter enthalten Attribute eines Files. Im Rahmen dieses Dokumentes werden sie lediglich an der Schnittstelle Interpreter (siehe CosA_e09) in den Antwortdaten eines SELECT-Kommandos (siehe (N048.300)a) sichtbar. Für die Codierung der File Control Parameter gilt:
REQ(ids=G2_N013.900)<b>G2_N013.900 - (N013.900) K_COS</b>
PAR Das COS MUSS die File Control Parameter (FCP) gemäß DER-TLV in einem DO_FCP mit Tag = '62' codieren. <b>[<=]</b>

REQ(ids=A_13909)<b>A_13909 - (N014.000) K_COS</b>
PAR '80': Wenn das File vom Typ transparentes EF (siehe CosK_76c) oder linear variables EF (siehe CosK_5a6) ist, genau dann MUSS das COS in DO_FCP ein DO_Size einstellen. <b>[<=]</b>

REQ(ids=G2_N014.000.a)<b>G2_N014.000.a - (N014.000)a K_COS</b>
PAR Das COS MUSS für DO_Size ein Tag = '80' verwenden. <b>[<=]</b>

REQ(ids=A_13910)<b>A_13910 - (N014.000)b K_externeWelt {K_Karte}</b>
PAR Das Wertfeld KANN eine beliebige Länge besitzen. Die externe Welt MUSS beliebige Längen des DO_Size akzeptieren. <b>[<=]</b>

REQ(ids=G2_N014.000.c)<b>G2_N014.000.c - (N014.000)c K_COS</b>
PAR Das COS MUSS das Wertfeld von DO_Size so codieren, dass das Ergebnis einer Konvertierung mittels OS2I(…)  gleich numberOfOctet (siehe (N011.500)a, bzw. (N013.000)a) der Datei ist. <b>[<=]</b>

REQ(ids=A_13911)<b>A_13911 - (N014.100) K_COS</b>
PAR '82': Das COS MUSS in DO_FCP ein DO_FileDescriptor einstellen. <b>[<=]</b>

REQ(ids=G2_N014.100.a)<b>G2_N014.100.a - (N014.100)a K_COS</b>
PAR Wenn das File vom Typ Ordner (siehe CosK_fd2) ist, dann MUSS das COS DO_FileDescriptor wie folgt codieren:<br>1. DO_FileDescriptor MUSS ein Tag = '82' besitzen.<br>2. Das Wertfeld MUSS aus einem Oktett bestehen.<br>3. Das Wertfeld MUSS einen Wert aus der Menge {'38', '78'} enthalten. <b>[<=]</b>

REQ(ids=G2_N014.100.b)<b>G2_N014.100.b - (N014.100)b K_COS</b>
PAR Wenn das File vom Typ transparentes EF (siehe CosK_76c) ist, dann MUSS das COS DO_FileDescriptor wie folgt codieren:<br>1. DO_FileDescriptor MUSS ein Tag = '82' besitzen.<br>2. Das Wertfeld MUSS aus einem Oktett bestehen.<br>3. Das Wertfeld MUSS einen Wert aus der Menge {'01', '41'} enthalten. <b>[<=]</b>

REQ(ids=G2_N014.100.c)<b>G2_N014.100.c - (N014.100)c K_COS</b>
PAR Wenn das File vom Typ strukturiertes EF (siehe CosK_b94) ist, dann MUSS das COS DO_FileDescriptor wie folgt codieren:<br>1. DO_FileDescriptor MUSS ein Tag = '82' besitzen.<br>2. Die Länge des Wertfeldes von DO_FileDescriptor MUSS aus der Menge {5, 6} sein.<br>3. Das erste Oktett des Wertfeld MUSS einen Wert aus der Menge<br>    i.   {'02', '42'} besitzen, wenn File vom Typ linear fixes EF ist.<br>    ii.  {'04', '44'} besitzen, wenn File vom Typ linear variables EF ist.<br>    iii. {'06', '46'} besitzen, wenn File vom Typ zyklisches EF ist.<br>4. Das zweite Oktett im Wertfeld MUSS den Wert '41' besitzen.<br>5. Das 3. und 4. Oktett MUSS gleich I2OS( maximumRecordLength, 2) sein.<br>6. Das fünfte Oktett MUSS bzw. das fünfte und sechste Oktett MÜSSEN so gewählt werden, dass deren OS2I Konvertierung das Attribut maximumNumberOfRecords liefert. <b>[<=]</b>

REQ(ids=G2_N014.200)<b>G2_N014.200 - (N014.200) K_COS</b>
PAR '83': Wenn das File ein Attribut vom Typ fileIdentifier gemäß CosK_6ab besitzt, genau dann MUSS das COS in DO_FCP ein DO_FID einstellen, wobei gilt:<br>DO_FID = '83 02 || I2OS( fileIdentifier, 2 )'. <b>[<=]</b>

REQ(ids=G2_N014.300)<b>G2_N014.300 - (N014.300) K_COS</b>
PAR '84': Wenn das File Attribute vom Typ applicationIdentifier gemäß (N010.200) besitzt, dann MUSS das COS in DO_FCP jedes dieser Attribute einstellen. Jedes dieser Attribute wird als Wertfeld in einem DO_AID codiert und es gilt:    <br>DO_AID = '84 || I2OS(OctetLength( applicationIdentifier, 1 ) || applicationIdentifier'. <b>[<=]</b>

REQ(ids=A_13912)<b>A_13912 - (N014.400) K_COS</b>
PAR '88': Wenn das File vom Typ Datei (siehe CosK_9e0) ist, genau dann MUSS das COS in DO_FCP ein DO_SFI einstellen. <b>[<=]</b>

REQ(ids=G2_N014.400.a)<b>G2_N014.400.a - (N014.400)a K_COS</b>
PAR Wenn die Datei ein Attribut shortFileIdentifier gemäß (N007.000) besitzt, dann MUSS das COS DO_SFI wie folgt codieren:<br>DO_SFI = '88 01 || I2OS( 8 shortFileIdentifier, 1 )'. <b>[<=]</b>

REQ(ids=G2_N014.400.b)<b>G2_N014.400.b - (N014.400)b K_COS</b>
PAR Wenn die Datei kein Attribut shortFileIdentifier gemäß (N007.000) besitzt, dann MUSS das COS DO_SFI wie folgt codieren:<br>DO_SFI = '88 00'. <b>[<=]</b>

REQ(ids=A_13913)<b>A_13913 - (N014.500) K_COS</b>
PAR '8A': Das COS MUSS den physikalischen Wert des Attributes lifeCycleStatus (siehe (N007.100)a) eines Files in DO_FCP als DO_LCS mit einem Tag = '8A' und einem Wertfeld der Länge eins einstellen. Der Wert von lifeCycleStatuswird gemäß [ISO/IEC 7816-4#Tabelle 14] codiert. <b>[<=]</b>

REQ(ids=G2_N014.500.a)<b>G2_N014.500.a - (N014.500)a K_COS</b>
PAR Das COS MUSS für lifeCycleStatus == "Operational state (active)" einen Wert aus der Menge {'05', '07'} verwenden. <b>[<=]</b>

REQ(ids=G2_N014.500.b)<b>G2_N014.500.b - (N014.500)b K_COS</b>
PAR Das COS MUSS für lifeCycleStatus == "Operational state (deactivated)" einen Wert aus der Menge {'04', '06'} verwenden. <b>[<=]</b>

REQ(ids=G2_N014.500.c)<b>G2_N014.500.c - (N014.500)c K_COS</b>
PAR Das COS MUSS für lifeCycleStatus == "Termination state" einen Wert aus der Menge {'0C'. '0D', '0E', '0F'} verwenden. <b>[<=]</b>

REQ(ids=G2_N014.600.a)<b>G2_N014.600.a - (N014.600)a K_COS</b>
PAR '8F': Wenn das File vom Typ strukturiertes EF (siehe CosK_b94) ist und das Attribut flagRecordLifeCycleStatus hat den Wert False, dann MUSS das COS<br>1. entweder in den DO_FCP ein DO_Profile = '8F 01 00' einstellen,<br>2. oder auf ein DO mit Tag = '8F' in den DO_FCP verzichten. <b>[<=]</b>

REQ(ids=G2_N014.600.b)<b>G2_N014.600.b - (N014.600)b K_COS</b>
PAR '8F': Wenn das File vom Typ strukturiertes EF (siehe CosK_b94) ist und das Attribut flagRecordLifeCycleStatus hat den Wert True, genau dann MUSS das COS in DO_FCP ein DO_ProfileIdentifier = '8F 01 XX' einstellen, wobei das Wertfeld dieses DOs gemäß OS2I('XX') convertiert eine ungerade Zahl kleiner als 128 ist. <b>[<=]</b>

REQ(ids=A_13914)<b>A_13914 - (N014.700) K_COS</b>
PAR 'C5': Wenn das File vom Typ transparentes EF (siehe CosK_76c) ist, genau dann MUSS das COS in DO_FCP ein DO_ReadSize einstellen. <b>[<=]</b>

REQ(ids=G2_N014.700.a)<b>G2_N014.700.a - (N014.700)a K_COS</b>
PAR Das COS MUSS für DO_ReadSize ein Tag = 'C5' verwenden. <b>[<=]</b>

REQ(ids=G2_N014.700.b)<b>G2_N014.700.b - (N014.700)b K_externeWelt {K_Karte}</b>
PAR Das Wertfeld KANN eine beliebige Länge besitzen. Die externe Welt MUSS beliebige Längen des DO_ReadSize akzeptieren. <b>[<=]</b>

REQ(ids=G2_N014.700.c)<b>G2_N014.700.c - (N014.700)c K_COS</b>
PAR Das COS MUSS das Wertfeld von DO_Size so codieren, dass das Ergebnis einer Konvertierung mittels OS2I(…)  gleich positionLogicalEndOfFile (siehe (N011.510)) der Datei ist. <b>[<=]</b>

REQ(ids=A_13915)<b>A_13915 - (N014.800) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden DO_FCP enthielte weitere Datenobjekte. Enthält DO_FCP weitere Datenobjekte, so sind deren Codierung und Bedeutung herstellerspezifisch. <b>[<=]</b>

REQ(ids=A_13916)<b>A_13916 - (N014.900)a K_externeWelt {K_Karte}</b>
PAR Für die Reihenfolge der Datenobjekte in DO_FCP gilt: Die Reihenfolge aller Datenobjekte ist herstellerspezifisch. Die externe Welt MUSS jede beliebige Reihenfolge der DO in DO_FCP akzeptieren. <b>[<=]</b>

REQ(ids=G2_N014.900.b)<b>G2_N014.900.b - (N014.900)b K_COS</b>
PAR Wenn in DO_FCP vorhanden, dann MUSS das COS die Reihenfolge der DO in DO_FCP so wählen, dass die Datenobjekte DO_Size, DO_FileDescriptor, DO_FID, DO_AID, DO_SFI, DO_LCS, DO_ProfileIdentifier und DO_ReadSize vollständig in den ersten 256 Oktetten des Oktettstrings DO_FCP enthalten sind. <b>[<=]</b>

PAR -HEADING(ids=8.4)8.4 CosK_d13 Reguläres-Passwort (normativ)
PAR Hinweis CosH_f6b: Mit der Version 3.0 dieses Dokumentes wurde der Objekttyp "Multireferenz-Passwort" eingeführt (siehe CosK_7f0). An der Schnittstelle ist es nicht möglich zwischen einem "Regulären-Passwort", welches alle Attribute selbst besitzt und einem "Multireferenz-Passwort", welches gewisse Attribute eines "Regulären-Passworts" nachnutzt, zu unterscheiden. Diesbezüglich ist die Unterscheidung in diesem Dokument willkürlich und einerseits darin begründet die Unterschiede zu älteren Versionen dieses Dokumentes nicht unnötig zu vergrößern und andererseits eine einfache und präzise Darstellung zu ermöglichen. Als Konsequenz werden die Begriffe "Reguläres-Passwort" und "Multireferenz-Passwort" nur verwendet, wenn die Unterscheidung wichtig ist. An Stellen, wo diese Unterscheidung nicht wichtig ist wird der Begriff "Passwort" verwendet.
PAR Ein "Reguläres-Passwort" dient der Speicherung eines Geheimnisses, das in der Regel nur einem Karteninhaber bekannt ist. Das COS wird bestimmte Dienste erst dann zulassen, wenn dieses Geheimnis im Rahmen einer Benutzerverifikation erfolgreich präsentiert wurde. Die Notwendigkeit der Benutzerverifikation lässt sich einschalten (enable) oder abschalten (disable).
PAR Typischerweise ist das Geheimnis aus Sicherheitsgründen änderbar. Ebenfalls aus Sicherheitsgründen wird die Operation "Benutzerverifikation" für ein bestimmtes Passwort vom COS gesperrt, wenn die Benutzerverifikation mit diesem Passwort zu oft fehlschlug. Typischerweise ist es möglich, diese Sperrung aufzuheben.
PAR Hinweis CosH_b0a: In anderen Dokumenten wird in der Regel der Begriff PIN verwendet und bezeichnet dann teilweise das einem Karteninhaber bekannte sechsstellige Geheimnis ("Bitte geben Sie Ihre PIN ein.") und teilweise das Objekt in seiner Gesamtheit ("Die PIN ist blockiert."). In diesem Dokument wird der sprachlichen Klarheit wegen, weitgehend auf den Begriff PIN verzichtet und zur Bezeichnung des Objekttyps stets der Begriff Passwort verwendet.
PAR Bei der Spezifikation von Applikationen sind folgende Regeln einzuhalten:
REQ(ids=G2_N015.000.a)<b>G2_N015.000.a - (N015.000)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Reguläres-Passwort MUSS genau ein Attribut pwdIdentifier mit einem ganzzahligen Wert aus dem Intervall [0, 31] besitzen. <b>[<=]</b>

REQ(ids=A_13923)<b>A_13923 - (N015.000)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für pwdIdentifier<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N015.050)<b>G2_N015.050 - (N015.050) K_Anwendungsspezifikation {K_Karte}</b>
PAR Eine Reguläres-Passwort MUSS genau ein Attribut vom Typ lifeCycleStatus (siehe (N007.100)a) besitzen. <b>[<=]</b>

REQ(ids=G2_N015.100)<b>G2_N015.100 - (N015.100) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Reguläres-Passwort MUSS genau ein Attribut accessRules vom Typ interfaceDependentAccessRules (siehe CosK_b03) besitzen. <b>[<=]</b>

REQ(ids=G2_N015.200)<b>G2_N015.200 - (N015.200) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Reguläres-Passwort MUSS genau ein Attribut secret vom Typ pin (siehe CosK_9f1) besitzen. <b>[<=]</b>

REQ(ids=G2_N015.300.a)<b>G2_N015.300.a - (N015.300)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Das Reguläres-Passwort MUSS genau ein Attribut minimumLength mit einem ganzzahligen Wert aus dem Intervall [4, 12] besitzen. <b>[<=]</b>

REQ(ids=A_13925)<b>A_13925 - (N015.300)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für minimumLength<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N015.310.a)<b>G2_N015.310.a - (N015.310)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Das Reguläres-Passwort MUSS genau ein Attribut maximumLength mit einem ganzzahligen Wert aus dem Intervall [minimumLength, 12] besitzen. <b>[<=]</b>

REQ(ids=A_13927)<b>A_13927 - (N015.310)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für maximumLength<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N015.400.a)<b>G2_N015.400.a - (N015.400)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Reguläres-Passwort MUSS genau ein Attribut startRetryCounter mit einem ganzzahligen Wert aus dem Intervall [1, 15] besitzen. <b>[<=]</b>

REQ(ids=A_13929)<b>A_13929 - (N015.400)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für startRetryCounter<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N015.500.a)<b>G2_N015.500.a - (N015.500)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Reguläres-Passwort MUSS genau ein Attribut retryCounter mit einem ganzzahligen Wert aus dem Intervall [0, 15] besitzen. <b>[<=]</b>

REQ(ids=A_13931)<b>A_13931 - (N015.500)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für retryCounter<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N015.600)<b>G2_N015.600 - (N015.600) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Reguläres-Passwort MUSS genau ein Attribut transportStatus gemäß (N009.500) besitzen. <b>[<=]</b>

REQ(ids=G2_N015.610)<b>G2_N015.610 - (N015.610) K_COS {K_Karte}</b>
PAR Wenn das Attribut transportStatus eines regulären Passwortobjektes vom Zustand "Leer-PIN" in den Zustand "regularPassword" wechselt, dann MUSS das COS auf eine herstellerspezifische Art und Weise sicherstellen, dass der Use Case "Setzen eines Benutzergeheimnisses" gemäß (N073.700) für dieses reguläre Passwortobjekt und alle auf dieses reguläre Passwortobjekt verweisenden Multireferenz-Passwortobjekte nicht mehr ausführbar ist. <b>[<=]</b>

REQ(ids=G2_N015.700)<b>G2_N015.700 - (N015.700) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Reguläres-Passwort MUSS genau ein Attribut flagEnabled vom Typ Boolean besitzen. Es wird im Rahmen der Zugriffsregelauswertung verwendet (siehe (N022.200)a.2). <b>[<=]</b>

REQ(ids=A_13932)<b>A_13932 - (N015.800) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Reguläres-Passwort MUSS genau ein Attribut startSsecList besitzen. <b>[<=]</b>

REQ(ids=G2_N015.800.a)<b>G2_N015.800.a - (N015.800)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Die Liste startSsecList MUSS eine Länge aus dem Intervall [1, 4] haben. <b>[<=]</b>

REQ(ids=A_13933)<b>A_13933 - (N015.800)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Listenlängen für startSsecList<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N015.800.c)<b>G2_N015.800.c - (N015.800)c K_Anwendungsspezifikation {K_Karte}</b>
PAR Jedes Listenelement in startSsecList MUSS<br>1. genau einen seIdentifier gemäß (N007.900) und<br>2. genau eine ganze Zahl startSsec enthalten, deren Wert entweder aus dem Intervall [1, 250] zu wählen ist oder die den Wert "unendlich" repräsentiert. <b>[<=]</b>

REQ(ids=A_13934)<b>A_13934 - (N015.800)d K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für startSsecwürden<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N015.900)<b>G2_N015.900 - (N015.900) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Reguläres-Passwort MUSS genau ein Attribut PUK vom Typ pin (siehe CosK_9f1) besitzen, welches ein Geheimnis repräsentiert, welches das Zurücksetzten eines abgelaufenen retryCounter ermöglicht. <b>[<=]</b>

REQ(ids=G2_N016.000.a)<b>G2_N016.000.a - (N016.000)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Reguläres-Passwort MUSS ein Attribut pukUsage mit einem ganzzahligen Wert aus dem Intervall [0, 15] besitzen. <b>[<=]</b>

REQ(ids=A_13936)<b>A_13936 - (N016.000)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für pukUsage<br> 1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N016.100.a)<b>G2_N016.100.a - (N016.100)a K_externeWelt {K_Karte}</b>
PAR Die Ziffernfolgen secret und PUK MÜSSEN an der Schnittstelle Interpreter (siehe CosA_e09) stets als Format-2-PIN-Block (siehe (N008.100)) übertragen werden. <b>[<=]</b>

REQ(ids=A_13937)<b>A_13937 - (N016.100)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Übertragungsformate<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR Bevor eines der folgenden Kommandos in der Lage ist mit dem Passwort zu arbeiten, ist das Passwort zu selektieren. Dies geschieht mittels eines Identifiers, der als Parameter dem zugreifenden Kommando mitgegeben wird.
REQ(ids=A_13938)<b>A_13938 - (N016.200) K_COS</b>
PAR Das COS MUSS für den Objekttyp Passwort die folgenden Kommandos unterstützen:<br>a. reguläre Nutzung:<br>    1. CHANGE REFERENCE DATA (siehe (N073.300) und (N073.700)),<br>    2. DISABLE VERIFICATION REQUIREMENT (siehe (N075.386) und (N075.500)),<br>    3. ENABLE VERIFICATION REQUIREMENT (siehe (N076.586) und (N076.700)),<br>    4. GET PIN STATUS (siehe (N077.900)),<br>    5. RESET RETRY COUNTER (siehe (N079.300) und (N079.700) und (N080.100) und (N080.300)),<br>    6. VERIFY (siehe (N082.200)).<br>b. administrative Kommandos:<br>    1. ACTIVATE (siehe (N034.834)),<br>    2. DEACTIVATE (siehe (N036.034)),<br>    3. DELETE (siehe (N037.134)),<br>    4. TERMINATE (siehe (N048.934)). <b>[<=]</b>

REQ(ids=A_13939)<b>A_13939 - (N016.210) K_externeWelt {K_Karte}</b>
PAR Die externe Welt DARF ein reguläres Passwort NICHT löschen (Use Case entsprechend (N037.134)), solange es Multireferenz-Passwortobjekte gibt, die mittels ihres Attributes passwordReference (siehe (N016.320)f) auf dieses reguläre Passwortobjekt verweisen. <b>[<=]</b>

REQ(ids=A_13940)<b>A_13940 - (N016.300) K_TST</b>
PAR Ein Reguläres-Passwort KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS für Reguläre-Passworte weitere Kommandos<br>a. unterstützt oder<br>b. ableht. <b>[<=]</b>

PAR Einem Regulären-Passwort ist ein weiteres, kanalspezifisches Attribut securityStatusEvaluationCounter (siehe (N029.900)k) zugeordnet, das typischerweise einem flüchtig (etwa im RAM) gespeicherten Sicherheitszustand (siehe CosK_aad) zugerechnet wird. Es wird im Rahmen von Kommandos zur Benutzerverifikation (siehe (N082.200)) geändert.
PAR Hinweis CosH_1e8: Absichtlich ist einem Passwort kein Attribut shareable zugeordnet (vergleiche etwa (N011.050)). Es wird erwartet, dass sich ein Passwortobjekt in einem logischen Kanal unabhängig von beliebigen Aktivitäten in anderen Kanälen nutzen lässt.
PAR -HEADING(ids=8.5)8.5 CosK_7f0 Multireferenz-Passwort (normativ)
PAR Ein Multireferenz-Passwort ermöglicht die Nutzung eines Geheimnisses, welches als Attribut in einem Regulären-Passwort gespeichert ist (siehe (N015.200)), allerdings unter Bedingungen, die von denen des Regulären-Passwortes bewusst abweichen. Wird das Verhalten an der Schnittstelle zur Smartcard betrachtet, so scheinen Reguläres-Passwort und Multireferenz-Passwort gewisse Attribute gemeinsam zu nutzen, während es für die übrigen Attribute möglich ist diese individuell verschieden zu wählen. Aus Sicht eines Karteninhabers scheinen die im bekannten Geheimnisse (secret gemäß (N015.200) und PUK gemäß (N015.900)) unter mehreren "Referenzen" (genauer pwdIdentifiern gemäß (N015.000)) ansprechbar zu sein.
PAR Bei der Spezifikation von Applikationen sind folgende Regeln einzuhalten:
REQ(ids=A_13951)<b>A_13951 - (N016.320) K_Anwendungsspezifikation {K_Karte}</b>
PAR Folgende Attribute MÜSSEN für ein Multireferenz-Passwort individuell festlegt werden, das heißt diese Attribute werden nicht gemeinsam mit anderen Regulären-Passwörtern oder anderen Multireferenz-Passwörtern genutzt: <b>[<=]</b>

REQ(ids=G2_N016.320.a)<b>G2_N016.320.a - (N016.320)a K_Anwendungsspezifikation {K_Karte}</b>
PAR pwdIdentifier: Ein Multireferenz-Passwort MUSS genau ein Attribut pwdIdentifier besitzen. Für dieses Attribut gelten die in (N015.000) genannten Anforderungen. <b>[<=]</b>

REQ(ids=G2_N016.320.b)<b>G2_N016.320.b - (N016.320)b K_Anwendungsspezifikation {K_Karte}</b>
PAR lifeCycleStatus: Eine Multireferenz-Passwort MUSS genau ein Attribut vom Typ lifeCycleStatus (siehe (N007.100)a) besitzen. <b>[<=]</b>

REQ(ids=G2_N016.320.c)<b>G2_N016.320.c - (N016.320)c K_Anwendungsspezifikation {K_Karte}</b>
PAR accessRules: Ein Multireferenz-Passwort MUSS genau ein Attribut accessRules vom Typ interfaceDependentAccessRules (siehe CosK_b03) besitzen. <b>[<=]</b>

REQ(ids=G2_N016.320.d)<b>G2_N016.320.d - (N016.320)d K_Anwendungsspezifikation {K_Karte}</b>
PAR startSsecList: Ein Multireferenz-Passwort MUSS genau ein Attribut startSsecList besitzen. Für diese Liste gelten die in (N015.800) genannten Anforderungen. <b>[<=]</b>

REQ(ids=G2_N016.320.e)<b>G2_N016.320.e - (N016.320)e K_Anwendungsspezifikation {K_Karte}</b>
PAR flagEnabled: Ein Multireferenz-Passwort MUSS genau ein Attribut flagEnabled besitzen. Für dieses Attribut gelten die in (N015.700) genannten Anforderungen. <b>[<=]</b>

REQ(ids=G2_N016.320.f)<b>G2_N016.320.f - (N016.320)f K_Anwendungsspezifikation {K_Karte}</b>
PAR passwordReference: Ein Multireferenz-Passwort MUSS genau ein Attribut passwordReference mit den folgenden Eigenschaften besitzen.<br>1. Das Attribute passwordReference enthält eine Referenz auf ein Passwort.<br>2. Sei objectFolder der Ordner, welcher dieses Multireferenz-Passwort enthält, dann gilt:<br>    i.   Die Funktion pwd = SearchPwd(objectFolder, passwordReference) meldet nicht den Fehler pwdNotFound zurück.<br>    ii.  pwd ist ein Reguläres-Passwort (keine Kettenbildung).<br>    iii. Die Attribute, welche dieses Multireferenz-Passwort gemeinsam mit einem Regulären-Passwort nutzt, werden dem Passwort pwd entnommen. Mit anderen Worten: Die Attribute, welches das Multireferenz-Passwort nicht selber speichert, steuert pwd bei.<br><b>[<=]</b>

PAR Folgende Attribute werden von einem Mutlireferenz-Passwort und dem mittels des Attributes passwordReference referenzierten Regulären-Passwort pwd gemeinsam genutzt:
REQ(ids=G2_N016.325.a)<b>G2_N016.325.a - (N016.325)a K_COS</b>
PAR Das COS MUSS das Attribute secret gemeinsam mit dem gleichnamigen aus pwd nutzen. <b>[<=]</b>

REQ(ids=G2_N016.325.b)<b>G2_N016.325.b - (N016.325)b K_COS</b>
PAR Das COS MUSS das Attribute minimumLength gemeinsam mit dem gleichnamigen aus pwd nutzen. <b>[<=]</b>

REQ(ids=G2_N016.325.c)<b>G2_N016.325.c - (N016.325)c K_COS</b>
PAR Das COS MUSS das Attribute maximumLength gemeinsam mit dem gleichnamigen aus pwd nutzen. <b>[<=]</b>

REQ(ids=G2_N016.325.d)<b>G2_N016.325.d - (N016.325)d K_COS</b>
PAR Das COS MUSS das Attribute startRetryCounter gemeinsam mit dem gleichnamigen aus pwd nutzen. <b>[<=]</b>

REQ(ids=G2_N016.325.e)<b>G2_N016.325.e - (N016.325).e K_COS</b>
PAR Das COS MUSS das Attribute retryCounter gemeinsam mit dem gleichnamigen aus pwd nutzen. <b>[<=]</b>

REQ(ids=G2_N016.325.f)<b>G2_N016.325.f - (N016.325)f K_COS</b>
PAR Das COS MUSS das Attribute transportStatus gemeinsam mit dem gleichnamigen aus pwd nutzen. <b>[<=]</b>

REQ(ids=G2_N016.325.g)<b>G2_N016.325.g - (N016.325)g K_COS</b>
PAR Das COS MUSS das Attribute PUK gemeinsam mit dem gleichnamigen aus pwd nutzen. <b>[<=]</b>

REQ(ids=G2_N016.325.h)<b>G2_N016.325.h - (N016.325)h K_COS</b>
PAR Das COS MUSS das Attribute pukUsage gemeinsam mit dem gleichnamigen aus pwd nutzen. <b>[<=]</b>

REQ(ids=A_13952)<b>A_13952 - (N016.330) K_COS</b>
PAR Ein Multireferenz-Passwort MUSS dieselben Kommandos unterstützen wie für ein Reguläres-Passwort in (N016.200) gefordert. <b>[<=]</b>

REQ(ids=A_13953)<b>A_13953 - (N016.335) K_TST</b>
PAR Ein Multireferenz-Passwort KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS für Multireferenz-Passworte weitere Kommandos<br>a. unterstützt oder<br>b. ableht. <b>[<=]</b>

PAR Einem Multireferenz-Passwort ist ein weiteres, kanalspezifisches Attribut securityStatusEvaluationCounter (siehe (N029.900)k) zugeordnet, das typischerweise einem flüchtig (etwa im RAM) gespeicherten Sicherheitszustand (siehe CosK_aad) zugerechnet wird. Es wird im Rahmen von Kommandos zur Benutzerverifikation (siehe (N082.200)) geändert.
PAR -HEADING(ids=8.6)8.6 CosK_afb Schlüsselobjekt (normativ)
PAR Dieses Unterkapitel beschreibt Schlüsselobjekte, die im Rahmen kryptographischer Operationen zum Einsatz kommen. Der Terminus Schlüsselobjekt dient in diesem Dokument als Oberbegriff für symmetrische, private und öffentliche Schlüsselobjekte.
PAR Symmetrische Schlüssel werden in diesem Dokument zu folgenden Zwecken eingesetzt:
PAR       1. Mit persistent gespeichertem Geheimnis (Schlüssel) zur einseitigen Authentisierung (siehe 15.1.1).

ORDERED-LIST->
LITEM->PAR Mit persistent gespeichertem Geheimnis (Schlüssel) zur gegenseitigen Authentisierung bei gleichzeitiger Aushandlung von Sessionkeys (siehe CosK_b47 und CosK_580).LITEM->PAR Mit persistent gespeichertem Geheimnis (Schlüssel) zur gegenseitigen Authentisierung bei gleichzeitiger Übertragung von Sessionkeys (siehe CosK_07f).LITEM->PAR Als Sessionkey zur Sicherstellung einer vertraulichen Kommunikation.LITEM->PAR Als Sessionkey zur Sicherstellung einer integren und authentischen Kommunikation.
PAR Private Schlüssel werden in diesem Dokument zu folgenden Zwecken eingesetzt:

ORDERED-LIST->
LITEM->PAR Berechnung elektronischer Signaturen (siehe CosK_e61)LITEM->PAR Entschlüsselung von Daten (siehe CosK_a85)LITEM->PAR Nachweis der Authentizität dieser Karte (siehe CosK_0df)LITEM->PAR Transportsicherung von Sessionkey Material (siehe CosK_07f und (N085.068)b.7.viii (N084.400)c)
PAR Öffentliche Schlüssel werden in diesem Dokument zu folgenden Zwecken eingesetzt:

ORDERED-LIST->
LITEM->PAR Prüfen elektronischer Signaturen beim Import von Zertifikaten (siehe (N095.900))LITEM->PAR Prüfen von Signaturen im Rahmen von Rollenauthentisierungen (siehe (N084.400))LITEM->PAR Transportsicherung von Sessionkey Material (siehe CosK_07f und (N085.068)b.7.viii (N086.900)d)LITEM->PAR Verschlüsseln von Daten (siehe CosK_f48)
PAR -HEADING(ids=8.6.1)8.6.1 CosK_5fa Symmetrisches Authentisierungsobjekt
PAR Ein symmetrisches Authentisierungsobjekt wird im Rahmen von Authentisierungen gemäß CosK_b47 und CosK_07f eingesetzt. Für dieses Schlüsselobjekt gelten folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=G2_N016.400.a)<b>G2_N016.400.a - (N016.400)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein symmetrisches Authentisierungsobjekt MUSS ein Attribut keyIdentifier mit einem ganzzahligen Wert aus dem Intervall [2, 28] besitzen. <b>[<=]</b>

REQ(ids=A_13958)<b>A_13958 - (N016.400)b K_TST</b>
PAR En COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für keyIdentifier<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N016.450)<b>G2_N016.450 - (N016.450) K_Anwendungsspezifikation {K_Karte}</b>
PAR Eine symmetrisches Authentisierungsobjekt MUSS genau ein Attribut vom Typ lifeCycleStatus (siehe (N007.100)a) besitzen. <b>[<=]</b>

REQ(ids=G2_N016.500)<b>G2_N016.500 - (N016.500) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein symmetrisches Authentisierungsobjekt MUSS genau ein Attribut accessRules vom Typ interfaceDependentAccessRules (siehe CosK_b03) besitzen. <b>[<=]</b>

REQ(ids=G2_N016.590.a)<b>G2_N016.590.a - (N016.590)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein symmetrisches Authentisierungsobjekt MUSS genau ein Attribut keyType aus der Menge {3TDES (Option_DES), AES-128, AES-192, AES-256} besitzen. <b>[<=]</b>

REQ(ids=A_13959)<b>A_13959 - (N016.590)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für keyType<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N016.600)<b>G2_N016.600 - (N016.600) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein symmetrisches Authentisierungsobjekt MUSS genau ein Attribut encKey gemäß CosK_d6b besitzen. <b>[<=]</b>

REQ(ids=G2_N016.700)<b>G2_N016.700 - (N016.700) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein symmetrisches Authentisierungsobjekt MUSS genau ein Attribut macKey gemäß CosK_d6b besitzen. <b>[<=]</b>

REQ(ids=G2_N016.705)<b>G2_N016.705 - (N016.705) K_Anwendungsspezifikation {K_Karte}</b>
PAR Die Attribute encKey und macKey MÜSSEN passend zum Attribut keyType gewählt werden. <b>[<=]</b>

REQ(ids=G2_N016.710)<b>G2_N016.710 - (N016.710) K_Anwendungsspezifikation {K_Karte}</b>
PAR Wenn algorithmIdentifier Element der Menge {aesSessionkey4SM} ist, genau dann MUSS ein symmetrisches Authentisierungsobjekt ein Attribut numberScenario vom Typ ganze Zahl aus dem Intervall [0, 32.767] besitzen. <b>[<=]</b>

REQ(ids=A_13960)<b>A_13960 - (N016.800) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein symmetrisches Authentisierungsobjekt MUSS genau ein Attribut vom Typ algorithmIdentifier besitzen, welches angibt, für welchen Zweck es verwendbar ist. <b>[<=]</b>

REQ(ids=G2_N016.800.a)<b>G2_N016.800.a - (N016.800)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Für symmetrische Authentisierungsobjekte MUSS der Wert von algorithmIdentifier Element der Menge {<br>    1. aesSessionkey4SM, (siehe, (N084.410)a)<br>    2. desSessionkey4SM (siehe, (N084.410)b, Option_DES)<br>} sein (siehe CosT_2a4). <b>[<=]</b>

REQ(ids=G2_N016.800.b)<b>G2_N016.800.b - (N016.800)b K_Anwendungsspezifikation {K_Karte}, Option_Kryptobox</b>
PAR Für symmetrische Authentisierungsobjekte MUSS der Wert von algorithmIdentifier Element der Menge {<br>     1. aesSessionkey4TC, (siehe (N084.402)a, (N086.902)a),<br>     2. aesSessionkey4SM, (siehe, (N084.410)a)<br>     2. desSessionkey4TC     (siehe (N084.402)b, (N086.902)b, Option_DES)<br>} sein (siehe CosT_2a4). <b>[<=]</b>

REQ(ids=A_13961)<b>A_13961 - (N016.800)c K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für algorithmIdentifier<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N016.820)<b>G2_N016.820 - (N016.820) K_Anwendungsspezifiktion {K_Karte}, Option_Kryptobox</b>
PAR Wenn algorithmIdentifier Element der Menge {aesSessionkey4TC, desSessionkey4TC} ist, genau dann MUSS ein symmetrisches Authentisierungsobjekt ein Attribut accessRulesSessionkeys vom Typ interfaceDependentAccessRules (siehe CosK_b03) besitzen. <b>[<=]</b>

PAR Bevor eines der folgenden Kommandos in der Lage ist mit dem symmetrischen Authentisierungsobjekt zu arbeiten, ist es zu selektieren. Dies geschieht mittels der in CosK_146 beschriebenen Use Cases.
REQ(ids=G2_N016.900.a)<b>G2_N016.900.a - (N016.900)a K_COS</b>
PAR Zusätzlich zu den in (N016.900)b gelisteten Kommandos MUSS ein symmetrischen Authentisierungsobjekt auch die folgenden Kommandos unterstützen:<br>1. EXTERNAL AUTHENTICATE (siehe (N083.500) und (N101.400)),<br>2. GENERAL AUTHENTICATE (siehe (N085.022) und (N101.400)),<br>3. INTERNAL AUTHENTICATE (siehe (N086.400) und (N100.400)),<br>4. MUTUAL AUTHENTICATE (siehe (N083.800) und (N102.400)). <b>[<=]</b>

PAR Bevor eines der folgenden Kommandos in der Lage ist mit dem symmetrischen Authentisierungsobjekt zu arbeiten, ist es zu selektieren. Dies geschieht mittels eines Identifiers, der als Parameter dem zugreifenden Kommando mitgegeben wird.
REQ(ids=G2_N016.900.b)<b>G2_N016.900.b - (N016.900)b K_COS</b>
PAR Zusätzlich zu den in (N016.900)a gelisteten Kommandos MUSS ein symmetrischen Authentisierungsobjekt auch die folgenden Kommandos unterstützen:<br>1. ACTIVATE (siehe (N034.814)),<br>2. DEACTIVATE (siehe (N036.014)),<br>3. DELETE (siehe (N037.144)).<br>4. GET SECURITY STATUS KEY  (siehe (N085.200), Option_DES),<br> 4. TERMINATE (siehe (N048.914)). <b>[<=]</b>

REQ(ids=A_13962)<b>A_13962 - (N017.000) K_TST</b>
PAR Ein symmetrisches Authentisierungsobjekt KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS für symmetrischen Authentisierungsobjekt weitere Kommandos<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR Hinweis CosH_ef7: Absichtlich ist einem symmetrischen Authentisierungsobjekt kein Attribut shareable zugeordnet (vergleiche etwa (N011.050)). Es wird erwartet, dass sich ein symmetrisches Authentisierungsobjekt in einem logischen Kanal unabhängig von beliebigen Aktivitäten in anderen Kanälen nutzen lässt.
PAR -HEADING(ids=8.6.2)8.6.2 CosK_24a Symmetrisches Kartenverbindungsobjekt
PAR Ein symmetrisches Kartenverbindungsobjekt wird im Rahmen von Authentisierungen gemäß CosK_580 verwendet. Die normativen Festlegungen in diesem Dokument bilden eine Untermenge der in [BSI-TR-03110-3] für eine CAN (Card Access Number) beschriebenen Funktionalität: Ein symmetrisches Kartenverbindungsobjekt ist nicht änderbar und unterstützt ausschließlich PACE in der Version 2 in der ECDH-Variante.
PAR Für symmetrische Kartenverbindungsobjekte gelten folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=G2_N017.020.a)<b>G2_N017.020.a - (N017.020)a K_Anwendungsspezifikation {K_Karte}, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR Ein symmetrisches Kartenverbindungsobjekt MUSS ein Attribut keyIdentifier mit einem ganzzahligen Wert aus dem Intervall [2, 28] besitzen. <b>[<=]</b>

REQ(ids=A_13966)<b>A_13966 - (N017.020)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für keyIdentifier<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N017.024)<b>G2_N017.024 - (N017.024) K_Anwendungsspezifikation {K_Karte}, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR Eine symmetrisches Kartenverbindungsobjekt MUSS genau ein Attribut vom Typ lifeCycleStatus (siehe (N007,100)a) besitzen. <b>[<=]</b>

REQ(ids=G2_N017.026)<b>G2_N017.026 - (N017.026) K_Anwendungsspezifikation {K_Karte}, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR Ein symmetrisches Kartenverbindungsobjekt MUSS genau ein Attribut accessRules vom Typ interfaceDependentAccessRules (siehe CosK_b03)) besitzen. <b>[<=]</b>

REQ(ids=G2_N017.028)<b>G2_N017.028 - (N017.028) K_Anwendungsspezifikation {K_Karte}, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR Ein symmetrisches Kartenverbindungsobjekt MUSS genau ein Attribut can vom Typ pin gemäß (N008.000) besitzen. <b>[<=]</b>

REQ(ids=A_13967)<b>A_13967 - (N017.030) K_Anwendungsspezifikation {K_Karte}, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR Ein symmetrisches Kartenverbindungsobjekt MUSS genau ein Attribut vom Typ algorithmIdentifier besitzen, welches angibt, für welchen Zweck es verwendbar ist (siehe CosK_580). Folgende Werte sind zulässig: <b>[<=]</b>

REQ(ids=G2_N017.030.a.1)<b>G2_N017.030.a.1 - (N017.030)a.1 K_Anwendungsspezifikation {K_Karte}, Option_kontaktlose_Schnittstelle</b>
PAR algorithmIdentifier = id-PACE-ECDH-GM-AES-CBC-CMAC-128, <b>[<=]</b>

REQ(ids=G2_N017.030.a.2)<b>G2_N017.030.a.2 - (N017.030)a.2 K_Anwendungsspezifikation {K_Karte}, Option_kontaktlose_Schnittstelle</b>
PAR algorithmIdentifier = id-PACE-ECDH-GM-AES-CBC-CMAC-192, <b>[<=]</b>

REQ(ids=G2_N017.030.a.3)<b>G2_N017.030.a.3 - (N017.030)a.3 K_Anwendungsspezifikation {K_Karte}, Option_kontaktlose_Schnittstelle</b>
PAR algorithmIdentifier = id-PACE-ECDH-GM-AES-CBC-CMAC-256, <b>[<=]</b>

REQ(ids=G2_N017.030.b.1)<b>G2_N017.030.b.1 - (N017.030)b.1 K_Anwendungsspezifikation {K_Karte}, Option_PACE_PCD</b>
PAR algorithmIdentifier = id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-128, <b>[<=]</b>

REQ(ids=G2_N017.030.b.2)<b>G2_N017.030.b.2 - (N017.030)b.2 K_Anwendungsspezifikation {K_Karte}, Option_PACE_PCD</b>
PAR algorithmIdentifier = id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-192, <b>[<=]</b>

REQ(ids=G2_N017.030.b.3)<b>G2_N017.030.b.3 - (N017.030)b.3 K_Anwendungsspezifikation {K_Karte}, Option_PACE_PCD</b>
PAR algorithmIdentifier = id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-256. <b>[<=]</b>

REQ(ids=A_13968)<b>A_13968 - (N017.030)c K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für algorithmIdentifier<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N017.031)<b>G2_N017.031 - (N017.031) K_Anwendungsspezifiktion {K_Karte}, Option_PACE_PCD</b>
PAR Wenn algorithmIdentifier Element der Menge {<br>    id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-128,<br>    id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-192,<br>    id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-256<br>} ist, genau dann MUSS ein symmetrisches Kartenverbindungsobjekt ein Attribut accessRulesSessionkeys vom Typ interfaceDependentAccessRules (siehe CosK_b03) besitzen. <b>[<=]</b>

PAR Bevor eines der folgenden Kommandos in der Lage ist mit dem symmetrischen Kartenverbindungsobjekt zu arbeiten, ist es zu selektieren. Dies geschieht mittels des in (N102.448) beschriebenen Use Cases.
REQ(ids=G2_N017.032.a.1)<b>G2_N017.032.a.1 - (N017.032)a.1 K_COS, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR Zusätzlich zu den in (N017.032)a.2 gelisteten Kommandos MUSS ein symmetrischen Kartenverbindungsobjektauch die folgenden Kommandos unterstützen:<br>i. Option_kontaktlose_Schnittstelle<br>  GENERAL AUTHENTICATE (siehe (N085.001), (N085.003), (N085.005), (N085.007)),<br>ii. Option_PACE_PCD<br>   GENERAL AUTHENTICATE (siehe (N085.031), (N085.033), (N085.035), (N085.037, (N085.039)). <b>[<=]</b>

PAR Bevor eines der folgenden Kommandos in der Lage ist mit dem symmetrischen Kartenverbindungsobjekt zu arbeiten, ist es zu selektieren. Dies geschieht mittels eines Identifiers, der als Parameter dem zugreifenden Kommando mitgegeben wird.
REQ(ids=G2_N017.032.a.2)<b>G2_N017.032.a.2 - (N017.032)a.2 K_COS, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR Zusätzlich zu den in (N017.032)a.1 gelisteten Kommandos MUSS ein symmetrischen Kartenverbindungsobjektauch die folgenden Kommandos unterstützen:<br>i.   ACTIVATE (siehe (N034.814)),<br>ii.  DEACTIVATE (siehe (N036.014)),<br>iii. DELETE (siehe (N037.144)),<br>iv. TERMINATE (siehe (N048.914)). <b>[<=]</b>

REQ(ids=A_13969)<b>A_13969 - (N017.032)b K_TST</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass das COS für symmetrische Kartenverbindungsobjekte weitere Kommandos<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR Hinweis CosH_34c: Absichtlich ist einem symmetrischen Kartenverbindungsobjekt kein Attribut shareable zugeordnet (vergleiche etwa (N011.050)). Es wird erwartet, dass sich ein symmetrisches Kartenverbindungsobjekt in einem logischen Kanal unabhängig von beliebigen Aktivitäten in anderen Kanälen nutzen lässt.
PAR -HEADING(ids=8.6.3)8.6.3 CosK_ab8 Privates Schlüsselobjekt
PAR Hinweis CosH_1e5: Gegenüber der Generation 1 Spezifikation wird die dort beschriebene Unterteilung in private Authentisierungs-, Entschlüsselungs- und Signierobjekte in der Generation 2 aufgehoben. Mithin ist es möglich, dass ein privates Schlüsselobjekt sowohl für Authentisierungszwecke, als auch zur Entschlüsselung und zur Signaturerstellung nutzbar ist. Aus Sicherheitssicht ist es ratsam auf eine mögliche Vermischung wo irgend möglich zu verzichten. Die Trennung wird aufgehoben, da im Bereich IPSec oder auch TLS kryptographische Verfahren denkbar sind, wo ein privates Schlüsselobjekt sowohl entschlüsselt als auch signiert.
PAR Ein privates Schlüsselobjekt wird

LIST->
LITEM->PAR zur Authentisierung einer Karte gegenüber einer anderen technischen KomponenteLITEM->PAR zur Entschlüsselung von Daten undLITEM->PAR zur Berechnung elektronischer Signaturen
PAR verwendet. Für private Schlüsselobjekte gelten folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=G2_N017.100.a)<b>G2_N017.100.a - (N017.100)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein privates Schlüsselobjekt MUSS ein Attribut keyIdentifier mit einem ganzzahligen aus dem Intervall [2, 28] Wert besitzen. <b>[<=]</b>

REQ(ids=A_13971)<b>A_13971 - (N017.100)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für keyIdentifier<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N017.150)<b>G2_N017.150 - (N017.150) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein privates Schlüsselobjekt MUSS genau ein Attribut vom Typ lifeCycleStatus (siehe (N007.100)a) besitzen. <b>[<=]</b>

REQ(ids=G2_N017.200)<b>G2_N017.200 - (N017.200) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein privates Schlüsselobjekt MUSS genau ein Attribut accessRules vom Typ interfaceDependentAccessRules (siehe CosK_b03) besitzen. <b>[<=]</b>

REQ(ids=G2_N017.300)<b>G2_N017.300 - (N017.300) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein privates Schlüsselobjekt MUSS genau ein Attribut privateKey gemäß CosK_1e2 besitzen. <b>[<=]</b>

PAR (N017.310) Diese Anforderung ist absichtlich leer.
REQ(ids=A_13972)<b>A_13972 - (N017.400) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein privates Schlüsselobjekt MUSS genau ein Attribut listAlgorithmIdentifier besitzen, welches angibt, für welche Zwecke das private Schlüsselobjekt verwendbar ist. <b>[<=]</b>

REQ(ids=G2_N017.400.a)<b>G2_N017.400.a - (N017.400)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Die Liste listAlgorithmIdentifier MUSS eine Länge aus dem Intervall [1, 4] haben. <b>[<=]</b>

REQ(ids=G2_N017.400.b)<b>G2_N017.400.b - (N017.400)b K_Anwendungsspezifikation {K_Karte}</b>
PAR Jedes Listenelement in listAlgorithmIdentifier MUSS<br>1. genau einen seIdentifier gemäß (N007.900) und<br>2. genau eine Menge setAlgorithmIdentifier mit Elementen des Typs algorithmIdentifier enthalten.<br>3. Die Werte von algorithmIdentifier MÜSSEN aus den in (N017.600), (N017.900) und (N018.300) genannten Mengen gewählt werden. <b>[<=]</b>

REQ(ids=G2_N017.400.c)<b>G2_N017.400.c - (N017.400)c K_Anwendungsspezifikation {K_Karte}</b>
PAR Die Menge setAlgorithmIdentifier DARF NICHT mehr als sechs Elemente enthalten. <b>[<=]</b>

REQ(ids=A_13973)<b>A_13973 - (N017.400)d K_TST</b>
PAR Das COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS Listen des Typs<br>1. listAlgorithmIdentifier, welche mehr Elemente enthalten als nach (N017.400)a gefordert,<br>    i.  unterstützt, oder<br>    ii. ablehnt.<br>2. setAlgorithmIdentifier, welche andere Elemente enthalten als nach (N017.400)b.3 gefordert,<br>    i.  unterstützt, oder<br>    ii. ablehnt.<br>3. setAlgorithmIdentifier, welche mehr Elemente enthalten als nach (N017.400)c gefordert,<br>    i.  unterstützt, oder<br>    ii. ablehnt. <b>[<=]</b>

REQ(ids=G2_N017.420)<b>G2_N017.420 - (N017.420) K_Anwendungsspezifiktion {K_Karte}, Option_Kryptobox</b>
PAR Ist in listAlgorithmIdentifier ein algorithmIdentifier der Menge {rsaSessionkey4TC, elcSessionkey4TC} enthalten, genau dann MUSS ein privates Authentisierungsobjekt ein Attribut accessRulesSessionkeys vom Typ interfaceDependentAccessRules (siehe CosK_b03) besitzen. <b>[<=]</b>

REQ(ids=G2_N017.430)<b>G2_N017.430 - (N017.430) K_Anwendungsspezifiktion {K_Karte}</b>
PAR Ist in listAlgorithmIdentifier ein algorithmIdentifier der Menge {elcAsynchronAdmin} enthalten, genau dann MUSS ein privates Authentisierungsobjekt ein Attribut numberScenario vom Typ ganze Zahl aus dem Intervall [0, 32.767] besitzen. <b>[<=]</b>

PAR (N017.500) Dieser Punkt ist absichtlich leer.
PAR (N017.510) Dieser Punkt ist absichtlich leer.
REQ(ids=G2_N017.600.a.1)<b>G2_N017.600.a.1 - (N017.600)a.1 K_Anwendungsspezifikation {K_Karte}</b>
PAR Wenn das Attribut privateKey des privaten Schlüsselobjektes vom Typ privateRsaKey ist, dann MUSS zum Zwecke der Authentisierung algorithmIdentifier aus folgender Menge gewählt werden (siehe CosT_7a2): {<br>     1. rsaClientAuthentication (siehe (N086.400) und (N086.900)b)<br>     2. rsaRoleAuthentication,   (siehe (N086.400) und (N086.900)c, Option_RSA_CVC)<br>     3. rsaSessionkey4SM,      (siehe (N086.400) und (N086.900)d, Option_DES)<br>     4. rsaSessionkey4TC,       (siehe (N084.402)c,(N086.902)c,      Option_Kryptobox, Option_DES)<br>}. <b>[<=]</b>

REQ(ids=G2_N017.600.a.2)<b>G2_N017.600.a.2 - (N017.600)a.2 K_Anwendungsspezifikation {K_Karte}</b>
PAR Wenn das Attribut privateKey des privaten Schlüsselobjektes vom Typ privateElcKey ist, dann MUSS zum Zwecke der Authentisierung algorithmIdentifier aus folgender Menge gewählt werden (siehe CosT_7a2): {<br>     1. elcAsynchronAdmin (siehe (N085.041) und (N085.068)),<br>     2. elcRoleAuthentication (siehe (N086.400) und (N086.900)a),<br>     3. elcSessionkey4SM (siehe (N085.054)),<br>     4. elcSessionkey4TC (siehe (N085.056), Option_Kryptobox)<br>}. <b>[<=]</b>

REQ(ids=A_13974)<b>A_13974 - (N017.600)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für algorithmIdentifier<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR (N017.610) ist absichlich leer.
REQ(ids=G2_N017.610.a)<b>G2_N017.610.a - (N017.610)a K_Anwendungsspezifikation {K_Karte}, Option_DES, Option_RSA_CVC</b>
PAR Zusammenhang zwischen Moduluslänge und Card-to-Card-Algorithmen: Die algorithmIdentifier aus der Menge {rsaRoleAuthentication, rsaSessionkey4SM, rsaSessionkey4TC} DÜRFEN einem privaten Schlüssel NICHT zugewiesen werden, wenn dessen Moduluslänge ungleich 2048 bit ist. <b>[<=]</b>

REQ(ids=A_13975)<b>A_13975 - (N017.610)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden Werte algorithmIdentifier aus der Menge {rsaRoleAuthentication, rsaSessionkey4SM und rsaSessionkey4TC} würden für Moduluslängen ungleich 2048 bit<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_13976)<b>A_13976 - (N017.620)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Zusammenhang zwischen Kurvenparametern und Card-to-Card-Algorithmen: Die algorithmIdentifier aus der Menge {elcRoleAuthentication, elcSessionkey4SM, elcSessionkey4TC} DÜRFEN einem privaten Schlüssel NICHT zugewiesen werden, wenn dessen domainParameter nicht in der Menge {brainpoolP256r1, brainpoolP384r1, brainpoolP512r1} enthalten ist. <b>[<=]</b>

REQ(ids=A_13977)<b>A_13977 - (N017.620)b K_TST</b>
PAR Das COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS Algorithmen aus der Menge {elcRoleAuthentication, elcSessionkey4SM, elcSessionkey4TC} für weitere domainParameter<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR Bevor eines der folgenden Kommandos in der Lage ist mit dem privaten Schlüsselobjekt zu arbeiten, ist es zu selektieren. Dies geschieht mittels der in (N100.900) oder (N102.900) beschriebenen Use Cases.
REQ(ids=G2_N017.700)<b>G2_N017.700 - (N017.700) K_COS</b>
PAR Ist einem privaten Schlüsselobjekt ein algorithmIdentifier aus den in (N017.600)a.1 oder (N017.600)a.2 genannten Mengen zugeordnet, dann MUSS es die folgenden Kommandos unterstützen:<br>1. EXTERNAL AUTHENTICATE (siehe (N084.400)c),<br>1. GENERAL AUTHENTICATE (siehe CosK_2ed),<br>2. INTERNAL AUTHENTICATE (siehe (N086.400)),<br>3. PSO Compute Digital Signature (siehe (N088.600)c). <b>[<=]</b>

PAR (N017.800) Dieser Punkt ist absichtlich leer.
REQ(ids=G2_N017.900.a.1)<b>G2_N017.900.a.1 - (N017.900)a.1 K_Anwendungsspezifikation {K_Karte}</b>
PAR Wenn das Attribut privateKey des privaten Schlüsselobjektes vom Typ privateRsaKey ist, dann MUSS zum Zwecke der Entschlüsselung algorithmIdentifier aus folgender Menge gewählt werden (siehe CosT_605): {<br>    i.  dieser Punkt ist absichtlich leer.<br>    ii. rsaDecipherOaep (siehe (N089.200), (N092.800) und (N092.830))<br>}. <b>[<=]</b>

REQ(ids=G2_N017.900.a.2)<b>G2_N017.900.a.2 - (N017.900)a.2 K_Anwendungsspezifikation {K_Karte}</b>
PAR Wenn das Attribut privateKey des privaten Schlüsselobjektes vom Typ privateElcKey ist, dann MUSS zum Zwecke der Entschlüsselung algorithmIdentifier aus folgender Menge gewählt werden (siehe CosT_605): {<br>   i. elcSharedSecretCalculation (siehe (N089.800), (N093.600) und (N093.634))<br>}. <b>[<=]</b>

REQ(ids=A_13978)<b>A_13978 - (N017.900)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für algorithmIdentifier<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR Bevor eines der folgenden Kommandos in der Lage ist mit dem privaten Schlüsselobjekt zu arbeiten, ist es zu selektieren. Dies geschieht mittels des in (N103.800) beschriebenen Use Cases.
REQ(ids=G2_N018.000)<b>G2_N018.000 - (N018.000) K_COS</b>
PAR Wenn einem privaten Schlüsselobjekt ein algorithmIdentifier aus der in (N017.900)a.1 oder (N017.900)a.2 genannten Menge zugeordnet, dann MUSS es die folgenden Kommandos unterstützen:<br>1. PSO Decipher (siehe (N089.200) und (N089.800)),<br>2. PSO Transcipher (siehe (N092.800), (N092.830), (N093.600) und (N093.634)). <b>[<=]</b>

PAR (N018.100) Dieser Punkt ist absichtlich leer.
REQ(ids=G2_N018.200)<b>G2_N018.200 - (N018.200) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein privates Schlüsselobjekt MUSS ein Attribut keyAvailable vom Typ Boolean unterstützen:<br>a. Der Wert True zeigt an, dass das Attribut privateKey verwendbar ist.<br>b. Der Wert False zeigt an, dass das Attribut privateKey nicht verwendbar ist.<br>c. Auf dieses Attribut wird im Rahmen der folgenden Kommandos zugegriffen:<br>    1. INTERNAL AUTHENTICATE (siehe (N086.810)),<br>    2. PSO Compute Digital Signature (siehe (N088.500)),<br>    3. PSO Decipher (siehe (N090.210)),<br>    4. PSO Transcipher (siehe (N094.010)). <b>[<=]</b>

REQ(ids=G2_N018.300.a.1)<b>G2_N018.300.a.1 - (N018.300)a.1 K_Anwendungsspezifikation {K_Karte}</b>
PAR Wenn das Attribut privateKey des privaten Schlüsselobjektes vom Typ privateRsaKey ist, dann MUSS zum Zwecke der Signaturerzeugung algorithmIdentifier aus folgender Menge gewählt werden (siehe CosT_c40): {<br>    i.   sign9796_2_DS2 (siehe (N088.000) und (N088.600)b),<br>    ii.  signPKCS1_V1_5 (siehe (N087.500) und (N088.600)d),<br>    iii. signPSS (siehe (N087.500) und (N088.600)a)<br>}. <b>[<=]</b>

REQ(ids=G2_N018.300.a.2)<b>G2_N018.300.a.2 - (N018.300)a.2 K_Anwendungsspezifikation {K_Karte}</b>
PAR Wenn das Attribut privateKey des privaten Schlüsselobjektes vom Typ privateElcKey ist, dann MUSS zum Zwecke der Signaturerzeugung algorithmIdentifier aus folgender Menge gewählt werden (siehe CosT_c40): {<br>   i. signECDSA (siehe (N087.500) und (N088.600)c)<br>}. <b>[<=]</b>

REQ(ids=A_13979)<b>A_13979 - (N018.300)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für algorithmIdentifier<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR Bevor eines der folgenden Kommandos in der Lage ist mit dem privaten Schlüsselobjekt zu arbeiten, ist es zu selektieren. Dies geschieht mittels des in (N102.900) beschriebenen Use Cases.
REQ(ids=G2_N018.400)<b>G2_N018.400 - (N018.400) K_COS</b>
PAR Wenn einem privaten Schlüsselobjekt ein algorithmIdentifier aus den in (N018.300)a.1 oder (N018.300)a.2 genannten Menge zugeordnet, dann MUSS es die folgenden Kommandos unterstützen:<br>1. PSO Compute Digital Signature (siehe (N087.500) und (N088.000)). <b>[<=]</b>

PAR Bevor eines der folgenden Kommando in der Lage ist mit dem privaten Schlüsselobjekt zu arbeiten, ist es selektieren. Dies geschieht entweder mittels des in (N102.900) beschriebenen Use Cases oder mittels eines Identifiers, der als Parameter dem zugreifenden Kommando mitgegeben wird.
REQ(ids=G2_N018.410)<b>G2_N018.410 - (N018.410) K_COS</b>
PAR Ein privates Schlüsselobjekt MUSS folgendes Kommandos unterstützen:<br>1. GENERATE ASYMMETRIC KEY PAIR    (siehe CosK_d2f). <b>[<=]</b>

PAR Bevor eines der folgenden Kommandos in der Lage ist mit dem privaten Schlüsselobjekt zu arbeiten, ist es selektieren. Dies geschieht mittels eines Identifiers, der als Parameter dem zugreifenden Kommando mitgegeben wird.
REQ(ids=G2_N018.420)<b>G2_N018.420 - (N018.420) K_COS</b>
PAR Neben den in (N017.700), (N018.000), (N018.400) und (N18.410) genannten Kommandos MUSS ein privates Schlüsselobjekt zusätzlich die folgenden administrativen Kommandos unterstützen:<br>1. ACTIVATE (siehe (N034.814)),<br>2. DEACTIVATE (siehe (N036.014)),<br>3. DELETE (siehe (N037.114)),<br>4. TERMINATE (siehe (N048.914)). <b>[<=]</b>

REQ(ids=A_13980)<b>A_13980 - (N018.422) K_TST</b>
PAR Ein privates Schlüsselobjekt KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS für private Schlüsselobjekte weitere Kommandos<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR Hinweis CosH_42f: Absichtlich ist einem privaten Schlüsselobjekt kein Attribut shareable zugeordnet (vergleiche etwa (N011.050)). Es wird erwartet, dass sich ein privates Schlüsselobjekt in einem logischen Kanal unabhängig von beliebigen Aktivitäten in anderen Kanälen nutzen lässt.
PAR -HEADING(ids=8.6.4)8.6.4 CosK_cb7 Öffentliches Schlüsselobjekt
PAR Ein öffentliches Schlüsselobjekt wird als Oberbegriff für    

LIST->
LITEM->PAR öffentliche Signaturprüfobjekte           (siehe CosK_9bb)    LITEM->PAR öffentliche Authentisierungsobjekte    (siehe CosK_17c)LITEM->PAR öffentliches Verschlüsselungsobjekte (siehe CosK_5e7)    
PAR verwendet. Für öffentliche Schlüsselobjekte gelten folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=G2_N018.500)<b>G2_N018.500 - (N018.500) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein öffentliches Schlüsselobjekt MUSS ein Attribut keyIdentifier besitzen. <b>[<=]</b>

REQ(ids=G2_N018.550)<b>G2_N018.550 - (N018.550) K_Anwendungsspezifikation {K_Karte}</b>
PAR Eine öffentliches Schlüsselobjekt MUSS genau ein Attribut vom Typ lifeCycleStatus (siehe (N007.100)a) besitzen. <b>[<=]</b>

REQ(ids=G2_N018.600)<b>G2_N018.600 - (N018.600) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein öffentliches Schlüsselobjekt MUSS genau ein Attribut publicKey gemäß CosK_4a2 besitzen. <b>[<=]</b>

REQ(ids=G2_N018.700)<b>G2_N018.700 - (N018.700) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein öffentliches Schlüsselobjekt MUSS genau ein Attribut vom Typ oid besitzen, welches angibt, für welche Zwecke es verwendbar ist. <b>[<=]</b>

REQ(ids=G2_N018.800)<b>G2_N018.800 - (N018.800) K_COS</b>
PAR Ein öffentliches Schlüsselobjekt MUSS genau ein Attribut accessRules vom Typ interfaceDependentAccessRules (siehe CosK_b03) besitzen. <b>[<=]</b>

PAR Bevor eines der folgenden Kommandos in der Lage ist mit dem öffentlichen Schlüsselobjekt zu arbeiten, ist es zu selektieren. Dies geschieht mittels eines Identifiers, der als Parameter dem zugreifenden Kommando mitgegeben wird.
REQ(ids=G2_N018.820)<b>G2_N018.820 - (N018.820) K_COS</b>
PAR Neben den in (N019.300), (N019.800) und (N019.826) genannten Kommandos MUSS ein öffentliches Schlüsselobjekt zusätzlich die folgenden administrativen Kommandos unterstützen:<br>1. ACTIVATE (siehe (N034.824)),<br>2. DEACTIVATE (siehe (N036.024)),<br>3. DELETE (siehe (N037.124)),<br>4. TERMINATE (siehe (N048.924)). <b>[<=]</b>

REQ(ids=A_13982)<b>A_13982 - (N018.822) K_TST</b>
PAR Ein öffentliches Schlüsselobjekt KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS für öffentliche Schlüsselobjekte weitere Kommandos<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR (N018.900) Diese Anforderung ist absichtlich leer.
PAR Hinweis CosH_c5d: Absichtlich ist einem öffentlichen Schlüsselobjekt kein Attribut shareable zugeordnet (vergleiche etwa (N011.050)). Es wird erwartet, dass sich ein öffentliches Schlüsselobjekt in einem logischen Kanal unabhängig von beliebigen Aktivitäten in anderen Kanälen nutzen lässt.
PAR -HEADING(ids=8.6.4.1)8.6.4.1 CosK_9bb Öffentliches Signaturprüfobjekt
PAR Ein öffentliches Signaturprüfobjekt wird zur Prüfung von Signaturen in einem CV-Zertifikat eingesetzt. Für dieses Schlüsselobjekt gelten folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=G2_N019.000)<b>G2_N019.000 - (N019.000) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein öffentliches Signaturprüfobjekt ist eine Erweiterung von einem öffentlichen Schlüsselobjekt und MUSS deshalb den Anforderungen aus CosK_cb7 genügen. <b>[<=]</b>

REQ(ids=G2_N019.100.a)<b>G2_N019.100.a - (N019.100)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Als Wert des Attributes keyIdentifier MUSS ein beliebiger Oktettstring der Länge acht Oktett verwendet werden. <b>[<=]</b>

REQ(ids=A_13983)<b>A_13983 - (N019.100)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Längen für keyIdentifier von öffentlichen Signaturprüfobjekten<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N019.110.a)<b>G2_N019.110.a - (N019.110)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein öffentliches Signaturprüfobjekt MUSS ein Attribute accessRulesPublicSignatureVerificationObject vom Typ interfaceDependentAccessRules (siehe CosK_b03) besitzen, das an Schlüsselobjekte weitergereicht wird, die mittels CV-Zertifikat importiert werden (siehe (N095.900)b.16..vii.A). <b>[<=]</b>

REQ(ids=G2_N019.110.b)<b>G2_N019.110.b - (N019.110)b K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein öffentliches Signaturprüfobjekt MUSS ein Attribute accessRulesPublicAuthenticationObject vom Typ interfaceDependentAccessRules (siehe CosK_b03) besitzen, das an Schlüsselobjekte weitergereicht wird, die mittels CV-Zertifikat importiert werden (siehe (N095.900)b.16.{vii.B, viii}). <b>[<=]</b>

PAR (N019.200)a.1 ist absichtlich leer.
REQ(ids=G2_N019.200.a.1)<b>G2_N019.200.a.1 - (N019.200)a.1 K_Anwendungsspezifikation {K_Karte}, Option_RSA_CVC</b>
PAR Ist das Attribut publicKey des öffentlichen Signaturprüfobjektes vom Typ publicRsaKey MUSS der Wert von oid Element der Menge {<br>    1. sigS_ISO9796-2Withrsa_sha256<br>} sein, siehe CosT_a91. <b>[<=]</b>

REQ(ids=G2_N019.200.a.2)<b>G2_N019.200.a.2 - (N019.200)a.2 K_Anwendungsspezifikation {K_Karte}</b>
PAR Wenn das Attribut publicKey des öffentlichen Signaturprüfobjektes vom Typ publicElcKey ist, dann MUSS der Wert von oid Element der Menge {<br>    1. ecdsa-with-SHA256,<br>    2. ecdsa-with-SHA384,<br>    3. ecdsa-with-SHA512<br>} sein (siehe CosT_a91) und zu den Domainparametern von publicElcKey passen. <b>[<=]</b>

REQ(ids=A_13984)<b>A_13984 - (N019.200)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für oid eines öffentlichen Signaturprüfobjektes<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N019.210.a)<b>G2_N019.210.a - (N019.210)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Wenn das Attribut publicKey vom Typ publicElcKey ist, dann gilt: Das öffentliche Signaturprüfobjekt MUSS ein Attribut CHAT enthalten, welches Aktionen kennzeichnet, die nach einer erfolgreichen Authentisierung mit einem öffentlichen Authentisierungsobjekt freigeschaltet werden. <b>[<=]</b>

REQ(ids=G2_N019.210.b)<b>G2_N019.210.b - (N019.210)b K_Anwendungsspezifikation {K_Karte}</b>
PAR Wenn das Attribut publicKey vom Typ publicElcKey ist, dann gilt: Das öffentliche Signaturprüfobjekt MUSS ein Attribut expirationDate vom Typ date (siehe (N008.120)) enthalten, welches angibt, ab welchem Zeitpunkt die Schlüsselverwendung endet. <b>[<=]</b>

PAR Bevor eines der folgenden Kommando in der Lage ist mit dem öffentlichen Signaturprüfobjekt zu arbeiten, ist es zu selektieren. Dies geschieht mittels des in (N103.300) beschriebenen Use Cases.
REQ(ids=G2_N019.300)<b>G2_N019.300 - (N019.300) K_COS</b>
PAR Ein öffentliches Signaturprüfobjekt MUSS zusätzlich zu den in (N018.820) genannten Kommandos die folgenden Kommandos unterstützen:<br>1. PSO Verify Certificate (siehe (N095.100) und (N095.500),<br>2. PSO Verify Digital Signature (siehe (N096.388)). <b>[<=]</b>

PAR -HEADING(ids=8.6.4.2)8.6.4.2 CosK_17c Öffentliches Authentisierungsobjekt
PAR Ein öffentliches Authentisierungsobjekt wird zur Authentisierung einer anderen technischen Komponente gegenüber dieser Komponente eingesetzt. Für dieses Schlüsselobjekt gelten folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=G2_N019.400)<b>G2_N019.400 - (N019.400) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein öffentliches Authentisierungsobjekt ist eine Erweiterung von einem öffentlichen Schlüsselobjekt und MUSS deshalb den Anforderungen aus CosK_cb7 genügen. <b>[<=]</b>

REQ(ids=G2_N019.500.a)<b>G2_N019.500.a - (N019.500)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Als Wert des Attributes keyIdentifier MUSS ein beliebiger Oktettstring der Länge zwölf verwendet werden. <b>[<=]</b>

REQ(ids=A_13985)<b>A_13985 - (N019.500)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Längen für keyIdentifier<br> 1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR (N019.600)a.1 ist absichtlich leer.
REQ(ids=G2_N019.600.a.1)<b>G2_N019.600.a.1 - (N019.600)a.1 K_Anwendungsspezifikation {K_Karte}</b>
PAR Ist das Attribut publicKey des öffentlichen Authentisierungsobjekte vom Typ publicRsaKey MUSS der Wert von oid Element der Menge {<br>    1. authS_ISO9796-2Withrsa_sha256_mutual<br>} sein, siehe CosT_a91. <b>[<=]</b>

REQ(ids=G2_N019.600.a.2)<b>G2_N019.600.a.2 - (N019.600)a.2 K_Anwendungsspezifikation {K_Karte}</b>
PAR Wenn das Attribut publicKey des öffentlichen Authentisierungsobjekte vom Typ publicElcKey ist, dann MUSS der Wert von oid Element der Menge {<br>    1. authS_gemSpec-COS-G2_ecc-with-sha256,<br>    2. authS_gemSpec-COS-G2_ecc-with-sha384,<br>    3. authS_gemSpec-COS-G2_ecc-with-sha512<br>} sein (siehe CosT_a91) und zu den Domainparametern von publicElcKey passen. <b>[<=]</b>

REQ(ids=A_13991)<b>A_13991 - (N019.600)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für oid eines öffentlichen Authentisierungsobjekte<br> 1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR (N019.700)a ist absichtlich leer.
REQ(ids=G2_N019.700.a)<b>G2_N019.700.a - (N019.700)a K_Anwendungsspezifikation {K_Karte}, Option_RSA_CVC</b>
PAR Ist das Attribut publicKey des öffentlichen Authentisierungsobjekte vom Typ publicRsaKey MUSS das öffentliche Authentisierungsobjekt ein Attribut accessRights besitzen, welches eine CHA gemäß CosK_ec2 speichert. <b>[<=]</b>

REQ(ids=G2_N019.700.b)<b>G2_N019.700.b - (N019.700)b K_Anwendungsspezifikation {K_Karte}</b>
PAR Wenn das Attribut publicKey des öffentlichen Authentisierungsobjekte vom Typ publicElcKey ist, dann MUSS das öffentliche Authentisierungsobjekt ein Attribut<br>1. accessRights besitzen, welches ein CHAT speichert und<br>2. expirationDate vom Typ date (siehe (N008.120)) enthalten, welches angibt, ab welchem Zeitpunkt die Schlüsselverwendung endet. <b>[<=]</b>

PAR Bevor eines der folgenden Kommandos in der Lage ist mit dem öffentlichen Authentisierungsobjekt zu arbeiten, ist es zu selektieren. Dies geschieht mittels des in (N101.900) beschriebenen Use Cases.
REQ(ids=G2_N019.800)<b>G2_N019.800 - (N019.800) K_COS</b>
PAR Ein öffentliches Authentisierungsobjekt MUSS zusätzlich zu den in (N018.820) genannten Kommandos die folgenden Kommandos unterstützen:<br>a. EXTERNAL AUTHENTICATE (siehe (N083.500) und (N084.400)),<br>b. GENERAL AUTHENTICATE (siehe CosK_2ed).<br>c. INTERNAL AUTHENTICATE (siehe (N086.400), (N086.900)d und (N086.902)c). <b>[<=]</b>

PAR -HEADING(ids=8.6.4.3)8.6.4.3 CosK_5e7 Öffentliches Verschlüsselungsobjekt, Option_Kryptobox
PAR Ein öffentliches Verschlüsselungsobjekt wird zum Verschlüsseln von Daten eingesetzt. Für dieses Schlüsselobjekt gelten folgende Regeln, die bei der Spezifikation einer Anwendung einzuhalten sind:
REQ(ids=G2_N019.820)<b>G2_N019.820 - (N019.820) K_Anwendungsspezifikation {K_Karte}, Option_Kryptobox</b>
PAR Ein öffentliches Verschlüsselungsobjekt ist eine Erweiterung von einem öffentlichen Schlüsselobjekt und MUSS deshalb den Anforderungen aus CosK_cb7 genügen. <b>[<=]</b>

REQ(ids=G2_N019.822.a)<b>G2_N019.822.a - (N019.822)a K_Anwendungsspezifikation {K_Karte }, Option_Kryptobox</b>
PAR Als Wert des Attributes keyIdentifier MUSS ein beliebiger Oktettstring der Länge zwölf verwendet werden. <b>[<=]</b>

REQ(ids=A_13992)<b>A_13992 - (N019.822)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Längen für keyIdentifier<br> 1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N019.824.a.1)<b>G2_N019.824.a.1 - (N019.824)a.1 K_Anwendungsspezifikation {K_Karte}, Option_Kryptobox</b>
PAR Wenn das Attribut publicKey des öffentlichen Verschlüsselungsobjektes vom Typ publicRsaKey ist, dann MUSS der Wert von oid Element der Menge {<br>    i.  id-RSAES-OAEP<br>} sein, siehe CosT_a91. <b>[<=]</b>

REQ(ids=G2_N019.824.a.2)<b>G2_N019.824.a.2 - (N019.824)a.2 K_Anwendungsspezifikation {K_Karte}, Option_Kryptobox</b>
PAR Wenn das Attribut publicKey des öffentlichen Verschlüsselungsobjektes vom Typ publicElcKey ist, dann MUSS der Wert von oid Element der Menge {<br>    i. id-ELC-shared-secret-calculation<br>} sein, siehe CosT_a91. <b>[<=]</b>

REQ(ids=A_13993)<b>A_13993 - (N019.824)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für oid eines öffentlichen Verschlüsselungsobjektes<br> 1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

PAR Bevor eines der folgenden Kommando in der Lage ist mit dem öffentlichen Signaturprüfobjekt zu arbeiten, ist es zu selektieren. Dies geschieht mittels des in (N103.850) beschriebenen Use Cases.
REQ(ids=G2_N019.826)<b>G2_N019.826 - (N019.826) K_COS, Option_Kryptobox</b>
PAR Ein öffentliches Verschlüsselungsobjekt MUSS zusätzlich zu den in (N018.820) genannten Kommandos die folgenden Kommandos unterstützen:<br> 1. PSO Encipher (siehe (N091.424), (N091.434) und (N103.850)). <b>[<=]</b>

PAR -HEADING(ids=8.7)8.7 CosK_d51 Datenobjekte (informativ)
PAR Auf Datenobjekte wird im Rahmen der [ISO/IEC 7816-4] Kommandos GET DATA und PUT DATA zugegriffen. Da diese Kommandos für diese Version der Spezifikation nicht verpflichtend sind, werden sie hier nicht weiter behandelt.
PAR -HEADING(ids=8.8)8.8 CosK_48e Security Environment (informativ)
PAR Zum Begriff "Security Environment" gemäß [ISO/IEC 7816-4#10.3.3] existiert eine große Bandbreite an Interpretationen. Deshalb wird versucht, im normativen Bereich dieses Dokumentes auf diesen problematischen Begriff möglichst zu verzichten. Aus demselben Grund wird in diesem informativen (das heißt nicht-normativen) Kapitel nur das weitgehend unstrittige Prinzip der Security Environments kurz skizziert.
PAR Security Environments eröffnen die Möglichkeit, gewisse Attribute von Objekten in Abhängigkeit von der Einsatzumgebung mit konkreten Werten zu versehen. In diesem Dokument wird davon beim Attributstyp interfaceDependentAccessRules (siehe CosK_b03) Gebrauch gemacht. Damit ergeben sich beim Design von Anwendungen Gestaltungsmöglichkeiten.
PAR Beispiel: Eine Karte wird in zwei verschiedenen Umgebungen eingesetzt und in beiden sind sowohl vertrauliche Daten (EF.Notfalldaten) als auch allgemein bekannte Daten (EF.X509_Zertifikat) auslesbar (READ BINARY).

ORDERED-LIST->
LITEM->PAR In der Umgebung_1 werden Lauschangriffe auf die physikalische Schnittstelle (siehe CosA_e09) befürchtet. Zur Abwehr derartiger Angriffe wird die Zugriffsregel so gewählt, dass sensitive Daten nur vertraulich und integer übertragbar sind (siehe (N022.600)c). Für allgemein bekannte Daten wird ein derartiger Schutz nicht verlangt.LITEM->PAR In der Umgebung_2 existieren keine Angriffe auf die physikalische Schnittstelle (siehe CosA_e09). Deshalb wird aus diversen Gründen die Zugriffsregel so gewählt, dass alle Daten ungeschützt übertragen werden.
PAR Zu jeder Einsatzumgebung existiert ein Satz Zugriffsregeln:

ORDERED-LIST->
LITEM->PAR Umgebung_1:
ORDERED-LIST->
LITEM->PAR EF.Notfalldaten      READ BINARY an einem Kiosk mit Secure MessagingLITEM->PAR EF.X509_Zertifikat  READ BINARY immer erlaubtLITEM->PAR Umgebung_2:
ORDERED-LIST->
LITEM->PAR EF.Notfalldaten      READ BINARY in einer Arztpraxis ohne VerschlüsselungLITEM->PAR EF.X509_Zertifikat  READ BINARY immer erlaubt
PAR Welcher Satz von Zugriffsregeln gilt, wird durch die Einsatzumgebung bestimmt. Eine konkrete Einsatzumgebung (ein konkretes Security Environment) wird durch den Use Case in (N099.900) ausgewählt.
PAR Auf der anderen Seite werden Security Environments verwendet, um Schlüssel und andere Parameter für kryptographische Operationen auszuwählen. Die Vorgehensweise ist hier anders als bei Passwörtern. Welches Passwort von einem Kommando aus CosK_bd8 betroffen ist, bestimmt ein Parameter dieses Kommandos.
PAR Die Vorgehensweise ist für Schlüssel eher vergleichbar mit Dateien. Welche Datei von einem Kommando betroffen ist, bestimmt das Attribut currentEF, das mittels SELECT-Kommando vor Ausführung dieses Kommandos passend einzustellen ist. Weil die dateiorientierten Kommandos lediglich in der Lage sind stets nur mit einer Datei pro Kommando zu arbeiten, ist ein einziges Attribut currentEF pro Ordner völlig ausreichend (siehe (N029.900)m).
PAR Bei einigen kryptographischen Kommandos ist es hingegen möglich, dass bei der Bearbeitung mehrere kryptographische Objekte beteiligt sind, wie etwa

LIST->
LITEM->PAR Sessionkeys für Vertraulichkeit,LITEM->PAR Sessionkeys für Authentizität,LITEM->PAR Use Case spezifischer Schlüssel, etwa PSO Compute Digital Signature.
PAR Statt nun jedem derartigen Kommando analog zu den Passwortkommandos alle Schlüsselparameter mitzuliefern, ist in [ISO/IEC 7816-4] entschieden worden, diese Parameter zuvor mittels MANAGE SECURITY ENVIRONMENT Kommando (siehe CosK_146) auszuwählen. Derartige Selektionen wirken sich im Datenmodell dieses Dokumentes auf das Attribut keyReferenceList (siehe (N029.900)c) aus.
PAR Hinweis CosH_981: Die normativen Regeln dieses Dokumentes sind so gewählt, dass es für eine performante Implementierung zulässig ist, die kanalspezifischen Attribute (siehe CosK_6b7) im RAM zu speichern. Die genannten Attribute wurden lediglich der einfacheren Darstellung wegen, wie gezeigt zugeordnet.
PAR Hinweis CosH_2ab: Die normativen Regeln dieses Dokumentes sind so gewählt, dass es für eine speicherplatzoptimale Implementierung zulässig ist, die kanalspezifischen Ordnerattribute in (N030.000) nur für currentFolder und allen seinen Vorfahren inklusive root zu speichern, anstatt für alle Ordner innerhalb des Objektsystems. Die genannten Attribute wurden lediglich der einfacheren Darstellung wegen, jedem Ordner zugeordnet.
PAR -HEADING(ids=8.9)8.9 CosK_aad Sicherheitsstatus (informativ)
PAR Zum Begriff "Sicherheitsstatus" gemäß [ISO/IEC 7816-4#9] existiert eine große Bandbereite an Interpretationen. Deshalb wird versucht auf diesen problematischen Begriff im normativen Bereich dieses Dokumentes möglichst zu verzichten. Aus demselben Grund wird in diesem informativen (das heißt nicht-normativen) Kapitel nur das weitgehend unstrittige Prinzip des Sicherheitsstatus kurz skizziert.
PAR Gemäß [ISO/IEC 7816-4] zählen zum Sicherheitsstatus

ORDERED-LIST->
LITEM->PAR Globale Sicherheitsstatus, welche durch Benutzerverifikation oder Komponentenauthentikation mit Objekten im Ordner root (siehe (N019.900)a) modifizierbar ist.LITEM->PAR Applikationsspezifischer Sicherheitsstatus, welche mit Benutzerverifikationen oder Komponentenauthentisierungen mit Objekten in beliebigen Ordnern modifizierbar ist.LITEM->PAR File-spezifischer Status, welcher in diesem Dokument unberücksichtigt bleibt.LITEM->PAR Kommando-spezifischer Status, welchem bei der Auswertung von Zugriffsregeln Rechnung getragen wird.
PAR In diesem Dokument wird bezüglich der globalen und applikationsspezifischen Status für alle Ordner ein Sicherheitsstatus angenommen und für die

ORDERED-LIST->
LITEM->PAR Benutzerverifikation durch (N029.900)i bis (N029.900)k Rechnung getragen, wobei dort auch die kleinste Anzahl der zu unterstützenden Sicherheitsstatus für Benutzerverifikation festgelegt wird.LITEM->PAR Komponentenauthentisierung durch (N029.900)e bis (N029.900)h Rechnung getragen, wobei dort auch die kleinste Anzahl der zu unterstützenden Sicherheitsstatus für Komponentenauthentisierung festgelegt wird.
PAR Hinweis CosH_517: Die normativen Regeln dieses Dokumentes sind so gewählt, dass es für eine performante Implementierung zulässig ist, die Attribute globalSecurityList, dfSpecificSecurityList, globalPasswordList und dfSpecificPasswordList im RAM zu speichern. Die genannten Attribute wurden lediglich der einfacheren Darstellung wegen wie dargestellt zugeordnet.
PAR -HEADING(ids=9)9 CosK_e16 Objektsystem (normativ)
PAR Eine Smartcard wird in diesem Dokument als sicherer Datenspeicher betrachtet, wobei die Betonung auf beiden Wörtern liegt.

LIST->
LITEM->PAR Datenspeicher: Eine Smartcard speichert beliebige Informationen ganz analog zur Festplatte eines Computers in Dateien (siehe CosK_9e0).LITEM->PAR Sicherheit: Der Zugriff auf die in Dateien gespeicherten Informationen wird durch Regeln festgelegt. Die Einhaltung der Zugriffsregeln wird durch das Betriebssystem gewährleistet. Typischerweise enthalten Regeln Zugriffsbeschränkungen dergestalt, dass erst nach erfolgreicher Benutzerverifikation oder Komponentenauthentisierung ein Zugriff gestattet ist. Darüber hinaus wird vielfach zusätzlich ein vertraulicher und authentischer Datenaustausch erzwungen.
PAR Typischerweise werden Dateien und damit Informationen hierarchisch strukturiert.
PAR Die Regeln in diesem Dokument sind so aufgebaut, dass sich ein hierarchisches System mit mindestens vier Ordnerebenen aufbauen lässt (root enthält DF2, DF2 enthält DF3, DF3 enthält DF4, DF4 enthält keinen weiteren Ordner).
PAR Private und symmetrische Schlüssel sowie Passwörter lassen sich per "backtracking" suchen. Das bedeutet, sie werden zunächst im aktuellen Verzeichnis gesucht. Wenn die Suche dort erfolglos ist, dann wird rekursiv in der nächsthöheren Ebene gesucht.
PAR Eine DF-spezifische Suche bezieht root nie mit ein.
PAR Öffentliche Schlüssel werden als zentral gespeicherte Objekte betrachtet. In der Regel gehören solche Schlüssel einer externen Komponente und werden mittels eines Zertifikates importiert (siehe CosK_ca7).
PAR -HEADING(ids=9.1)9.1 CosK_dae Aufbau und Strukturtiefe
PAR Dieses Kapitel legt die hierarchische Struktur fest, so wie sie an der Schnittstelle gesehen wird. Wie die Information und die Struktur kartenintern gespeichert werden, ist nicht Gegenstand dieses Dokumentes. Zudem wird hier nicht der sonst übliche Terminus "Filesystem" verwendet, sondern "Objektsystem", weil neben Files auch andere Objekttypen, wie Passwörter und Schlüssel, als eigenständige Artefakte betrachtet werden.
PAR Bei der Spezifikation von Anwendungen sind folgende Regeln einzuhalten:
REQ(ids=A_13996)<b>A_13996 - (N019.900) K_COS</b>
PAR Das COS MUSS ein hierarchisches Objektsystem mit mehreren Ebenen unterstützen. <b>[<=]</b>

REQ(ids=G2_N019.900.a)<b>G2_N019.900.a - (N019.900)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Das Objektsystem MUSS ein Attribut root mit Eigenschaften gemäß (N019.910) und (N019.920) besitzen. <b>[<=]</b>

REQ(ids=A_13997)<b>A_13997 - (N019.900)b K_Anwendungsspezifikation {K_Karte}</b>
PAR Das Objektsystem MUSS die Attribute coldAnswerToReset und warmAnswerToReset vom Typ Oktettstring besitzen für die in (N024.100) Anforderungen genannt werden. <b>[<=]</b>

REQ(ids=G2_N019.900.b.1)<b>G2_N019.900.b.1 - (N019.900)b.1 K_COS</b>
PAR Das COS MUSS das Attribut coldAnswerToReset im Rahmen eines Cold Reset gemäß (N023.920)b versenden. <b>[<=]</b>

REQ(ids=G2_N019.900.b.2)<b>G2_N019.900.b.2 - (N019.900)b.2 K_COS</b>
PAR Das COS MUSS das Attribut warmAnswerToReset im Rahmen eines Warm Reset gemäß (N023.920)c versenden. <b>[<=]</b>

REQ(ids=A_13998)<b>A_13998 - (N019.900)b.3 K_Anwendungsspezifikation {K_Karte}</b>
PAR Es MÜSSEN identische Anforderungen an die Attribute coldAnswerToReset und warmAnswerToReset gestellt werden. <b>[<=]</b>

REQ(ids=A_13999)<b>A_13999 - (N019.900)b.4 K_TST</b>
PAR Das COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS für die Attribute coldAnswerToReset und warmAnswerToReset unterschiedliche Werte verwendet. <b>[<=]</b>

REQ(ids=G2_N019.900.c)<b>G2_N019.900.c - (N019.900)c K_Anwendungsspezifikation {K_Karte}</b>
PAR Das Objektsystem MUSS ein Attribut iccsn8 vom Typ Oktettstring der Länge acht Oktett und beliebigem Inhalt besitzen. <b>[<=]</b>

REQ(ids=A_14000)<b>A_14000 - (N019.900)d K_COS</b>
PAR Das Objektsystem MUSS ein Attribut applicationPublicKeyList mit folgenden Eigenschaften unterstützen:<br>1. In applicationPublicKeyList sind beliebig viele Listenelemente möglich.<br>2. Als Listenelemente wird der Objekttyp "Öffentliches Schlüsselobjekt" (siehe CosK_cb7) unterstützt in Verbindung mit einer Referenz zu einem Ordner, dem dieses Schlüsselobjekt zugeordnet ist (siehe (N021.600) und (N095.900)d).<br>3. Alle Elemente der Liste applicationPublicKeyList werden persistent gespeichert.<br>4. Elemente der Liste applicationPublicKeyList werden<br>    i.  entweder zentral an einer Stelle,<br>    ii. oder dezentral, etwa über mehrere Ordner verteilt<br>    gespeichert. <b>[<=]</b>

REQ(ids=A_14001)<b>A_14001 - (N019.900)e K_COS</b>
PAR Das Objektsystem MUSS ein Attribut persistentCache unterstützen. <b>[<=]</b>

REQ(ids=G2_N019.900.e.1)<b>G2_N019.900.e.1 - (N019.900)e.1 K_COS</b>
PAR Das COS MUSS eine beliebige Anzahl Listenelemente in persistentCache unterstützen. <b>[<=]</b>

REQ(ids=G2_N019.900.e.2)<b>G2_N019.900.e.2 - (N019.900)e.2 K_Anwendungsspezifikation {K_Karte}</b>
PAR Die Anwendungsspezifikation SOLL MUSS eine Anzahl an Listenelementen für persistentCache vorgeschreiben, die mindestens zu unterstützen ist. <b>[<=]</b>

REQ(ids=G2_N019.900.e.3)<b>G2_N019.900.e.3 - (N019.900)e.3 K_COS</b>
PAR Das COS MUSS in persistentCache als Listenelemente die Objekttypen "Öffentliches Signaturprüfobjekt" (siehe CosK_9bb) und "Öffentliches Authentisierungsobjekt" (siehe CosK_17c) unterstützen in Verbindung mit einer Referenz zu einem Ordner, dem dieses Schlüsselobjekt zugeordnet ist (siehe (N021.600) und (N095.900)d). <b>[<=]</b>

REQ(ids=G2_N019.900.e.4)<b>G2_N019.900.e.4 - (N019.900)e.4 K_COS</b>
PAR Das COS MUSS alle Listenelemente in persistentCache persistent speichern. <b>[<=]</b>

REQ(ids=A_14002)<b>A_14002 - (N019.900)e.5 K_TST</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass das COS Elemente der List persistentCache<br>i.  zentral an einer Stelle,<br>ii. oder dezentral über mehrere Ordner verteilt<br>speichert. <b>[<=]</b>

REQ(ids=G2_N019.900.f)<b>G2_N019.900.f - (N019.900)f K_Anwendungsspezifikation {K_Karte}</b>
PAR Die Anwendungsspezifikation SOLL MUSS eine Anzahl an Listenelementen für persistentPublicKeyList vorgeschreiben, die mindestens zu unterstützten ist. <b>[<=]</b>

REQ(ids=A_14003)<b>A_14003 - (N019.900)g K_COS</b>
PAR Das Objektsystem MUSS ein Attribut volatileCache vom Typ Liste unterstützen. <b>[<=]</b>

REQ(ids=G2_N019.900.g.1.i)<b>G2_N019.900.g.1.i - (N019.900)g.1 K_TST</b>
PAR Das COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS Listenlängen mit dem Wert null, eins oder größer unterstützt. <b>[<=]</b>

REQ(ids=G2_N019.900.g.2)<b>G2_N019.900.g.2 - (N019.900)g.2 K_COS</b>
PAR Das COS MUSS in volatileCache als Listenelemente die Objekttypen "Öffentliches Signaturprüfobjekt" (siehe CosK_9bb) und "Öffentliches Authentisierungsobjekt" (siehe CosK_17c) unterstützen in Verbindung mit einer Referenz zu einem Ordner, dem dieses Schlüsselobjekt zugeordnet ist (siehe (N021.600) und (N095.900)d). <b>[<=]</b>

REQ(ids=A_14004)<b>A_14004 - (N019.900)g.3 K_COS</b>
PAR Das COS DARF Elemente der Liste volatileCache NICHT persistent speichern. <b>[<=]</b>

REQ(ids=A_14005)<b>A_14005 - (N019.900)g.4 K_COS</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass das COS Elemente der List volatileCache<br>i.  zentral an einer Stelle,<br>ii. oder dezentral über mehrere Ordner verteilt<br>speichert. <b>[<=]</b>

REQ(ids=G2_N019.900.h)<b>G2_N019.900.h - (N019.900)h K_COS, Option_logische_Kanäle</b>
PAR Das COS MUSS alle Elemente der Liste allPublicKeyList in allen logischen Kanälen shareable zur Verfügung stellen. <b>[<=]</b>

REQ(ids=G2_N019.900.i)<b>G2_N019.900.i - (N019.900)i K_Anwendungsspezifikation {K_Karte}</b>
PAR Das Objektsystem MUSS genau ein Attribut vom Typ lifeCycleStatus (siehe (N007.100)a) besitzen. <b>[<=]</b>

REQ(ids=G2_N019.900.j)<b>G2_N019.900.j - (N019.900)j K_Anwendungsspezifikation {K_Karte}</b>
PAR Das Objektsystem MUSS genau ein Attribut pointInTime vom Typ date gemäß (N008.120) besitzen. <b>[<=]</b>

PAR Hinweis CosH_c83: Der zu unterstützende Wertebereich von pointInTime ergibt sich implizit aus dem Attribut CED, welches in CV-Zertifikaten enthalten ist, siehe [gemSpec_PKI#6.7.2.6].
REQ(ids=A_14006)<b>A_14006 - (N019.910) K_Anwendungsspezifikation {K_Karte}</b>
PAR Für das Attribut root des Objektsystems MUSS gelten:<br>a. Die Anwendungsspezifikation lässt für root die Wahl zwischen den Typen<br>     1. Applikation (siehe CosK_ad6) und<br>     2. Application Dedicated File (siehe CosK_356) zu.<br>b. Die Anwendungsspezifikation fordert als Zugriffbedingung für die Zugriffsart<br>     DELETE (siehe (N037.100)) den Wert NEVER (siehe (N022.100)). <b>[<=]</b>

REQ(ids=G2_N019.920.a)<b>G2_N019.920.a - (N019.920)a K_COS</b>
PAR Das COS MUSS für root den Typ Applikation (siehe CosK_ad6) unterstützen. <b>[<=]</b>

REQ(ids=A_14007)<b>A_14007 - (N019.920)b K_TST</b>
PAR Das COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS für root weitere Ordnertypen<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=A_14008)<b>A_14008 - (N019.920)c K_TST</b>
PAR Das COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS für root weitere Zugriffsbedingungen für die Zugriffsart DELETE<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=A_14009)<b>A_14009 - (N019.930) K_Anwendungsspezifikation {K_Karte}</b>
PAR Die Werte aller Attribute applicationIdentifier MÜSSEN paarweise verschieden sein. Im Objektsystem DARF es KEINE zwei verschiedenen Ordner geben, deren Attribut applicationIdentifier identisch ist.  <b>[<=]</b>

REQ(ids=G2_N020.000)<b>G2_N020.000 - (N020.000) K_COS</b>
PAR Der Ordner root wird der Ebene_0 zugeordnet. Ebene_0 wird als "höchste Ebene im Objektsystem" bezeichnet. <b>[<=]</b>

REQ(ids=G2_N020.100)<b>G2_N020.100 - (N020.100) K_COS</b>
PAR Wenn ein Ordner der Ebene_i zugeordnet ist, dann werden alle Elemente der Liste children dieses Ordners der Ebene_(i + 1) zugeordnet. Ebene_i ist die nächsthöhere Ebene zu Ebene_(i + 1). Ebene_(i + 1) ist die nächsttiefere Ebene zu Ebene_i. <b>[<=]</b>

PAR (N020.200) Diese Anforderung ist absichtlich leer.
REQ(ids=G2_N020.300)<b>G2_N020.300 - (N020.300) K_COS</b>
PAR Ordner, die der Ebene_0 (root), Ebene_1 oder Ebene_2 zugeordnet sind, MÜSSEN im Attribut children als Listenelement die Objekttypen Applikation (siehe CosK_ad6) und Dedicated File (siehe CosK_5a3) und Application Dedicated File (siehe CosK_356) zulassen. <b>[<=]</b>

REQ(ids=A_14010)<b>A_14010 - (N020.390) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ordner, die der Ebene_3 zugeordnet sind DÜRFEN KEIN Objekt des Typs Ordner enthalten. <b>[<=]</b>

REQ(ids=A_14011)<b>A_14011 - (N020.400) K_TST</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass das COS in Ordnern, die der Ebene_3 zugeordnet sind, im Attribut children Ordner<br>a. zulässt oder<br>b. ablehnt. <b>[<=]</b>

PAR Dem Objektsystem sind weitere, kanalspezifische Attribute zugeordnet, die einem flüchtig (im RAM) gespeicherten Kanalkontext (siehe (N029.900)) zugerechnet werden. Sie werden im Rahmen einer Selektion des Ordners verändert.
PAR Gemäß CosK_6aa (File), CosK_d13 (Reguläres-Passwortobjekt), CosK_7f0 (Multireferenz-Passwortobjekt) und CosK_afb (Schlüsselobjekt) besitzen die dort genannten Objekttypen ein Attribut lifeCycleStatus. Gemäß (N020.000) und (N020.100) lassen sich die Instanzen aller Objekttypen Ebenen zuordnen, wobei Rekords hier als eine nächsttiefere Ebene zu der Datei aufgefasst werden, in der sie enthalten sind. Es wird nun unterschieden zwischen dem physikalischen und dem logischen Wert des lifeCycleStatus:
REQ(ids=A_14012)<b>A_14012 - (N020.500) K_COS</b>
PAR Als physikalischer Wert des lifeCycleStatus MUSS der Wert betrachtet werden, den das entsprechende Attribut eines Objektes besitzt. <b>[<=]</b>

REQ(ids=A_14013)<b>A_14013 - (N020.600) K_COS</b>
PAR Als logischer Wert des lifeCycleStatus MUSS der Wert betrachtet werden, der sich aus der Betrachtung des physikalischen Wertes des lifeCycleStatus eines Objektes sowie der logischen Werte des lifeCycleStatus in allen höheren Ebenen ergibt. Dabei gilt folgende Rangordnung und Rekursion: <b>[<=]</b>

REQ(ids=G2_N020.600.a)<b>G2_N020.600.a - (N020.600)a K_COS</b>
PAR "Operational state (active)" < "Operational state (deactivated)" < "Termination state" <b>[<=]</b>

REQ(ids=G2_N020.600.b)<b>G2_N020.600.b - (N020.600)b K_COS</b>
PAR Für das Objekt root MUSS als logischer Wert der nächsthöheren Ebene der physikalische Wert des lifeCycleStatus des Objektsystems verwendet werden (siehe (N019.900)i) <b>[<=]</b>

REQ(ids=G2_N020.600.c)<b>G2_N020.600.c - (N020.600)c K_COS</b>
PAR Für ein Objekt mit einem Attribut lifeCycleStatus MUSS gelten: Wenn

ORDERED-LIST->
LITEM->PAR der logische Wert des lifeCycleStatus der nächsthöheren Ebene größer ist als der physikalische Wert des lifeCycleStatus des Objektes, dann ist der logische Wert des lifeCycleStatus des Objektes gleich dem logischen Wert des lifeCycleStatus der nächsthöheren Ebene.LITEM->PAR sonst ist der der logische Wert des lifeCycleStatus des Objektes gleich seinem physikalischen.
PAR <b>[<=]</b>

REQ(ids=G2_N020.600.d)<b>G2_N020.600.d - (N020.600)d K_COS</b>
PAR Für ein Objekt, welches selbst kein Attribut lifeCycleStatus besitzt, MUSS der logische Wert von lifeCycleStatus identisch zum logischen Wert der nächsthöheren Ebene sein. <b>[<=]</b>

PAR -HEADING(ids=9.2)9.2 Objektsuche
PAR Gemäß CosK_dae ist an der Schnittstelle zur Karte ein hierarchisches Objektsystem sichtbar. Dieses Kapitel legt fest, wie ein Objekt gesucht und nach welchen Regeln es gefunden wird.
PAR -HEADING(ids=9.2.1)9.2.1 Filesuche
PAR Eine Suche nach Files (das heißt Ordnern und Dateien) findet lediglich im Rahmen einer Selektion statt. Deshalb ist die explizite Suche in CosK_119 beschrieben. Daneben unterstützen die Kommandos, welche sich auf Dateien beziehen, Varianten mit Parameter shortFileIdentifier. Bei den jeweiligen Kommandos ist beschrieben, wie in diesem Fall eine Datei gesucht wird.
PAR -HEADING(ids=9.2.2)9.2.2 Suche nach einem Passwortobjekt
PAR Passwörter werden im Rahmen der Kommandos in CosK_bd8 verwendet, aber auch bei der Auswertung von Zugriffsregeln (siehe (N022.200)). Bei der Passwortsuche handelt es sich um eine karteninterne Funktionalität, bei der viele Implementierungsdetails eine Rolle spielen. An der Schnittstelle "Interpreter" (siehe CosA_e09) wird das im Folgenden festgelegte Verhalten deutlich:
REQ(ids=G2_N020.700)<b>G2_N020.700 - (N020.700) K_COS</b>
PAR (ids=Tabelle-63-,-CosT_65c)Tabelle 63 , CosT_65c: Definition der Funktion SearchPwd(...)

TABLE(rows=5,cols=70+138+504)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR passwordReference TD(0,2/1/1)->PAR Gemäß (N072.800)
TR-> TD(1,1/1/1)->PAR startFolder TD(1,2/1/1)->PAR Ordner, bei dem die Suche nach einem Passwortobjekt startet
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR password TD(2,2/1/1)->PAR Enthält das gefundene Passwortobjekt
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR pwdNotFound TD(3,2/1/1)->PAR Zu den gegebenen Inputparametern wurde kein passendes Passwortobjekt gefunden.
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR password = SearchPwd( startFolder, passwordReference )
PAR Das COS MUSS den Inputparameter
PAR passwordReference
PAR gemäß (N072.800) wie folgt in seine Bestandteile zerlegen:
PAR a.
PAR identifier
PAR    =
PAR passwordReference
PAR   mod   128
PAR b.
PAR location
PAR     =
PAR passwordReference
PAR –
PAR identifier
PAR <b>[<=]</b>

REQ(ids=A_14131)<b>A_14131 - (N020.800) K_COS</b>
PAR Wenn location den Wert '00' = 0 besitzt und damit ein globales Passwort adressiert, dann MUSS das COS im Wurzelverzeichnis root des Objektsystems nach einem Passwort suchen, dessen Attribut pwdIdentifier identisch zu identifier ist. <b>[<=]</b>

REQ(ids=G2_N020.800.a)<b>G2_N020.800.a - (N020.800)a K_COS</b>
PAR Wenn ein solches Passwortobjekt existiert,<br>dann MUSS das COS als Outputparameter password verwenden. <b>[<=]</b>

REQ(ids=G2_N020.800.b)<b>G2_N020.800.b - (N020.800)b K_COS</b>
PAR Wenn ein solches Passwortobjekt nicht existiert,<br>dann MUSS das COS den Algorithmus mit pwdNotFound abbrechen. <b>[<=]</b>

REQ(ids=G2_N020.900)<b>G2_N020.900 - (N020.900) K_COS</b>
PAR Wenn location den Wert '80' = 128 besitzt und damit ein DF-spezifisches Passwort adressiert,<br>dann MUSS das COS die "lokale Variable" folder auf startFolder setzen. <b>[<=]</b>

REQ(ids=G2_N021.000.a)<b>G2_N021.000.a - (N021.000)a K_COS</b>
PAR Wenn folder auf das Wurzelverzeichnis root zeigt,<br>dann MUSS das COS den Algorithmus mit pwdNotFound abbrechen. <b>[<=]</b>

REQ(ids=A_14132)<b>A_14132 - (N021.000)b K_COS</b>
PAR Wenn folder nicht auf das Wurzelverzeichnis root zeigt,<br>dann MUSS das COS in folder nach einem Passwort suchen, dessen Attribut pwdIdentifier identisch zu identifier ist. <b>[<=]</b>

REQ(ids=G2_N021.000.b.1)<b>G2_N021.000.b.1 - (N021.000)b.1 K_COS</b>
PAR Wenn ein solches Passwortobjekt existiert,<br>dann MUSS das COS es als Outputparameter password verwenden. <b>[<=]</b>

REQ(ids=G2_N021.000.b.2)<b>G2_N021.000.b.2 - (N021.000)b.2 K_COS</b>
PAR Wenn ein solches Passwortobjekt nicht existiert,<br>dann MUSS das COS folder auf den nächsthöheren Ordner setzen und den Algorithmus mit Schritt (N021.000)a fortsetzen. <b>[<=]</b>

PAR -HEADING(ids=9.2.3)9.2.3 Suche nach einem Schlüsselobjekt
PAR Die hier beschriebene Funktion ist eine Generalisierung der anderen Schlüsselsuchfunktionen und stellt damit den generalisierten Einsprungspunkt für die Schlüsselsuche dar, so wie sie an verschiedenen Stellen in diesem Dokument verwendet wird.
PAR (ids=Tabelle-64,-CosT_a08)Tabelle 64, CosT_a08: Definition der Funktion SearchKey(...)

TABLE(rows=7,cols=68+104+547)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR startFolder TD(0,2/1/1)->PAR Ordner, aus dem heraus die Suche startet
TR-> TD(1,1/1/1)->PAR identifier TD(1,2/1/1)->PAR Für diesen Parameter sind die folgende Wertebereiche möglich:<br>a) ein    Oktett keyReference gemäß (N099.600),<br>b) acht  Oktett keyIdentifier  gemäß (N019.100)a,<br>c) zwölf Oktett keyIdentifier  gemäß (N019.500)a,<br>d) zwölf Oktett keyIdentifier  gemäß (N019.822)a,<br>e) herstellerspezifisch, zur Auswahl von Sessionkeys
TR-> TD(2,1/1/1)->PAR algID TD(2,2/1/1)->PAR Kryptographisches Verfahren, welches der zu suchende Schlüssel unterstützt, oder "Wildcard"
TR-> TD(3,0/1/1)->PAR Output: TD(3,1/1/1)->PAR key TD(3,2/1/1)->PAR Enthält das gefundene Schlüsselobjekt
TR-> TD(4,0/2/1)->PAR Errors: TD(4,1/1/1)->PAR keyNotFound TD(4,2/1/1)->PAR Zu den gegebenen Inputparametern wurde kein passendes Schlüsselobjekt gefunden.
TR-> TD(5,1/1/1)->PAR notSupported TD(5,2/1/1)->PAR Der Schlüssel unterstützt den von algID geforderten Algorithmus nicht.
TR-> TD(6,0/1/1)->PAR Notation: TD(6,1/1/1)-> TD(6,2/1/1)->PAR key = SearchKey( startFolder, identifier, algID )
REQ(ids=A_14133)<b>A_14133 - (N021.050)a K_COS</b>
PAR Enthält der Parameter identifier eine Schlüsselreferenz gemäß (N099.600) (d. h. symmetrisches Authentisierungsobjekt, symmetrisches Kartenverbindungsobjekt oder privates Schlüsselobjekt), dann MUSS das COS folgende Funktion nutzen:<br>      key = SearchSecretKey( startFolder, identifier, algID ) <b>[<=]</b>

REQ(ids=A_14134)<b>A_14134 - (N021.500)b K_COS</b>
PAR Enthält der Parameter identifier eine Schlüsselreferenz gemäß (N019.100)a oder (N019.500)a oder (N019.822)a (d. h. ein öffentliches Schlüsselobjekt), dann MUSS das COS folgende Funktion nutzen:<br>      key = SearchPublicKey( startFolder, identifier, algID ) <b>[<=]</b>

REQ(ids=G2_N021.050.c)<b>G2_N021.050.c - (N021.050)c K_COS</b>
PAR Enthält der Parameter identifier eine Schlüsselreferenz gemäß eines herstellerspezifischen Wertebereiches, dann gilt: Es handelt sich um Sessionkeys, die im Rahmen von PSO-Kommandos zur Unterstützung eines Trusted Channels eingesetzt werden. Solange der Sicherheitszustand, der im Rahmen der Sessionkey Aushandlung gesetzt wurde, noch besteht (vergleiche (N030.700)), existieren diese Sessionkeys. Solange die Sessionkeys existieren, MUSS das COS sie erfolgreich finden. <b>[<=]</b>

PAR -HEADING(ids=9.2.3.1)9.2.3.1 Suche nach einem geheimen Schlüsselobjekt
PAR In diesem Kapitel werden symmetrische Authentisierungsobjekte gemäß CosK_5fa, symmetrische Kartenverbindungsobjekte gemäß CosK_24a und private Schlüsselobjekte gemäß CosK_ab8 gemeinsam behandelt, da nach ihnen auf gleiche Art und Weise gesucht wird. Sie werden im Rahmen diverser kryptographischer Operationen verwendet. Symmetrische Authentisierungsobjekte und symmetrische Kartenverbindungsobjekte werden zudem auch bei der Auswertung von Zugriffsregeln (siehe (N022.300)) verwendet. Bei dieser Art der Schlüsselsuche handelt es sich um eine karteninterne Funktionalität, bei der viele Implementierungsdetails eine Rolle spielen. An der Schnittstelle "Interpreter" (siehe CosA_e09) wird das im Folgenden festgelegte Verhalten sichtbar:
PAR (ids=Tabelle-65,-CosT_d11)Tabelle 65, CosT_d11: Definition der Funktion SearchSecretkey(...)

TABLE(rows=7,cols=72+103+547)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR keyReference TD(0,2/1/1)->PAR Gemäß (N099.600)
TR-> TD(1,1/1/1)->PAR algID TD(1,2/1/1)->PAR Kryptographisches Verfahren, welches der zu suchende Schlüssel unterstützt, oder "Wildcard"
TR-> TD(2,1/1/1)->PAR startFolder TD(2,2/1/1)->PAR Ordner, bei dem die Suche nach einem Schlüsselobjekt startet
TR-> TD(3,0/1/1)->PAR Output: TD(3,1/1/1)->PAR key TD(3,2/1/1)->PAR Enthält das gefundene Schlüsselobjekt
TR-> TD(4,0/2/1)->PAR Errors: TD(4,1/1/1)->PAR keyNotFound TD(4,2/1/1)->PAR Zu den gegebenen Inputparametern wurde kein passendes Schlüsselobjekt gefunden.
TR-> TD(5,1/1/1)->PAR notSupported TD(5,2/1/1)->PAR Der Schlüssel unterstützt den von algID geforderten Algorithmus nicht.
TR-> TD(6,0/1/1)->PAR Notation: TD(6,1/1/1)-> TD(6,2/1/1)->PAR key = SearchSecretKey( startFolder, keyReference, algID )
REQ(ids=G2_N021.100)<b>G2_N021.100 - (N021.100) K_COS</b>
PAR Das COS MUSS den Inputparameter keyReference gemäß (N099.600) wie folgt in seine Bestandteile zerlegen:<br>a. identifier  = keyReference   mod   128<br>b. location   = keyReference – identifier <b>[<=]</b>

REQ(ids=A_14136)<b>A_14136 - (N021.200) K_COS</b>
PAR Wenn location den Wert '00' = 0 besitzt und damit ein globales Schlüsselobjekt adressiert, dann MUSS das COS im Wurzelverzeichnis root des Objektsystems nach einem Schlüsselobjekt suchen, dessen Attribut keyIdentifier identisch zu identifier ist. <b>[<=]</b>

REQ(ids=G2_N021.200.a)<b>G2_N021.200.a - (N021.200)a K_COS</b>
PAR Wenn ein solches Schlüsselobjekt existiert,<br>dann MUSS das COS als Outputparameter key verwenden. <b>[<=]</b>

REQ(ids=G2_N021.200.b)<b>G2_N021.200.b - (N021.200)b K_COS</b>
PAR Wenn ein solches Schlüsselobjektnicht existiert,<br>dann MUSS das COS den Algorithmus mit keyNotFound abbrechen. <b>[<=]</b>

REQ(ids=G2_N021.300)<b>G2_N021.300 - (N021.300) K_COS</b>
PAR Wenn location den Wert '80' = 128 besitzt und damit ein DF-spezifisches Schlüsselobjekt adressiert,<br>dann MUSS das COS die "lokale Variable" folder auf startFolder setzen. <b>[<=]</b>

REQ(ids=G2_N021.400.a)<b>G2_N021.400.a - (N021.400)a K_COS</b>
PAR Wenn folder auf das Wurzelverzeichnis root zeigt,<br>dann MUSS das COS den Algorithmus mit keyNotFound abbrechen. <b>[<=]</b>

REQ(ids=A_14137)<b>A_14137 - (N021.400)b K_COS</b>
PAR Das COS MUSS in folder nach einem Schlüsselobjekt suchen, dessen Attribut keyIdentifier identisch zu identifier ist. <b>[<=]</b>

REQ(ids=G2_N021.400.b.1)<b>G2_N021.400.b.1 - (N021.400)b.1 K_COS</b>
PAR Wenn ein solches Schlüsselobjekt existiert,<br>dann MUSS das COS es als Outputparameter key verwenden. <b>[<=]</b>

REQ(ids=G2_N021.400.b.2)<b>G2_N021.400.b.2 - (N021.400)b.2 K_COS</b>
PAR Wenn ein solches Schlüsselobjekt nicht existiert,<br>dann MUSS das COS folder auf den nächsthöheren Ordner setzen und den Algorithmus mit Schritt (N021.400)a fortsetzen. <b>[<=]</b>

REQ(ids=G2_N021.500.a)<b>G2_N021.500.a - (N021.500)a K_COS</b>
PAR Wenn der Outputparameter key ein symmetrischer Schlüssel ist und dessen Attribut algorithmIdentifier nicht zum Parameter algID passt, dann MUSS das COS den Algorithmus mit notSupported abbrechen. <b>[<=]</b>

REQ(ids=A_14138)<b>A_14138 - (N021.500)b K_COS</b>
PAR Wenn der Outputparameter key ein privater Schlüssel ist, dann MUSS das COS in den Elementen von listAlgorithmIdentifier nach einem Element suchen, dessen seIdentifier (siehe (N017.400)b.i) identisch zum Attribut seIdentifier (siehe (N030.000)a) des Ordners ist, in welchem key als child enthalten ist. <b>[<=]</b>

REQ(ids=G2_N021.500.b.1)<b>G2_N021.500.b.1 - (N021.500)b.1 K_COS</b>
PAR Wenn ein solches Element nicht existiert,<br>dann MUSS das COS den Algorithmus mit notSupported abbrechen. <b>[<=]</b>

REQ(ids=G2_N021.500.b.2)<b>G2_N021.500.b.2 - (N021.500)b.2 K_COS</b>
PAR Wenn ein solches Element existiert, aber die Menge setAlgorithmIdentifier (siehe (N017.400)b.2) das Element algID nicht enthält,<br>dann MUSS das COS den Algorithmus mit notSupported abbrechen. <b>[<=]</b>

PAR -HEADING(ids=9.2.3.2)9.2.3.2 Suche nach einem öffentlichen Schlüsselobjekt
PAR Öffentliche Schlüsselobjekte werden zum Importieren von Schlüsseln mittels Zertifikaten und im Rahmen von Authentisierungsprotokollen oder Verschlüsselung verwendet. Die Unterklasse "Öffentliche Authentisierungsobjekte" wird zudem auch bei der Auswertung von Zugriffsregeln (siehe (N022.400) und (N022.500)) verwendet. Bei dieser Art der Schlüsselsuche handelt es sich um eine karteninterne Funktionalität, bei der viele Implementierungsdetails eine Rolle spielen. An der Schnittstelle "Interpreter" (siehe CosA_e09) wird das im Folgenden festgelegte Verhalten sichtbar:
PAR (ids=Tabelle-66,-CosT_995)Tabelle 66, CosT_995: Definition der Funktion SearchPublicKey(...)

TABLE(rows=7,cols=81+115+499)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR identifier TD(0,2/1/1)->PAR Gemäß (N018.500), (N019.100)a, (N019.500)a, (N019.822)a
TR-> TD(1,1/1/1)->PAR algID TD(1,2/1/1)->PAR Kryptographisches Verfahren, welches der zu suchende Schlüssel unterstützt
TR-> TD(2,1/1/1)->PAR startFolder TD(2,2/1/1)->PAR Ordner, aus dem heraus die Suche startet
TR-> TD(3,0/1/1)->PAR Output: TD(3,1/1/1)->PAR key TD(3,2/1/1)->PAR Enthält das gefundene Schlüsselobjekt
TR-> TD(4,0/2/1)->PAR Errors: TD(4,1/1/1)->PAR keyNotFound TD(4,2/1/1)->PAR Zu den gegebenen Inputparametern wurde kein passendes Schlüsselobjekt gefunden.
TR-> TD(5,1/1/1)->PAR notSupported TD(5,2/1/1)->PAR Der Schlüssel unterstützt den von algID geforderten Algorithmus nicht.
TR-> TD(6,0/1/1)->PAR Notation TD(6,1/1/1)-> TD(6,2/1/1)->PAR key = SearchPublicKey( startFolder, identifier, algID )
PAR Im Rahmen der Suche nach öffentlichen Schlüsselobjekten wird folgender Algorithmus durchgeführt:
REQ(ids=A_14140)<b>A_14140 - (N021.600) K_COS</b>
PAR Das COS MUSS die "lokale Variable" folder wird auf startFolder setzen. <b>[<=]</b>

REQ(ids=G2_N021.600.a)<b>G2_N021.600.a - (N021.600)a K_COS</b>
PAR Das COS MUSS in allPublicKeyList nach einem Schlüsselobjekt suchen,<br>1. dessen Attribut keyIdentifier identisch zu identifier ist und<br>2. das dem Ordner folder zugeordnet ist. <b>[<=]</b>

REQ(ids=G2_N021.600.b.1)<b>G2_N021.600.b.1 - (N021.600)b.1 K_COS</b>
PAR Wenn ein solches Schlüsselobjekt existiert,<br>dann MUSS das COS es als Outputparameter key verwenden. <b>[<=]</b>

REQ(ids=G2_N021.600.b.2.i)<b>G2_N021.600.b.2.i - (N021.600)b.2.i K_COS</b>
PAR Wenn ein solches Schlüsselobjekt nicht existiert und folder ist gleich root,<br>dann MUSS das COS den Algorithmus mit keyNotFound abbrechen. <b>[<=]</b>

REQ(ids=G2_N021.600.b.2.ii)<b>G2_N021.600.b.2.ii - (N021.600)b.2.ii K_COS</b>
PAR Wenn ein solches Schlüsselobjekt nicht existiert und folder ist ungleich root,<br>dann MUSS das COS folder auf den nächsthöheren Ordner setzen und der Algorithmus mit Schritt (N021.600)a fortsetzen. <b>[<=]</b>

REQ(ids=G2_N021.605)<b>G2_N021.605 - (N021.605) K_COS</b>
PAR Wenn das Attribut oid des Outputparameters key nicht äquivalent zur vorgegebenen algID ist (siehe (N021.610)), genau dann MUSS das COS den Algorithmus mit notSupported abbrechen. <b>[<=]</b>

PAR (N021.610)a ist absichtlich leer.<br>(N021.610)b ist absichtlich leer.
REQ(ids=G2_N021.610.a)<b>G2_N021.610.a - (N021.610)a K_COS</b>
PAR Das COS MUSS oid = sigS_ISO9796-2Withrsa_sha256 (siehe CosT_a91) als äquivalent zum algID = verifyCertificate (siehe CosT_c40) betrachten. <b>[<=]</b>

REQ(ids=G2_N021.610.b)<b>G2_N021.610.b - (N021.610)b K_COS</b>
PAR Das COS MUSS oid = authS_ISO9796-2Withrsa_sha256_mutual (siehe CosT_a91) als äquivalent zum algID aus der folgenden Menge betrachten (siehe CosT_7a2): {rsaRoleCheck, rsaSessionkey4SM, rsaSessionkey4TC}. <b>[<=]</b>

REQ(ids=G2_N021.610.c)<b>G2_N021.610.c - (N021.610)c K_COS</b>
PAR Das COS MUSS einen oid aus der Menge {ecdsa-with-SHA256, ecdsa-with-SHA384, ecdsa-with-SHA512} (siehe CosT_a91) als äquivalent zum algID = verifyCertificate (siehe CosT_c40) betrachten. <b>[<=]</b>

REQ(ids=G2_N021.610.d)<b>G2_N021.610.d - (N021.610)d K_COS</b>
PAR Das COS MUSS einen oid aus der Menge {authS_gemSpec-COS-G2_ecc-with-sha256, authS_gemSpec-COS-G2_ecc-with-sha384, authS_gemSpec-COS-G2_ecc-with-sha512} (siehe CosT_a91) als äquivalent zum algID aus der folgenden Menge betrachten (siehe CosT_7a2): {elcAsynchronAdmin, elcRoleCheck, elcSessionkey4SM, elcSessionkey4TC}. <b>[<=]</b>

REQ(ids=G2_N021.610.e)<b>G2_N021.610.e - (N021.610)e K_COS</b>
PAR Das COS MUSS oid = id-RSAES-OAEP (siehe CosT_a91) als äquivalent zum algID = rsaEncipherOaep (siehe CosT_605) betrachten. <b>[<=]</b>

PAR (N021.610)f Diese Anforderung ist absichtlich leer.
REQ(ids=G2_N021.610.g)<b>G2_N021.610.g - (N021.610)g K_COS</b>
PAR Das COS MUSS oid = id-ELC-shared-secret-calculation (siehe CosT_a91) als äquivalent zum algID = elcSharedSecretCalculation (siehe CosT_605) betrachten. <b>[<=]</b>

PAR -HEADING(ids=9.3)9.3 Cache für öffentliche Schlüsselobjekte
PAR Die in diesem Unterkapitel beschriebene Funktion speichert ein übergebenes "öffentliches Signaturprüfobjekt" (siehe CosK_9bb) oder "öffentliches Authentisierungsobjekt" (siehe CosK_17c) im Cache.
PAR (ids=Tabelle-67,-CosT_995)Tabelle 67, CosT_995: Definition der Funktion StoreInCache(...)

TABLE(rows=4,cols=78+84+437)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR puk TD(0,2/1/1)->PAR "Öffentliches Signaturprüfobjekt"        (siehe CosK_9bb) oder<br>"Öffentliches Authentisierungsobjekt" (siehe CosK_17c)
TR-> TD(1,1/1/1)->PAR folder TD(1,2/1/1)->PAR Ordner, dem puk zuzuordnen ist
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR isPersistent TD(2,2/1/1)->PAR True    =>   puk wurde in persistentCache gespeichert    <br>False  =>   puk wurde in volatileCache gespeichert
TR-> TD(3,0/1/1)->PAR Notation TD(3,1/1/1)-> TD(3,2/1/1)->PAR isPersistent = StoreInCache( folder, puk )
PAR (N021.630) ist absichtlich leer.
REQ(ids=G2_N021.630)<b>G2_N021.630 - (N021.630)a K_COS, Option_RSA_CVC</b>
PAR Wenn puk.publicKey vom Typ publicRsaKey ist, dann MUSS das COS puk in Cache speichern. <b>[<=]</b>

REQ(ids=A_15682)<b>A_15682 - (N021.630)b K_TST</b>
PAR Wenn puk.publicKey vom Typ publicRsaKey ist, dann DARF einem Prüfling die funktionale Eignung NICHT mit der Begründung verwehrt werden puk würde in persistentCache gespeichert. <b>[<=]</b>

REQ(ids=A_15683)<b>A_15683 - (N021.630)c K_TST</b>
PAR Wenn puk.publicKey vom Typ publicRsaKey ist, dann DARF einem Prüfling die funktionale Eignung NICHT mit der Begründung verwehrt werden puk würde in volatileCache gespeichert. <b>[<=]</b>

REQ(ids=G2_N021.633.a)<b>G2_N021.633.a - (N021.633)a K_COS</b>
PAR Wenn puk.publicKey vom Typ publicElcKey ist, dann MUSS das COS puk in Cache speichern. <b>[<=]</b>

REQ(ids=A_15684)<b>A_15684 - (N021.633)b.1 K_TST</b>
PAR Wenn puk.publicKey vom Typ publicElcKey ist und in Cache ist bereits ein Schlüsselobjekt vorhanden, dessen Attribut keyIdentifier identisch ist zu puk.keyIdentifier und dieses im Cache vorhandene Schlüsselobjekt unterscheidet sich hinsichtlich Schlüssellänge oder Schlüsseltyp (RSA oder ELC) von puk, dann MUSS im Rahmen der funktionalen Prüfung jedes COS-Verhalten akzeptiert werden. <b>[<=]</b>

REQ(ids=G2_N021.633.b.2)<b>G2_N021.633.b.2 - (N021.633)b.2 K_COS</b>
PAR Wenn puk.publicKey vom Typ publicElcKey ist und in Cache ist bereits ein Schlüsselobjekt vorhanden, dessen Attribut keyIdentifier identisch ist zu puk.keyIdentifier und dieses im Cache vorhandene Schlüsselobjekt ist hinsichtlich Schlüssellänge und Schlüsseltyp identisch zu puk, dann MUSS das COS das im Cache vorhandene Schlüsselobjekt mit identischem keyIdentifier durch puk ersetzen. <b>[<=]</b>

REQ(ids=A_18255)<b>A_18255 - (N021.633)c K_COS</b>
PAR Wenn puk.publicKey vom Typ publicElcKey ist und in Cache ist kein Schlüsselobjekt vorhanden dessen Attribut keyIdentifier identisch ist zu puk.keyIdentifier, dann MUSS das COS wie folgt vorgehen: <b>[<=]</b>

REQ(ids=G2_N021.633.c.1)<b>G2_N021.633.c.1 - (N021.633)c.1 K_COS</b>
PAR Wenn in persistentCache nicht genügend Platz vorhanden ist, dann MUSS das COS gemäß (N021.636) freien Platz schaffen. <b>[<=]</b>

REQ(ids=G2_N021.633.c.2.i)<b>G2_N021.633.c.2.i - (N021.633)c.2.i K_COS</b>
PAR Wenn in persistentCache genügend Platz vorhanden ist, dann MUSS das COS puk in persistentCache speichern. <b>[<=]</b>

REQ(ids=G2_N021.633.c.2.ii)<b>G2_N021.633.c.2.ii - (N021.633)c.2.ii K_COS</b>
PAR Wenn in persistentCache nicht genügend Platz vorhanden ist, obwohl gemäß (N021.633)c.1 versucht wurde Platz zu schaffen, dann MUSS das COS puk in volatileCache speichern. <b>[<=]</b>

REQ(ids=G2_N021.636)<b>G2_N021.636 - (N021.636) K_COS</b>
PAR Das COS MUSS anhand des folgenden Algorithmus versuchen freien Platz in peristentCache zu schaffen:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Schritt 1: In persistentCache wird nach abgelaufenen EE-Schlüssel(n) und abgelaufenen CA-Schlüssel(n) gesucht, unabhängig davon, ob diese in irgendeinem logischen Kanal in channelContext.keyReferenceList eingetragen sind oder nicht. Wenn solche Schlüsselobjekte
ORDERED-LIST->
LITEM->PAR existieren, dann wird eines oder mehrere dieser Schlüsselobjekte aus persistentCache entfernt. Wenn dadurch genügend Platz geschaffen wird, dann bricht dieser Algorithmus ab, sonst wird dieser Schritt wiederholt.LITEM->PAR nicht existieren, dann wird mit Schritt 2 fortgefahren.LITEM->PAR Schritt 2: Dieser Schritt wird erforderlich, wenn durch das Löschen abgelaufener EE-Schlüssel oder abgelaufener CA-Schlüssel nicht genügend Platz geschaffen wurde. Dann wird in persistentCache nach EE-Schlüssel(n) oder CA-Schlüssel(n) gesucht, die in keinem logischen Kanal in channelContext.keyReferenceList eingetragen sind. Wenn solche Schlüsselobjekte
ORDERED-LIST->
LITEM->PAR existieren, dann wird eines dieser Schlüsselobjekte aus persistentCache entfernt. Wenn dadurch genügend Platz geschaffen wird, bricht dieser Algorithmus ab, sonst wird dieser Schritt wiederholt.LITEM->PAR nicht existieren, dann wird mit Schritt 3 fortgefahren.LITEM->PAR Schritt 3: Dieser Schritt wird erforderlich, wenn persistentCache voll ist mit Sicherheitsankern und Schlüsseln, die in channelContext.keyReferenceList selektiert sind. Wenn in volatileCache
ORDERED-LIST->
LITEM->PAR genügend freier Platz vorhanden ist, dann bricht dieser Algorithmus ab.LITEM->PAR nicht genügend Platz vorhanden, dann MUSS ein beliebiges Schlüsselobjekt aus Cache entfernt und dieser Schritt wiederholt werden.
PAR <b>[<=]</b>

PAR (N021.638)a Diese Anforderung ist absichtlich leer.
PAR (N021.638)b Diese Anforderung ist absichtlich leer.
REQ(ids=G2_N021.638.a)<b>G2_N021.638.a - (N021.638)a K_COS</b>
PAR Wird ein öffentliches Schlüsselobjekt aus Cache entfernt, so DARF das COS in KEINEM logischen Kanal den Inhalt von globalSecurityList (siehe (N029.900)e) ändern. <b>[<=]</b>

REQ(ids=G2_N021.638.b)<b>G2_N021.638.b - (N021.638)b K_COS</b>
PAR Wird ein öffentliches Schlüsselobjekt aus Cache entfernt, so DARF das COS in KEINEM logischen Kanal den Inhalt von dfSpecificSecurityList (siehe (N029.900)f) ändern. <b>[<=]</b>

REQ(ids=G2_N021.638.c)<b>G2_N021.638.c - (N021.638)c K_COS</b>
PAR Wird ein öffentliches Schlüsselobjekt aus Cache entfernt, so DARF das COS in KEINEM logischen Kanal den Inhalt von bitSecurityList (siehe (N029.900)h) ändern. <b>[<=]</b>

REQ(ids=A_15685)<b>A_15685 - (N021.638)d K_TST</b>
PAR Wenn ein öffentliches Schlüsselobjekt aus Cache entfernt wird, dann MUSS es für die funktionale Eignung zulässig sein, dass das COS in beliebigen logischen Kanälen Einträge in keyReferenceList, welche eine Referenz auf das entfernte Schlüsselobjekt enthalten,<br>1. verändert oder<br>2. unverändert lässt.  <b>[<=]</b>

REQ(ids=A_15686)<b>A_15686 - (N021.639) K_COS</b>
PAR Für den Rückgabewert gilt: Wenn puk in persistentCache gespeichert wurde,<br>dann MUSS das COS als Rückgabewert persistent = True wählen,<br>sonst False. <b>[<=]</b>

PAR Hinweis CosH_df6: Die Bedingungen, die zu (N021.633)b.1 führen, sind nur erfüllt, wenn es zwei verschiedene Instanzen mit derselben Schlüsselreferenz gibt. Das wird in [gemSpec_PKI] ausgeschlossen.
PAR Hinweis CosH_d42: In (N021.636) ist eine Strategie beschrieben, die in mehreren Schritten versucht ein "unwichtiges" Schlüsselobjekt im Cache zu finden. Wenn so ein "unwichtiges" Schlüsselobjekt existiert, dann wird es aus dem Cache entfernt mit dem Ziel Platz für puk zu schaffen. Der Text wurde nicht mit dem Ziel geschrieben eine bestimmte Implementierung vorzugeben, sondern mit dem Ziel das gewünschte Verhalten zu verdeutlichen. Damit logische Kanäle bezüglich importierter Schlüssel unabhängig voneinander sind, ist persistentCache so zu dimensionieren, dass Schritt 3 in (N021.636)c nicht erforderlich wird. Dem COS ist es nicht möglich dies sicherzustellen. Beispielsweise ist es der externen Welt möglich sehr viele Sicherheitsanker zu importieren. In praxisrelevanten Fällen wären dann alte, überflüssige Sicherheitsanker im Rahmen einer Kartenadministration zu löschen um für freien Platz in persistentCache zu sorgen. Nach Abarbeitung des Algorithmus in (N021.636) ist im Cache genügend Platz für puk frei.
PAR Hinweis CosH_b42: Wenn die Bedingung in (N021.636)a auf mehrere Schlüsselobjekte zutrifft, so wird hier weder festgelegt welches gelöscht wird, noch ob nur eines oder alle gelöscht werden.
PAR Hinweis CosH_0c3: Wenn die Bedingung in (N021.636)a auf mehrere zutrifft aber nur eines gelöscht wird, so erscheint es sinnvoll, das mit dem kleinsten CXD (am längsten abgelaufen) zu entfernen.
PAR Hinweis CosH_b54: Wenn die Bedingung (N021.636)b auf mehrere Schlüsselobjekte zutrifft, so wird nicht festgelegt welches gelöscht wird. Es erscheint sinnvoll, aus der Menge der EE-Schlüssel das mit dem kleinsten CXD zu entfernen.
PAR -HEADING(ids=10)10 CosK_893 Zugriffskontrolle (normativ)
PAR Fast alle in CosK_3a7 beschriebenen Kommandos werden durch Zugriffsregeln geschützt. Das bedeutet, dass das Betriebssystem kontrolliert, ob der Sicherheitsstatus für die Ausführung der Operation ausreichend ist. Die in diesem Kapitel aufgeführten Regeln bilden eine Untermenge der in [ISO/IEC 7816-4#9.3.3] Expanded format definierten Regeln.
PAR -HEADING(ids=10.1)10.1 CosK_b28 Zugriffsart
PAR Die Zugriffsart (access mode) zeigt an, ob die der Zugriffsart zugeordnete Zugriffsbedingung im Rahmen einer Zugriffsregelprüfung auszuwerten ist. Bei der Spezifikation von Anwendungen sind folgende Regeln einzuhalten:
REQ(ids=G2_N021.700)<b>G2_N021.700 - (N021.700) K_Anwendungsspezifikation {K_Karte}</b>
PAR Eine Zugriffsart MUSS eine Liste von Kommandobeschreibungen sein. <b>[<=]</b>

PAR Als Untermenge zu [ISO/IEC 7816-4#Tabelle 32] gilt für jedes Listenelement fogendes:
REQ(ids=A_15687)<b>A_15687 - (N021.800)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Listenelement MUSS den Namen eines Kommandos enthalten, der gemäß CosK_3a7 äquivalent ist zu genau einer Kombination aus CLA Byte (siehe CosK_90e) und INS Byte (siehe CosK_19e). <b>[<=]</b>

REQ(ids=G2_N021.800.a.1)<b>G2_N021.800.a.1 - (N021.800)a.1 K_Anwendungsspezifikation {K_Karte}</b>
PAR Das CLA Byte in einer Zugriffsart MUSS die Kanalnummer null enthalten. Das ist so zu interpretieren, dass die Zugriffsart für beliebige Kanalnummern gilt. <b>[<=]</b>

REQ(ids=G2_N021.800.a.2)<b>G2_N021.800.a.2 - (N021.800)a.2 K_Anwendungsspezifikation {K_Karte}</b>
PAR Das CLA Byte in einer Zugriffsart DARF KEIN Secure Messaging anzeigen. Das ist so zu interpretieren, dass die Zugriffsart sowohl für ungeschützte Nachrichtenübertragung, als auch für beliebig per Secure Messaging geschützte Nachrichtenübertragung gilt. <b>[<=]</b>

PAR Innerhalb eines Listenelementes ist der Parameter P1 (siehe CosK_66b) optional. Das bedeutet:
REQ(ids=G2_N021.800.b.1)<b>G2_N021.800.b.1 - (N021.800)b.1 K_Anwendungsspezifikation {K_Karte}</b>
PAR Es MUSS möglich sein, dass ein Listenelement genau einen Wert für den Parameter P1 enthält. Das ist so zu interpretieren, dass die Zugriffsart nur für diesen Wert von P1 gilt. <b>[<=]</b>

REQ(ids=G2_N021.800.b.2)<b>G2_N021.800.b.2 - (N021.800)b.2 K_Anwendungsspezifikation {K_Karte}</b>
PAR Es MUSS möglich sein, dass ein Listenelement keinen Parameter P1 enthält. Das ist so zu interpretieren, dass die Zugriffsart für beliebige Werte von P1 gilt. <b>[<=]</b>

PAR Innerhalb eines Listenelementes ist der Parameter P2 (siehe CosK_165) optional. Das bedeutet:
REQ(ids=G2_N021.800.c.1)<b>G2_N021.800.c.1 - (N021.800)c.1 K_Anwendungsspezifikation {K_Karte}</b>
PAR Es MUSS möglich sein, dass ein Listenelement genau einen Wert für den Parameter P2 enthält. Das ist so zu interpretieren, dass die Zugriffsart nur für diesen Wert von P2 gilt. <b>[<=]</b>

REQ(ids=G2_N021.800.c.2)<b>G2_N021.800.c.2 - (N021.800)c.2 K_Anwendungsspezifikation {K_Karte}</b>
PAR Es MUSS möglich sein, dass ein Listenelement keinen Parameter P2 enthält. Das ist so zu interpretieren, dass die Zugriffsart für beliebige Werte von P2 gilt. <b>[<=]</b>

REQ(ids=A_15690)<b>A_15690 - (N021.800)d K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS  weitere Arten von Kommandobeschreibungen<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N021.900)<b>G2_N021.900 - (N021.900) K_COS</b>
PAR Das COS MUSS bei der Auswertung der Zugriffsart diese genau dann als passend zur aktuellen Kommando-APDU ansehen, wenn es in der Liste der Kommandobeschreibungen ein Listenelement gibt, dessen Bestandteile identisch sind zu den Bestandteilen der Kommando-APDU an der Schnittstelle "Interpreter" (siehe CosA_e09). <b>[<=]</b>

PAR -HEADING(ids=10.2)10.2 CosK_4de Zugriffsbedingung
PAR Eine Zugriffsbedingung ist ein boolescher Ausdruck. Bei der Spezifikation einer Anwendung sind folgende Regeln einzuhalten, wobei zur Beschreibung folgende Definitionen eingeführt werden:
PAR (ids=Tabelle-68,-CosT_6f1)Tabelle 68, CosT_6f1: Definition von Begriffen, die bei der Beschreibung von Zugriffsregeln verwendet werden

TABLE(rows=2,cols=90+522)->
TR-> TD(0,0/1/1)->PAR objectFolder TD(0,1/1/1)->PAR Wenn diese Zugriffsbedingung zu einem Objekt<br> vom Typ Ordner gehört, dann ist objectFolder gleich dieser Ordner        vom Typ Sessionkey gehört, dann ist objectFolder gleich dem Ordner, auf den SessionkeyContext.folderSessionkeys zeigt.        anderen Typs gehört, dann ist objectFolder gleich dem Ordner, dessen Attribut children dieses Objekt enthält
TR-> TD(1,0/1/1)->PAR path( folder ) TD(1,1/1/1)->PAR Pfad eines Ordners mit Namen folder. Zum Pfad gehört nach dieser Definition sowohl der Ordner folder, als auch alle seine übergeordneten Ebenen gemäß CosK_dae einschließlich root
REQ(ids=G2_N022.000)<b>G2_N022.000 - (N022.000) K_COS</b>
PAR Das COS MUSS für das boolesche Elemente ALWAYS den Wert True verwenden. <b>[<=]</b>

REQ(ids=G2_N022.100)<b>G2_N022.100 - (N022.100) K_COS</b>
PAR Das COS MUSS für das boolesche Element NEVER den Wert False verwenden. <b>[<=]</b>

REQ(ids=A_15706)<b>A_15706 - (N022.200) K_COS</b>
PAR Das COS MUSS für das boolesche Element PWD(passwordReference) <b>[<=]</b>

REQ(ids=A_15707)<b>A_15707 - (N022.000)a</b>
PAR genau dann den Wert True verwenden, wenn die Passwortsuche gemäß CosT_65c mit den Inputparametern SearchPwd( objectFolder, passwordReference ) ein Passwort findet und wenigstens eine der beiden folgenden Bedingungen erfüllt ist: <b>[<=]</b>

REQ(ids=G2_N022.200.a.1)<b>G2_N022.200.a.1 - (N022.200)a.1</b>
PAR Dieses Passwortobjekt ist entweder in globalPasswordList (siehe (N029.900)i) oder in dfSpecificPasswordList (siehe (N029.900)j) enthalten und das Attribut securityStatusEvaluationCounter dieses Passwortes ist ungleich null. Anschließend MUSS das COS das Attribut securityStatusEvaluationCounter dieses Passwortes um eins dekrementieren. <b>[<=]</b>

REQ(ids=G2_N022.200.a.2)<b>G2_N022.200.a.2 - (N022.200)a.2</b>
PAR Das Attribut flagEnabled dieses Passwortes besitzt den Wert False. <b>[<=]</b>

REQ(ids=G2_N022.200.b)<b>G2_N022.200.b - (N022.200)b</b>
PAR in allen anderen Fällenden Wert False verwenden. <b>[<=]</b>

REQ(ids=A_15708)<b>A_15708 - (N022.210) K_TST</b>
PAR Wenn durch das Dekrementieren gemäß (N022.200)a.1 der Wert auf Null gefallen ist, dann MUSS es für die funktionale Eignung zulässig sein, dass das COS den Eintrag für dieses Passwort in einer der Listen globalPasswordList oder dfSpecificPasswordList<br>a. verbleibt, oder<br>b. entfernt. <b>[<=]</b>

REQ(ids=A_15709)<b>A_15709 - (N022.300) K_COS</b>
PAR Das COS MUSS für das boolesche Element AUT(keyReference) <b>[<=]</b>

REQ(ids=G2_N022.300.a)<b>G2_N022.300.a - (N022.300)a</b>
PAR genau dann den Wert True verwenden, wenn die Schlüsselsuche gemäß CosT_d11 mit den Inputparametern SearchSecretKey ( objectFolder, keyReference, "Wildcard") ein Schlüsselobjekt key findet und genau dieses Schlüsselobjekt entweder in globalSecurityList (siehe (N029.900)e) oder in dfSpecificSecurityList (siehe (N029.900)f) enthalten ist. <b>[<=]</b>

REQ(ids=G2_N022.300.b)<b>G2_N022.300.b - (N022.300)b</b>
PAR in allen anderen Fällenden Wert False verwenden. <b>[<=]</b>

REQ(ids=A_15710)<b>A_15710 - (N022.400) K_COS</b>
PAR Das COS MUSS für das boolesche Element AUT(CHAT) <b>[<=]</b>

REQ(ids=G2_N022.400.a)<b>G2_N022.400.a - (N022.400)a</b>
PAR genau dann Wert True verwenden, wenn es mindestens ein Element in bitSecurityList (siehe (N029.900)h) gibt, in welchem die OID übereinstimmt und mindestens dieselben Bits gesetzt sind wie in accessFlags (siehe auch CosH_1ea) und dieses Element ist einem Ordner in path(objectFolder) zugeordnet (siehe (N030.400)b). <b>[<=]</b>

REQ(ids=G2_N022.400.b)<b>G2_N022.400.b - (N022.400)b</b>
PAR in allen anderen Fällenden Wert False verwenden. <b>[<=]</b>

PAR (N022.500) ist absichtlich leer.
REQ(ids=A_15711)<b>A_15711 - (N022.500) K_COS, Option_RSA_CVC</b>
PAR Das COS MUSS für das boolesche Element AUT(CHA) <b>[<=]</b>

REQ(ids=G2_N022.500.a)<b>G2_N022.500.a - (N022.500)a</b>
PAR genau dann Wert True verwenden, wenn CHA in globalSecurityList (siehe (N029.900)e) oder in dfSpecificSecurityList (siehe (N029.900)f) enthalten ist und CHA einem Ordner in path(objectFolder) zugeordnet ist (siehe (N030.300)b.2). <b>[<=]</b>

REQ(ids=G2_N022.500.b)<b>G2_N022.500.b - (N022.500)b</b>
PAR in allen anderen Fällenden Wert False verwenden. <b>[<=]</b>

PAR Secure Messaging gemäß CosK_2ff wird wie folgt in Zugriffsbedingungen verwendet:
REQ(ids=G2_N022.600.a)<b>G2_N022.600.a - (N022.600)a K_COS</b>
PAR Das COS MUSS für das boolesche Element SmMac(keyInformation) genau dann den Wert True verwenden, falls SessionkeyContext.flagSessionEnabled gleich SK4SM ist, und SessionkeyContext.negotiationKeyInformation<br> 1. eine Schlüsselreferenz gemäß (N099.600) enthält und AUT(keyInformation) gemäß (N022.300) liefert True, oder<br>2. enthält accessRights gemäß (N019.700) mit<br>    a. dieser Punkt ist absichtlich leer.Option_RSA_CVC, CHA gemäß CosK_ec2 und AUT(keyInformation) gemäß (N022.500) liefert True, oder<br>    b. CHAT und AUT(keyInformation) gemäß (N022.400) liefert True,<br>3. sonst False. <b>[<=]</b>

REQ(ids=G2_N022.600.b)<b>G2_N022.600.b - (N022.600)b K_COS</b>
PAR Das COS MUSS für das boolesche Element SmCmdEnc den Wert von SessionkeyContext.flagCmdEnc verwenden. <b>[<=]</b>

REQ(ids=G2_N022.600.c)<b>G2_N022.600.c - (N022.600)c K_COS</b>
PAR Das COS MUSS für das boolesche Element SmRspEnc stets den Wert True verwenden. <b>[<=]</b>

REQ(ids=G2_N022.600.d)<b>G2_N022.600.d - (N022.600)d K_COS</b>
PAR Das COS MUSS SessionkeyContext.flagRspEnc genau dann auf True setzen, wenn die Zugriffsbedingung den Wert True besitzt (siehe (N022.800)) und das Element SmRspEnc enthält. <b>[<=]</b>

PAR Die zuvor definierten booleschen Elemente lassen sich zu einem booleschen Ausdruck verbinden.
REQ(ids=G2_N022.700)<b>G2_N022.700 - (N022.700) K_COS</b>
PAR a. Das COS MUSS den AND-Operator unterstützen.<br>b. Das COS MUSS den OR-Operator unterstützen. <b>[<=]</b>

REQ(ids=A_15712)<b>A_15712 - (N022.700)c K_Anwendungsspezifikation {K_Karte}</b>
PAR Eine Anwendungsspezifikation DARF in Zugriffsbedingungen neben AND- und OR-Operatoren keine weiteren Operatoren enthalten. <b>[<=]</b>

PAR Eine Verschlüsselung ist nur bei gleichzeitiger MAC-Sicherung sinnvoll, das heißt:
REQ(ids=G2_N022.710.a)<b>G2_N022.710.a - (N022.710)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Jedes boolsche Element SmCmdEnc MUSS durch den AND-Operator mit SmMac(keyInformation) verknüpft werden. <b>[<=]</b>

REQ(ids=G2_N022.710.b)<b>G2_N022.710.b - (N022.710)b K_Anwendungsspezifikation {K_Karte}</b>
PAR Jedes boolsche Element SmRspEnc MUSS durch den AND-Operator mit SmMac(keyInformation) verknüpft werden. <b>[<=]</b>

REQ(ids=A_15713)<b>A_15713 - (N022.710)c K_Anwendungsspezifikation {K_Karte}</b>
PAR Enthält ein AND-Operator ein SmRspEnc Element, so DARF dieser AND-Operator NICHT in einem OR-Operator enthalten sein. <b>[<=]</b>

REQ(ids=G2_N022.800)<b>G2_N022.800 - (N022.800) K_COS</b>
PAR Das COS MUSS als Wert der Zugriffsbedingung das Ergebnis des booleschen Ausdrucks verwenden. <b>[<=]</b>

PAR Für die Kommandos GET CHALLENGE (siehe (N098.900)), MANAGE CHANNEL (siehe (N099.545)), MANAGE SECURITY ENVIRONMENT (siehe (N104.100) und SELECT (siehe (N047.600)) ist nicht festgelegt, ob Zugriffsregeln auszuwerten sind oder nicht. Darum gilt für die Zugriffsbedingung dieser Kommandos:
REQ(ids=G2_N022.810.a)<b>G2_N022.810.a - (N022.810)a K_COS</b>
PAR Wenn ein COS für eines der Kommandos aus der Menge {GET CHALLENGE, MANAGE CHANNEL, MANAGE SECURITY ENVIRONMENT, SELECT} keine Zugriffsregeln auswertet, dann MUSS sich das COS so verhalten, als ob die Zugriffsbedingung für derartige Zugriffsarten ALWAYS lautet. <b>[<=]</b>

REQ(ids=A_15714)<b>A_15714 - (N022.810)b K_Karte</b>
PAR Wenn ein COS für eines der Kommandos aus der Menge {GET CHALLENGE, MANAGE CHANNEL, MANAGE SECURITY ENVIRONMENT, SELECT} Zugriffsregeln auswertet, dann MUSS eine Karte so konfiguriert werden, dass <b>[<=]</b>

REQ(ids=G2_N022.810.b.1)<b>G2_N022.810.b.1 - (N022.810)b.1 K_Karte</b>
PAR für die kontaktbehaftete Kommunikation die Zugriffsbedingung des Kommanods ALWAYS lautet. <b>[<=]</b>

REQ(ids=G2_N022.810.b.2.i)<b>G2_N022.810.b.2.i - (N022.810)b.2.i K_Karte</b>
PAR für die kontaktlose Kommunikation MUSS die Zugriffsbedingung des Kommanods ALWAYS lauten, falls beabsichtigt ist, diese Schnittstelle zu nutzen. <b>[<=]</b>

REQ(ids=G2_N022.810.b.2.ii)<b>G2_N022.810.b.2.ii - (N022.810)b.2.ii K_Karte</b>
PAR für die kontaktlose Kommunikation MUSS die Zugriffsbedingung des Kommanods NEVER lauten, falls beabsichtigt ist, diese Schnittstelle nicht zu nutzen. <b>[<=]</b>

PAR Hinweis CosH_34d: Die normativen Regeln dieses Dokumentes, insbesondere die<br>       – zu Attributen eines Passwortes (siehe CosK_d13 und CosK_7f0)<br>       – zu Statusänderungen bei erfolgreicher Benutzerverifikation (siehe (N082.900))<br>       – zum booleschen Element PWD (siehe (N022.200))<br>    sind so aufgebaut, dass nach erfolgreicher Benutzerverifikation<br>        – genau eine Operation (etwa Signatur) möglich ist  (startSSEC = 1, siehe (N015.800)c.2), oder<br>        – genau n Operationen möglich sind (startSSEC = n > 1), oder<br>        – beliebig viele Operationen möglich sind (startSSEC = "unendlich").
PAR Hinweis CosH_1ea: Obwohl in (N029.900)h.1 festgelgt ist, dass eine Listenlänge von eins für das COS hinreichend ist um spezifikationskonform zu sein, wird in den folgenden Beispielen mit einer Listenlänge von zwei gearbeitet um den Inhalt von (N022.400) zu erläutern. Zur Vereinfachung sind in den Beispielen OID nicht dargestellt.

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Für bitSecurityList = {0001, 0110} ist AUT(0011) gleich False, weil es in bitSecurityList kein Element gibt, in welchem die beiden letzten Bits gesetzt sind. Ein verODERn der Listen in bitSecurityList findet demnach nicht statt.LITEM->PAR Für bitSecurityList = {0001, 1011} ist AUT(0011) gleich True, weil in bitSecurityList im zweiten Element ebenfalls die beiden letzten Bits gesetzt sind.
PAR Hinweis CosH_7fe: Gemäß (N022.600)a lässt sich für SmMac festlegen mit welchem Schlüssel Secure Messaging erfolgt. Eine ensprechende Festlegung für SmCmdEnc oder SmRspEnc ist nicht erforderlich, da ausschließlich Sessionkeys betrachtet werden, wo sowohl Kmac als auch Kenc gemeinsam vereinbart werden.
PAR Hinweis CosH_cbc: In (N022.600)d ist festgelegt, wann Daten einer Antwortnachricht zu verschlüsseln sind und (N022.710)c dient der präzisen Beschreibung des gewünschten Verhaltens. Das wird an folgendem Beispiel verdeutlicht: Ein privates Schlüsselobjekt sei durch folgende Zugriffsregel geschützt: {<br>        PsoCompDigSig AND[PWD(1), SmMac, SmRspEnc)],<br>        PsoCompDigSig AND[PWD(2), SmMac]<br>}<br>Damit ist unter Verwendung von Secure Messaging eine Signaturerzeugung möglich. Das ließe sich kürzer formulieren: {PsoCompDigSig OR[AND[PWD(1), SmMac, SmRspEnc)], AND[PWD(2), SmMac]]}.<br>Nur in der nicht gekürzten Zugriffsregel wird deutlich, dass nur bei gesetztem Sicherheitszustand von PWD(1) die Signatur verschlüsselt übertragen wird. Wenn der Sicherheitszustand von PWD(1) nicht gesetzt ist, dann wird eine Signatur im Klartext übertragen.
PAR -HEADING(ids=10.3)10.3 CosK_3b4 Zugriffsregel
PAR Eine Zugriffsregel kombiniert Zugriffsart und Zugriffsbedingung und liefert bei der Auswertung ein boolesches Ergebnis. Bei der Spezifikation einer Anwendung sind folgende Regeln einzuhalten:
REQ(ids=G2_N022.900)<b>G2_N022.900 - (N022.900) K_Anwendungsspezifikation {K_Karte}</b>
PAR Eine Zugriffsregel MUSS eine Liste mit mindestens einem Element sein. <b>[<=]</b>

REQ(ids=G2_N023.000)<b>G2_N023.000 - (N023.000) K_Anwendungsspezifikation {K_Karte}</b>
PAR Ein Listenelement MUSS genau eine Zugriffsart gemäß CosK_b28 und eine Zugriffsbedingung gemäß CosK_4de enthalten. <b>[<=]</b>

REQ(ids=A_15715)<b>A_15715 - (N023.100) K_COS</b>
PAR Das COS MUSS für den booleschen Wert eines Listenelementes <b>[<=]</b>

REQ(ids=G2_N023.100.a)<b>G2_N023.100.a - (N023.100)a K_COS</b>
PAR genau dann den Wert True verwenden, wenn<br>1. die Zugriffsart gemäß (N021.900) passt und<br>2. der boolesche Wert der Zugriffsbedingung den Wert True hat. <b>[<=]</b>

REQ(ids=G2_N023.100.b)<b>G2_N023.100.b - (N023.100)b</b>
PAR in allen anderen Fällen den Wert False liefern (implizites NEVER). <b>[<=]</b>

REQ(ids=A_15716)<b>A_15716 - (N023.200) K_COS</b>
PAR Das COS MUSS eine Zugriffsregel <b>[<=]</b>

REQ(ids=G2_N023.200.a)<b>G2_N023.200.a - (N023.200)a K_COS</b>
PAR genau dann als erfüllt ansehen, wenn mindestens ein Listenelement den Wert True liefert. <b>[<=]</b>

REQ(ids=G2_N023.200.b)<b>G2_N023.200.b - (N023.200)b K_COS</b>
PAR in allen anderen Fällen als nicht erfüllt ansehen. <b>[<=]</b>

REQ(ids=A_15717)<b>A_15717 - (N023.300) K_Anwendungsspezifikation {K_Karte}</b>
PAR Eine Zugriffsregel, welche die übrigen Bedingungen in CosK_893 erfüllt, DARF bei Codierung gemäß [ISO/IEC 7816-4#9.3.3] NICHT mehr als 240 Oktette beanspruchen. <b>[<=]</b>

PAR -HEADING(ids=10.4)10.4 CosK_f35 Zugriffsregelauswertung
PAR Dieses Unterkapitel beschreibt wie das COS feststellt, ob die Ausführung eines bestimmten Kommandos erlaubt oder verboten ist.
PAR (ids=Tabelle-69,-CosT_fe2)Tabelle 69, CosT_fe2: Definition der Funktion AccessRuleEvaluation(...)

TABLE(rows=5,cols=89+57+522)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR obj TD(0,2/1/1)->PAR Instanz eines Objektes vom Typ Ordner, Datei, Passwortobjekt oder Schlüsselobjekt
TR-> TD(1,1/1/1)->PAR CLA<br>INS<br>P1<br>P2 TD(1,2/1/1)->PAR CLA Byte<br>INS Byte<br>Parameter P1<br>Parameter P2
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR b TD(2,2/1/1)->PAR Boolean,<br>   True    bedeutet: Kommandoausführung erlaubt;    <br>   False  bedeutet: Kommandoausführung verboten
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR b = AccessRuleEvaluation( obj, CLA, INS, P1, P2 )
PAR Schritt 1: Handelt es sich bei obj
REQ(ids=G2_N023.400.a)<b>G2_N023.400.a - (N023.400)a K_COS</b>
PAR um einen Ordner, dann MUSS se = seIdentifier dieses Ordners sein (siehe (N030.000)a). <b>[<=]</b>

REQ(ids=G2_N023.400.b)<b>G2_N023.400.b - (N023.400)b K_COS</b>
PAR um einen Sessionkey, dann MUSS se = seIdentifier des Ordners sein (siehe (N030.000)a), auf den SessionkeyContext.folderSessionkeys zeigt. <b>[<=]</b>

REQ(ids=G2_N023.400.c)<b>G2_N023.400.c - (N023.400)c K_COS</b>
PAR sonst MUSS se = seIdentifier des Ordners sein (siehe (N030.000)a), der obj in seinem Attribut children (siehe (N010.000)) enthält. <b>[<=]</b>

REQ(ids=A_15718)<b>A_15718 - (N023.500) K_COS</b>
PAR Schritt 2: Das COS MUSS unter Berücksichtigung des aktuell aktiven Übertragungsprotokolls (kontaktbehaftet oder kontaktlos) des logischen Wertes von obj.lifeCycleStatus (siehe (N020.600)) und se aus obj.accessRules, welches vom Typ interfaceDependentAccessRules ist, die passende Zugriffsregel ausgewählen (siehe CosK_b03). <b>[<=]</b>

REQ(ids=A_15719)<b>A_15719 - (N023.600) K_COS</b>
PAR Schritt 3: Das COS MUSS anhand von CLA, INS, P1 und P2 ermitteln, ob die in (N023.500) ausgewählte Zugriffsregel erfüllt ist (siehe CosK_3b4). <b>[<=]</b>

PAR Schritt 4: Ist die ausgewählte Zugriffsregel
REQ(ids=G2_N023.700.a)<b>G2_N023.700.a - (N023.700)a K_COS</b>
PAR erfüllt, dann MUSS b = True gelten. <b>[<=]</b>

REQ(ids=G2_N023.700.b)<b>G2_N023.700.b - (N023.700)b K_COS</b>
PAR sonst MUSS b = False gelten. <b>[<=]</b>

PAR Hinweis CosH_c0a: Wenn in folgender, beispielhafter Zugriffsbedingung (PWD1 OR PWD2) beide Passwortobjekte mit 0 < SSEC < unendlich vorkommen, dann ist es herstellerspezifisch, ob beide SSEC oder nur einer und in diesem Falle welcher dekrementiert wird.
PAR -HEADING(ids=10.5)10.5 Auslesen von Zugriffsregeln
PAR In CosK_b28 bis CosK_f35 wird festgelegt in welchem Rahmen sich eine Anwendungsspezifikation im Bereich Zugriffsregeln zu bewegen hat. Zur COS-internen Codierung von Zugriffsregeln gibt es keine Anforderung. Die COS-interne Codierung von Zugriffsregeln ist und bleibt herstellerspezifisch und liegt damit außerhalb des Regelungsbereiches dieses Dokumentes.
PAR Das Konzept zur Evaluierung und damit zur Zulassung des COS sieht ab der Generation 2 vor, dass Zugriffsregeln aus einer Smartcard auslesbar sind. Dieses Unterkapitel nennt die zugehörigen Anforderungen:
PAR Hinweis CosH_89e: Die folgenden Anforderungen beziehen sich ausschließlich auf Zugriffsregeln, die Teil einer Anwendungsspezifikation sind. Da alle Anwendungsspezifikationen auf den Webseiten der gematik allgemein zugänglich veröffentlicht werden, sind sie öffentlich. Aus datenschutzrechtlicher Sicht ist deshalb gegen das Auslesen dieser Zugriffsregeln nichts einzuwenden. Das Auslesen dient dem Nachweis, dass eine Smartcard Zugriffsregeln semantisch spezifikationskonform umsetzt.
REQ(ids=A_15720)<b>A_15720 - (N023.740)a.1 K_Karte</b>
PAR Der Hersteller MUSS eine Karte so konfigurieren, dass jede Zugriffsregel, die in einer Anwendungspezifikation definiert ist, auslesbar ist. <b>[<=]</b>

REQ(ids=A_15721)<b>A_15721 - (N023.740)a.2 K_Karte</b>
PAR Der Hersteller SOLL eine Karte so konfigurieren, dass jede Zugriffsregel, die in einer Anwendungspezifikation definiert ist, frei auslesbar ist, das heißt die Zugriffsregel zum Auslesen von Zugriffsregeln SOLL "read ALWAYS" sein. <b>[<=]</b>

REQ(ids=A_15722)<b>A_15722 - (N023.740)b K_TST</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass Zugriffsregeln für Objekte, die nicht in einer Anwendungsspezifikation definiert sind (etwa herstellerspezifische zusätzliche Objekte, EF.Pwd, etc.)<br>1. auslesbar oder<br>2. nicht auslesbar<br>sind. <b>[<=]</b>

PAR -HEADING(ids=11)11 CosK_581 Kommunikation (normativ)
PAR -HEADING(ids=11.1)11.1 CosK_ad0 Request - Response
PAR Für Smartcards entspricht es dem Stand der Technik, dass sie Nachrichten mit einem externen Kommunikationspartner über einen Kanal im Halbduplex-Verfahren austauschen. Zudem arbeiten sie ähnlich wie ein Server. Das bedeutet, dass der externe Kommunikationspartner eine Nachricht (Kommando) über den Kanal schickt. Diese Nachricht (Kommando) wird von der Smartcard verarbeitet. Anschließend sendet die Smartcard über denselben Kanal eine Nachricht (Antwort) zurück. Erst nach dem vollständigen Empfang der Smartcard-Nachricht hat der externe Kommunikationspartner die Möglichkeit, eine weitere Nachricht zu schicken.
PAR -HEADING(ids=11.2)11.2 CosK_458 Elektrische Schnittstellen
PAR Dieses Kapitel behandelt elektrische Schnittstellen zum COS. Das Übertragungsprotokoll T=1 gemäß [ISO/IEC 7816-3#11] ist verpflichtend und wird in CosK_36d näher spezifiziert. Eine Datenübertragung gemäß [ISO/IEC 7816-12] (siehe CosK_70c) oder kontaklos gemäß ISO/IEC 14443 (siehe CosK_009) ist optional.
PAR -HEADING(ids=11.2.1)11.2.1 CosK_36d Übertragungsprotokoll T=1 gemäß [ISO/IEC 7816-3#11]
PAR Dieses Kapitel behandelt das kontaktbehaftete Übertragungsprotokoll T=1 gemäß [ISO/IEC 7816-3#11]. Die Unterstützung dieses Übertragungsprotokolls ist verpflichtend.
PAR (N023.800) Diese Anforderung ist absichtlich leer.
REQ(ids=G2_N023.801)<b>G2_N023.801 - (N023.801) K_COS</b>
PAR Das COS MUSS das kontaktbehaftete Übertragungsprotokoll T=1 unterstützen. Das Intervall [(N023.820), (N024.220)] spezifiziert die diesbezüglichen Anforderungen. <b>[<=]</b>

REQ(ids=G2_N023.820.a)<b>G2_N023.820.a - (N023.820)a K_IC</b>
PAR Das IC einer Smartcard MUSS elektrische Eigenschaften gemäß [EMV®_Book-1#5.3] aufweisen. <b>[<=]</b>

REQ(ids=G2_N023.820.b)<b>G2_N023.820.b - (N023.820)b K_IC</b>
PAR Das IC einer Smartcard MUSS die Spannungklasse "Class A" unterstützen. <b>[<=]</b>

REQ(ids=G2_N023.820.c)<b>G2_N023.820.c - (N023.820)c K_IC</b>
PAR Das IC einer Smartcard MUSS die Spannungsklasse "Class B" unterstützen. <b>[<=]</b>

REQ(ids=A_15723)<b>A_15723 - (N023.820)d K_TST</b>
PAR Die funktionale Eignung MUSS es zulässig sein, dass das IC einer Smartcard die Spannungsklasse "Class C" unterstützt. <b>[<=]</b>

REQ(ids=A_15724)<b>A_15724 - (N023.820)e K_TST</b>
PAR Die funktionale Eignung MUSS es zulässig sein, dass das IC einer Smartcard die Spannungsklasse "Class C" nicht unterstützt. <b>[<=]</b>

REQ(ids=G2_N023.820.f)<b>G2_N023.820.f - (N023.820)f K_Karte</b>
PAR Der Hersteller einer Karte  MUSS diese so konfigurieren, dass alle Spannungsklassen, welche die Smartcard im ATR oder in einem EF.ATR anzeigt, konform zu [EMV®_Book-1#5.3] implementiert sind (siehe auch (N024.100)i). <b>[<=]</b>

PAR (N023.900) Diese Anforderung ist absichtlich leer.
PAR Eine Kartensession gliedert sich in die Abschnitte Kartenaktivierung, Reset, Nachrichtenaustausch und Deaktivierung. Dabei gilt:
REQ(ids=G2_N023.920.a)<b>G2_N023.920.a - (N023.920)a K_externeWelt {K_Karte}</b>
PAR Der externe Kommunikationspartner MUSS die Smartcard gemäß [EMV®_Book-1#6.1.2] aktivieren. <b>[<=]</b>

REQ(ids=G2_N023.920.b)<b>G2_N023.920.b - (N023.920)b K_externeWelt {K_Karte}</b>
PAR Im Anschluss an die Aktivierung gemäß (N023.920)a MUSS der externe Kommunikationspartner einen Cold Reset gemäß [EMV®_Book-1#6.1.3.1] ausführen. <b>[<=]</b>

REQ(ids=G2_N023.920.c)<b>G2_N023.920.c - (N023.920)c K_IC</b>
PAR Das IC einer Smartcard MUSS einen Warm Reset gemäß [EMV®_Book-1#6.1.3.2] unterstützen. <b>[<=]</b>

REQ(ids=G2_N023.920.d)<b>G2_N023.920.d - (N023.920)d K_externeWelt {K_Karte}</b>
PAR Der externe Kommunikationspartner MUSS die "Information Field Size" IFSD durch einen IFSD-Request (siehe [ISO/IEC 7816-3#11.4.2]) auf den Wert 'FE' = 254 setzen. <b>[<=]</b>

REQ(ids=G2_N023.920.f.1)<b>G2_N023.920.f.1 - (N023.920)f.1 K_externeWelt {K_Karte}</b>
PAR Der externe Kommunikationspartner SOLL das IC einer Smartcard gemäß [EMV®_Book-1#6.1.5] deaktivieren. <b>[<=]</b>

REQ(ids=A_15725)<b>A_15725 - (N023.920)f.2 K_COS</b>
PAR Die Deaktivierung KANN auf andere Art erfolgen. Das COS MUSS so robust sein, dass eine Deaktivierung möglich ist, die von den Vorgaben aus [EMV®_Book-1#6.1.5] abweicht (beispielsweise "Karte ziehen"). <b>[<=]</b>

REQ(ids=G2_N023.920.f.3)<b>G2_N023.920.f.3 - (N023.920)f.3 K_COS</b>
PAR Geschieht die Deaktivierung zu einem Zeitpunkt, in welchem eine transaktionsgeschützte Schreiboperation durchgeführt wird (siehe CosK_c9b), so MUSS das COS dafür Sorge tragen, dass gemäß den Regeln in (N034.600) bzw. (N034.700) verfahren wird, bevor die nächste Kommando-APDU von der Komponente "Cmd Interpreter" in CosA_e09 bearbeitet wird. <b>[<=]</b>

REQ(ids=G2_N023.940)<b>G2_N023.940 - (N023.940) K_COS</b>
PAR Wenn das COS keinen IFSD-Request empfängt (siehe (N023.920)d),<br>dann MUSS das COS mit einem Wert IFSD=254 (siehe [EMV®_Book-1#9.2.4.2.1]) arbeiten. <b>[<=]</b>

PAR (N024.000) Diese Anforderung ist absichtlich leer.
REQ(ids=G2_N024.020)<b>G2_N024.020 - (N024.020) K_IC, K_externeWelt {K_Karte}</b>
PAR Im Rahmen des hier spezifizierten Übertragungsprotkolls MÜSSEN auf der physikalischen Schnittstelle (siehe CosA_e09) Character gemäß [EMV®_Book-1#7.2] verwendet werden. <b>[<=]</b>

PAR Ein Cold Reset gemäß (N023.920)b und ein Warm Reset gemäß (N023.920)c lassen sich als spezielle "Nachrichten" des externen Kommunikationspartners auffassen, die von der Smartcard mit einem Answer to Reset (ATR) gemäß [ISO/IEC 7816-3#8.2] beantwortet wird. Dabei gilt:
REQ(ids=G2_N024.100.a)<b>G2_N024.100.a - (N024.100)a K_COS</b>
PAR Das COS MUSS den ATR gemäß [EMV®_Book-1#8.1] versenden. <b>[<=]</b>

REQ(ids=G2_N024.100.b)<b>G2_N024.100.b - (N024.100)b K_COS</b>
PAR Das COS MUSS als "initial character" im ATR den Wert '3B' verwenden. Daraus ergibt sich, dass die Kommunikation mittels "direct convention" (siehe [ISO/IEC 7816-3#8.1]) erfolgt. <b>[<=]</b>

REQ(ids=G2_N024.100.c)<b>G2_N024.100.c - (N024.100)c K_COS</b>
PAR Das COS MUSS im Rahmen eines Cold Reset für das TA1 Byte im ATR einen Wert aus der Menge {'18', '95', '96', '97'} verwenden. <b>[<=]</b>

REQ(ids=G2_N024.100.d)<b>G2_N024.100.d - (N024.100)d K_COS</b>
PAR Das COS MUSS im Rahmen eines Warm Reset für das TA1 Byte im ATR einen Wert aus der Menge {'18', '95', '96'} verwenden. <b>[<=]</b>

REQ(ids=G2_N024.100.e.1)<b>G2_N024.100.e.1 - (N024.100)e.1 K_COS</b>
PAR Das COS SOLL im ATR ein TC1 Byte enthalten. <b>[<=]</b>

REQ(ids=A_15726)<b>A_15726 - (N024.100)e.2 K_TST</b>
PAR Das COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS auf ein TC1 Byte in einem ATR verzichtet. <b>[<=]</b>

REQ(ids=G2_N024.100.e.3)<b>G2_N024.100.e.3 - (N024.100)e.3 K_COS</b>
PAR Wenn das TC1 Byte im ATR vorhanden ist, dann MUSS es den Wert 'FF' besitzen. <b>[<=]</b>

REQ(ids=G2_N024.100.f)<b>G2_N024.100.f - (N024.100)f K_COS</b>
PAR Das COS MUSS im TD1 Byte des ATR das Protokoll T=1 anzeigen. <b>[<=]</b>

REQ(ids=G2_N024.100.g)<b>G2_N024.100.g - (N024.100)g K_COS</b>
PAR Das COS DARF in den ATR KEIN TA2 Byte einstellen. Daraus folgt, dass das COS den "negotiable mode" unterstützt (siehe (N024.220)). <b>[<=]</b>

REQ(ids=G2_N024.100.h)<b>G2_N024.100.h - (N024.100)h K_COS</b>
PAR Das COS MUSS im TA3 Byte den Wert 254 = 'FE' enthalten. Dadurch wird gemäß [ISO/IEC 7816-3#11.4.2] eine "Information Field Size" IFSC = 254 = 'FE' angezeigt. <b>[<=]</b>

REQ(ids=G2_N024.100.i)<b>G2_N024.100.i - (N024.100).i K_COS</b>
PAR Das COS MUSS im ATR einen "class indicator" gemäß [ISO/IEC 7816-3#Tabelle 10] anzeigen. Der "class indicator" MUSS einen Wert aus der Menge {"A und B", "A, B und C"} = {3, 7} haben. <b>[<=]</b>

REQ(ids=G2_N024.100.j)<b>G2_N024.100.j - (N024.100)j K_COS</b>
PAR Wenn das COS im ATR in den Historical Bytes die "Third software function table" gemäß [ISO/IEC 7816-4#Table 119] enthält, dann MUSS die dort angezeigte Anzahl logischer Kanäle kleiner oder gleich der Anzahl maximal unterstützter logischer Kanäle sein. <b>[<=]</b>

PAR (N024.200) Diese Anforderung ist absichtlich leer.
REQ(ids=A_15727)<b>A_15727 - (N024.220) K_COS</b>
PAR Gemäß (N024.100)g zeigt der ATR stets den "negotiable mode" an. Deshalb MUSS das COS das "Protocol-and-Parameter-Selection"-Verfahren gemäß [ISO/IEC 7816-3#9] unterstützen. Im einzelnen bedeutet das: <b>[<=]</b>

REQ(ids=G2_N024.220.a)<b>G2_N024.220.a - (N024.220)a K_COS</b>
PAR Wenn TA1 im ATR den Wert '18' besitzt, dann MUSS das COS in PPS1 einen Wert aus der Menge {'12', '13', '18'} akzeptieren. <b>[<=]</b>

REQ(ids=G2_N024.220.b)<b>G2_N024.220.b - (N024.220)b K_COS</b>
PAR Wenn TA1 im ATR den Wert '95' besitzt, dann MUSS das COS in PPS1 einen Wert aus der Menge {'92', '93', '94', '95'} akzeptieren. <b>[<=]</b>

REQ(ids=G2_N024.220.c)<b>G2_N024.220.c - (N024.220)c K_COS</b>
PAR Wenn TA1 im ATR den Wert '96 besitzt, dann MUSS das COS in PPS1 einen Wert aus der Menge {'92', '93', '94', '95', '96'} akzeptieren. <b>[<=]</b>

REQ(ids=G2_N024.220.d)<b>G2_N024.220.d - (N024.220)d K_COS</b>
PAR Wenn TA1 im ATR den Wert '97 besitzt, dann MUSS das COS in PPS1 einen Wert aus der Menge {'92', '93', '94', '95', '96', '97'} akzeptieren. <b>[<=]</b>

PAR (N024.300) Diese Anforderung ist absichtlich leer.
REQ(ids=G2_N024.320)<b>G2_N024.320 - (N024.320) K_COS</b>
PAR Das COS MUSS bezüglich der Datenübertragung mittels des Blockprotokolls T=1 die Vorgaben aus [EMV®_Book-1#9.2.4] erfüllen und bezüglich der Fehlerbehandlung die Vorgaben aus [ISO/IEC 7816-3#11.6.3] erfüllen. <b>[<=]</b>

PAR (N024.400) Diese Anforderung ist absichtlich leer.
PAR (N024.500) Diese Anforderung ist absichtlich leer.
PAR (N024.600) Diese Anforderung ist absichtlich leer.
PAR -HEADING(ids=11.2.2)11.2.2 CosK_70c Übertragungsprotokoll gemäß [ISO/IEC 7816-12]
PAR Dieses Kapitel behandelt das kontaktbehaftete Übertragungsprotokoll gemäß [ISO/IEC 7816-12]. Dieses Übertragungsprotokolls wird von der Smartcard optional bereitgestellt.
PAR (N024.700) Diese Anforderung ist absichtlich leer.
PAR (N024.800) Diese Anforderung ist absichtlich leer.
REQ(ids=A_15728)<b>A_15728 - (N024.810) K_IC, Option_USB_Schnittstelle</b>
PAR Das IC einer Smartcard MUSS das kontaktbehaftete Übertragungsprotokoll gemäß [ISO/IEC 7816-12] unterstützen, wobei gilt: <b>[<=]</b>

REQ(ids=G2_N024.810.a)<b>G2_N024.810.a - (N024.810)a K_IC, K_COS, Option_USB_Schnittstelle</b>
PAR Das IC und COS einer Smartcard MÜSSEN "Bulk Transfer" gemäß [ISO/IEC 7816-12#8.1] unterstützen. <b>[<=]</b>

REQ(ids=A_15729)<b>A_15729 - (N024.810)b K_TST</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass das COS neben "Bulk Transfer" weitere Übertragungsarten aus [ISO/IEC 7816-12] KÖNNEN<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR Für die Übertragungsgeschwindigkeit des hier betrachteten Protokolls gilt:
REQ(ids=G2_N024.820.a)<b>G2_N024.820.a - (N024.820)a K_IC, Option_USB_Schnittstelle</b>
PAR Das IC MUSS die Übertragungsgeschwindigkeit "Low Speed" unterstützen. <b>[<=]</b>

REQ(ids=A_15730)<b>A_15730 - (N024.820)b K_TST</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass das COS neben der Übertragungsgeschwindingkeit "Low Speed" weitere Übertragungsgeschwindigkeiten<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

PAR (N024.900) Diese Anforderung ist absichtlich leer.
PAR (N025.000) Diese Anforderung ist absichtlich leer.
PAR (N025.100) Diese Anforderung ist absichtlich leer.
PAR -HEADING(ids=11.2.3)11.2.3 CosK_009 Kontaktlose Datenübertragung gemäß ISO/IEC 14443
PAR Dieses Kapitel behandelt die kontaktlose Datenübertragung gemäß ISO/IEC 14443. Die Unterstützung dieser Datenübertragungsart ist optional.
PAR (N025.200) Diese Anforderung ist absichtlich leer.
PAR (N025.300) Diese Anforderung ist absichtlich leer.
REQ(ids=A_15731)<b>A_15731 - (N025.310) K_IC, Option_kontaktlose_Schnittstelle</b>
PAR Das IC einer Smartcard MUSS die kontaktlose Datenübertragung gemäß [ISO/IEC 14443-1], [ISO/IEC 14443-2], [ISO/IEC 14443-3] und [ISO/IEC 14443-4] unterstützen. Dabei gelten folgende Besonderheiten: <b>[<=]</b>

REQ(ids=G2_N025.310.a)<b>G2_N025.310.a - (N025.310)a K_IC, Option_kontaktlose_Schnittstelle</b>
PAR Das IC und das COS MÜSSEN mindestens einen Typ aus der Menge {"Typ A", "Typ B"} unterstützen. <b>[<=]</b>

REQ(ids=G2_N025.310.b.1)<b>G2_N025.310.b.1 - (N025.310)b.1 K_IC, Option_kontaktlose_Schnittstelle</b>
PAR Das IC und das COS MÜSSEN alle Datenraten aus der Menge {f<sub>C</sub> / 128, f<sub>C</sub> / 64, f<sub>C</sub> / 32, f<sub>C</sub> / 16} unterstützen. <b>[<=]</b>

REQ(ids=A_15732)<b>A_15732 - (N025.310)b.2 K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS neben den in (N025.310)b.1 genannten Datenraten weitere Datenraten<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N025.310.c.1)<b>G2_N025.310.c.1 - (N025.310)c.1 K_IC, K_COS, K_Antenne, Option_kontaktlose_Schnittstelle</b>
PAR Die gesamte Karte bestehend aus IC, COS und Antenne im Kartenkörper MUSS alle Datenraten aus der Menge {f<sub>C</sub> / 128} unterstützen. <b>[<=]</b>

REQ(ids=G2_N025.310.c.2)<b>G2_N025.310.c.2 - (N025.310)c.2 K_IC, K_COS, K_Antenne, Option_kontaktlose_Schnittstelle</b>
PAR Die gesamte Karte bestehend aus IC, COS und Antenne im Kartenkörper SOLL alle Datenraten aus der Menge {f<sub>C</sub> / 64, f<sub>C</sub> / 32, f<sub>C</sub> / 16} unterstützen. <b>[<=]</b>

REQ(ids=A_15733)<b>A_15733 - (N025.310)c.3 K_TST</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass eine Karte neben den in (N025.310)c.1 und (N025.310)c.2 genannten Datenraten weitere Datenraten<br>i.  unterstützt oder<br>ii. ablehnt. <b>[<=]</b>

REQ(ids=A_15734)<b>A_15734 - (N025.320) K_IC, K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Das IC einer Smartcardund das COS MÜSSEN bei der kontaktlosen Datenübertragung spätestens mit Beginn der Nutzungsphase (siehe CosK_91f) dynamisch generierte, zufällig gewählte Kennnummern verwenden, siehe dazu<br>a. [ISO/IEC 14443-3#6.5.4] für "Typ A" Smartcard und<br>b. [ISO/IEC 14443-3#7.9.2] für "Typ B" Smartcard <b>[<=]</b>

PAR (N025.400) Diese Anforderung ist absichtlich leer.
PAR (N025.500) Diese Anforderung ist absichtlich leer.
PAR (N025.510) Diese Anforderung ist absichtlich leer.
PAR -HEADING(ids=11.3)11.3 CosK_3b9 OSI-Referenzmodell (informativ)
PAR In Anlehnung an das OSI-Referenzmodell werden hier verschiedene Layer definiert, die an der Bearbeitung einer Nachricht beteiligt sind, welche von einem externen Kommunikationspartner gesendet wurde. Es sei ausdrücklich darauf hingewiesen, dass die Inhalte dieses Abschnittes keine Implementierungsdetails festlegen. Das bedeutet, es ist zulässig, den internen Aufbau eines Smartcard-Betriebssystems oder dessen Kommunikationsaufbau anders zu gestalten. Die normativen Teile dieses Dokumentes lassen sich aber leichter beschreiben und verstehen, wenn man das Folgende zugrunde legt.
PAR In CosA_e09 wird exemplarisch gezeigt, wie eine Kommando-APDU CmdApdu1 vom externen Kommunikationspartner zunächst entsprechend den Konventionen des Übertragungsprotokolls (siehe CosK_458) im physikalischen Layer und im Data Link Layer in einen oder möglicherweise mehrere TPDU zerlegt und im I/O der Smartcard wieder zu einer CmdApdu1 gemäß CosK_ac1 zusammengesetzt wird.
PAR Der nächste Layer verwaltet logische Kanäle (siehe [ISO/IEC 7816-4#5.4.2]) und leitet das empfangene Kommando entsprechend der Kanalnummer im CLA Byte weiter an den entsprechenden logischen Kanal, hier Channel_x.
PAR Im nächsten Layer "SecMes" wird die optional per Secure Messaging gesicherte Kommando-APDU ausgepackt und an den Kommandointerpreter weitergeleitet.
PAR Der Kommandointerpreter verarbeitet die Kommando-APDU und erstellt eine entsprechende Antwort-APDU, welche optional per Secure Messaging gesichert wird. Die eventuell gesicherte Antwort wird im I/O in eine oder mehrere TPDU zerlegt, welche dann über die physikalische Schnittstelle an den externen Kommunikationspartner übermittelt werden.

PAR Abbildung 1, CosA_e09: Message Sequence Chart für die Kommandobearbeitung
PAR -HEADING(ids=11.4)11.4 Kommandobearbeitung
PAR Dieses Kapitel beschreibt die Bearbeitung eines Kommandos, welches von einem externen Kommunikationspartner an das COS gesendet wurde. Es werden die Begriffe aus CosK_3b9 verwendet. Es wird nochmals darauf verwiesen, dass die Inhalte von CosK_3b9 nicht normativ sind. Insofern ist die genaue Zuordnung der normativen Aussagen dieses Kapitels zu Teilen eines COS nicht festgelegt. Wichtig ist aber, dass das Verhalten des COS auf Ebene der physikalischen Schnittstelle den normativen Vorgaben entspricht.
PAR Bei der Bearbeitung einer Kommando-APDU und der Generierung einer Antwort-APDU werden folgende Schritte durchlaufen:
REQ(ids=G2_N025.600)<b>G2_N025.600 - (N025.600) K_externeWelt {K_Karte}</b>
PAR Ein externer Kommunikationspartner sendet über eine physikalische Schnittstelle eine Kommando-APDU CmdApdu1, welche den Vorgaben aus CosK_ac1 entsprechen MUSS. Dazu wird CmdApdu1 auf der physikalischen Schnittstelle entsprechend dem Übertragungsprotokoll (siehe CosK_458) als (eine oder mehrere) TPDU transportiert. <b>[<=]</b>

REQ(ids=G2_N025.650)<b>G2_N025.650 - (N025.650) K_COS</b>
PAR Das I/O der Smartcard MUSS die TPDU zusammensetzen und gewinnt dabei CmdApdu1 zurück. <b>[<=]</b>

REQ(ids=G2_N025.700)<b>G2_N025.700 - (N025.700) K_COS, K_externeWelt {K_Karte}</b>
PAR Das COS MUSS die Fehlerbehandlung auf der physikalischen Schnittstelle gemäß [EMV®_Book-1] umsetzen. <b>[<=]</b>

REQ(ids=G2_N025.800)<b>G2_N025.800 - (N025.800) K_COS</b>
PAR Das COS MUSS anschließend die Kanalnummer aus dem CLA Byte von CmdApdu1 extrahieren. <b>[<=]</b>

REQ(ids=G2_N025.900.a)<b>G2_N025.900.a - (N025.900)a K_COS</b>
PAR Wenn der Kanal mit der Kanalnummer aus dem CLA Byte nicht geöffnet ist, dann MUSS die Bearbeitung des Kommandos terminieren. <b>[<=]</b>

REQ(ids=G2_N025.900.b)<b>G2_N025.900.b - (N025.900)b K_COS</b>
PAR Wenn der Kanal mit der Kanalnummer aus dem CLA Byte nicht geöffnet ist, dann MUSS die RspApdu3 lediglich aus dem Trailer ChannelClosed = '68 81' bestehen. Dies Response APDU enthält in diesem Fall keine Antwortdaten. <b>[<=]</b>

REQ(ids=G2_N026.000)<b>G2_N026.000 - (N026.000) K_COS</b>
PAR Entsprechend der Kanalnummer MUSS CmdApdu1 unverändert als CmdApdu2 an den entsprechenden logischen Kanal weitergeleitet werden. <b>[<=]</b>

PAR (N026.100) Dieser Punkt ist absichtlich leer.
REQ(ids=G2_N026.200)<b>G2_N026.200 - (N026.200) K_COS</b>
PAR Das COS MUSS innerhalb des logischen Kanals CmdApdu2 mit dem entsprechenden Kanalkontext channelContext an den Secure Messaging Layer ("SecMes" in CosA_e09) weiterleiten und dort gemäß CosK_7f6 bearbeiten. Das Ergebnis ist RspApdu2. <b>[<=]</b>

REQ(ids=G2_N026.300)<b>G2_N026.300 - (N026.300) K_COS</b>
PAR Das COS MUSS RspApdu2 MUSS unverändert als RspApdu3 an das I/O der Smartcard schicken. <b>[<=]</b>

REQ(ids=G2_N026.400)<b>G2_N026.400 - (N026.400) K_COS</b>
PAR Das I/O der Smartcard MUSS RspApdu3 gemäß dem verwendeten Übertragungsprotokoll in eine oder mehrere TPDU umwandeln und über die physikalische Schnittstelle senden. <b>[<=]</b>

PAR -HEADING(ids=11.5)11.5 CosK_ac1 Kommando-APDU
PAR -HEADING(ids=11.5.1)11.5.1 CosK_90e Class Byte
PAR Das Class Byte (CLA Byte) enthält die Kommandoklasse. Zusammen mit dem Instruction Byte (siehe CosK_19e) legt es eindeutig das auszuführende Kommando fest.
PAR Welche Kombinationen aus CLA, INS, P1 und P2 zu unterstützen sind, wird in CosK_3a7 festgelegt.
REQ(ids=G2_N026.500)<b>G2_N026.500 - (N026.500) K_externeWelt {K_Karte}</b>
PAR Gemäß [ISO/IEC 7816-3] MUSS das CLA Byte in einem Oktett codiert werden. <b>[<=]</b>

REQ(ids=G2_N026.510)<b>G2_N026.510 - (N026.510) K_COS</b>
PAR Die Bits im CLA Byte MÜSSEN die Bedeutung gemäß CosT_760 oder CosT_67a haben.
PAR (ids=Tabelle-70-,-CosT_760)Tabelle 70 , CosT_760: Codierung des CLA-Bytes für Kanalnummern kleiner vier

TABLE(rows=11,cols=17+17+17+17+17+17+17+17+514)->
TR-> TH(0,0/1/1)->PAR b8 TH(0,1/1/1)->PAR b7 TH(0,2/1/1)->PAR b6 TH(0,3/1/1)->PAR b5 TH(0,4/1/1)->PAR b4 TH(0,5/1/1)->PAR b3 TH(0,6/1/1)->PAR b2 TH(0,7/1/1)->PAR b1 TH(0,8/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR x TD(1,1/1/1)->PAR 0 TD(1,2/1/1)->PAR 0 TD(1,3/1/1)->PAR - TD(1,4/1/1)->PAR - TD(1,5/1/1)->PAR - TD(1,6/1/1)->PAR - TD(1,7/1/1)->PAR - TD(1,8/1/1)->PAR Unterscheidung der Kommandoklasse
TR-> TD(2,0/1/1)->PAR 0 TD(2,1/1/1)->PAR 0 TD(2,2/1/1)->PAR 0 TD(2,3/1/1)->PAR - TD(2,4/1/1)->PAR - TD(2,5/1/1)->PAR - TD(2,6/1/1)->PAR - TD(2,7/1/1)->PAR - TD(2,8/1/1)->PAR Kommando gemäß ISO/IEC 7816
TR-> TD(3,0/1/1)->PAR 1 TD(3,1/1/1)->PAR 0 TD(3,2/1/1)->PAR 0 TD(3,3/1/1)->PAR - TD(3,4/1/1)->PAR - TD(3,5/1/1)->PAR - TD(3,6/1/1)->PAR - TD(3,7/1/1)->PAR - TD(3,8/1/1)->PAR Kommandoerweiterung
TR-> TD(4,0/1/1)->PAR - TD(4,1/1/1)->PAR 0 TD(4,2/1/1)->PAR 0 TD(4,3/1/1)->PAR x TD(4,4/1/1)->PAR - TD(4,5/1/1)->PAR - TD(4,6/1/1)->PAR - TD(4,7/1/1)->PAR - TD(4,8/1/1)->PAR Command Chaining Indikator
TR-> TD(5,0/1/1)->PAR - TD(5,1/1/1)->PAR 0 TD(5,2/1/1)->PAR 0 TD(5,3/1/1)->PAR 0 TD(5,4/1/1)->PAR - TD(5,5/1/1)->PAR - TD(5,6/1/1)->PAR - TD(5,7/1/1)->PAR - TD(5,8/1/1)->PAR Einziges Kommando oder letztes Kommando einer Kette
TR-> TD(6,0/1/1)->PAR - TD(6,1/1/1)->PAR 0 TD(6,2/1/1)->PAR 0 TD(6,3/1/1)->PAR 1 TD(6,4/1/1)->PAR - TD(6,5/1/1)->PAR - TD(6,6/1/1)->PAR - TD(6,7/1/1)->PAR - TD(6,8/1/1)->PAR Nicht letztes Kommando einer Kette
TR-> TD(7,0/1/1)->PAR - TD(7,1/1/1)->PAR 0 TD(7,2/1/1)->PAR 0 TD(7,3/1/1)->PAR - TD(7,4/1/1)->PAR x TD(7,5/1/1)->PAR x TD(7,6/1/1)->PAR - TD(7,7/1/1)->PAR - TD(7,8/1/1)->PAR Secure Messaging Indikator
TR-> TD(8,0/1/1)->PAR - TD(8,1/1/1)->PAR 0 TD(8,2/1/1)->PAR 0 TD(8,3/1/1)->PAR - TD(8,4/1/1)->PAR 1 TD(8,5/1/1)->PAR 1 TD(8,6/1/1)->PAR - TD(8,7/1/1)->PAR - TD(8,8/1/1)->PAR Secure Messaging gemäß CosK_7f6
TR-> TD(9,0/1/1)->PAR - TD(9,1/1/1)->PAR 0 TD(9,2/1/1)->PAR 0 TD(9,3/1/1)->PAR - TD(9,4/1/1)->PAR 0 TD(9,5/1/1)->PAR 0 TD(9,6/1/1)->PAR - TD(9,7/1/1)->PAR - TD(9,8/1/1)->PAR Kein Secure Messaging
TR-> TD(10,0/1/1)->PAR - TD(10,1/1/1)->PAR 0 TD(10,2/1/1)->PAR 0 TD(10,3/1/1)->PAR - TD(10,4/1/1)->PAR - TD(10,5/1/1)->PAR - TD(10,6/1/1)->PAR x TD(10,7/1/1)->PAR x TD(10,8/1/1)->PAR Kanalnummer gemäß [ISO/IEC 7816-4#Tab. 2]
PAR (ids=Tabelle-71-,-CosT_67a)Tabelle 71 , CosT_67a: Codierung des CLA-Bytes für Kanalnummern größer gleich vier

TABLE(rows=11,cols=17+17+17+17+17+17+17+17+514)->
TR-> TH(0,0/1/1)->PAR b8 TH(0,1/1/1)->PAR b7 TH(0,2/1/1)->PAR b6 TH(0,3/1/1)->PAR b5 TH(0,4/1/1)->PAR b4 TH(0,5/1/1)->PAR b3 TH(0,6/1/1)->PAR b2 TH(0,7/1/1)->PAR b1 TH(0,8/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR x TD(1,1/1/1)->PAR 1 TD(1,2/1/1)->PAR - TD(1,3/1/1)->PAR - TD(1,4/1/1)->PAR - TD(1,5/1/1)->PAR - TD(1,6/1/1)->PAR - TD(1,7/1/1)->PAR - TD(1,8/1/1)->PAR Unterscheidung der Kommandoklasse
TR-> TD(2,0/1/1)->PAR 0 TD(2,1/1/1)->PAR 1 TD(2,2/1/1)->PAR - TD(2,3/1/1)->PAR - TD(2,4/1/1)->PAR - TD(2,5/1/1)->PAR - TD(2,6/1/1)->PAR - TD(2,7/1/1)->PAR - TD(2,8/1/1)->PAR Kommando gemäß ISO/IEC 7816
TR-> TD(3,0/1/1)->PAR 1 TD(3,1/1/1)->PAR 1 TD(3,2/1/1)->PAR - TD(3,3/1/1)->PAR - TD(3,4/1/1)->PAR - TD(3,5/1/1)->PAR - TD(3,6/1/1)->PAR - TD(3,7/1/1)->PAR - TD(3,8/1/1)->PAR Kommandoerweiterung
TR-> TD(4,0/1/1)->PAR - TD(4,1/1/1)->PAR 1 TD(4,2/1/1)->PAR x TD(4,3/1/1)->PAR - TD(4,4/1/1)->PAR - TD(4,5/1/1)->PAR - TD(4,6/1/1)->PAR - TD(4,7/1/1)->PAR - TD(4,8/1/1)->PAR Secure Messaging Indikator
TR-> TD(5,0/1/1)->PAR - TD(5,1/1/1)->PAR 1 TD(5,2/1/1)->PAR 1 TD(5,3/1/1)->PAR - TD(5,4/1/1)->PAR - TD(5,5/1/1)->PAR - TD(5,6/1/1)->PAR - TD(5,7/1/1)->PAR - TD(5,8/1/1)->PAR Secure Messaging gemäß CosK_7f6
TR-> TD(6,0/1/1)->PAR - TD(6,1/1/1)->PAR 1 TD(6,2/1/1)->PAR 0 TD(6,3/1/1)->PAR - TD(6,4/1/1)->PAR - TD(6,5/1/1)->PAR - TD(6,6/1/1)->PAR - TD(6,7/1/1)->PAR - TD(6,8/1/1)->PAR Kein Secure Messaging
TR-> TD(7,0/1/1)->PAR - TD(7,1/1/1)->PAR 1 TD(7,2/1/1)->PAR - TD(7,3/1/1)->PAR x TD(7,4/1/1)->PAR - TD(7,5/1/1)->PAR - TD(7,6/1/1)->PAR - TD(7,7/1/1)->PAR - TD(7,8/1/1)->PAR Command Chaining Indikator
TR-> TD(8,0/1/1)->PAR - TD(8,1/1/1)->PAR 1 TD(8,2/1/1)->PAR - TD(8,3/1/1)->PAR 0 TD(8,4/1/1)->PAR - TD(8,5/1/1)->PAR - TD(8,6/1/1)->PAR - TD(8,7/1/1)->PAR - TD(8,8/1/1)->PAR Einziges Kommando oder letztes Kommando einer Kette
TR-> TD(9,0/1/1)->PAR - TD(9,1/1/1)->PAR 1 TD(9,2/1/1)->PAR - TD(9,3/1/1)->PAR 1 TD(9,4/1/1)->PAR - TD(9,5/1/1)->PAR - TD(9,6/1/1)->PAR - TD(9,7/1/1)->PAR - TD(9,8/1/1)->PAR Nicht letztes Kommando einer Kette
TR-> TD(10,0/1/1)->PAR - TD(10,1/1/1)->PAR 1 TD(10,2/1/1)->PAR - TD(10,3/1/1)->PAR - TD(10,4/1/1)->PAR x TD(10,5/1/1)->PAR x TD(10,6/1/1)->PAR x TD(10,7/1/1)->PAR x TD(10,8/1/1)->PAR Kanalnummer gemäß [ISO/IEC 7816-4#Tab. 3]
PAR <b>[<=]</b>

PAR -HEADING(ids=11.5.2)11.5.2 CosK_19e Instruction Byte
PAR Das Instruction Byte (INS Byte) enthält die Codierung für den auszuführenden Befehl. Zusammen mit dem Class Byte (siehe CosK_90e) legt es eindeutig das auszuführende Kommando fest.
PAR Welche Kombinationen aus CLA, INS, P1 und P2 zu unterstützen sind, wird in CosK_3a7 festgelegt.
REQ(ids=A_15735)<b>A_15735 - (N026.600) K_externeWelt {K_Karte}</b>
PAR Gemäß [ISO/IEC 7816-3] MUSS das INS Byte in einem Oktett codiert werden. <b>[<=]</b>

PAR -HEADING(ids=11.5.3)11.5.3 CosK_66b Parameter P1
PAR Der Parameter P1 enthält in der Regel eine Variable, die bei der Kommandoausführung benötigt wird. Die Bedeutung dieses Parameters hängt gewöhnlich von der Kombination aus CLA, INS und P2 ab.
PAR Welche Kombinationen aus CLA, INS, P1 und P2 zu unterstützen sind, wird in CosK_3a7 festgelegt.
REQ(ids=A_15736)<b>A_15736 - (N026.700) K_externeWelt {K_Karte}</b>
PAR Gemäß [ISO/IEC 7816-3] MUSS der Parameter P1 in einem Oktett codiert werden. <b>[<=]</b>

PAR -HEADING(ids=11.5.4)11.5.4 CosK_165 Parameter P2
PAR Der Parameter P2 enthält in der Regel eine Variable, die bei der Kommandoausführung benötigt wird. Die Bedeutung dieses Parameters hängt von der Kombination aus CLA, INS und P1 ab.
PAR Welche Kombinationen aus CLA, INS, P1 und P2 zu unterstützen sind, wird in CosK_3a7 festgelegt.
REQ(ids=A_15737)<b>A_15737 - (N026.800) K_externeWelt {K_Karte}</b>
PAR Gemäß [ISO/IEC 7816-3] MUSS der Parameter P2 in einem Oktett codiert werden. <b>[<=]</b>

PAR -HEADING(ids=11.5.5)11.5.5 CosK_d08 Datenfeld
PAR Das Datenfeld einer Kommando-APDU ist optional. Es ist möglich, dass es fehlt. Das Datenfeld ist ein Oktettstring der Länge Nc. Gemäß [ISO/IEC 7816-3] ist der Definitionsbereich von Nc gleich {1, …, 65535}.
REQ(ids=G2_N026.900.a)<b>G2_N026.900.a - (N026.900)a K_COS</b>
PAR Das COS MUSS für Nc an der Schnittstelle "Interpreter" (siehe CosA_e09) alle Werte unterstützen, die sich aus (N029.892) ergeben. <b>[<=]</b>

REQ(ids=A_15738)<b>A_15738 - (N026.900)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS über den durch (N029.892) definierten Bereich hinaus weitere Werte für Nc<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=G2_N026.900.c)<b>G2_N026.900.c - (N026.900)c K_COS</b>
PAR Ein COS DARF eine APDU NICHT wegen eines Längenfehlers an der Schnittstelle "Interpreter" (siehe CosA_e09) abweisen, wenn<br>1. die Kommando-APDU den Anforderungen aus CosK_ba1 genügt und<br>2. das Datenfeld die Längenbeschränkung aus (N026.900)a oder die gesamte Kommando-APDU die Längenbeschränkung aus EF.ATR erfüllt. <b>[<=]</b>

REQ(ids=A_15739)<b>A_15739 - (N026.910) K_externeWelt {K_Karte}</b>
PAR Der Sender einer Kommando-APDU SOLLMUSS die Längenbeschränkung durch passende Wahl von Nc einhalten. <b>[<=]</b>

PAR Hinweis CosH_576: Die obere Grenze in (N026.900)a gilt für das COS einer Smartcard. Für das IFD (Kartenleser) wird wegen möglicher, zukünftiger Erweiterungen, Entwicklungen und wegen Performanzgewinns empfohlen, größere Werte zu unterstützen.
PAR Hinweis CosH_ce0: Anders als in der Generation 1 ist die obere Grenze in (N026.900)a nicht mehr durch ein bestimmtes Kommando motiviert, welches besonders viele Daten überträgt und sich zudem schlecht auf mehrere Kommandos aufteilen lässt. Die in die (N026.900)a genannte Grenze ergibt sich aus Performanzüberlegungen verbunden mit dem aktuellen Stand der Technik.
PAR -HEADING(ids=11.5.6)11.5.6 CosK_e6a LeFeld
PAR Das LeFeld einer Kommando-APDU ist optional. Es ist möglich, dass es fehlt. Das LeFeld enthält eine Zahl Ne, die angibt, wie viele Oktette im Datenfeld der Antwort-APDU erwartet werden. In diesem Dokument gelten folgende Definitionen:
PAR (ids=Tabelle-72,-CosT_93c)Tabelle 72, CosT_93c: Definition von WildCard-Werten für das LeFeld

TABLE(rows=2,cols=126+621)->
TR-> TD(0,0/1/1)->PAR WildCardShort TD(0,1/1/1)->PAR Dieser Wert wird verwendet, um anzuzeigen, dass innerhalb der Obergrenze von 256 Oktetten alle verfügbaren Oktette in das Datenfeld der Antwortnachricht einzustellen sind.
TR-> TD(1,0/1/1)->PAR WildCardExtended TD(1,1/1/1)->PAR Dieser Wert wird verwendet, um anzuzeigen, dass innerhalb der Obergrenze von 65.536 Oktetten alle verfügbaren Oktette in das Datenfeld der Antwortnachricht einzustellen sind.
PAR Gemäß [ISO/IEC 7816-4] ist der Definitionsbereich für Ne: {1, 2, …, 65.534, 65.535, WildCardShort, WildCardExtended}
REQ(ids=G2_N027.000.a)<b>G2_N027.000.a - (N027.000)a K_COS</b>
PAR Das COS MUSS an der Schnittstelle "Interpreter" (siehe CosA_e09) für Ne alle Werte aus der Menge {1, 2, …, 65.534, 65.535, WildCardShort, WildCardExtended} unterstützen. <b>[<=]</b>

REQ(ids=G2_N027.000.b)<b>G2_N027.000.b - (N027.000)b K_COS</b>
PAR Ein COS DARF eine APDU NICHT wegen eines Längenfehlers an der Schnittstelle "Interpreter" (siehe CosA_e09) abweisen, wenn die Längenbeschränkung aus (N027.000)a oder die gesamte Antwort-APDU die Längenbeschränkung aus EF.ATR erfüllt. <b>[<=]</b>

REQ(ids=A_15740)<b>A_15740 - (N027.010) K_externeWelt {K_Karte}</b>
PAR Der Sender einer Kommando-APDU SOLLMUSS die Längenbeschränkung durch passende Wahl von Ne einhalten. <b>[<=]</b>

PAR Hinweis CosH_317: Die obere Grenze in (N027.000)a gilt für das COS einer Smartcard und (N027.010) gilt für die "externe Welt". Für das IFD (Kartenleser) wird wegen Performanzgewinns empfohlen, ebenfalls die gemäß [ISO/IEC 7816-3] maximal mögliche Länge einer Antwortnachricht zu unterstützen.
PAR Hinweis CosH_b79: Anders als in der Generation 1 ist die obere Grenze in (N027.000)a nicht mehr durch ein bestimmtes Kommando motiviert, welches besonders viele Daten überträgt und sich zudem schlecht auf mehrere Kommandos aufteilen lässt. Im Rahmen dieses Dokumentes ist es das READ BINARY Kommando, welches die größtmögliche Antwortdatenmenge überträgt.
PAR -HEADING(ids=11.6)11.6 CosK_3dc Antwort-APDU
PAR Mit den Definitionen aus den CosK_3c7 und CosK_8a5 ergibt sich für eine Antwort-APDU:
REQ(ids=G2_N027.100)<b>G2_N027.100 - (N027.100) K_COS</b>
PAR Eine Antwort-APDU MUSS ein Oktettstring gemäß 'rspData || Trailer' sein, wobei rspData möglicherweise leer ist. <b>[<=]</b>

PAR -HEADING(ids=11.6.1)11.6.1 CosK_3c7 Datenfeld
PAR Das Datenfeld rspData einer Antwort-APDU ist optional in dem Sinne, dass es möglicherweise leer ist. Es ist möglich, dass es fehlt. Das Datenfeld rspData ist ein Oktettstring der Länge Nr. Gemäß [ISO/IEC 7816-3] ist der Definitionsbereich von Nr {0, 1, …, 65536}.
REQ(ids=A_15787)<b>A_15787 - (N027.200) K_COS</b>
PAR An der Schnittstelle "Interpreter" (siehe CosA_e09) gilt für Nr: Das COS MUSS dafür sorgen, dass Nr kleiner gleich Ne der zugehörigen Kommando-APDU sein. <b>[<=]</b>

REQ(ids=G2_N027.200.a)<b>G2_N027.200.a - (N027.200)a K_COS</b>
PAR Wenn eine Kommando-APDU kein LeFeld besitzt, dann MUSS das COS dafür sorgen, dass Nr = 0 ist. <b>[<=]</b>

REQ(ids=G2_N027.200.b.1)<b>G2_N027.200.b.1 - (N027.200)b.1 K_COS</b>
PAR Wenn eine Kommando-APDU ein LeFeld = '00' = WidlCardShort besitzt, dann MUSS das COS dafür sorgen, dass Nr kleiner gleich '100' = 256 ist. <b>[<=]</b>

REQ(ids=G2_N027.200.b.2)<b>G2_N027.200.b.2 - (N027.200)b.2 K_COS</b>
PAR Wenn eine Kommando-APDU ein LeFeld = '0000' = WildCardExtended besitzt, dann MUSS das COS dafür sorgen, dass Nr kleiner gleich '10000' = 65536 ist. <b>[<=]</b>

REQ(ids=G2_N027.200.b.3)<b>G2_N027.200.b.3 - (N027.200)b.3 K_COS</b>
PAR Wenn eine Kommando-APDU ein LeFeld besitzt und dieses nicht Element der Menge {'00', '0000'} ist, dann MUSS das COS dafür sorgen, dass Nr kleiner gleich OS2I( LeFeld ) ist. <b>[<=]</b>

PAR -HEADING(ids=11.6.2)11.6.2 CosK_8a5 Trailer
PAR Der Trailer zeigt den Status nach Bearbeitung einer Kommandonachricht an. CosT_7aa zeigt die in diesem Dokument definierten Trailer. Der Trailer enthält Statusangaben über die Bearbeitung des Kommandos. Dazu zählen auch Fehlerindikationen.
REQ(ids=A_15788)<b>A_15788 - (N027.210) K_COS</b>
PAR Das COS MUSS den Trailer (siehe [ISO/IEC 7816-4#Tabelle 1]) in zwei Oktetten codieren. <b>[<=]</b>

PAR -HEADING(ids=11.7)11.7 CosK_ba1 Zulässige Kommando-Antwort-Paare
PAR Wie in CosK_d08 und CosK_e6a dargestellt, sind zwei Bestandteile einer Kommando-APDU optional. Daraus ergeben sich vier Kombinationsmöglichkeiten, die im Folgenden beschrieben werden.
PAR -HEADING(ids=11.7.1)11.7.1 CosK_f7e Case 1 Kommando-Antwort-Paar
PAR Im Fall einer Case 1 Kommando-APDU fehlen Datenfeld und LeFeld. Die Kommando-APDU enthält folgende Angaben:
PAR (ids=Tabelle-73,-CosT_2be)Tabelle 73, CosT_2be: Case 1 Kommando-APDU

TABLE(rows=5,cols=65+77+600)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR 'XX' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'XX' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR Erster Parameter
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR Zweiter Parameter
PAR Gemäß den Regeln aus CosK_ac1 werden CLA, INS, P1 und P2 in jeweils einem Oktett codiert. Damit gilt für die gesamte Case 1 Kommando-APDU:
REQ(ids=A_15789)<b>A_15789 - (N027.300) K_externeWelt {K_Karte}</b>
PAR Eine Case 1 Kommando-APDU MUSS aus vier Oktetten bestehen. <b>[<=]</b>

REQ(ids=A_15790)<b>A_15790 - (N027.400) K_externeWelt {K_Karte}</b>
PAR Die vier Oktette einer Case 1 Kommando-APDU MÜSSEN wie folgt konkateniert werden:    <br>CLA   ||   INS   ||   P1   ||   P2. <b>[<=]</b>

PAR Die zu einer Case 1 Kommando-APDU gehörende Antwort-APDU besteht nur aus dem Trailer.
PAR (ids=Tabelle-74,-CosT_d12)Tabelle 74, CosT_d12: Case 1 Antwort-APDU

TABLE(rows=2,cols=115+481)->
TR-> TH(0,0/1/1)->PAR Inhalt TH(0,1/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR Trailer TD(1,1/1/1)->PAR Statusbytes SW1 und SW2
PAR -HEADING(ids=11.7.2)11.7.2 CosK_37c Case 2 Kommando-Antwort-Paar
PAR Im Fall einer Case 2 Kommando-APDU fehlt das Datenfeld. Das LeFeld ist vorhanden. In Abhängigkeit vom Wert Ne, der im LeFeld transportiert wird, werden die Fälle "short" und "extended" unterschieden.
PAR -HEADING(ids=11.7.2.1)11.7.2.1 CosK_80d Case 2 Short Kommando
PAR In diesem Fall enthält das Datenfeld der Antwortnachricht nie mehr als 256 Oktette. Die Kommando-APDU enthält im Fall einer Case 2 Short folgende Angaben:
PAR (ids=Tabelle-75,-CosT_55c)Tabelle 75, CosT_55c: Case 2 Short Kommando-APDU

TABLE(rows=6,cols=52+61+479)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR 'XX' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'XX' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR Erster Parameter
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR Zweiter Parameter
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR 'XX' TD(5,2/1/1)->PAR Ne aus der Menge {1, …, 255, WildCardShort}
PAR Gemäß den Regeln aus CosK_ac1 werden CLA, INS, P1 und P2 in jeweils einem Oktett codiert. Damit gilt für die gesamte Case 2 Short Kommando-APDU:
REQ(ids=A_15791)<b>A_15791 - (N027.500) K_externeWelt {K_Karte}</b>
PAR Eine Case 2 Short Kommando-APDU MUSS aus fünf Oktetten bestehen. <b>[<=]</b>

REQ(ids=A_15792)<b>A_15792 - (N027.600) K_externeWelt {K_Karte}</b>
PAR Der Wert von Ne wird wie folgt in einem Oktett codiert, welches als LeFeld bezeichnet wird:<br>a. Wenn Ne im Intervall [1, 255] liegt, dann MUSS diese ganze Zahl in einem Oktett codiert werden: LeFeld = I2OS( Ne, 1 ).<br>b. Wenn Ne den Wert WildCardShort besitzt, dann MUSS das LeFeld gleich '00' sein. <b>[<=]</b>

REQ(ids=A_15793)<b>A_15793 - (N027.700) K_externeWelt {K_Karte}</b>
PAR Die fünf Oktette einer Case 2 Short Kommando-APDU MÜSSEN wie folgt konkateniert werden:    <br>CLA   ||   INS   ||   P1   ||   P2   ||   LeFeld. <b>[<=]</b>

PAR -HEADING(ids=11.7.2.2)11.7.2.2 CosK_f88 Case 2 Extended Kommando
PAR In diesem Fall enthält das Datenfeld der Antwortnachricht möglicherweise mehr als 256 Oktette. Die Kommando-APDU enthält im Fall einer Case 2 Extended folgende Angaben:
PAR (ids=Tabelle-76,-CosT_12e)Tabelle 76, CosT_12e: Case 2 Extended Kommando-APDU

TABLE(rows=6,cols=52+61+479)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR 'XX' TD(1,2/1/1)->PAR CLA Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'XX' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR Erster Parameter
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR Zweiter Parameter
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR 'XXXX' TD(5,2/1/1)->PAR Ne aus der Menge {256, …, 65535, WildCardExtended}
PAR Gemäß den Regeln aus CosK_ac1 werden CLA, INS, P1 und P2 in jeweils einem Oktett codiert. Damit gilt für die gesamte Case 2 Extended Kommando-APDU:
REQ(ids=A_15794)<b>A_15794 - (N027.800) K_externeWelt {K_Karte}</b>
PAR Eine Case 2 Extended Kommando-APDU MUSS aus sieben Oktetten bestehen. <b>[<=]</b>

REQ(ids=A_15795)<b>A_15795 - (N027.900) K_externeWelt {K_Karte}</b>
PAR Der Wert von Ne wird wie folgt in zwei Oktetten codiert, welche das LeFeld bilden:<br>a. Wenn Ne im Intervall [256, 65535] liegt, dann MUSS diese ganze Zahl in zwei Oktette codiert werden: LeFeld = I2OS( Ne, 2 ).<br>b. Wenn Ne den Wert WildCardExtended besitzt, dann MUSS das LeFeld gleich '0000' sein. <b>[<=]</b>

REQ(ids=A_15796)<b>A_15796 - (N028.000) K_externeWelt {K_Karte}</b>
PAR Die sieben Oktette einer Case 2 Extended Kommando-APDU MÜSSEN wie folgt konkateniert werden:    <br>CLA   ||   INS   ||   P1   ||   P2   ||   '00'  ||   LeFeld. <b>[<=]</b>

PAR Hinweis CosH_d25: Das Oktett '00' nach dem Parameter P2 lässt sich als Indikator für "extended length" auffassen.
PAR -HEADING(ids=11.7.2.3)11.7.2.3 CosK_f8c Case 2 Response
PAR Die zu einer Case 2 Kommando-APDU gehörende Antwort-APDU besteht aus dem optionalen Datenfeld und aus dem Trailer.
PAR (ids=Tabelle-77,-CosT_e50)Tabelle 77, CosT_e50: Case 2 Antwort-APDU

TABLE(rows=3,cols=99+648)->
TR-> TH(0,0/1/1)->PAR Inhalt TH(0,1/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR Daten TD(1,1/1/1)->PAR Optionaler Bestandteil der Antwort-APDU. Wenn vorhanden, dann gelten die Bestimmungen aus CosK_3c7.
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Statusbytes SW1 und SW2
PAR -HEADING(ids=11.7.3)11.7.3 CosK_914 Case 3 Kommando-Antwort-Paare
PAR Im Fall einer Case 3 Kommando-APDU fehlt das LeFeld. Das Datenfeld ist vorhanden. In Abhängigkeit von der Anzahl der Oktette im Datenfeld werden die Fälle "short" und "extended" unterschieden.
PAR -HEADING(ids=11.7.3.1)11.7.3.1 CosK_d83 Case 3 Short Kommando
PAR In diesem Fall enthält das Datenfeld der Kommandonachricht nie mehr als 255 Oktette. Die Kommando-APDU enthält im Fall einer Case 3 Short folgende Angaben:
PAR (ids=Tabelle-78,-CosT_fbc)Tabelle 78, CosT_fbc: Case 3 Short Kommando-APDU

TABLE(rows=6,cols=52+76+465)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR 'XX' TD(1,2/1/1)->PAR CLA Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'XX' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR Erster Parameter
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR Zweiter Parameter
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR Datenfeld mit beliebigen Oktetten, Anzahl Oktette aus dem Intervall [1, 255]
PAR Gemäß den Regeln aus CosK_ac1 werden CLA, INS, P1 und P2 in jeweils einem Oktett codiert. Damit gilt für die gesamte Case 3 Short Kommando-APDU:
REQ(ids=A_15797)<b>A_15797 - (N028.100) K_externeWelt {K_Karte}</b>
PAR Eine Case 3 Short Kommando-APDU MUSS aus fünf Oktetten plus den Oktetten aus dem Datenfeld bestehen. <b>[<=]</b>

REQ(ids=A_15798)<b>A_15798 - (N028.200) K_externeWelt {K_Karte}</b>
PAR Die Anzahl Nc der Oktette des Datenfeldes MUSS in einem Oktett codiert werden, welches als LcFeld bezeichnet wird:<br>LcFeld = I2OS( Nc, 1 ). <b>[<=]</b>

REQ(ids=A_15799)<b>A_15799 - (N028.300) K_externeWelt {K_Karte}</b>
PAR Die fünf plus Nc Oktette einer Case 3 Short Kommando-APDU MÜSSEN wie folgt konkateniert werden:    <br>CLA   ||   INS   ||   P1   ||   P2   ||   LcFeld   ||   Datenfeld. <b>[<=]</b>

PAR -HEADING(ids=11.7.3.2)11.7.3.2 CosK_afd Case 3 Extended Kommando
PAR In diesem Fall enthält das Datenfeld der Kommandonachricht mehr als 255 Oktette. Die Kommando-APDU enthält im Fall einer Case 3 Extended folgende Angaben:
PAR (ids=Tabelle-79,-CosT_740)Tabelle 79, CosT_740: Case 3 Extended Kommando-APDU

TABLE(rows=6,cols=55+76+460)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR 'XX' TD(1,2/1/1)->PAR CLA Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'XX' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR Erster Parameter
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR Zweiter Parameter
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR Datenfeld mit beliebigem Inhalt, Anzahl Oktette aus dem Intervall [256, 65535]
PAR Gemäß den Regeln aus CosK_ac1 werden CLA, INS, P1 und P2 in jeweils einem Oktett codiert. Damit gilt für die gesamte Case 3 Extended Kommando-APDU:
REQ(ids=A_15800)<b>A_15800 - (N028.400) K_externeWelt {K_Karte}</b>
PAR Eine Case 3 Extended Kommando-APDU MUSS aus sieben Oktetten plus den Oktetten aus dem Datenfeld bestehen. <b>[<=]</b>

REQ(ids=A_15801)<b>A_15801 - (N028.500) K_externeWelt {K_Karte}</b>
PAR Die Anzahl Nc der Oktette des Datenfeldes MUSS in zwei Oktette codiert werden, welche als LcFeld bezeichnet werden:<br>LcFeld = I2OS( Nc, 2 ). <b>[<=]</b>

REQ(ids=A_15802)<b>A_15802 - (N028.600) K_externeWelt {K_Karte}</b>
PAR Die sieben plus Nc Oktette einer Case 3 Extended Kommando-APDU MÜSSEN wie folgt konkateniert werden:    <br>CLA   ||   INS   ||   P1   ||   P2   ||   '00'  ||   LcFeld   ||   Datenfeld. <b>[<=]</b>

PAR Hinweis CosH_7c2: Das Oktett '00' nach dem Parameter P2 lässt sich als Indikator für "extended length" auffassen.
PAR -HEADING(ids=11.7.3.3)11.7.3.3 CosK_452 Case 3 Response
PAR Die zu einer Case 3 Kommando-APDU gehörende Antwort-APDU besteht nur aus dem Trailer.
PAR (ids=Tabelle-80,-CosT_42d)Tabelle 80, CosT_42d: Case 3 Antwort-APDU

TABLE(rows=2,cols=127+469)->
TR-> TH(0,0/1/1)->PAR Inhalt TH(0,1/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR Trailer TD(1,1/1/1)->PAR Statusbytes SW1 und SW2
PAR -HEADING(ids=11.7.4)11.7.4 CosK_a2b Case 4 Kommando-Antwort-Paare
PAR Eine Case 4 Kommando-APDU enthält alle optionalen Bestandteile. In Abhängigkeit von der Anzahl der Oktette im Datenfeld der Kommandonachricht und in Abhängigkeit vom Wert Ne, der im LeFeld transportiert wird, werden die Fälle "short" und "extended" unterschieden.
PAR -HEADING(ids=11.7.4.1)11.7.4.1 CosK_876 Case 4 Short Kommando
PAR In diesem Fall enthält das Datenfeld der Kommandonachricht nie mehr als 255 Oktette und das Datenfeld der Antwortnachricht nie mehr als 256 Oktette. Die Kommando-APDU enthält im Fall einer Case 4 Short folgende Angaben:
PAR (ids=Tabelle-81,-CosT_704)Tabelle 81, CosT_704: Case 4 Short Kommando-APDU

TABLE(rows=8,cols=52+72+468)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR 'XX' TD(1,2/1/1)->PAR CLA Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'XX' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR Erster Parameter
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR Zweiter Parameter
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR Datenfeld mit beliebigen Oktetten, Anzahl Oktette aus dem Intervall [1, 255]
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR 'XX' TD(6,2/1/1)->PAR Ne aus der Menge {1, …, 255, WildCardShort}
TR-> TD(7,0/1/2)->PAR Notation TD(7,2/1/1)->PAR CmdApdu = Case4S( CLA, INS, P1, P2, Data, Ne )
PAR Gemäß den Regeln aus CosK_ac1 werden CLA, INS, P1 und P2 in jeweils einem Oktett codiert. Damit gilt für die gesamte Case 4 Short Kommando-APDU:
REQ(ids=A_15803)<b>A_15803 - (N028.700) K_externeWelt {K_Karte}</b>
PAR Eine Case 4 Short Kommando-APDU MUSS aus sechs Oktetten plus den Oktetten aus dem Datenfeld bestehen. <b>[<=]</b>

REQ(ids=A_15804)<b>A_15804 - (N028.800) K_externeWelt {K_Karte}</b>
PAR Die Anzahl Nc der Oktette des Datenfeldes MUSS in einem Oktett codiert werden, welches als LcFeld bezeichnet wird:<br>LcFeld = I2OS( Nc, 1 ). <b>[<=]</b>

REQ(ids=A_15805)<b>A_15805 - (N028.900) K_externeWelt {K_Karte}</b>
PAR Der Wert von Ne wird wie folgt in einem Oktett codiert, welches das LeFeld bildet:<br>a. Wenn Ne im Intervall [1, 255] liegt, dann MUSS diese ganze Zahl in einem Oktett codiert werden: LeFeld = I2OS( Ne, 1 ).<br>b. Wenn Ne den Wert WildCardShort besitzt, dann MUSS das LeFeld gleich '00' sein. <b>[<=]</b>

REQ(ids=A_15806)<b>A_15806 - (N029.000) K_externeWelt {K_Karte}</b>
PAR Die sechs plus Nc Oktette einer Case 4 Short Kommando-APDU MÜSSEN wie folgt konkateniert werden:    <br>CLA   ||   INS   ||   P1   ||   P2   ||   LcFeld   ||   Datenfeld   ||   LeFeld. <b>[<=]</b>

PAR -HEADING(ids=11.7.4.2)11.7.4.2 CosK_265 Case 4 Extended Kommando
PAR In diesem Fall enthält das Datenfeld der Kommandonachricht mehr als 255 Oktette oder es wird erwartet, dass das Datenfeld der Antwortnachricht mehr als 256 Oktette enthält. Die Kommando-APDU enthält im Fall einer Case 4 Extended folgende Angaben:
PAR (ids=Tabelle-82,-CosT_447)Tabelle 82, CosT_447: Case 4 Extended Kommando-APDU

TABLE(rows=8,cols=52+72+468)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR 'XX' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'XX' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR Erster Parameter
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR Zweiter Parameter
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR Datenfeld mit beliebigen Oktetten, Anzahl Oktette aus dem Intervall [1, 65535]
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR 'XXXX' TD(6,2/1/1)->PAR Ne aus der Menge {1, …, 65535, WildCardExtended}
TR-> TD(7,0/1/2)->PAR Notation TD(7,2/1/1)->PAR CmdApdu = Case4E( CLA, INS, P1, P2, Data, Ne )
PAR Gemäß den Regeln aus CosK_ac1 werden CLA, INS, P1 und P2 in jeweils einem Oktett codiert. Damit gilt für die gesamte Case 4 Extended Kommando-APDU:
REQ(ids=A_15807)<b>A_15807 - (N029.100) K_externeWelt {K_Karte}</b>
PAR Eine Case 4 Extended Kommando-APDU MUSS aus neun Oktetten plus den Oktetten aus dem Datenfeld bestehen. <b>[<=]</b>

REQ(ids=A_15808)<b>A_15808 - (N029.200) K_externeWelt {K_Karte}</b>
PAR Die Anzahl Nc der Oktette des Datenfeldes MUSS in zwei Oktetten codiert werden, welche als LcFeld bezeichnet werden:<br>LcFeld = I2OS( Nc, 2 ). <b>[<=]</b>

REQ(ids=A_15809)<b>A_15809 - (N029.300) K_externeWelt {K_Karte}</b>
PAR Der Wert von Ne wird wie folgt in zwei Oktette codiert, welche das LeFeld bilden:<br>a. Wenn Ne im Intervall [1, 65535] liegt, dann MUSS diese ganze Zahl in zwei Oktette codiert werden: LeFeld = I2OS( Ne, 2 ).<br>b. Wenn Ne den Wert WildCardExtended besitzt, dann MUSS das LeFeld gleich '0000' sein. <b>[<=]</b>

REQ(ids=A_15810)<b>A_15810 - (N029.400) K_externeWelt {K_Karte}</b>
PAR Die neun plus Nc Oktette einer Case 4 Extended Kommando-APDU MÜSSEN wie folgt konkateniert werden:    <br>CLA   ||   INS   ||   P1   ||   P2   ||   '00'  ||   LcFeld   ||   Datenfeld   ||   LeFeld. <b>[<=]</b>

PAR Hinweis CosH_67b: Das Oktett '00' nach dem Parameter P2 lässt sich als Indikator für "extended length" auffassen.
PAR -HEADING(ids=11.7.4.3)11.7.4.3 CosK_189 Case 4 Response
PAR Die zu einer Case 4 Kommando-APDU gehörende Antwort-APDU besteht aus dem optionalen Datenfeld und aus dem Trailer.
PAR (ids=Tabelle-83,-CosT_d0a)Tabelle 83, CosT_d0a: Case 4 Antwort-APDU

TABLE(rows=3,cols=87+660)->
TR-> TH(0,0/1/1)->PAR Inhalt TH(0,1/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR Daten TD(1,1/1/1)->PAR Optionaler Bestandteil der Antwort-APDU. Wenn vorhanden, dann gelten die Bestimmungen aus CosK_3c7.
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Statusbytes SW1 und SW2
PAR (N029.500), (N029.600), (N029.610), (N029.700), (N029.800) Diese Anforderungen sind absichtlich leer.
PAR -HEADING(ids=11.8)11.8 CosK_c26 Command Chaining
PAR Gemäß [ISO/IEC 7816-4#5.3.3] ist "Command Chaining" die Möglichkeit, auszudrücken, dass konsekutive Kommando-Antwort-Paare verkettet sind, also zusammen gehören. In diesem Sinne wird der Mechanismus genutzt, um die Teilschritte eines mehrschrittigen Ablaufes als zusammengehörig zu kennzeichnen. Während in [ISO/IEC 7816-4#5.3.3] einige Details offen gelassen werden, gilt für dieses Dokument folgendes Verhalten:
PAR Command Chaining ist eine konsekutive Folge von Kommando-Antwort-Paaren mit folgenden Eigenschaften:
REQ(ids=G2_N029.870.a)<b>G2_N029.870.a - (N029.870)a K_externeWelt {K_Karte}</b>
PAR Mit Ausnahme des Bits b5 im CLA-Byte MÜSSEN alle Kommando-APDU einer Chaining-Kette identische Werte für CLA, INS, P1 und P2 haben. <b>[<=]</b>

REQ(ids=G2_N029.870.b)<b>G2_N029.870.b - (N029.870)b K_externeWelt {K_Karte}</b>
PAR Das Bit b5 im CLA-Byte der letzten Kommando-APDU einer Command-Chaining-Sequenz MUSS den Wert 0 und die Bits b5 aller anderen CLA-Bytes einer Command-Chaining-Sequenz MÜSSEN den Wert 1 haben. <b>[<=]</b>

REQ(ids=G2_N029.870.c)<b>G2_N029.870.c - (N029.870)c K_externeWelt {K_Karte}</b>
PAR Die Aussagen in (N029.870)a und (N029.870)b MÜSSEN für Kommando-APDU an der Schnittstelle "Interface I/O" aus CosA_e09 gelten. <b>[<=]</b>

REQ(ids=A_15811)<b>A_15811 - (N029.874) K_externeWelt {K_Karte}</b>
PAR Die konsekutive Folge einer Command-Chaining-Sequenz SOLLDARF an der Schnittstelle "Interface I/O" aus CosA_e09 NICHT<br>a. durch Kommandos unterbrochen werden, welche nicht zu dieser Sequenz gehören oder<br>b. durch eine Deaktivierung unterbrochen werden. <b>[<=]</b>

REQ(ids=A_15812)<b>A_15812 - (N029.876) K_externeWelt {K_Karte}</b>
PAR Die konsekutive Folge einer Command-Chaining-Sequenz DARF an der Schnittstelle "Interface I/O" aus CosA_e09 NICHT fortgesetz werden, falls ein Kommando der Sequenz mit einem Fehler terminiert. <b>[<=]</b>

REQ(ids=G2_N029.876.a)<b>G2_N029.876.a - (N029.876)a K_externeWelt {K_Karte}</b>
PAR Wenn LOAD APPLICATION mit einem Trailer aus CosT_df0 antwortet, dann DARF die Command-Chaining-Sequenz an der Schnittstelle "Interface I/O" aus CosA_e09 NICHT fortgesetz werden. <b>[<=]</b>

REQ(ids=G2_N029.876.b)<b>G2_N029.876.b - (N029.876)b K_externeWelt {K_Karte}</b>
PAR Wenn GENERAL AUTHENTICATE mit einem Trailer aus CosT_b4e antwortet, dann DARF die Command-Chaining-Sequenz an der Schnittstelle "Interface I/O" aus CosA_e09 NICHT fortgesetz werden. <b>[<=]</b>

REQ(ids=G2_N029.878.a)<b>G2_N029.878.a - (N029.878)a K_COS</b>
PAR Wenn die Anforderung (N029.874)a von der externen Entität nicht eingehalten wird, mithin also die Command-Chaining-Sequenz durch ein Kommando unterbrochen wird, dann MUSS das COS das unterbrechende Kommando akzeptieren. <b>[<=]</b>

REQ(ids=A_15813)<b>A_15813 - (N029.878)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS das Fortsetzen einer unterbrochenen Comman-Chaining-Sequenz akzeptiert. <b>[<=]</b>

REQ(ids=G2_N029.878.c)<b>G2_N029.878.c - (N029.878)c K_COS</b>
PAR Wenn die Anforderung (N029.874)a von der externen Entität nicht eingehalten wird, mithin also die Command-Chaining-Sequenz durch ein Kommando unterbrochen wird, dann SOLL das COS ein Fortsetzen der unterbrochenen Sequenz ablehnen. <b>[<=]</b>

REQ(ids=G2_N029.880.a)<b>G2_N029.880.a - (N029.880)a K_COS</b>
PAR Wenn die Anforderung (N029.876) von der externen Entität nicht eingehalten wird, mithin also die Command-Chaining-Sequenz trotz Fehlers im vorherigen Kommando fortgesetzt wird, dann SOLL das COS ein Fortsetzen der Sequenz ablehnen. <b>[<=]</b>

REQ(ids=A_15814)<b>A_15814 - (N029.880)b K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS das Fortsetzen einer unterbrochenen Comman-Chaining-Sequenz trotz Fehlers im vorherigen Kommando akzeptiert. <b>[<=]</b>

PAR Hinweis CosH_8f7: Es ist gewollt, dass gemäß (N029.870)a alle Kommandos einer Kette dieselbe Kanalnummer aufweisen und die Secure Messaging Bits im CLA-Byte identisch sind. In Verbindung mit (N029.874) folgt daraus, dass Command Chaining nicht durch Kommandos auf anderen logischen Kanälen unterbrechbar ist.
PAR -HEADING(ids=11.9)11.9 CosK_3e8 Längenbeschränkung von APDU
PAR Gemäß [ISO/IEC 7816-4] ist die Länge einer APDU auf rund 64 kByte beschränkt. Zumindest für Kommando-APDU entspricht es dem Stand der Technik, dass diese Grenze wegen der RAM-Speichergrößen heute verfügbarer Halbleiter bei weitem nicht ausgeschöpft wird. Typischerweise zeigt eine Smartcard im EF.ATR an, welche APDU-Längenbeschränkung für diese Smartcard gilt. Dabei werden Werte getrennt nach Kommando- und Antwortnachricht einerseits und andererseits getrennt nach ungeschützter Übertragung und geschützter Übertragung angegeben.
PAR Im folgenden werden Intervalle für die Länge einer Nachricht angegeben. Dabei bedeutet "ungeschützte Kommandonachricht", dass im CLA-Byte kein Secure Messaging angezeigt wird. In diesem Fall wird die korrespondierende Antwortnachricht ebenfalls ungeschützt übertragen. Im Falle einer "geschützten Kommandonachricht" wird im CLA-Byte Secure Messaging angezeigt und die korrespondierende Antwortnachricht wird in der Regel ebenfalls geschützt übertragen.
PAR Für die Längenbeschränkung von Kommando- und Antwortnachrichten gilt:
REQ(ids=G2_N029.890.a.1)<b>G2_N029.890.a.1 - (N029.890)a.1 K_COS</b>
PAR Wenn die Option_logische_Kanäle unterstützt wird, dann MUSS das COS ungeschützte Kommandonachrichten mit einer Länge aus dem Intervall [4, 1033] Oktett unterstützen. <b>[<=]</b>

REQ(ids=A_15815)<b>A_15815 - (N029.890)a.2 K_COS</b>
PAR Wenn die Option_logische_Kanäle unterstützt wird, dann MUSS das COS ungeschützte Antwortnachrichten mit einer Länge aus dem Intervall [2, 32770] Oktett unterstützen. <b>[<=]</b>

REQ(ids=G2_N029.890.a.3)<b>G2_N029.890.a.3 - (N029.890)a.3 K_COS</b>
PAR Wenn die Option_logische_Kanäle unterstützt wird, dann MUSS das COS geschützte Kommandonachrichten mit einer Länge aus dem Intervall [16, 1033] Oktett unterstützen. <b>[<=]</b>

REQ(ids=A_15816)<b>A_15816 - (N029.890)a.4 K_COS</b>
PAR Wenn die Option_logische_Kanäle unterstützt wird, dann MUSS das COS geschützte Antwortnachrichten mit einer Länge aus dem Intervall [16, 1033] Oktett unterstützen. <b>[<=]</b>

REQ(ids=G2_N029.890.b.1)<b>G2_N029.890.b.1 - (N029.890)b.1 K_COS</b>
PAR Wenn die Option_logische_Kanäle nicht unterstützt wird, dann MUSS das COS ungeschützte Kommandonachrichten mit einer Länge aus dem Intervall [4, 2057] Oktett unterstützen. <b>[<=]</b>

REQ(ids=A_15817)<b>A_15817 - (N029.890)b.2 K_COS</b>
PAR Wenn die Option_logische_Kanäle nicht unterstützt wird, dann MUSS das COS ungeschützte Antwortnachrichten mit einer Länge aus dem Intervall [2, 32770] Oktett unterstützen. <b>[<=]</b>

REQ(ids=G2_N029.890.b.3)<b>G2_N029.890.b.3 - (N029.890)b.3 K_COS</b>
PAR Wenn die Option_logische_Kanäle nicht unterstützt wird, dann MUSS das COS geschützte Kommandonachrichten mit einer Länge aus dem Intervall [16, 2057] Oktett unterstützen. <b>[<=]</b>

REQ(ids=A_15818)<b>A_15818 - (N029.890)b.4 K_COS</b>
PAR Wenn die Option_logische_Kanäle nicht unterstützt wird, dann MUSS das COS geschützte Antwortnachrichten mit einer Länge aus dem Intervall [16, 2057] Oktett unterstützen. <b>[<=]</b>

REQ(ids=A_15819)<b>A_15819 - (N029.890)c K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS weitere Werte für die Länge von Nachrichten<br>1. unterstützt oder<br>2. ablehnt. <b>[<=]</b>

REQ(ids=A_15820)<b>A_15820 - (N029.892)a K_Anwendungsspezifikation {K_Karte}</b>
PAR Die Anwendungsspezifikation MUSS ein EF.ATR so spezifizieren, dass

ORDERED-LIST->
LITEM->PAR es als Kindobjekt im Ordner root (siehe (N019.900)a) enthalten ist undLITEM->PAR Längenbeschränkung sowohl für Kommando- und Antwortnachrichten als auch für geschützte und ungeschützte Nachrichten enthält, dabei gelten folgende Definitionen:
ORDERED-LIST->
LITEM->PAR limitCmdPlain ist die maximale Anzahl von Oktetten in einer ungeschützt übertragenen Kommandonachricht.LITEM->PAR limitCmdSecureMessaging ist die maximale Anzahl von Oktetten in einer geschützt übertragenen Kommandonachricht.LITEM->PAR limitRspPlain ist die maximale Anzahl von Oktetten in einer ungeschützt übertragenen Antwortnachricht.LITEM->PAR limitRspSecureMessaging ist die maximale Anzahl von Oktetten in einer geschützt übertragenen Antwortnachricht.
PAR <b>[<=]</b>

REQ(ids=A_15821)<b>A_15821 - (N029.892)b K_Karte</b>
PAR Der Hersteller MUSS die Längenangaben im EF.ATR so wählen, dass sie größer oder gleich den Längenbeschränkungen aus (N029.890) sind. <b>[<=]</b>

PAR -HEADING(ids=12)12 CosK_d0b Kanalkontext (normativ)
PAR Während das Objektsystem gemäß CosK_e16 Informationen bündelt, die persistent in der Smartcard zu speichern sind und in allen logischen Kanälen gleichermaßen zur Verfügung stehen, wird in diesem Kapitel auf die Information eingegangen, die lediglich zwischen Öffnen und Schließen eines logischen Kanals zur Verfügung steht und damit kanalspezifisch ist. Die kanalspezifischen Attribute werden im Objekt channelContext zusammengefasst.
PAR Die im Folgenden genannten Attribute werden typischerweise einem flüchtig (im RAM) gespeicherten Security Environment (siehe CosK_48e) oder Sicherheitsstatus (siehe CosK_aad) zugerechnet, oder durch das in CosK_082 beschriebene Kommando MANAGE SECURITY ENVIRONMENT (restore) verändert.
PAR -HEADING(ids=12.1)12.1 CosK_6b7 Attribute eines logischen Kanals
PAR An der physikalischen Schnittstelle (siehe CosA_e09) verhält sich das COS so, als gäbe es für jeden logischen Kanal ein Objekt channelContext mit den folgenden Attributen:
REQ(ids=A_15825)<b>A_15825 - (N029.900) K_COS</b>
PAR Folgende Attribute von channelContext sind dem Objektsystem zugeordnet: Der channelContext MUSS <b>[<=]</b>

REQ(ids=G2_N029.900.a)<b>G2_N029.900.a - (N029.900)a K_COS</b>
PAR genau ein Attribut currentFolder enthalten, das auf ein Objekt vom Typ Ordner zeigt. <b>[<=]</b>

REQ(ids=G2_N029.900.b)<b>G2_N029.900.b - (N029.900)b K_COS</b>
PAR genau ein Attribut RND.ICC enthalten, welches eine vom COS erzeugte Zufallszahl oder den Wert "NoRandom" speichert (siehe (N086.902)a.8, b.8 und (N099.300)). <b>[<=]</b>

REQ(ids=A_15826)<b>A_15826 - (N029.900)c K_COS</b>
PAR genau eine Liste keyReferenceList besitzen. Jedes Listenelement MUSS einen Wert unterstützen, der anzeigt, dass es leer ist. Die Liste keyReferenceList MUSS sich aus folgenden Elementen zusammensetzen: <b>[<=]</b>

REQ(ids=G2_N029.900.c.1)<b>G2_N029.900.c.1 - (N029.900)c.1 K_COS</b>
PAR           externalAuthenticate, mit den Komponenten keyReference und algorithmIdentifier. <b>[<=]</b>

REQ(ids=G2_N029.900.c.2)<b>G2_N029.900.c.2 - (N029.900)c.2 K_COS</b>
PAR          internalAuthenticate, mit den Komponenten keyReference und algorithmIdentifier. <b>[<=]</b>

REQ(ids=G2_N029.900.c.3)<b>G2_N029.900.c.3 - (N029.900)c.3 K_COS</b>
PAR          verifyCertificate, mit der Komponente keyReference. <b>[<=]</b>

REQ(ids=G2_N029.900.c.4)<b>G2_N029.900.c.4 - (N029.900)c.4 K_COS</b>
PAR          signatureCreation, mit den Komponenten keyReference und algorithmIdentifier. <b>[<=]</b>

REQ(ids=G2_N029.900.c.5)<b>G2_N029.900.c.5 - (N029.900)c.5 K_COS</b>
PAR          dataDecipher, mit den Komponenten keyReference und algorithmIdentifier. <b>[<=]</b>

REQ(ids=G2_N029.900.c.6)<b>G2_N029.900.c.6 - (N029.900)c.6 K_COS</b>
PAR          dataEncipher, mit den Komponenten keyReference und algorithmIdentifier. <b>[<=]</b>

REQ(ids=G2_N029.900.c.7)<b>G2_N029.900.c.7 - (N029.900)c.7 K_COS</b>
PAR          macCalculation mit den Komponenten keyReference und algorithmIdentifier. <b>[<=]</b>

REQ(ids=G2_N029.900.d)<b>G2_N029.900.d - (N029.900)d.(1,2,3,4,5,6,7,8) K_COS</b>
PAR genau ein Attribut SessionkeyContext besitzen, welches folgende Elemente enthält:

ORDERED-LIST->
LITEM->PAR flagSessionEnabled für welches folgender Wertebereich definiert ist:
ORDERED-LIST->
LITEM->PAR noSK zeigt an, dass keine Sessionkeys vorhanden sind.LITEM->PAR SK4SM zeigt an, dass die übrigen Attribute gebrauchsfertiges kryptographisches Material enthalten, welches im Layer SecMes (siehe CosA_e09) zum Entsichern einer Kommando-APDU oder zum Sichern einer Antwort-APDU verwendbar ist.LITEM->PAR SK4TC zeigt an, dass die übrigen Attribute gebrauchsfertiges kryptographisches Material enthalten, welches im Layer CmdInterpreter (siehe CosA_e09) verwendbar ist (beispielsweise im Rahmen von PSO-Kommandos).LITEM->PAR Kenc ist ein symmetrischer Schlüssel zur Ver- und Entschlüsselung.LITEM->PAR Kmac ist ein symmetrischer Schlüssel zur MAC-Berechnung und MAC-Verifikation.LITEM->PAR Dieser Punkt ist absichtlich leer.SSCenc ist eine nicht-negative, ganze Zahl, die als Send Sequence Counter im Zusammenhang mit Kenc verwendet wird.LITEM->PAR SSCmac ist eine nicht-negative, ganze Zahl, die als Send Sequence Counter im Zusammenhang mit Kmac verwendet wird.LITEM->PAR flagCmdEnc ist eine boolesche Variable, welche anzeigt, ob die gesicherte Kommando-APDU ein Datenobjekt mit verschlüsselten Kommandodaten enthält. Dieses Flag wird in (N031.700)a.1 mit einem Wert versehen und in (N022.600)b ausgewertet.LITEM->PAR flagRspEnc ist eine boolesche Variable, welche anzeigt, ob die Daten einer Antwort-APDU verschlüsselt übertragen werden. Das Flag wird in (N022.600)d mit einem Wert versehen und in (N033.700) bzw. (N033.800) ausgewertet.LITEM->PAR negotiationKeyInformation ist eine Variable, welche Informationen zum Schlüssel enthält, der an der Etablierung der Sessionkeys beteiligt war. Dabei sind folgende Fälle zu unterscheiden: negotiationKeyInformation enthält
ORDERED-LIST->
LITEM->PAR eine Schlüsselreferenz gemäß (N099.600) auf das beteiligte Authentisierunsobjekt, wenn dieses folgenden Typ besitzt:<br>A. symmetrischem Authentisierungsobjekt (siehe CosK_5fa).<br>B. symmetrisches Kartenverbindungsobjekt (siehe CosK_24a).LITEM->PAR accessRight gemäß (N019.700) des beteiligten Schlüsselobjektes, wenn dieses folgenden Typ besitzt: öffentliches Authentisierungsobjekt (siehe CosK_17c).
PAR <b>[<=]</b>

REQ(ids=G2_N029.900.d.9)<b>G2_N029.900.d.9 - (N029.900)d.9 K_COS, Option_Kryptobox</b>

ORDERED-LIST->

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR accessRulesSessionkeys ist eine Variable vom Typ interfaceDependentAccessRules (siehe CosK_b03), welche die Zugriffsregeln enthält, die im Rahmen einer Trusted-Channel-Unterstützung ausgewertet werden, siehe (N087.244), (N090.200), (N091.650)b und (N096.364).LITEM->PAR folderSessionkeys ist eine Variable, die angibt, welchem Ordner die Sessionkeys zugeordnet sind.
PAR <b>[<=]</b>

REQ(ids=G2_N029.900.e.1)<b>G2_N029.900.e.1 - (N029.900)e.1 K_COS</b>
PAR genau eine Liste globalSecurityList besitzen, wobei das COS für die Länge der Liste alle Werte aus dem Intervall [0, 3] unterstützen MUSS. <b>[<=]</b>

REQ(ids=A_15827)<b>A_15827 - (N029.900)e.2 K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS bezüglich globalSecurityList längere Listen unterstützt.<br> <b>[<=]</b>

REQ(ids=G2_N029.900.f.1)<b>G2_N029.900.f.1 - (N029.900)f.1 K_COS</b>
PAR genau eine Liste dfSpecificSecurityList besitzen, wobei das COS für die Länge der Liste alle Werte aus dem Intervall [0, 3] unterstützen MUSS. <b>[<=]</b>

REQ(ids=A_15828)<b>A_15828 - (N029.900)f.2 K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS bezüglich dfSpecificSecurityList längere Listen unterstützt.<br> <b>[<=]</b>

REQ(ids=A_15829)<b>A_15829 - (N029.900)g K_COS</b>
PAR Jedes Element der Liste globalSecurityList und jedes Element der Liste dfSpecificSecurityList MUSS entweder <b>[<=]</b>

PAR (N029.900)g.1 ist absichtlich leer.
REQ(ids=G2_N029.900.g.1)<b>G2_N029.900.g.1 - (N029.900)g.1 K_COS</b>
PAR Option_RSA_CVC, ein CHA gemäß (N019.700)a sein in Verbindung mit einer Referenz zu einem Ordner, wodurch angezeigt wird, dass eine erfolgreiche Komponentenauthentisierung gemäß (N084.400)b oder (N084.400)c stattgefunden hat mit einem Schlüsselobjekt aus vorgenanntem Ordner, dem dieses Schlüsselobjekt zugeordnet ist (siehe (N021.600) und (N095.900)d), <b>[<=]</b>

REQ(ids=G2_N029.900.g.2)<b>G2_N029.900.g.2 - (N029.900)g.2 K_COS</b>
PAR eine Referenz auf ein symmetrisches Authentisierungsobjekt (siehe CosK_5fa) sein, wodurch angezeigt wird, dass eine erfolgreiche Komponentenauthentisierung gemäß (N084.402)a, b oder (N084.410)a, b stattgefunden hat, oder <b>[<=]</b>

REQ(ids=G2_N029.900.g.3)<b>G2_N029.900.g.3 - (N029.900)g.3 K_COS Option_kontaktlose_Schnittstelle</b>
PAR eine Referenz auf ein symmetrisches Kartenverbindungsobjekt (siehe CosK_24a) sein, wodurch angezeigt wird, dass eine erfolgreiche Komponentenauthentisierung gemäß CosK_580 stattgefunden hat. <b>[<=]</b>

REQ(ids=G2_N029.900.h.1)<b>G2_N029.900.h.1 - (N029.900)h.1 K_COS</b>
PAR genau eine Liste bitSecurityList besitzen, wobei das COS für die Länge der Liste alle Werte aus dem Intervall [0, 1] unterstützen MUSS. <b>[<=]</b>

REQ(ids=A_15830)<b>A_15830 - (N029.900)h.2 K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS bezüglich bitSecurityList längere Listen unterstützt. <b>[<=]</b>

REQ(ids=G2_N029.900.h.3)<b>G2_N029.900.h.3 - (N029.900)h.3 K_COS</b>
PAR Jedes Element der Liste bitSecurityList MUSS ein CHAT sein in Verbindung mit einer Referenz zu einem Ordner, wodurch angezeigt wird, dass eine erfolgreiche Komponentenauthentisierung gemäß (N084.400)a oder (N085.054) oder (N085.056) stattgefunden hat mit einem Schlüsselobjekt aus vorgenanntem Ordner, dem dieses Schlüsselobjekt zugeordnet ist (siehe (N021.600) und (N095.900)d.1). <b>[<=]</b>

REQ(ids=G2_N029.900.i.1)<b>G2_N029.900.i.1 - (N029.900)i.1 K_COS</b>
PAR genau eine Liste globalPasswordList besitzen, wobei das COS für die Länge der Liste alle Werte aus dem Intervall [0, 4] unterstützen MUSS. <b>[<=]</b>

REQ(ids=A_15831)<b>A_15831 - (N029.900)i.2 K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS bezüglich globalPasswordList längere Listen unterstützt. <b>[<=]</b>

REQ(ids=G2_N029.900.j.1)<b>G2_N029.900.j.1 - (N029.900)j.1 K_COS</b>
PAR genau eine Liste dfSpecificPasswordList besitzen, wobei das COS für die Länge der Liste alle Werte aus dem Intervall [0, 4] unterstützen MUSS. <b>[<=]</b>

REQ(ids=A_15832)<b>A_15832 - (N029.900)j.2 K_TST</b>
PAR Ein COS KANN Für die funktionale Eignung MUSS es zulässig sein, dass das COS bezüglich dfSpecificPasswordList längere Listen unterstützt. <b>[<=]</b>

REQ(ids=G2_N029.900.k)<b>G2_N029.900.k - (N029.900)k K_COS</b>
PAR Jedes Element der Liste globalPasswordList und jedes Element der Liste dfSpecificPasswordList MUSS genau ein Attribut securityStatusEvaluationCounter sein in Verbindung mit einer Referenz auf ein Passwortobjekt, wodurch angezeigt wird, dass eine erfolgreiche Benutzerverifikation gemäß (N082.200) mit diesem Passwortobjekt stattgefunden hat. <b>[<=]</b>

REQ(ids=G2_N029.900.l.1)<b>G2_N029.900.l.1 - (N029.900)l.1 K_COS</b>
PAR Der Wertebereich von securityStatusEvaluationCounter MUSS alle Werte von startSsec (siehe (N015.800)c.2) umfassen. <b>[<=]</b>

REQ(ids=A_15834)<b>A_15834 - (N029.900)l.2 K_TST</b>
PAR Für die funktionale Eignung MUSS es zulässig sein, dass das COS bezüglich securityStatusEvaluationCounter weitere Werte<br>i.  untertstützt, oder<br>ii. ablehnt.<br> <b>[<=]</b>

REQ(ids=G2_N029.900.m)<b>G2_N029.900.m - (N029.900)m K_COS</b>
PAR genau ein Attribut currentEF enthalten, das<br>1. entweder unbestimmt ist,<br>2. oder auf ein Listenelement von currentFolder.children vom Typ Datei zeigt. <b>[<=]</b>

REQ(ids=A_15835)<b>A_15835 - (N030.000) K_COS</b>
PAR Folgende Attribute von channelContext sind einem Ordner zugeordnet: Der channelContext MUSS für jeden Ordner im Objektsystem <b>[<=]</b>

REQ(ids=G2_N030.000.a)<b>G2_N030.000.a - (N030.000)a K_COS</b>
PAR genau ein Attribut seIdentifier gemäß (N007.900) enthalten. <b>[<=]</b>

REQ(ids=G2_N030.010)<b>G2_N030.010 - (N030.010) K_COS, Option_logische_Kanäle</b>
PAR Das COS MUSS mindestens vier logische Kanäle unterstützen. Das heißt neben dem Basiskanal sind mindestens drei weitere logische Kanäle zu unterstützen. <b>[<=]</b>

PAR -HEADING(ids=12.2)12.2 CosK_b33 Reset-Verhalten
PAR Ein "neuer" Kanalkontext gemäß CosK_6b7 wird dann etabliert, wenn ein Reset durchgeführt wird, oder ein neuer logischer Kanal geöffnet wird. Dann gilt:
REQ(ids=A_15838)<b>A_15838 - (N030.000) K_COS</b>
PAR Wenn der logische Kanal mit der Kanalnummer null (Basiskanal) durch <b>[<=]</b>

REQ(ids=A_17516)<b>A_17516 - (N030.100)a K_externeWelt {K_Karte}</b>
PAR Einschalten des physikalischen Interfaces, das heißt <b>[<=]</b>

REQ(ids=G2_N030.100.a.1)<b>G2_N030.100.a.1 - (N030.100)a.1 K_externeWelt {K_Karte}</b>
PAR für das Übertragungsprotokoll T=1 gemäß [ISO/IEC 7816-3#11] wird eine Aktivierung gemäß (N023.920)a durchgeführt, <b>[<=]</b>

REQ(ids=G2_N030.100.a.2)<b>G2_N030.100.a.2 - (N030.100)a.2 K_externeWelt {K_Karte}</b>
PAR für das USB-Übertragungsprotokoll gemäß CosK_70c wird eine Aktivierung gemäß [ISO/IEC 7816-12] durchgeführt, <b>[<=]</b>

REQ(ids=G2_N030.100.a.3)<b>G2_N030.100.a.3 - (N030.100)a.3 K_externeWelt {K_Karte}</b>
PAR für die kontaktlose Datenübertragung gemäß CosK_009 wird eine Aktivierung gemäß ISO/IEC 14443 durchgeführt <b>[<=]</b>

REQ(ids=G2_N030.100.b)<b>G2_N030.100.b - (N030.100)b K_externeWelt {K_Karte}</b>
PAR durch einen Warm-Reset gemäß (N023.920)c <b>[<=]</b>

PAR geöffnet wird oder ein anderer logischer Kanal durch das Kommando MANAGE CHANNEL geöffnet wird (siehe (N099.508)), oder ein logischer Kanal zurückgesetzt wird (siehe (N099.524) und (N099.532)) dann MUSS für den betroffenen Kanal gelten:
REQ(ids=G2_N030.100.c)<b>G2_N030.100.c - (N030.100)c K_COS</b>
PAR Dem betroffenen logischen Kanal MUSS exklusiv ein Kanalkontext gemäß CosK_6b7 zugeordnet werden. <b>[<=]</b>

REQ(ids=G2_N030.100.d)<b>G2_N030.100.d - (N030.100)d K_COS</b>
PAR Das Attribut currentFolder MUSS auf root gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N030.100.e)<b>G2_N030.100.e - (N030.100)e K_COS</b>
PAR Das Attribut RND.ICC MUSS auf den Wert "NoRandom" gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N030.100.f)<b>G2_N030.100.f - (N030.100)f K_COS</b>
PAR Das Attribut keyReferenceList MUSS so gesetzt werden, dass alle Elemente leer sind. <b>[<=]</b>

REQ(ids=G2_N030.100.g)<b>G2_N030.100.g - (N030.100)g K_COS</b>
PAR Das Attribut SessionkeyContext.flagSessionEnabled MUSS auf noSK gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N030.100.h)<b>G2_N030.100.h - (N030.100)h K_COS</b>
PAR Die Liste globalSecurityList MUSS leer sein. <b>[<=]</b>

REQ(ids=G2_N030.100.i)<b>G2_N030.100.i - (N030.100)i K_COS</b>
PAR Die Liste dfSpecificSecurityList MUSS leer sein. <b>[<=]</b>

REQ(ids=G2_N030.100.j)<b>G2_N030.100.j - (N030.100)j K_COS</b>
PAR Das Attribut bitSecurityList MUSS leer sein. <b>[<=]</b>

REQ(ids=G2_N030.100.k)<b>G2_N030.100.k - (N030.100)k K_COS</b>
PAR Die Liste globalPasswordList MUSS leer sein. <b>[<=]</b>

REQ(ids=G2_N030.100.l)<b>G2_N030.100.l - (N030.100)l K_COS</b>
PAR Die Liste dfSpecificPasswordList MUSS leer sein. <b>[<=]</b>

REQ(ids=G2_N030.100.m.1)<b>G2_N030.100.m.1 - (N030.100)m.1 K_COS</b>
PAR Für alle Ordner gilt: seIdentifier MUSS auf den Wert eins gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N030.100.n)<b>G2_N030.100.n - (N030.100)n K_COS</b>
PAR Das Attribut currentEF MUSS auf den Wert "unbestimmt" gesetzt werden. <b>[<=]</b>

PAR Hinweis CosH_3bf: In (N030.100) sind absichtlich keine Zustände oder Zustandsübergänge aus ISO/IEC 14443 aufgeführt. Daraus folgt, dass mit Ausnahme des Zustandsübergangs nach "POWER-OFF" kein Kanalkontext durch Zustandsübergänge beeinflusst wird.
PAR -HEADING(ids=12.3)12.3 Setzen eines Sicherheitsstatus
PAR Die hier beschriebene Routine setzt den Sicherheitsstatus des als Parameter übergebenen Authentisierungsschlüssels.
PAR (ids=Tabelle-84,-CosT_e4d)Tabelle 84, CosT_e4d: Definition der Funkton setSecurityStatus(...)

TABLE(rows=3,cols=78+71+442)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR obj TD(0,2/1/1)->PAR Ein Schlüsselobjekt
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR – TD(1,2/1/1)->PAR Kein Rückgabewert
TR-> TD(2,0/1/1)->PAR Notation: TD(2,1/1/1)-> TD(2,2/1/1)->PAR setSecurityStatus( obj )
REQ(ids=G2_N030.200.a)<b>G2_N030.200.a - (N030.200)a K_COS</b>
PAR Wenn obj im Ordner root (siehe (N019.900)a) in der Liste children eingetragen ist, dann MUSS tmpList = globalSecurityList gelten (siehe (N029.900)e). <b>[<=]</b>

REQ(ids=G2_N030.200.b)<b>G2_N030.200.b - (N030.200)b K_COS</b>
PAR Wenn obj einem von root (siehe (N019.900)a) verschiedenen Ordner zugeordnet ist, dann MUSS tmpList = dfSpecificSecurityList gelten (siehe (N029.900)f). <b>[<=]</b>

REQ(ids=G2_N030.300.a.1)<b>G2_N030.300.a.1 - (N030.300)a.1 K_COS</b>
PAR Wenn obj ein symmetrisches Authentisierungsobjekt (siehe CosK_5fa) oder ein symmetrisches Kartenverbindungsobjekt (siehe CosK_24a) und obj in der Liste tmpList bereits vorhanden ist, dann MUSS dieser Algorithmus beendet werden. <b>[<=]</b>

REQ(ids=G2_N030.300.a.2)<b>G2_N030.300.a.2 - (N030.300)a.2 K_COS</b>
PAR Wenn obj ein symmetrisches Authentisierungsobjekt (siehe CosK_5fa) oder ein symmetrisches Kartenverbindungsobjekt (siehe CosK_24a) und obj in der Liste tmpList noch nicht vorhanden ist, dann MUSS obj am Anfang von tmpList eingetragen werden. <b>[<=]</b>

PAR (N030.300)b ist absichtlich leer.
REQ(ids=G2_N030.300.b.1)<b>G2_N030.300.b.1 - (N030.300)b.1 K_COS, Option_RSA_CVC</b>
PAR Wenn obj ein öffentliches Authentisierungsobjekt (siehe CosK_17c) ist und obj.publicKey ein RSA-Schlüssel ist und obj.CHA (siehe (N019.700)a) in der Liste tmpList bereits vorhanden ist, dann MUSS dieser Algorithmus beendet werden. <b>[<=]</b>

REQ(ids=G2_N030.300.b.2)<b>G2_N030.300.b.2 - (N030.300)b.2 K_COS, Option_RSA_CVC</b>
PAR Wenn obj ein öffentliches Authentisierungsobjekt (siehe CosK_17c) ist und obj.publicKey ein RSA-Schlüssel ist und obj.CHA (siehe (N019.700)a) in der Liste tmpList noch nicht vorhanden ist, dann MUSS obj.CHA am Anfang von tmpList eingetragen werden zusammen mit einem Verweis auf den Ordner, der auch obj enthält. Dadurch wird der Sicherheitsstatus von obj.CHA demselben Ordner zugeordnet, der auch obj enthält.  <b>[<=]</b>

REQ(ids=G2_N030.300.c)<b>G2_N030.300.c - (N030.300)c K_COS</b>
PAR Wenn tmpList durch Eintragungen länger wurde, als vom COS unterstützt, dann MUSS das COS das letzte Listenelement (hier als objLast bezeichnet) mittels clearSecurityStatusKey( objLast ) entfernen (FIFO = first in first out). <b>[<=]</b>

REQ(ids=A_15839)<b>A_15839 - (N030.400) K_COS</b>
PAR Wenn obj ein öffentliches Authentisierungsobjekt (siehe CosK_17c) ist und obj.publicKey ein ELC-Schlüssel ist und obj.CHAT (siehe (N019.700)b.1) in der Liste bitSecurityList (siehe (N029.900)h) <b>[<=]</b>

REQ(ids=G2_N030.400.a)<b>G2_N030.400.a - (N030.400)a K_COS</b>
PAR bereits vorhanden ist, dann MUSS dieser Algorithmus beendet werden. <b>[<=]</b>

REQ(ids=G2_N030.400.b)<b>G2_N030.400.b - (N030.400)b K_COS</b>
PAR noch nicht vorhanden ist, dann MUSS obj.CHAT am Anfang von bitSecurityList eingetragen werden zusammen mit einem Verweis auf den Ordner, der auch obj enthält. Dadurch wird der Sicherheitsstatus von obj.CHAT demselben Ordner zugeordnet, der auch obj enthält. <b>[<=]</b>

REQ(ids=G2_N030.400.c)<b>G2_N030.400.c - (N030.400)c K_COS</b>
PAR Wenn bitSecurityList durch Eintragungen länger wurde, als vom COS unterstützt, dann MUSS das COS das letzte Listenelement (hier als objLast bezeichnet) mittels clearSecurityStatusKey( objLast ) entfernen (FIFO = first in first out). <b>[<=]</b>

PAR -HEADING(ids=12.4)12.4 Löschen eines Sicherheitsstatus
PAR -HEADING(ids=12.4.1)12.4.1 Löschen des Sicherheitszustandes eines Schlüssels
PAR Die hier beschriebene Routine löscht den Sicherheitsstatus des als Parameter übergebenen Authentisierungsschlüssels.
PAR (ids=Tabelle-85,-CosT_489)Tabelle 85, CosT_489: Definition der Funktion clearSecurityStatusKey(...) für Authentisierungsschlüssel

TABLE(rows=3,cols=78+72+444)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR obj TD(0,2/1/1)->PAR Ein Schlüsselobjekt
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR – TD(1,2/1/1)->PAR Kein Rückgabewert
TR-> TD(2,0/1/1)->PAR Notation: TD(2,1/1/1)-> TD(2,2/1/1)->PAR clearSecurityStatusKey( obj )
REQ(ids=G2_N030.500.a)<b>G2_N030.500.a - (N030.500)a K_COS</b>
PAR Wenn obj im Ordner root (siehe (N019.900)a) in der Liste children eingetragen ist, dann MUSS tmpList = globalSecurityList gelten (siehe (N029.900)e). <b>[<=]</b>

REQ(ids=G2_N030.500.b)<b>G2_N030.500.b - (N030.500)b K_COS</b>
PAR Wenn obj einem von root (siehe (N019.900)a) verschiedenen Ordner zugeordnet ist, dann MUSS tmpList = dfSpecificSecurityList gelten (siehe (N029.900)f). <b>[<=]</b>

REQ(ids=G2_N030.600.a.1)<b>G2_N030.600.a.1 - (N030.600)a.1 K_COS</b>
PAR Wenn obj ein symmetrisches Authentisierungsobjekt (siehe CosK_5fa) oder ein symmetrisches Kartenverbindungsobjekt (siehe CosK_24a) und obj in der Liste tmpList nicht vorhanden ist, dann MUSS dieser Algorithmus beendet werden. <b>[<=]</b>

REQ(ids=G2_N030.600.a.2)<b>G2_N030.600.a.2 - (N030.600)a.2 K_COS</b>
PAR Wenn obj ein symmetrisches Authentisierungsobjekt (siehe CosK_5fa) oder ein symmetrisches Kartenverbindungsobjekt (siehe CosK_24a) und obj in der Liste tmpList noch vorhanden ist, dann MUSS obj aus tmpList entfernt werden. <b>[<=]</b>

REQ(ids=A_15840)<b>A_15840 - (N030.600)b K_COS</b>
PAR Wenn obj ein öffentliches Authentisierungsobjekt (siehe CosK_17c) ist und obj.publicKey ein <b>[<=]</b>

PAR (N030.600)b.1 ist absichtlich leer.
REQ(ids=G2_N030.600.b.1.i)<b>G2_N030.600.b.1.i - (N030.600)b.1.i K_COS, Option_RSA_CVC</b>
PAR RSA-Schlüssel ist und obj.CHA (siehe (N019.700)a) in der Liste tmpList nicht vorhanden ist, dann MUSS dieser Algorithmus beendet werden. <b>[<=]</b>

REQ(ids=G2_N030.600.b.1.ii)<b>G2_N030.600.b.1.ii - (N030.600)b.1.ii K_COS, Option_RSA_CVC</b>
PAR RSA-Schlüssel ist und obj.CHA (siehe (N019.700)a) in der Liste tmpList noch vorhanden ist, dann MUSS obj.CHA aus tmpList entfernt werden. <b>[<=]</b>

REQ(ids=G2_N030.600.b.2.i)<b>G2_N030.600.b.2.i - (N030.600)b.2.i K_COS</b>
PAR ELC-Schlüssel ist und obj.CHAT (siehe (N019.700)b.1) in der Liste bitSecurityList (siehe (N029.900)h) nicht vorhanden ist, dann MUSS dieser Algorithmus beendet werden. <b>[<=]</b>

REQ(ids=G2_N030.600.b.2.ii)<b>G2_N030.600.b.2.ii - (N030.600)b.2.ii K_COS</b>
PAR ELC-Schlüssel ist und obj.CHAT (siehe (N019.700)b.1) in der Liste bitSecurityList (siehe (N029.900)h) noch vorhanden ist, dannMUSS obj.CHAT aus bitSecurityList entfernt werden. <b>[<=]</b>

REQ(ids=G2_N030.600.c)<b>G2_N030.600.c - (N030.600)c K_TST</b>
PAR einen anderen Typ besitzt, dann DARF einem Prüfling die funktionale Eignung NICHT mit der Begründung verwehrt werden er reagiere herstellerspezifisch auf einen Schlüsseltyp, der in diesem Dokument nicht behandelt wird. <b>[<=]</b>

REQ(ids=G2_N030.700)<b>G2_N030.700 - (N030.700) K_COS</b>
PAR Wenn der Sicherheitszustand eines Schlüssels gelöscht wurde, der an der Aushandlung von Sessionkeys beteiligt war, dann MUSS SessionkeyContext.flagSessionEnabled (siehe (N029.900)d.1) auf den Wert noSK gesetzt werden. <b>[<=]</b>

PAR -HEADING(ids=12.4.2)12.4.2 Löschen der Sicherheitszustände eines Ordners
PAR Die hier beschriebene Routine löscht die Sicherheitszustände aller Schlüssel, welche dem als Parameter übergebenen Ordner zugeordnet sind.
PAR (ids=Tabelle-86,-CosT_956)Tabelle 86, CosT_956: Definition der Funktion clearSecurityStatus(...) für Ordner

TABLE(rows=3,cols=78+72+444)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR obj TD(0,2/1/1)->PAR Ein Ordner (siehe CosK_fd2)
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR – TD(1,2/1/1)->PAR Kein Rückgabewert
TR-> TD(2,0/1/1)->PAR Notation: TD(2,1/1/1)-> TD(2,2/1/1)->PAR clearSecurityStatusFolder( obj )
REQ(ids=G2_N030.720)<b>G2_N030.720 - (N030.720) K_COS</b>
PAR Die dem Ordner obj zugeordneten Sicherheitszustände von Schlüsseln sind wie folgt zu löschen: Jedes Element in globalSecurityList (siehe (N029.900)e) und in dfSpecificSecurityList (siehe (N029.900)f) und in bitSecurityList (siehe (N029.900)h) MUSS mittels clearSecurityStatusKey(…) aus den genannten Listen entfernt werden, falls es obj zugeordnet ist. <b>[<=]</b>

PAR -HEADING(ids=12.4.3)12.4.3 Löschen von Sessionkeys
PAR Die hier beschriebene Routine löscht den Sicherheitsstatus, welcher bei der Aushandlung von Sessionkeys gesetzt wurde.
PAR (ids=Tabelle-87,-CosT_e7c)Tabelle 87, CosT_e7c: Definition der Funktion clearSessionkeys()

TABLE(rows=3,cols=78+72+444)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR – TD(0,2/1/1)->PAR Kein Parameter
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR – TD(1,2/1/1)->PAR Kein Rückgabewert
TR-> TD(2,0/1/1)->PAR Notation: TD(2,1/1/1)-> TD(2,2/1/1)->PAR clearSessionkeys( )
PAR Der Sicherheitszustand, welcher bei der Aushandlung von Sessionkeys gesetzt wurde, ist wie folgt zu löschen:
REQ(ids=G2_N030.740.a)<b>G2_N030.740.a - (N030.740)a K_COS</b>
PAR Das Elementen in globalSecurityList (siehe (N029.900)e) oder dfSpecificSecurityList (siehe (N029.900)f) oder bitSecurityList (siehe (N029.900)h) MUSS aus den genannten Listen entfernt werden, welches an der Aushandlung der Sessionkeys beteiligt war. <b>[<=]</b>

REQ(ids=G2_N030.740.b)<b>G2_N030.740.b - (N030.740)b K_COS</b>
PAR SessionkeyContext.flagSessionEnabled (siehe (N029.900)d.1) MUSS auf den Wert noSK gesetzt werden. <b>[<=]</b>

PAR -HEADING(ids=12.5)12.5 Setzen eines Passwortstatus
PAR Die hier beschriebene Routine setzt den Sicherheitsstatus des als Parameter übergebenen Passwortes.
PAR (ids=Tabelle-88,-CosT_1ba)Tabelle 88, CosT_1ba: Definition der Funktion setPasswordStatus(...)

TABLE(rows=3,cols=78+72+444)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR obj TD(0,2/1/1)->PAR Ein Passowrtobjekt
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR – TD(1,2/1/1)->PAR Kein Rückgabewert
TR-> TD(2,0/1/1)->PAR Notation: TD(2,1/1/1)-> TD(2,2/1/1)->PAR setPasswordStatus( obj )
REQ(ids=G2_N030.800.a)<b>G2_N030.800.a - (N030.800)a K_COS</b>
PAR Wenn obj im Ordner root (siehe (N019.900)a) in der Liste children eingetragen ist, dann MUSS tmpList = globalPasswordList gelten (siehe (N029.900)i). <b>[<=]</b>

REQ(ids=G2_N030.800.b)<b>G2_N030.800.b - (N030.800)b K_COS</b>
PAR Wenn obj einem von root (siehe (N019.900)a) verschiedenen Ordner zugeordnet ist, dann MUSS tmpList = dfSpecificPasswordList gelten (siehe (N029.900)j). <b>[<=]</b>

REQ(ids=G2_N030.900.a)<b>G2_N030.900.a - (N030.900)a K_COS</b>
PAR Wenn obj in der Liste tmpList bereits vorhanden ist, dann MUSS zunächst clearPasswordStatus(obj) und dann (N030.900)b ausgeführt werden. <b>[<=]</b>

REQ(ids=G2_N030.900.b)<b>G2_N030.900.b - (N030.900)b K_COS</b>
PAR Wenn obj in der Liste tmpList noch nicht vorhanden ist, dann MUSS obj am Anfang von tmpList eingetragen werden. Dabei MUSS das Attribut securityStatusEvaluationCounter des neuen Listenelementes in tmpList (siehe (N029.900)k) auf den Wert startSsec (siehe (N015.800)c.2) gesetzt werden, der aus obj.startSsecList (siehe (N015.800)) unter Berücksichtigung von seIdentifier aus (N015.800)c.1 und seIdentifier aus (N030.000)a ermittelt wird. Dabei MUSS in (N030.000) der Ordner zu Grunde gelegt werden, der obj enthält. <b>[<=]</b>

REQ(ids=G2_N031.000)<b>G2_N031.000 - (N031.000) K_COS</b>
PAR Wenn tmpList durch Eintragungen länger wurde, als vom COS unterstützt, dann MUSS das COS das letzte Listenelement entfernen (FIFO = first in first out). <b>[<=]</b>

REQ(ids=G2_N031.100)<b>G2_N031.100 - (N031.100) K_COS</b>
PAR Im Eintrag zu obj in tmpList MUSS das Attribut securityStatusEvaluationCounter auf den Wert obj.startSsec gesetzt werden. <b>[<=]</b>

PAR -HEADING(ids=12.6)12.6 Löschen eines Passwortstatus
PAR Die hier beschriebene Routine löscht den Sicherheitsstatus des als Parameter übergebenen Passwortes.
PAR (ids=Tabelle-89,-CosT_f93)Tabelle 89, CosT_f93: Definition der Funktion clearPasswordStatus(...)

TABLE(rows=3,cols=78+72+444)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR obj TD(0,2/1/1)->PAR Ein Passwortobjekt
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR – TD(1,2/1/1)->PAR Kein Rückgabewert
TR-> TD(2,0/1/1)->PAR Notation: TD(2,1/1/1)-> TD(2,2/1/1)->PAR clearPasswordStatus( obj )
REQ(ids=G2_N031.200.a)<b>G2_N031.200.a - (N031.200)a K_COS</b>
PAR Wenn obj im Ordner root (siehe (N019.900)a) in der Liste children eingetragen ist, dann MUSS tmpList = globalPasswordList gelten (siehe (N029.900)i). <b>[<=]</b>

REQ(ids=G2_N031.200.b)<b>G2_N031.200.b - (N031.200)b</b>
PAR Wenn obj einem von root (siehe (N019.900)a) verschiedenen Ordner zugeordnet ist, dann MUSS tmpList = dfSpecificPasswordList gelten (siehe (N029.900)j). <b>[<=]</b>

REQ(ids=G2_N031.300.a)<b>G2_N031.300.a - (N031.300)a K_COS</b>
PAR Wenn obj in der Liste tmpList nicht vorhanden ist, dann MUSS dieser Algorithmus beendet werden. <b>[<=]</b>

REQ(ids=G2_N031.300.b)<b>G2_N031.300.b - (N031.300)b K_COS</b>
PAR Wenn obj in der Liste tmpList noch vorhanden ist, dann MUSS obj aus tmpList entfernt werden. <b>[<=]</b>

PAR -HEADING(ids=13)13 CosK_2ff Gesicherte Kommunikation (normativ)
PAR -HEADING(ids=13.1)13.1 Secure Messaging Layer
PAR Dieses Unterkapitel beschreibt die Funktionsweise des Layers "SecMes" in CosA_e09. Dieser Layer benutzt neben den Informationen aus (N029.900)d folgende weitere Attribute:
PAR (ids=Tabelle-90,-CosT_a2e)Tabelle 90, CosT_a2e: Definition von Oktettstring zur Schlüsselableitung

TABLE(rows=2,cols=33+393)->
TR-> TD(0,0/1/1)->PAR KD.i TD(0,1/1/1)->PAR ein Oktettstring, der eine vom COS generierte Zufallszahl speichert, die im Rahmen der Ableitung von Sessionkeys verwendet wird
TR-> TD(1,0/1/1)->PAR KD.e TD(1,1/1/1)->PAR ein Oktettstring, der eine extern generierte Zufallszahl speichert, die im Rahmen der Ableitung von Sessionkeys verwendet wird
PAR -HEADING(ids=13.1.1)13.1.1 Ableitung von Sessionkeys
PAR (ids=Tabelle-91,-CosT_b83)Tabelle 91, CosT_b83: Definition der Funktion SessionkeyDerivation()

TABLE(rows=4,cols=78+17+498)->
TR-> TD(0,0/1/1)->PAR Input: TD(0,1/1/1)->PAR – TD(0,2/1/1)->PAR Der benötigte Input wird dem channelContext entnommen
TR-> TD(1,0/1/1)->PAR Output: TD(1,1/1/1)->PAR – TD(1,2/1/1)->PAR Kein Output vorhanden
TR-> TD(2,0/1/1)->PAR Errors: TD(2,1/1/1)->PAR – TD(2,2/1/1)->PAR Keine
TR-> TD(3,0/1/1)->PAR Notation: TD(3,1/1/1)-> TD(3,2/1/1)->PAR SessionkeyDerivation()
PAR Im Folgenden gelten die Definitionen:
PAR (ids=Tabelle-92,-CosT_d73)Tabelle 92, CosT_d73: Definitionen im Rahmen der Ableitung von Sessionkeys

TABLE(rows=4,cols=51+17+676)->
TR-> TD(0,0/1/1)->PAR algId TD(0,1/1/1)->PAR = TD(0,2/1/1)->PAR channelContext.keyReferenceList.externalAuthenticate.algorithmIdentifier<br>oder<br>channelContext.keyReferenceList.internalAuthenticate.algorithmIdentifier
TR-> TD(1,0/1/1)->PAR PrK TD(1,1/1/1)->PAR = TD(1,2/1/1)->PAR an der Authentisierung beteiligter privater Schlüssel, referenziert in     <br>channelContext.keyReferenceList.internalAuthenticate.keyReference
TR-> TD(2,0/1/1)->PAR PuK TD(2,1/1/1)->PAR = TD(2,2/1/1)->PAR an der Authentisierung beteiligter öffentlicher Schlüssel
TR-> TD(3,0/1/1)->PAR SK TD(3,1/1/1)->PAR = TD(3,2/1/1)->PAR an der Authentisierung beteiligter symmetrischer Schlüssel, referenziert in<br>channelContext.keyReferenceList.externalAuthenticate.keyReference
PAR Hinweis CosH_e5c: Bei der Aushandlung von Sessionkeys sind zwei Fälle zu unterscheiden: Entweder die Sessionkeyaushandlung erfolgte mittels

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR symmetrischer Schlüssel, dann ist aus den obigen Definitionen SK relevant und sowohl PrK als auch PuK sind irrelevant, oderLITEM->PAR die Sessionkeyaushandlung erfolgte mittels asymmetrischer Schlüssel, dann ist aus den obigen Definitionen SK irrelevant und sowohl PrK als auch PuK sind relevant.
REQ(ids=A_15843)<b>A_15843 - (N031.390) K_COS</b>
PAR Das Attribut SessionkeyContext.negotiationKeyInformation MUSS wie folgt gesetzt werden: <b>[<=]</b>

REQ(ids=G2_N031.390.a)<b>G2_N031.390.a - (N031.390)a K_COS</b>
PAR Wenn die Sessionkeys asymmetrisch ausgehandelt wurden, dann gilt:<br>SessionkeyContext.negotiationKeyInformation = PuK.accessRights. <b>[<=]</b>

REQ(ids=G2_N031.390.b)<b>G2_N031.390.b - (N031.390)b K_COS</b>
PAR Wenn die Sessionkeys symmetrisch ausgehandelt wurden, dann gilt:    <br>SessionkeyContext.negotiationKeyInformation = channelContext.keyReferenceList.externalAuthenticate.keyReference. <b>[<=]</b>

PAR (N031.400) ist absichtlich leer.
REQ(ids=A_15844)<b>A_15844 - (N031.400) K_COS, Option_DES</b>
PAR Wenn der an der Aushandlung beteiligte Aushandlungsschlüssel die Aushandlung von 3TDES-Schlüsseln impliziert, dann MUSS für die Attribute aus SessionkeyContext gelten: <b>[<=]</b>

REQ(ids=G2_N031.400.a)<b>G2_N031.400.a - (N031.400)a K_COS, Option_DES</b>
PAR (Kenc, SSCenc, Kmac, SSCmac) = KeyDerivation_3TDES(KD.i   XOR   KD.e). <b>[<=]</b>

REQ(ids=G2_N031.400.b)<b>G2_N031.400.b - (N031.400)b K_COS, Option_DES</b>
PAR Für algIDSessionkey in (N031.522) MUSS dann algIDSessionkey = desSessionkey gelten. <b>[<=]</b>

REQ(ids=A_15845)<b>A_15845 - (N031.500) K_COS</b>
PAR Wenn der an der Aushandlung beteiligte Aushandlungsschlüssel die Aushandlung von AES-Schlüsseln impliziert, dann MUSS für die Attribute aus SessionkeyContext gelten: Wenn die Sessionkeys <b>[<=]</b>

REQ(ids=G2_N031.500.a.1)<b>G2_N031.500.a.1 - (N031.500)a.1 K_COS</b>
PAR symmetrisch ausgehandelt wurden und SK ein AES-128 Schlüssel ist, dann gilt:<br>        (Kenc, Kmac, SSCmac) = KeyDerivation_AES128(KD.i  XOR  KD.e). <b>[<=]</b>

REQ(ids=G2_N031.500.a.2)<b>G2_N031.500.a.2 - (N031.500)a.2 K_COS</b>
PAR symmetrisch ausgehandelt wurden und SK ein AES-192 Schlüssel ist, dann gilt:<br>        (Kenc, Kmac, SSCmac) = KeyDerivation_AES192(KD.i  XOR  KD.e). <b>[<=]</b>

REQ(ids=G2_N031.500.a.3)<b>G2_N031.500.a.3 - (N031.500)a.3 K_COS</b>
PAR symmetrisch ausgehandelt wurden und SK ein AES-256 Schlüssel ist, dann gilt:<br>        (Kenc, Kmac, SSCmac) = KeyDerivation_AES256KD.i  XOR  KD.e). <b>[<=]</b>

REQ(ids=G2_N031.500.b.1)<b>G2_N031.500.b.1 - (N031.500)b.1 K_COS</b>
PAR asymmetrisch ausgehandelt wurden und PrK.domainParameter gleich brainpoolP256r1 ist, dann gilt:<br>        (Kenc, Kmac, SSCmac) = KeyDerivation_AES128(KD.i  XOR  KD.e). <b>[<=]</b>

REQ(ids=G2_N031.500.b.2)<b>G2_N031.500.b.2 - (N031.500)b.2 K_COS</b>
PAR asymmetrisch ausgehandelt wurden und PrK.domainParameter gleich brainpoolP384r1 ist, dann gilt:<br>        (Kenc, Kmac, SSCmac) = KeyDerivation_AES192(KD.i  XOR  KD.e). <b>[<=]</b>

REQ(ids=G2_N031.500.b.3)<b>G2_N031.500.b.3 - (N031.500)b.3 K_COS</b>
PAR asymmetrisch ausgehandelt wurden und PrK.domainParameter gleich brainpoolP512r1 ist, dann gilt:<br>        (Kenc, Kmac, SSCmac) = KeyDerivation_AES256KD.i  XOR  KD.e). <b>[<=]</b>

REQ(ids=G2_N031.500.c.1)<b>G2_N031.500.c.1 - (N031.500)c.1 K_COS</b>
PAR mittels PACE ausgehandelt wurden und channelContext.keyReferenceList.externalAuthenticate.algID ist Element der Menge<br>{id-PACE-ECDH-GM-AES-CBC-CMAC-128, id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-128}    <br>        (Kenc, Kmac, SSCmac) = KeyDerivation_AES128(KD.i  XOR  KD.e). <b>[<=]</b>

REQ(ids=G2_N031.500.c.2)<b>G2_N031.500.c.2 - (N031.500)c.2 K_COS</b>
PAR mittels PACE ausgehandelt wurden und channelContext.keyReferenceList.externalAuthenticate.algID ist Element der Menge<br>{id-PACE-ECDH-GM-AES-CBC-CMAC-192, id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-192}<br>        (Kenc, Kmac, SSCmac) = KeyDerivation_AES192(KD.i  XOR  KD.e). <b>[<=]</b>

REQ(ids=G2_N031.500.c.3)<b>G2_N031.500.c.3 - (N031.500)c.3 K_COS</b>
PAR mittels PACE ausgehandelt wurden und channelContext.keyReferenceList.externalAuthenticate.algID ist Element der Menge<br>{id-PACE-ECDH-GM-AES-CBC-CMAC-256, id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-256}<br>        (Kenc, Kmac, SSCmac) = KeyDerivation_AES256KD.i  XOR  KD.e). <b>[<=]</b>

REQ(ids=G2_N031.500.d)<b>G2_N031.500.d - (N031.500)d K_COS</b>
PAR Für algIDSessionkey in (N031.522) MUSS dann algIDSessionkey = aesSessionkey gelten. <b>[<=]</b>

REQ(ids=A_15847)<b>A_15847 - (N031.520) K_COS</b>
PAR Wenn algId anzeigt, dass die Sessionkeys im Rahmen von Secure Messaging einzusetzen sind, dann MUSS gesetzt werden <b>[<=]</b>

REQ(ids=G2_N031.520.a)<b>G2_N031.520.a - (N031.520)a K_COS</b>
PAR SessionkeyContext.flagSessionEnabled = SK4SM und <b>[<=]</b>

REQ(ids=A_15848)<b>A_15848 - (N031.520)b K_COS</b>
PAR SessionkeyContext.accessRulesSessionkeys auf einen beliebigen Wert, weil die Zugriffsregeln der Sessionkeys im Rahmen dieser Spezifikation nicht ausgewertet werden (vergleiche auch (N031.522)b). <b>[<=]</b>

REQ(ids=A_15849)<b>A_15849 - (N031.522) K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn algId anzeigt, dass die Sessionkeys den Betrieb eines Trusted Channels zu unterstützen haben, dann MÜSSEN mit algIDSessionkey aus (N031.400)b bzw. (N031.500)d folgende Änderungen am channelContext vorgenommen werden: <b>[<=]</b>

REQ(ids=G2_N031.522.a)<b>G2_N031.522.a - (N031.522)a K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR setze SessionkeyContext.flagSessionEnabled = SK4TC. <b>[<=]</b>

REQ(ids=G2_N031.522.b.1)<b>G2_N031.522.b.1 - (N031.522)b.1 K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR setze SessionkeyContext.accessRulesSessionkeys gleich SK.accessRulesSessionkeys falls die Sessionkeys symmetrisch vereinbart wurden. <b>[<=]</b>

REQ(ids=G2_N031.522.b.2)<b>G2_N031.522.b.2 - (N031.522)b.2 K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR setze SessionkeyContext.accessRulesSessionkeys gleich PrK.accessRulesSessionkeys, falls die Sessionkeys asymmetrisch vereinbart wurden. <b>[<=]</b>

REQ(ids=G2_N031.522.c)<b>G2_N031.522.c - (N031.522)c K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR setze SessionkeyContext.folderSessionkeys so, dass dadurch die Sessionkeys demselben Ordner zugeordnet werden wie SK bzw. PrK. <b>[<=]</b>

REQ(ids=G2_N031.522.d)<b>G2_N031.522.d - (N031.522)d K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR trage in channelContext.keyReferenceList.dataDecipher eine herstellerspezifische keyReference und algorithmReference = algIDSessionkey ein. <b>[<=]</b>

REQ(ids=G2_N031.522.e)<b>G2_N031.522.e - (N031.522)e K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR trage in channelContext.keyReferenceList.dataEncipher eine herstellerspezifische keyReference und algorithmReference = algIDSessionkey ein. <b>[<=]</b>

REQ(ids=G2_N031.522.f)<b>G2_N031.522.f - (N031.522)f K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR trage in channelContext.keyReferenceList.macCalculation eine herstellerspezifische keyReference und algorithmReference = algIDSessionkey ein. <b>[<=]</b>

PAR -HEADING(ids=13.1.2)13.1.2 CosK_7f6 Bearbeitung einer Kommando-APDU
PAR Dieses Kapitel beschreibt die generische Bearbeitung eines Kommandos. Hier, wie auch in CosK_3a7 werden gelegentlich kanalspezifische Angaben benötigt, wie etwa currentFolder. Auf eine spezielle Kennzeichnung, dass damit der Wert aus dem Kanalkontext channelContext des logischen Kanals zu nehmen ist, der im CLA-Byte angezeigt wird, wird der Übersichtlichkeit halber verzichtet.
REQ(ids=A_15855)<b>A_15855 - (N031.600)a K_COS</b>
PAR Wenn im CLA-Byte kein Secure Messaging angezeigt wird (siehe [ISO/IEC 7816-4#5.4.1]) und SessionkeyContext.flagSessionEnabled den Wert SK4SM besitzt, dann MUSS das COS folgende zwei Schritte ausführen: <b>[<=]</b>

REQ(ids=G2_N031.600.a.1)<b>G2_N031.600.a.1 - (N031.600)a.1 K_COS</b>
PAR Schritt 1: Das COS MUSS den Sicherheitszustand des zugehörigen Aushandlungsschlüssels mittels clearSessionkeys() zurücksetzen (siehe CosK_e7c). <b>[<=]</b>

REQ(ids=G2_N031.600.a.2)<b>G2_N031.600.a.2 - (N031.600)a.2 K_COS</b>
PAR Schritt 2: Das COS MUSS CmdApdu3 = CmdApdu2 setzen. <b>[<=]</b>

REQ(ids=G2_N031.600.b)<b>G2_N031.600.b - (N031.600)b K_COS</b>
PAR Wenn im CLA-Byte kein Secure Messaging angezeigt wird (siehe [ISO/IEC 7816-4#5.4.1]) und SessionkeyContext.flagSessionEnabled einen anderen den Wert als SK4SM besitzt, dann MUSS CmdApdu3 = CmdApdu2 gesetzt werden. <b>[<=]</b>

REQ(ids=A_15856)<b>A_15856 - (N031.700)a K_COS</b>
PAR Wenn im CLA-Byte Secure Messaging angezeigt wird und SessionkeyContext.flagSessionEnabled besitzt den Wert SK4SM, dann MUSS das COS folgende zwei Schritte ausführen: <b>[<=]</b>

REQ(ids=A_15857)<b>A_15857 - (N031.700)a.1.i K_externeWelt {K_Karte}</b>
PAR Die externe Welt MUSS die gesicherte Kommanod-APDU CmdApdu2 gemäß den Vorgaben aus CosK_842 codieren. <b>[<=]</b>

REQ(ids=G2_N031.700.a.1)<b>G2_N031.700.a.1 - (N031.700)a.1.ii K_COS</b>
PAR Schritt 1: Wenn ein DO mit Tag = '87' in der CmdApdu2 vorhanden ist, dann MUSS flagCmdEnc auf True gesetzt werden, sonst auf False. <b>[<=]</b>

REQ(ids=A_15858)<b>A_15858 - (N031.700)a.1.iii K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden Secure Messaging Formate, die verschieden sind von den Vorgaben in CosK_842, würden<br>A. unterstützt oder<br>B. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N031.700.a.2)<b>G2_N031.700.a.2 - (N031.700)a.2 K_COS</b>
PAR Schritt 2: Das COS MUSS CmdApdu3 mittels der Umkehroperation zu den Regeln in CosK_842 aus CmdApdu2 berechnen. Wenn dabei ein Fehler festgestellt wird, genau dann

ORDERED-LIST->

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR MUSS der Sicherheitszustand des zugehörigen Aushandlungsschlüssels mittels clearSessionkeys() zurückgesetzt werden (siehe CosK_e7c)LITEM->PAR MUSS die Bearbeitung des Kommandos terminieren.LITEM->PAR RspApdu2 enthält in diesem Fall keine Antwortdaten und besteht lediglich aus dem Trailer IncorrectSmDo = '69 88'.
PAR <b>[<=]</b>

REQ(ids=G2_N031.700.b)<b>G2_N031.700.b - (N031.700)b K_COS</b>
PAR Wenn im CLA-Byte Secure Messaging angezeigt wird und SessionkeyContext.flagSessionEnabled einen anderen Wert als SK4SM, besitzt, dann MUSS

ORDERED-LIST->
LITEM->PAR die Bearbeitung des Kommandos terminieren.LITEM->PAR RspApdu2 DARF in diesem Fall NICHT mehr als den Trailer IncorrectSmDo = '69 88' enthalten. Das bedeutet, dass RspApdu2 in diesem Fall keine Antwortdaten enthält.
PAR <b>[<=]</b>

REQ(ids=G2_N031.800)<b>G2_N031.800 - (N031.800) K_COS</b>
PAR Das COS MUSS die vom Secure Messaging Layer ("SecMes" in CosA_e09) gegebenenfalls weitergeleitete CmdApdu3 gemäß den Vorgaben aus CosK_3a7 bearbeiten, wobei eine Antwortnachricht-RspApdu1 entsteht. <b>[<=]</b>

PAR Hinweis CosH_46d: In CosK_3a7 wird davon ausgegangen, dass der Secure Messaging Layer CmdApdu3 so aufbereitet, dass im CLA-Byte kein Secure Messaging angezeigt wird und die Kanalnummer auf null gesetzt wird.
REQ(ids=G2_N031.900.a)<b>G2_N031.900.a - (N031.900)a K_COS</b>
PAR Wenn SessionkeyContext.flagSessionEnabled den Wert SK4SM besitzt, dann MUSS die ungesicherte RspApdu1 gemäß den Vorgaben aus CosK_c3a in die gesicherte RspApdu2 umgewandelt werden. <b>[<=]</b>

REQ(ids=G2_N031.900.b)<b>G2_N031.900.b - (N031.900)b K_COS</b>
PAR Wenn SessionkeyContext.flagSessionEnabled einen anderen Wert als SK4SM besitzt, dann MUSS RspApdu2 = RspApdu1 gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N031.920)<b>G2_N031.920 - (N031.920) K_COS</b>
PAR Wenn sowohl KD.i, als auch KD.e vorhanden sind (einer oder beide Werte wurden mit dem gerade bearbeiteten Kommando gesetzt), dann<br>a. MUSS SessionkeyContext mittels SessionkeyDerivation() geändert werden (siehe CosT_b83) und anschließend<br>b. MÜSSEN KD.i und KD.e auf den Wert "nicht vorhanden" gesetzt werden. <b>[<=]</b>

PAR Während der Kommandobearbeitung ist es möglich, dass Fälle eintreten, die eine weitere Bearbeitung von Kommandos verhindern. Dieser Zustand ist wie folgt gekennzeichnet: Die Kommando-APDU CmdApdu1 in CosA_e09 wird nicht mit einer korrespondierenden Antwort-APDU RspApdu3 beantwortet. Gemäß den in CosK_581 beschriebenen Übertragungsprotokollen ist es dann nicht möglich, eine weitere Kommando-APDU zu schicken.
REQ(ids=A_15859)<b>A_15859 - (N031.940)a K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er sende in diesem Zustand WTX-Requests über "Interface physical" in CosA_e09. <b>[<=]</b>

REQ(ids=A_15860)<b>A_15860 - (N031.940)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er sende in diesem Zustand keine WTX-Requests über "Interface physical" in CosA_e09. <b>[<=]</b>

REQ(ids=A_15861)<b>A_15861 - (N031.940)c) K_COS</b>
PAR Das COS MUSS diesen Zustand durch einen Reset verlassen. <b>[<=]</b>

PAR Hinweis CosH_095: Wenn zum Zeitpunkt des Resets eine Transaktion offen ist (siehe CosK_c9b), dann ist es möglich, dass im Rahmen eines Roll-Forward oder eines Roll-Back Fälle eintreten, die eine weitere Bearbeitung von Kommandos verhindern.
PAR -HEADING(ids=13.2)13.2 CosK_842 Sicherung einer Kommando-APDU
PAR Dieses Unterkapitel beschreibt, wie eine gemäß CosK_ac1 strukturierte Kommando-APDU zu sichern ist. Die hier beschriebenen Regeln richten sich an die Instanz, welche Kommando-APDU sendet. Das COS führt die entsprechenden Umkehroperationen durch.
PAR Generell wird hier ein Subset der Regeln aus [ISO/IEC 7816-4#10] beschrieben, wobei

LIST->
LITEM->PAR alle Kommando-APDU mit Integritätsschutz übertragen werden,LITEM->PAR der Kommandoheader stets mit Integritätsschutz übertragen wird,LITEM->PAR Kommandodaten als Klartext oder verschlüsselt übertragen werden.
PAR Hier sei angemerkt, dass der Sender zwar die Wahl hat zwischen der Übertragung von Kommandodaten im Klartext oder als Chiffrat, aber die Zugriffsregel gegebenenfalls eine verschlüsselte Übertragung erzwingt.
PAR Wie in CosK_ac1 beschrieben, besteht eine Kommando-APDU generisch betrachtet aus den Oktetten CLA, INS, P1 und P2 sowie aus dem optionalen Datenfeld Data und dem optionalen LeFeld. Somit gelten folgende Definitionen:
PAR (ids=Tabelle-93,-CosT_281)Tabelle 93, CosT_281: Definition der Funktionsparameter zur Sicherung einer Kommando-APDU

TABLE(rows=12,cols=66+84+449)->
TR-> TD(0,0/10/1)->PAR Input: TD(0,1/1/1)->PAR CLA TD(0,2/1/1)->PAR Oktett gemäß (N026.500)
TR-> TD(1,1/1/1)->PAR INS TD(1,2/1/1)->PAR Oktett gemäß (N026.600)
TR-> TD(2,1/1/1)->PAR P1 TD(2,2/1/1)->PAR Oktett gemäß (N026.700)
TR-> TD(3,1/1/1)->PAR P2 TD(3,2/1/1)->PAR Oktett gemäß (N026.800)
TR-> TD(4,1/1/1)->PAR Data TD(4,2/1/1)->PAR Optionaler Oktettstring gemäß CosK_d08
TR-> TD(5,1/1/1)->PAR LeFeld TD(5,2/1/1)->PAR Optionaler Oktettstring gemäß CosK_e6a, welcher gemäß (N027.600) oder (N027.900) eine Zahl Ne enthält
TR-> TD(6,1/1/1)->PAR Kenc TD(6,2/1/1)->PAR Symmetrischer Schlüssel für die Verschlüsselung, (N029.900)d.2
TR-> TD(7,1/1/1)->PAR SSCenc TD(7,2/1/1)->PAR Beliebige nicht-negative Zahl, die als Send Sequence Counter bei der Verschlüsselung verwendet wird, (N029.900)d.3
TR-> TD(8,1/1/1)->PAR Kmac TD(8,2/1/1)->PAR Symmetrischer Schlüssel für die MAC-Berechnung, (N029.900)d.4
TR-> TD(9,1/1/1)->PAR SSCmac TD(9,2/1/1)->PAR Beliebige nicht-negative Zahl, die als Send Sequence Counter bei der MAC-Berechnung verwendet wird, (N029.900)d.5
TR-> TD(10,0/1/1)->PAR Output: TD(10,1/1/1)->PAR CmdApdu TD(10,2/1/1)->PAR Gesicherte Kommando-APDU
TR-> TD(11,0/1/1)->PAR Errors: TD(11,1/1/1)->PAR – TD(11,2/1/1)->PAR Keine
PAR Zur Sicherung einer generischen Kommando-APDU sind folgende Schritte durchzuführen:
REQ(ids=G2_N032.000)<b>G2_N032.000 - (N032.000) K_externeWelt {K_Karte}</b>
PAR Wenn das optionale Datenfeld Data fehlt oder leer ist,<br>dann MUSS gelten: ProtectedData = '' (leerer Oktettstring). <b>[<=]</b>

REQ(ids=G2_N032.100)<b>G2_N032.100 - (N032.100) K_externeWelt {K_Karte}</b>
PAR Wenn das optionale Datenfeld Data vorhanden und nicht leer ist und im Klartext übertragen wird,<br>dann MUSS gelten:<br>a. Setze     lenPDO = OctetLength( Data ), falls lenPDO im Intervall<br>    1. [    1,    127] liegt, gilt:  LenP = I2OS(lenPDO, 1)<br>    2. [128,    255] liegt, gilt:  LenP = '81'   ||   I2OS(lenPDO, 1)<br>    3. [256, 65535] liegt, gilt: LenP  = '82'   ||   I2OS(lenPDO, 2)<br>b. Setze     ProtectedData = '81   ||   LenP   ||   Data' <b>[<=]</b>

REQ(ids=G2_N032.190)<b>G2_N032.190 - (N032.190) K_externeWelt {K_Karte}</b>
PAR SSCmac MUSS inkrementiert werden, das heißt:   SSCmac = SSCmac + 1. <b>[<=]</b>

PAR (N032.200) ist absichtlich leer.
REQ(ids=G2_N032.200)<b>G2_N032.200 - (N032.200) K_externeWelt {K_Karte}, Option_DES</b>
PAR Wenn das optionale Datenfeld Data vorhanden ist und verschlüsselt übertragen wird und Kenc ein 3TDES-Schlüssel ist, dann MUSS gelten:<br>a. SSCenc = SSCenc + 1<br>b. C = 3TDES_CBC_ENC(Kenc, SSCenc, PaddingIso( Data, 8 ) )<br>c. Setze     lenCDO = OctetLength( C ) + 1, falls lenCDO im Intervall<br>    1. [    1,     127] liegt, gilt:     LenC    = I2OS(lenCDO, 1)<br>    2. [128,     255] liegt, gilt:      LenC    = '81'   ||   I2OS(lenCDO, 1)<br>    3. [256, 65535] liegt, gilt       LenC    = '82'   ||   I2OS(lenCDO, 2)<br>d. Setze     ProtectedData = '87   ||   LenC   ||   01   ||   C' <b>[<=]</b>

REQ(ids=G2_N032.300)<b>G2_N032.300 - (N032.300) K_externeWelt {K_Karte}</b>
PAR Wenn das optionale Datenfeld Data vorhanden ist und verschlüsselt übertragen wird und Kenc ein AES-Schlüssel ist, dann MUSS gelten:<br>a. IVenc = OS2I(AES_ENC( Kenc, I2OS(SSCmac, 16)))<br>b. C       = AES_CBC_ENC( Kenc, IVenc, PaddingIso( Data, 16 ) )<br>c. Setze     lenCDO = OctetLength( C ) + 1, falls lenCDO im Intervall<br>    1. [    1,     127] liegt, gilt:     LenC    = I2OS(lenCDO, 1)<br>    2. [128,     255] liegt, gilt:      LenC    = '81'   ||   I2OS(lenCDO, 1)<br>    3. [256, 65535] liegt, gilt       LenC    = '82'   ||   I2OS(lenCDO, 2)<br>d. Setze     ProtectedData = '87   ||   LenC   ||   01   ||   C' <b>[<=]</b>

REQ(ids=G2_N032.400)<b>G2_N032.400 - (N032.400) K_externeWelt {K_Karte}</b>
PAR Für LeDO MUSS gelten: Wenn das optionale LeFeld<br>a. fehlt, dann gilt: LeDO = '', (leerer Oktettstring).<br>b. vorhanden ist, dann gilt: LeDO = '97 || I2OS(OctetLength( LeFeld ), 1) || LeFeld' <b>[<=]</b>

REQ(ids=G2_N032.500)<b>G2_N032.500 - (N032.500) K_externeWelt {K_Karte}</b>
PAR Wenn die Kanalnummer im CLA-Byte im Intervall<br>a. [0, 3] liegt, dann MUSS gesetzt werden    CLA' = CLA   OR   '0C'<br>    Hinweis CosH_1d4: Dadurch werden die Bits b4 und b3 in CLA gesetzt.<br>b. andernfalls MUSS gesetzt werden            CLA' = CLA   OR   '20'<br>    Hinweis CosH_f56: Dadurch wird das Bit b6 in CLA gesetzt. <b>[<=]</b>

REQ(ids=G2_N032.600)<b>G2_N032.600 - (N032.600) K_externeWelt {K_Karte}</b>
PAR Wenn die Kanalnummer im CLA-Byte im Intervall<br>a. [0, 3] liegt, dann MUSS gelten head =                    CLA'  ||  INS  ||  P1  ||  P2<br>b. andernfalls MUSS gelten         head =   '89 04' ||    CLA'  ||  INS  ||  P1  ||  P2 <b>[<=]</b>

PAR (N032.700) Diese Anforderung ist absichtlich leer.
REQ(ids=A_15862)<b>A_15862 - (N032.800) K_externeWelt {K_Karte}</b>
PAR Es MUSS gelten: tmpData = ProtectedData   ||   LeDO <b>[<=]</b>

PAR (N032.800)a ist absichtlich leer.
REQ(ids=G2_N032.800.a)<b>G2_N032.800.a - (N032.800)a K_externeWelt {K_Karte}, Option_DES</b>
PAR Wenn Kmac ein 3TDES-Schlüssel ist, dann MUSS gelten:<br>1. MACin = I2OS(SSCmac, 8 )<br>2. Wenn die Kanalnummer im CLA-Byte größer gleich vier ist, oder OctetLength( tmpData ) gleich null ist<br>    i.  dann gilt:    MACin = MACin   ||   head   ||   tmpData<br>    ii. sonst:        MACin = MACin   ||   PaddingIso( head,   8 )   ||   tmpData<br>3. MAC = CALCULATE_Retail_MAC(Kmac, MACin ) <b>[<=]</b>

REQ(ids=G2_N032.800.b)<b>G2_N032.800.b - (N032.800)b K_externeWelt {K_Karte}</b>
PAR Wenn Kmac ein AES-Schlüssel ist, dann MUSS gelten:<br>1. MACin = I2OS(SSCmac, 16 )<br>2. Wenn die Kanalnummer im CLA-Byte größer gleich vier ist, oder OctetLength( tmpData ) gleich null ist<br>    i.  dann gilt:    MACin = MACin   ||   head   ||   tmpData<br>    ii. sonst:        MACin = MACin   ||   PaddingIso( head, 16)   ||   tmpData<br>3. MAC = CalculateCMAC_IsoPadding(Kmac, MACin ) <b>[<=]</b>

REQ(ids=G2_N032.900)<b>G2_N032.900 - (N032.900) K_externeWelt {K_Karte}</b>
PAR Für MDO MUSS gelten:   MDO = '8E   ||   I2OS(OctetLength(MAC), 1)   ||   MAC' <b>[<=]</b>

PAR Für newD MUSS gelten:
REQ(ids=G2_N033.000.a)<b>G2_N033.000.a - (N033.000)a K_externeWelt {K_Karte}</b>
PAR Wenn die Kanalnummer im CLA-Byte im Intervall [0, 3] liegt,<br>dann setze: newD =                 tmpData   ||   MDO <b>[<=]</b>

REQ(ids=G2_N033.000.b)<b>G2_N033.000.b - (N033.000)b K_externeWelt {K_Karte}</b>
PAR Wenn die Kanalnummer im CLA-Byte größer als drei ist,<br>dann setze: newD = head   ||    tmpData   ||   MDO <b>[<=]</b>

REQ(ids=G2_N033.100)<b>G2_N033.100 - (N033.100) K_externeWelt {K_Karte}</b>
PAR Case 1: Wenn Data und LeFeld fehlen, dann MUSS gelten:    <br>CmdApdu     = Case4S(CLA’, INS, P1, P2, newD, WildCardShort) <b>[<=]</b>

REQ(ids=G2_N033.200)<b>G2_N033.200 - (N033.200) K_externeWelt {K_Karte}</b>
PAR Case 2: Wenn Data fehlt und LeFeld vorhanden ist, dann MUSS gelten:    <br>CmdApdu     = Case4E(CLA’, INS, P1, P2, newD, WildCardExtended) <b>[<=]</b>

REQ(ids=G2_N033.300.a)<b>G2_N033.300.a - (N033.300)a K_externeWelt {K_Karte}</b>
PAR Case 3S: Wenn Data vorhanden ist und LeFeld fehlt und OctetLength( newD ) kleiner gleich 255 ist, dann MUSS gelten:<br>CmdApdu     = Case4S(CLA’, INS, P1, P2, newD, WildCardShort) <b>[<=]</b>

REQ(ids=G2_N033.300.b)<b>G2_N033.300.b - (N033.300)b K_externeWelt {K_Karte}</b>
PAR Case 3E: Wenn Data vorhanden ist und LeFeld fehlt und OctetLength( newD ) größer als 255 ist, dann MUSS gelten:<br>CmdApdu     = Case4E(CLA’, INS, P1, P2, newD, WildCardExtended) <b>[<=]</b>

REQ(ids=G2_N033.400)<b>G2_N033.400 - (N033.400) K_externeWelt {K_Karte}</b>
PAR Case 4: Wenn Data und LeFeld vorhanden sind, dann MUSS gelten:<br>CmdApdu     = Case4E(CLA’, INS, P1, P2, newD, WildCardExtended) <b>[<=]</b>

PAR Hinweis CosH_da9: Zu (N033.100) und (N033.300)a: Gemäß CosK_f7e (CosK_914) hat die korrespondierende Antwort-APDU zu einer Case 1 (Case 3) Kommando-APDU niemals Antwortdaten. Zudem werden in CosK_c3a ausschließlich symmetrische Verfahren verwendet. Daraus folgt, dass eine gesicherte Antwort-APDU zu einer ungesicherten Case 1 (Case 3) APDU niemals mehr als 256 Oktette Antwortdaten enthält. Deshalb wird hier für die gesicherte Case 1 (Case 3) Kommando-APDU eine Case 4 Short Kommando-APDU verwendet.
PAR Hinweis CosH_fb6: Zu (N033.200) und (N033.400): Gemäß CosK_80d (CosK_876) hat die korrespondierende Antwort-APDU zu einer Case 2 Short (Case 4 Short) Kommando-APDU bis zu 256 Oktette Antwortdaten. Gemäß CosK_c3a ist es deshalb möglich, dass eine gesicherte Antwort-APDU zu einer ungesicherten Case 2 Short (Case 4 Short) APDU mehr als 256 Oktette Antwortdaten enthält. Deshalb wird hier für gesicherte Case 2 Short (Case 4 Short) Kommando-APDU eine Case 4 Extended Kommando-APDU verwendet.
PAR -HEADING(ids=13.3)13.3 CosK_c3a Sicherung einer Antwort-APDU
PAR Dieses Unterkapitel beschreibt, wie eine Antwort-APDU gemäß CosK_3dc zu sichern ist. Die hier beschriebenen Regeln richten sich an das COS. Die Instanz, welche die korrespondierende Kommando-APDU gesendet hat und typischerweise diese gesicherte Antwort-APDU entgegennimmt, führt die entsprechenden Umkehroperationen durch, um in den Besitz der ungesicherten Antwort-APDU zu gelangen.
PAR Generell wird hier ein Subset der Regeln aus [ISO/IEC 7816-4#10] beschrieben, wobei

LIST->
LITEM->PAR alle Antwort-APDU mit Integritätsschutz übertragen werden,LITEM->PAR der Trailer stets mit Integritätsschutz übertragen wird,LITEM->PAR Response-Daten als Klartext oder verschlüsselt übertragen werden.
PAR Hier sei angemerkt, dass das COS anhand der verwendeten Zugriffsbedingung (Vorhandensein oder Fehlen von flagRspEnc, siehe (N022.600)d) entscheidet, ob vorhandene Responsedaten im Klartext oder als Chiffrat übertragen werden.
PAR Wie in CosK_3dc beschrieben, besteht eine Antwort-APDU generisch betrachtet aus dem optionalen Datenfeld Data und dem Trailer. Somit gelten folgende Definitionen:
PAR (ids=Tabelle-94,-CosT_4d6)Tabelle 94, CosT_4d6: Definition von Funktionsparametern zur Sicherung einer Antwort-APDU

TABLE(rows=8,cols=66+83+443)->
TR-> TD(0,0/6/1)->PAR Input: TD(0,1/1/1)->PAR Data TD(0,2/1/1)->PAR Optionaler Oktettstring gemäß CosK_3c7
TR-> TD(1,1/1/1)->PAR Trailer TD(1,2/1/1)->PAR Oktettstring gemäß CosK_8a5
TR-> TD(2,1/1/1)->PAR Kenc TD(2,2/1/1)->PAR Symmetrischer Schlüssel für die Verschlüsselung, (N029.900)d.2
TR-> TD(3,1/1/1)->PAR SSCenc TD(3,2/1/1)->PAR Beliebige nicht-negative Zahl, die als Send Sequence Counter bei der Verschlüsselung verwendet wird, (N029.900)d.3
TR-> TD(4,1/1/1)->PAR Kmac TD(4,2/1/1)->PAR Symmetrischer Schlüssel für die MAC-Berechnung, (N029.900)d.4
TR-> TD(5,1/1/1)->PAR SSCmac TD(5,2/1/1)->PAR beliebige nicht-negative Zahl, die als Send Sequence Counter bei der MAC-Berechnung verwendet wird, (N029.900)d.5
TR-> TD(6,0/1/1)->PAR Output: TD(6,1/1/1)->PAR RspApdu TD(6,2/1/1)->PAR Gesicherte Antwort-APDU
TR-> TD(7,0/1/1)->PAR Errors: TD(7,1/1/1)->PAR – TD(7,2/1/1)->PAR Keine
PAR Zur Sicherung einer generischen Antwort-APDU sind folgende Schritte durchzuführen:
REQ(ids=G2_N033.500)<b>G2_N033.500 - (N033.500) K_COS</b>
PAR Wenn das optionale Datenfeld Data fehlt, dann MUSS gelten:    <br>ProtectedData = '' (leerer Oktettstring). <b>[<=]</b>

REQ(ids=G2_N033.600)<b>G2_N033.600 - (N033.600) K_COS</b>
PAR Wen das optionale Datenfeld Data vorhanden ist und im Klartext übertragen wird, dann MUSS gelten:<br>a. Setze     lenPDO = OctetLength( Data ), falls lenPDO im Intervall<br>    1. [    1,    127] liegt, gilt:  LenP = I2OS(lenPDO, 1)<br>    2. [128,    255] liegt, gilt:  LenP = '81'   ||   I2OS(lenPDO, 1)<br>    3. [256, 65535] liegt, gilt: LenP  = '82'   ||   I2OS(lenPDO, 2)<br>b. Setze     ProtectedData = '81   ||   LenP   ||   Data' <b>[<=]</b>

REQ(ids=G2_N033.690)<b>G2_N033.690 - (N033.690) K_COS</b>
PAR SSCmac MUSS inkrementiert werden, das heißt:   SSCmac = SSCmac + 1. <b>[<=]</b>

PAR (N033.700) ist absichtlich leer.
REQ(ids=G2_N033.700)<b>G2_N033.700 - (N033.700) K_COS, Option_DES</b>
PAR Wenn das optionale Datenfeld Data vorhanden und nicht leer ist und verschlüsselt übertragen wird (flagRspEnc ist True, siehe (N029.900)d.7 und (N022.600)d) und Kenc ein 3TDES-Schlüssel ist, dann MUSS gelten:<br>a. SSCenc = SSCenc + 1<br>b. C = 3TDES_CBC_ENC(Kenc, SSCenc, PaddingIso( Data, 8 ) )<br>c. Setze     lenCDO = OctetLength( C ) + 1, falls lenCDO im Intervall<br>    1. [    1,     127] liegt, gilt:     LenC    = I2OS(lenCDO, 1)<br>    2. [128,     255] liegt, gilt:      LenC    = '81'   ||   I2OS(lenCDO, 1)<br>    3. [256, 65535] liegt, gilt       LenC    = '82'   ||   I2OS(lenCDO, 2)<br>d. Setze     ProtectedData = '87   ||   LenC   ||   01   ||   C' <b>[<=]</b>

REQ(ids=G2_N033.800)<b>G2_N033.800 - (N033.800) K_COS</b>
PAR Wenn das optionale Datenfeld Data vorhanden und nicht leer ist und verschlüsselt übertragen wird (flagRspEnc ist True, siehe (N029.900)d.7 und (N022.600)d) und Kenc ein AES-Schlüssel ist, dann MUSS gelten:<br>a. IVenc = OS2I(AES_ENC( Kenc, I2OS(SSCmac, 16)))<br>b. C       = AES_CBC_ENC( Kenc, IVenc, PaddingIso( Data, 16 ) )<br>c. Setze     lenCDO = OctetLength( C ) + 1, falls lenCDO im Intervall<br>    1. [    1,     127] liegt, gilt:     LenC    = I2OS(lenCDO, 1)<br>    2. [128,     255] liegt, gilt:      LenC    = '81'   ||   I2OS(lenCDO, 1)<br>    3. [256, 65535] liegt, gilt       LenC    = '82'   ||   I2OS(lenCDO, 2)<br>d. Setze     ProtectedData = '87   ||   LenC   ||   01   ||   C' <b>[<=]</b>

REQ(ids=G2_N033.900)<b>G2_N033.900 - (N033.900) K_COS</b>
PAR Für TDO MUSS gelten:    TDO     = '99 02   ||   Trailer' <b>[<=]</b>

PAR (N034.000) Diese Anforderung ist absichtlich leer.
PAR (N034.100)a ist absichtlich leer.
REQ(ids=G2_N034.100.a)<b>G2_N034.100.a - (N034.100)a K_COS, Option_DES</b>
PAR Wenn Kmac ein 3TDES-Schlüssel ist, dann MUSS gelten:<br>1. MACin = I2OS(SSCmac, 8 )<br>2. MACin = MACin   ||    ProtectedData<br>3. MACin = MACin   ||    TDO<br>4. MAC   = CALCULATE_Retail_MAC(Kmac, MACin ) <b>[<=]</b>

REQ(ids=G2_N034.100.b)<b>G2_N034.100.b - (N034.100)b K_COS</b>
PAR Wenn Kmac ein AES-Schlüssel ist, dann MUSS gelten:<br>1. MACin = I2OS(SSCmac, 16 )<br>2. MACin = MACin   ||    ProtectedData<br>3. MACin = MACin   ||    TDO<br>4. MAC   = CalculateCMAC_IsoPadding(Kmac, MACin ) <b>[<=]</b>

REQ(ids=G2_N034.200)<b>G2_N034.200 - (N034.200) K_COS</b>
PAR Für MDO MUSS gelten:   MDO = '8E   ||   I2OS(OctetLength(MAC), 1)   ||   MAC' <b>[<=]</b>

REQ(ids=G2_N034.300)<b>G2_N034.300 - (N034.300) K_COS</b>
PAR Für die gesicherte Antwort-APDU RspApdu MUSS gelten:<br>a. RspApdu.Datenfeld = ProtectedData   ||   TDO   ||   MDO<br>b. RspApdu.Trailer      = Trailer <b>[<=]</b>

PAR -HEADING(ids=14)14 CosK_3a7 Kommandos (normativ)
PAR (ids=Tabelle-95,-CosT_c84)Tabelle 95, CosT_c84: Kommandos alphabetisch und numerisch sortiert

TABLE(rows=48,cols=206+45+56+17+203+46+53)->
TR-> TH(0,0/1/1)->PAR Kommando alphabetisch TH(0,1/1/1)->PAR CLA INS TH(0,2/1/1)->PAR siehe TH(0,3/1/1)-> TH(0,4/1/1)->PAR Kommandos numerisch TH(0,5/1/1)->PAR CLA INS TH(0,6/1/1)->PAR siehe
TR-> TD(1,0/1/1)->PAR ACITVATE TD(1,1/1/1)->PAR '00 44' TD(1,2/1/1)->PAR CosK_c7f TD(1,3/1/1)-> TD(1,4/1/1)->PAR DEACTIVATE TD(1,5/1/1)->PAR '00 04' TD(1,6/1/1)->PAR CosK_a78
TR-> TD(2,0/1/1)->PAR ACTIVATE RECORD TD(2,1/1/1)->PAR '00 08' TD(2,2/1/1)->PAR CosK_18e TD(2,3/1/1)-> TD(2,4/1/1)->PAR DEACTIVATE RECORD TD(2,5/1/1)->PAR '00 06' TD(2,6/1/1)->PAR CosK_419
TR-> TD(3,0/1/1)->PAR APPEND RECORD TD(3,1/1/1)->PAR '00 E2' TD(3,2/1/1)->PAR CosK_b11 TD(3,3/1/1)-> TD(3,4/1/1)->PAR ACTIVATE RECORD TD(3,5/1/1)->PAR '00 08' TD(3,6/1/1)->PAR CosK_18e
TR-> TD(4,0/1/1)->PAR CHANGE REFERENCE DATA TD(4,1/1/1)->PAR '00 24' TD(4,2/1/1)->PAR CosK_f67 TD(4,3/1/1)-> TD(4,4/1/1)->PAR ERASE RECORD TD(4,5/1/1)->PAR '00 0C' TD(4,6/1/1)->PAR CosK_645
TR-> TD(5,0/1/1)->PAR CREATE TD(5,1/1/1)->PAR '00 E0' TD(5,2/1/1)->PAR CosK_ed6 TD(5,3/1/1)-> TD(5,4/1/1)->PAR ERASE BINARY TD(5,5/1/1)->PAR '00 0E' TD(5,6/1/1)->PAR CosK_a6a
TR-> TD(6,0/1/1)->PAR DEACTIVATE TD(6,1/1/1)->PAR '00 04' TD(6,2/1/1)->PAR CosK_a78 TD(6,3/1/1)-> TD(6,4/1/1)->PAR VERIFY TD(6,5/1/1)->PAR '00 20' TD(6,6/1/1)->PAR CosK_2ec
TR-> TD(7,0/1/1)->PAR DEACTIVATE RECORD TD(7,1/1/1)->PAR '00 06' TD(7,2/1/1)->PAR CosK_419 TD(7,3/1/1)-> TD(7,4/1/1)->PAR MANAGE SECURITY ENVIRONMENT TD(7,5/1/1)->PAR '00 22' TD(7,6/1/1)->PAR CosK_146
TR-> TD(8,0/1/1)->PAR DELETE TD(8,1/1/1)->PAR '00 E4' TD(8,2/1/1)->PAR CosK_da3 TD(8,3/1/1)-> TD(8,4/1/1)->PAR CHANGE REFERENCE DATA TD(8,5/1/1)->PAR '00 24' TD(8,6/1/1)->PAR CosK_f67
TR-> TD(9,0/1/1)->PAR DELETE RECORD TD(9,1/1/1)->PAR '80 0C' TD(9,2/1/1)->PAR CosK_e30 TD(9,3/1/1)-> TD(9,4/1/1)->PAR DISABLE VERIFICATION REQUIREMENT TD(9,5/1/1)->PAR '00 26' TD(9,6/1/1)->PAR CosK_3ee
TR-> TD(10,0/1/1)->PAR DISABLE VERIFICATION REQUIREMENT TD(10,1/1/1)->PAR '00 26' TD(10,2/1/1)->PAR CosK_3ee TD(10,3/1/1)-> TD(10,4/1/1)->PAR ENABLE VERIFICATION REQUIREMENT TD(10,5/1/1)->PAR '00 28' TD(10,6/1/1)->PAR CosK_fc7
TR-> TD(11,0/1/1)->PAR ENABLE VERIFICATION REQUIREMENT TD(11,1/1/1)->PAR '00 28' TD(11,2/1/1)->PAR CosK_fc7 TD(11,3/1/1)-> TD(11,4/1/1)->PAR PERFORM SECURITY OPERATION TD(11,5/1/1)->PAR '00 2A' TD(11,6/1/1)->PAR CosK_00c
TR-> TD(12,0/1/1)->PAR ENVELOPE TD(12,1/1/1)->PAR '00 C2' TD(12,2/1/1)->PAR CosK_1e9 TD(12,3/1/1)-> TD(12,4/1/1)->PAR RESET RETRY COUNTER TD(12,5/1/1)->PAR '00 2C' TD(12,6/1/1)->PAR CosK_5e0
TR-> TD(13,0/1/1)->PAR ERASE BINARY TD(13,1/1/1)->PAR '00 0E' TD(13,2/1/1)->PAR CosK_a6a TD(13,3/1/1)-> TD(13,4/1/1)->PAR ACITVATE TD(13,5/1/1)->PAR '00 44' TD(13,6/1/1)->PAR CosK_c7f
TR-> TD(14,0/1/1)->PAR ERASE RECORD TD(14,1/1/1)->PAR '00 0C' TD(14,2/1/1)->PAR CosK_645 TD(14,3/1/1)-> TD(14,4/1/1)->PAR GENERATE ASYMMETRIC KEY PAIR TD(14,5/1/1)->PAR '00 46' TD(14,6/1/1)->PAR CosK_d2f
TR-> TD(15,0/1/1)->PAR EXTERNAL AUTHENTICATE TD(15,1/1/1)->PAR '00 82' TD(15,2/1/1)->PAR CosK_e22 TD(15,3/1/1)-> TD(15,4/1/1)->PAR MANAGE CHANNEL TD(15,5/1/1)->PAR '00 70' TD(15,6/1/1)->PAR CosK_02b
TR-> TD(16,0/1/1)->PAR FINGERPRINT TD(16,1/1/1)->PAR '80 FA' TD(16,2/1/1)->PAR CosK_6b0 TD(16,3/1/1)-> TD(16,4/1/1)->PAR EXTERNAL AUTHENTICATE TD(16,5/1/1)->PAR '00 82' TD(16,6/1/1)->PAR CosK_e22
TR-> TD(17,0/1/1)->PAR GENERAL AUTHENTICATE TD(17,1/1/1)->PAR '00 86' TD(17,2/1/1)->PAR CosK_72e TD(17,3/1/1)-> TD(17,4/1/1)->PAR MUTUAL AUTHENTICATE TD(17,5/1/1)->PAR '00 82' TD(17,6/1/1)->PAR CosK_e22
TR-> TD(18,0/1/1)->PAR GENERATE ASYMMETRIC KEY PAIR TD(18,1/1/1)->PAR '00 46' TD(18,2/1/1)->PAR CosK_d2f TD(18,3/1/1)-> TD(18,4/1/1)->PAR GET CHALLENGE TD(18,5/1/1)->PAR '00 84' TD(18,6/1/1)->PAR CosK_8c2
TR-> TD(19,0/1/1)->PAR GET CHALLENGE TD(19,1/1/1)->PAR '00 84' TD(19,2/1/1)->PAR CosK_8c2 TD(19,3/1/1)-> TD(19,4/1/1)->PAR GENERATE ASYMMETRIC KEY PAIR TD(19,5/1/1)->PAR '00 46' TD(19,6/1/1)->PAR CosK_d2f
TR-> TD(20,0/1/1)->PAR GET DATA TD(20,1/1/1)->PAR '00 CA' TD(20,2/1/1)->PAR CosK_c53 TD(20,3/1/1)-> TD(20,4/1/1)->PAR INTERNAL AUTHENTICATE TD(20,5/1/1)->PAR '00 88' TD(20,6/1/1)->PAR CosK_6fe
TR-> TD(21,0/1/1)->PAR GET PIN STATUS TD(21,1/1/1)->PAR '80 20' TD(21,2/1/1)->PAR CosK_348 TD(21,3/1/1)-> TD(21,4/1/1)->PAR SEARCH BINARY TD(21,5/1/1)->PAR '00 A0' TD(21,6/1/1)->PAR CosK_d46
TR-> TD(22,0/1/1)->PAR GET RANDOM TD(22,1/1/1)->PAR '80 84' TD(22,2/1/1)->PAR CosK_5d7 TD(22,3/1/1)-> TD(22,4/1/1)->PAR SEARCH RECORD TD(22,5/1/1)->PAR '00 A2' TD(22,6/1/1)->PAR CosK_cde
TR-> TD(23,0/1/1)->PAR GET RESPONSE TD(23,1/1/1)->PAR '00 C0' TD(23,2/1/1)->PAR CosK_dfe TD(23,3/1/1)-> TD(23,4/1/1)->PAR SELECT TD(23,5/1/1)->PAR '00 A4' TD(23,6/1/1)->PAR CosK_119
TR-> TD(24,0/1/1)->PAR GET SECURITY STATUS KEY TD(24,1/1/1)->PAR '80 82' TD(24,2/1/1)->PAR CosK_e80 TD(24,3/1/1)-> TD(24,4/1/1)->PAR READ BINARY TD(24,5/1/1)->PAR '00 B0' TD(24,6/1/1)->PAR CosK_052
TR-> TD(25,0/1/1)->PAR INTERNAL AUTHENTICATE TD(25,1/1/1)->PAR '00 88' TD(25,2/1/1)->PAR CosK_6fe TD(25,3/1/1)-> TD(25,4/1/1)->PAR READ RECORD TD(25,5/1/1)->PAR '00 B2' TD(25,6/1/1)->PAR CosK_52e
TR-> TD(26,0/1/1)->PAR LIST PUBLIC KEY TD(26,1/1/1)->PAR '80 CA' TD(26,2/1/1)->PAR CosK_ed1 TD(26,3/1/1)-> TD(26,4/1/1)->PAR GET RESPONSE TD(26,5/1/1)->PAR '00 C0' TD(26,6/1/1)->PAR CosK_dfe
TR-> TD(27,0/1/1)->PAR LOAD APPLICATION TD(27,1/1/1)->PAR '00 EA' TD(27,2/1/1)->PAR CosK_74a TD(27,3/1/1)-> TD(27,4/1/1)->PAR ENVELOPE TD(27,5/1/1)->PAR '00 C2' TD(27,6/1/1)->PAR CosK_1e9
TR-> TD(28,0/1/1)->PAR MANAGE CHANNEL TD(28,1/1/1)->PAR '00 70' TD(28,2/1/1)->PAR CosK_02b TD(28,3/1/1)-> TD(28,4/1/1)->PAR GET DATA TD(28,5/1/1)->PAR '00 CA' TD(28,6/1/1)->PAR CosK_c53
TR-> TD(29,0/1/1)->PAR MANAGE SECURITY ENVIRONMENT TD(29,1/1/1)->PAR '00 22' TD(29,2/1/1)->PAR CosK_146 TD(29,3/1/1)-> TD(29,4/1/1)->PAR WRITE BINARY TD(29,5/1/1)->PAR '00 D0' TD(29,6/1/1)->PAR CosK_a3c
TR-> TD(30,0/1/1)->PAR MUTUAL AUTHENTICATE TD(30,1/1/1)->PAR '00 82' TD(30,2/1/1)->PAR CosK_e22 TD(30,3/1/1)-> TD(30,4/1/1)->PAR WRITE RECORD TD(30,5/1/1)->PAR '00 D2' TD(30,6/1/1)->PAR CosK_de2
TR-> TD(31,0/1/1)->PAR PERFORM SECURITY OPERATION TD(31,1/1/1)->PAR '00 2A' TD(31,2/1/1)->PAR CosK_00c TD(31,3/1/1)-> TD(31,4/1/1)->PAR UPDATE BINARY TD(31,5/1/1)->PAR '00 D6' TD(31,6/1/1)->PAR CosK_721
TR-> TD(32,0/1/1)->PAR PUT DATA TD(32,1/1/1)->PAR '00 DA' TD(32,2/1/1)->PAR CosK_c47 TD(32,3/1/1)-> TD(32,4/1/1)->PAR PUT DATA TD(32,5/1/1)->PAR '00 DA' TD(32,6/1/1)->PAR CosK_c47
TR-> TD(33,0/1/1)->PAR READ BINARY TD(33,1/1/1)->PAR '00 B0' TD(33,2/1/1)->PAR CosK_052 TD(33,3/1/1)-> TD(33,4/1/1)->PAR UPDATE RECORD TD(33,5/1/1)->PAR '00 DC' TD(33,6/1/1)->PAR CosK_aaa
TR-> TD(34,0/1/1)->PAR READ RECORD TD(34,1/1/1)->PAR '00 B2' TD(34,2/1/1)->PAR CosK_52e TD(34,3/1/1)-> TD(34,4/1/1)->PAR CREATE TD(34,5/1/1)->PAR '00 E0' TD(34,6/1/1)->PAR CosK_ed6
TR-> TD(35,0/1/1)->PAR RESET RETRY COUNTER TD(35,1/1/1)->PAR '00 2C' TD(35,2/1/1)->PAR CosK_5e0 TD(35,3/1/1)-> TD(35,4/1/1)->PAR APPEND RECORD TD(35,5/1/1)->PAR '00 E2' TD(35,6/1/1)->PAR CosK_b11
TR-> TD(36,0/1/1)->PAR SEARCH BINARY TD(36,1/1/1)->PAR '00 A0' TD(36,2/1/1)->PAR CosK_d46 TD(36,3/1/1)-> TD(36,4/1/1)->PAR DELETE TD(36,5/1/1)->PAR '00 E4' TD(36,6/1/1)->PAR CosK_da3
TR-> TD(37,0/1/1)->PAR SEARCH RECORD TD(37,1/1/1)->PAR '00 A2' TD(37,2/1/1)->PAR CosK_cde TD(37,3/1/1)-> TD(37,4/1/1)->PAR TERMINATE DF TD(37,5/1/1)->PAR '00 E6' TD(37,6/1/1)->PAR CosK_150
TR-> TD(38,0/1/1)->PAR SELECT TD(38,1/1/1)->PAR '00 A4' TD(38,2/1/1)->PAR CosK_119 TD(38,3/1/1)-> TD(38,4/1/1)->PAR TERMINATE TD(38,5/1/1)->PAR '00 E8'  TD(38,6/1/1)->PAR CosK_406 
TR-> TD(39,0/1/1)->PAR SET LOGICAL EOF TD(39,1/1/1)->PAR '80 0E' TD(39,2/1/1)->PAR CosK_427 TD(39,3/1/1)-> TD(39,4/1/1)->PAR LOAD APPLICATION TD(39,5/1/1)->PAR '00 EA'  TD(39,6/1/1)->PAR CosK_74a 
TR-> TD(40,0/1/1)->PAR TERMINATE TD(40,1/1/1)->PAR '00 E8' TD(40,2/1/1)->PAR CosK_406 TD(40,3/1/1)-> TD(40,4/1/1)->PAR TERMINATE CARD USAGE TD(40,5/1/1)->PAR '00 FE'  TD(40,6/1/1)->PAR CosK_cd6 
TR-> TD(41,0/1/1)->PAR TERMINATE CARD USAGE TD(41,1/1/1)->PAR '00 FE' TD(41,2/1/1)->PAR CosK_cd6 TD(41,3/1/1)-> TD(41,4/1/1)->PAR DELETE RECORD TD(41,5/1/1)->PAR '80 0C'  TD(41,6/1/1)->PAR CosK_e30 
TR-> TD(42,0/1/1)->PAR TERMINATE DF TD(42,1/1/1)->PAR '00 E6' TD(42,2/1/1)->PAR CosK_150 TD(42,3/1/1)-> TD(42,4/1/1)->PAR SET LOGICAL EOF TD(42,5/1/1)->PAR '80 0E'  TD(42,6/1/1)->PAR CosK_427 
TR-> TD(43,0/1/1)->PAR UPDATE BINARY TD(43,1/1/1)->PAR '00 D6' TD(43,2/1/1)->PAR CosK_721 TD(43,3/1/1)-> TD(43,4/1/1)->PAR GET PIN STATUS TD(43,5/1/1)->PAR '80 20'  TD(43,6/1/1)->PAR CosK_348 
TR-> TD(44,0/1/1)->PAR UPDATE RECORD TD(44,1/1/1)->PAR '00 DC' TD(44,2/1/1)->PAR CosK_aaa TD(44,3/1/1)-> TD(44,4/1/1)->PAR GET SECURITY STATUS KEY TD(44,5/1/1)->PAR '80 82'  TD(44,6/1/1)->PAR CosK_e80 
TR-> TD(45,0/1/1)->PAR VERIFY TD(45,1/1/1)->PAR '00 20' TD(45,2/1/1)->PAR CosK_2ec TD(45,3/1/1)-> TD(45,4/1/1)->PAR GET RANDOM TD(45,5/1/1)->PAR '80 84' TD(45,6/1/1)->PAR CosK_5d7
TR-> TD(46,0/1/1)->PAR WRITE BINARY TD(46,1/1/1)->PAR '00 D0'  TD(46,2/1/1)->PAR CosK_a3c TD(46,3/1/1)-> TD(46,4/1/1)->PAR LIST PUBLIC KEY TD(46,5/1/1)->PAR '80 CA' TD(46,6/1/1)->PAR CosK_ed1
TR-> TD(47,0/1/1)->PAR WRITE RECORD TD(47,1/1/1)->PAR '00 D2' TD(47,2/1/1)->PAR CosK_de2 TD(47,3/1/1)-> TD(47,4/1/1)->PAR FINGERPRINT TD(47,5/1/1)->PAR '80 FA' TD(47,6/1/1)->PAR CosK_6b0
REQ(ids=A_15865)<b>A_15865 - (N034.400) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden Kommando-APDU, die in diesem Kapitel nicht aufgeführt sind würden<br>a. unterstützt oder<br>b. abgelehnt. <b>[<=]</b>

PAR -HEADING(ids=14.1)14.1 CosK_c9b Roll-Verhalten
PAR In den folgenden Unterkapiteln ist gelegentlich die Rede davon, dass der persistente Speicher mittels "Roll-Forward" oder "Roll-Back" zu verändern ist. Als Oberbegriff wird "Transaktionsschutz" verwendet, um auszudrücken, dass Roll-Forward oder Roll-Back gemeint ist. Kurz gesagt verbirgt sich dahinter Folgendes: Das persistente Speichern von Informationen dauert aus technischen Gründen einige Millisekunden. Da Smartcards aus technischen Gründen nicht in der Lage sind, einen Ausfall der Spannungsversorgung zu puffern, ist es denkbar, dass der Ausfall zu einem Zeitpunkt geschieht, in welchem der Zustand des persistenten Speichers in einem undefinierten Zustand ist. Der Transaktionsschutz legt dann fest, wie mit diesem möglicherweise undefiniertem Zustand umzugehen ist.

PAR Abbildung 2, CosA_8fc: Zeitlicher Ablauf eines Roll-Back-Kommandos
PAR Für die Bearbeitung eines Kommandos mit Transaktionsschutz werden, wie in CosA_8fc gezeigt, die folgenden Zeitpunkte definiert:

LIST->
LITEM->PAR Zum Zeitpunkt t<sub>0</sub> werde das erste Bit der Kommando-APDU über die physikalische Schnittstelle (siehe CosA_e09) zur Smartcard gesendet.LITEM->PAR Zum Zeitpunkt t<sub>1</sub> sei die Kommandobearbeitung so weit vorgeschritten, dass der Zwischenspeicher bereit ist, befüllt zu werden.LITEM->PAR Zum Zeitpunkt t<sub>2</sub> sei der Zwischenspeicher komplett befüllt, aber sein Inhalt noch nicht als gültig gekennzeichnet.LITEM->PAR Zum Zeitpunkt t<sub>3</sub> sei der Inhalt als gültig gekennzeichnet und die eigentliche, persistente Änderung werde gestartet.LITEM->PAR Zum Zeitpunkt t<sub>4</sub> sei die eigentliche, persistente Änderung abgeschlossen, aber der Inhalt des Zwischenpuffers sei noch als gültig gekennzeichnet.LITEM->PAR Zum Zeitpunkt t<sub>5</sub> sei der Inhalt des Zwischenspeichers als ungültig gekennzeichnet.LITEM->PAR Zum Zeitpunkt t<sub>e</sub> (in CosA_8fc nicht dargestellt) habe die Smartcard das letzte Bit der Antwort-APDU über die physikalische Schnittstelle versendet.
REQ(ids=A_15915)<b>A_15915 - (N034.500) K_TST</b>
PAR Dieses Dokument legt nicht fest, in welchem zeitlichen Zusammenhang t<sub>e</sub> zu den anderen Zeiten aus der Menge {t<sub>1</sub>, t<sub>2</sub>, t<sub>3</sub>, t<sub>4</sub>, t<sub>5</sub>} steht. Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden t<sub>e</sub> liege bezüglich eines beliebigen Zeitpunktes aus der Menge {t<sub>1</sub>, t<sub>2</sub>, t<sub>3</sub>, t<sub>4</sub>, t<sub>5</sub>}<br>a. zeitlich früher, oder<br>b. zeitlich später. <b>[<=]</b>

PAR Hinweis CosH_ea8: Gemäß CosK_ad0 findet die Kommunikation zwischen der externen Welt und dem COS im Halbduplex-Verfahren statt. Daraus folgt, dass t<sub>e</sub> stets zeitlich nach t<sub>0</sub> liegt.
PAR -HEADING(ids=14.1.1)14.1.1 CosK_dec Roll-Back
PAR Roll-Back legt fest, dass die durch den Spannungsausfall unterbrochene Aktion rückgängig zu machen ist, wenn wieder eine Versorgungsspannung anliegt. Typischerweise wird dazu vor Durchführung der Änderung der ursprüngliche Inhalt in einen Zwischenspeicher geschrieben, dann die Änderung durchgeführt und anschließend der Inhalt des Zwischenspeichers als ungültig gekennzeichnet.
REQ(ids=A_15916)<b>A_15916 - (N034.600) K_COS</b>
PAR Findet der Ausfall der Versorgungsspannung

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR vor t<sub>4</sub> statt, so ist entweder noch keine Änderung erfolgt, oder der Inhalt des Zwischenpuffers definitiv auf gültig gesetzt und der (hier ursprüngliche) Inhalt des Zwischenspeichers MUSS nach Wiederanlegen der Versorgungsspannung wiederhergestellt werden.LITEM->PAR nach t<sub>5</sub> statt, so ist der Inhalt des Zwischenpuffers definitiv auf ungültig gesetzt und damit eine Wiederherstellung des ursprünglichen Zustandes unmöglich.LITEM->PAR zwischen t<sub>4</sub> und t<sub>5</sub> statt, so hängt es vom Zufall ab, ob der Zustand des Zwischenspeichers als gültig oder ungültig beurteilt wird (physikalische Speicher haben mitnichten ein zeit- oder wertediskretes Verhalten).    <br>In diesem Fall MUSS entweder der ursprüngliche Zustand rekonstruiert oder der neue Zustand beibehalten werden.
PAR <b>[<=]</b>

PAR -HEADING(ids=14.1.2)14.1.2 CosK_2df Roll-Forward
PAR Roll-Forward legt fest, dass die durch den Spannungsausfall unterbrochene Aktion fortzusetzen ist, wenn wieder eine Versorgungsspannung anliegt. Typischerweise wird dazu vor Durchführung der Änderung der neue Inhalt in einen Zwischenspeicher geschrieben, dann die Änderung durchgeführt und anschließend der Inhalt des Zwischenspeichers als ungültig gekennzeichnet.
REQ(ids=A_15917)<b>A_15917 - (N034.700) K_COS</b>
PAR Findet der Ausfall der Versorgungsspannung

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR vor t<sub>2</sub> statt, so ist der Inhalt des Zwischenspeichers definitiv nicht auf gültig gesetzt, und damit ist ein Wechsel zum neuen Zustand unmöglich.LITEM->PAR nach t<sub>3</sub> statt, so ist der Inhalt des Zwischenpuffers definitiv auf gültig gesetzt, und der (hier neue) Inhalt des Zwischenspeichers MUSS nach Wiederanlegen der Versorgungsspannung wiederhergestellt werden.LITEM->PAR zwischen t<sub>2</sub> und t<sub>3</sub> statt, so hängt es vom Zufall ab, ob der Zustand des Zwischenspeichers als gültig oder ungültig beurteilt wird (physikalische Speicher haben mitnichten zeit- oder wertediskretes Verhalten).    <br>In diesem Fall MUSS entweder der ursprüngliche Zustand beibehalten oder der neue Zustand gesetzt werden.
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2)14.2 Management des Objektsystems
PAR -HEADING(ids=14.2.1)14.2.1 CosK_c7f ACTIVATE
PAR Das Kommando ACTIVATE aktiviert reversibel ein Objekt. Ein betroffenes File wird vor der Operation ausgewählt. Dies geschieht vor dem Senden dieses ACTIVATE-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier). Wenn ein Schlüsselobjekt oder ein Passwortobjekt vom Kommando betroffen ist, dann wird dieses durch eine Schlüssel- oder Passwortreferenz bestimmt, die in der Kommandonachricht enthalten ist.
PAR -HEADING(ids=14.2.1.1)14.2.1.1 CosK_2c3 Use Case Aktivieren eines Ordners oder einer Datei
PAR In dieser Variante wird ein Ordner oder eine Datei aktiviert und die APDU des ACTIVATE-Kommandos enthält einen Parameter:
REQ(ids=A_15918)<b>A_15918 - (N034.798) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode MUSS anzeigen, dass das aktuelle File zu aktivieren ist. <b>[<=]</b>

REQ(ids=A_15919)<b>A_15919 - (N034.800) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_2b6 verwendet werden.
PAR Tabelle 96, CosT_2b6: ACTIVATE aktuelles File

TABLE(rows=5,cols=43+47+654)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '44' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR mode, der Wert '00' zeigt an, dass das aktuelle File zu aktivieren ist
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR –
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.1.2)14.2.1.2 CosK_5d9 Use Case Aktivieren eines privaten oder symmetrischen Schlüsselobjektes
PAR In dieser Variante wird ein privates Schlüsselobjekt oder ein symmetrisches Authentisierungsobjekt aktiviert und die APDU des ACTIVATE-Kommandos enthält zwei Parameter:
REQ(ids=A_15920)<b>A_15920 - (N034.810) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode MUSS anzeigen, dass ein privates oder symmetrisches Schlüsselobjekt zu aktivieren ist, wobei eine ein Oktett lange Schlüsselreferenz im Kommandoheader enthalten ist. <b>[<=]</b>

REQ(ids=A_15921)<b>A_15921 - (N034.812) K_externeWelt {K_Karte}</b>
PAR Der Parameter reference enthält eine Schlüsselreferenz. Wert und Codierung MÜSSEN gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=A_15922)<b>A_15922 - (N034.814) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_079 verwendet werden.
PAR (ids=Tabelle-97,-CosT_079)Tabelle 97, CosT_079: ACTIVATE privates oder symmetrisches Schlüsselobjekt

TABLE(rows=5,cols=41+46+657)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '44' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '20' TD(3,2/1/1)->PAR mode, hier: Ein Oktett lange Schlüsselreferenz im Parameter P2
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR reference auf ein Schlüsselobjekt
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.1.3)14.2.1.3 CosK_ff4 Use Case Aktivieren eines öffentlichen Schlüsselobjektes
PAR In dieser Variante wird ein öffentliches Schlüsselobjekt aktiviert und die APDU des ACTIVATE-Kommandos enthält zwei Parameter:
REQ(ids=A_15923)<b>A_15923 - (N034.820) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode MUSS anzeigen, dass ein Schlüsselobjekt zu aktivieren ist, wobei eine acht oder zwölf Oktett lange Schlüsselreferenz im Datenteil der Kommandonachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_15924)<b>A_15924 - (N034.822) K_externeWelt {K_Karte}</b>
PAR Der Parameter reference MUSS eine acht oder zwölf Oktett lange Schlüsselreferenz mit beliebigem Inhalt enthalten. <b>[<=]</b>

REQ(ids=A_15925)<b>A_15925 - (N034.824) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_ded verwendet werden.
PAR (ids=Tabelle-98,-CosT_ded)Tabelle 98, CosT_ded: ACTIVATE öffentliches Schlüsselobjekt

TABLE(rows=6,cols=50+66+628)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '44' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '21' TD(3,2/1/1)->PAR mode, hier: Schlüsselreferenz im Datenteil
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR -
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '83 – I2OS(OctetLength(reference), 1) – reference'
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.1.4)14.2.1.4 CosK_52c Use Case Aktivieren eines Passwortobjektes
PAR In dieser Variante wird ein Passwortobjekt aktiviert und die APDU des ACTIVATE-Kommandos enthält zwei Parameter:
REQ(ids=A_15926)<b>A_15926 - (N034.830) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode MUSS anzeigen, dass ein Passwortobjekt zu aktivieren ist, wobei eine ein Oktett lange Passwortreferenz im Kommandoheader enthalten ist. <b>[<=]</b>

REQ(ids=A_15927)<b>A_15927 - (N034.832) K_externeWelt {K_Karte}</b>
PAR Der Parameter reference enthält eine Passwortreferenz. Wert und Codierung MÜSSEN gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_15928)<b>A_15928 - (N034.834) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_ee1 verwendet werden.
PAR (ids=Tabelle-99,-CosT_ee1)Tabelle 99, CosT_ee1: ACTIVATE Passwortobjekt

TABLE(rows=5,cols=45+49+650)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '44' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '10' TD(3,2/1/1)->PAR mode, hier: Ein Oktett lange Passwortreferenz im Parameter P2
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR reference auf ein Passwortobjekt
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.1.5)14.2.1.5 Antwort der Karte auf Aktivieren eines Files
PAR (ids=Tabelle-100,-CosT_b59)Tabelle 100, CosT_b59: ACTIVATE Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=61+133+550)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiche Aktivierung
PAR (ids=Tabelle-101,-CosT_60b)Tabelle 101, CosT_60b: ACTIVATE Antwort-APDU im Fehlerfall

TABLE(rows=7,cols=52+172+520)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '64 00' TD(1,1/1/1)->PAR ObjectTerminated TD(1,2/1/1)->PAR Objekt befindet sich im Zustand "Termination state"
TR-> TD(2,0/1/1)->PAR '65 81' TD(2,1/1/1)->PAR MemoryFailure TD(2,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(3,0/1/1)->PAR '69 81' TD(3,1/1/1)->PAR VolatileKeyWithoutLCS TD(3,2/1/1)->PAR volatile Schlüssel vom Kommando nicht unterstützt
TR-> TD(4,0/1/1)->PAR '69 82' TD(4,1/1/1)->PAR SecurityStatusNotSatisfied TD(4,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(5,0/1/1)->PAR '6A 88' TD(5,1/1/1)->PAR KeyNotFound TD(5,2/1/1)->PAR Schlüsselobjekt nicht gefunden
TR-> TD(6,0/1/1)->PAR '6A 88' TD(6,1/1/1)->PAR PasswordNotFound TD(6,2/1/1)->PAR Adressiertes Passwort wurde nicht gefunden
PAR Hinweis CosH_60e: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_15929)<b>A_15929 - (N034.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando ACTIVATE verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.2.1.6)14.2.1.6 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N035.000.a)<b>G2_N035.000.a - (N035.000)a K_COS</b>
PAR Das COS MUSS die ACTIVATE-Varianten aus (N034.800), (N034.814), (N034.824) und (N034.834) unterstützen. <b>[<=]</b>

REQ(ids=A_15930)<b>A_15930 - (N035.000)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere ACTIVATE-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N035.100.a.1)<b>G2_N035.100.a.1 - (N035.100)a.1 K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '00' besitzt und channelContext.currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N035.100.a.2)<b>G2_N035.100.a.2 - (N035.100)a.2 K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '00' besitzt und channelContext.currentEF (siehe (N029.900)m) nicht auf eine Datei zeigt, dann MUSS affectedObject gleich currentFolder gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N035.100.b)<b>G2_N035.100.b - (N035.100)b K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '20' oder '21' besitzt, dann gilt<br>affectedObject = SearchKey(<br>    channelContext.currentFolder,<br>    reference,<br>   "WildCard"     <br>). Gemäß CosT_08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N035.100.c)<b>G2_N035.100.c - (N035.100)c K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '10' besitzt, dann gilt<br>affectedObject = SearchPwd( currentFolder, reference ). Wenn die Passwortsuche mit einem Fehler abbricht, genau dann MUSS das Kommando mit dem Trailer PasswordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N035.110)<b>G2_N035.110 - (N035.110) K_COS</b>
PAR Wenn affectedObject zu einem Eintrag in volatileCache gehört, dann MUSS das Kommando mit dem Trailer VolatileKeyWithoutLCS terminieren. <b>[<=]</b>

REQ(ids=G2_N035.200)<b>G2_N035.200 - (N035.200) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N035.300.a)<b>G2_N035.300.a - (N035.300)a K_COS</b>
PAR Wenn der physikalische Wert von lifeCycleStatus von affectedObject den Wert "Termination state" besitzt, genau dann MUSS das Kommando mit dem Trailer ObjectTerminated terminieren. <b>[<=]</b>

REQ(ids=G2_N035.300.b)<b>G2_N035.300.b - (N035.300)b K_COS</b>
PAR Wenn der physikalische Wert von lifeCycleStatus von affectedObject den Wert "Operational state (active)" besitzt, dann MUSS als Trailer NoError verwendet werden. <b>[<=]</b>

REQ(ids=G2_N035.400)<b>G2_N035.400 - (N035.400) K_COS</b>
PAR Der physikalische Wert von lifeCycleStatus von affectedObject MUSS mittels Transaktionsschutz auf den Wert "Operational state (active)" gesetzt werden. <b>[<=]</b>

REQ(ids=A_15931)<b>A_15931 - (N035.500) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_15932)<b>A_15932 - (N035.600) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N035.700)<b>G2_N035.700 - (N035.700) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_15933)<b>A_15933 - (N035.800) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>a. Die Priorität der Trailer in CosT_60b ist herstellerspezifisch.<br>b. Jeder Trailer in CosT_60b MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>c. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.2.2)14.2.2 CosK_ed6 CREATE
REQ(ids=A_15934)<b>A_15934 - (N035.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das CREATE-Kommando gemäß [ISO/IEC 7816-9] würde<br>a. unterstützt oder<br>b. abgelehnt. <b>[<=]</b>

PAR Hinweis CosH_f64: Die entsprechende Funktionalität dieses Kommandos wird im Rahmen dieses Dokumentes durch das Kommando LOAD APPLICATION (siehe CosK_74a) bereitgestellt.
PAR -HEADING(ids=14.2.3)14.2.3 CosK_a78 DEACTIVATE
PAR Das Kommando DEACTIVATE deaktiviert reversibel ein Objekt. Ein betroffenes File wird vor der Operation ausgewählt. Dies geschieht vor dem Senden dieses DEACTIVATE-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier). Wenn ein Schlüsselobjekt oder ein Passwortobjekt vom Kommando betroffen ist, dann wird dieses durch eine Schlüssel- oder Passwortreferenz bestimmt, die in der Kommandonachricht enthalten ist.
PAR -HEADING(ids=14.2.3.1)14.2.3.1 CosK_a04 Use Case Deaktivieren eines Ordners oder einer Datei
PAR In dieser Variante wird ein Ordner oder eine Datei deaktiviert und die APDU des DEACTIVATE-Kommandos enthält einen Parameter:
REQ(ids=A_15936)<b>A_15936 - (N035.998) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode MUSS anzeigen, dass das aktuelle File zu deaktivieren ist. <b>[<=]</b>

REQ(ids=A_15937)<b>A_15937 - (N036.000) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_e37 verwendet werden.
PAR (ids=Tabelle-102,-CosT_e37)Tabelle 102, CosT_e37: DEACTIVATE aktuelles File

TABLE(rows=5,cols=42+54+648)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '04' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR mode, der Wert '00' zeigt an, dass das aktuelle File zu deaktivieren ist
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR –
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.3.2)14.2.3.2 CosK_05b Use Case Deaktivieren eines privaten oder symmetrischen Schlüsselobjektes
PAR In dieser Variante wird ein privates Schlüsselobjekt oder ein symmetrisches Authentisierungsobjekt deaktiviert und die APDU des DEACTIVATE-Kommandos enthält zwei Parameter:
REQ(ids=A_15938)<b>A_15938 - (N036.010) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode MUSS anzeigen, dass ein privates oder symmetrisches Schlüsselobjekt zu deaktivieren ist, wobei eine ein Oktett lange Schlüsselreferenz im Kommandoheader enthalten ist. <b>[<=]</b>

REQ(ids=A_15939)<b>A_15939 - (N036.012) K_externeWelt {K_Karte}</b>
PAR Der Parameter reference enthält eine Schlüsselreferenz. Wert und Codierung MÜSSEN gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=A_15940)<b>A_15940 - (N036.014) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_a2f verwendet werden.
PAR (ids=Tabelle-103,-CosT_a2f)Tabelle 103, CosT_a2f: DEACTIVATE privates oder symmetrisches Schlüsselobjekt

TABLE(rows=5,cols=40+40+664)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '04' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '20' TD(3,2/1/1)->PAR mode, hier: Ein Oktett lange Schlüsselreferenz im Parameter P2
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR reference auf ein Schlüsselobjekt
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.3.3)14.2.3.3 CosK_6f9 Use Case Deaktivieren eines öffentlichen Schlüsselobjektes
PAR In dieser Variante wird ein öffentliches Schlüsselobjekt deaktiviert und die APDU des DEACTIVATE-Kommandos enthält zwei Parameter:
REQ(ids=A_15941)<b>A_15941 - (N036.020) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode MUSS anzeigen, dass ein Schlüsselobjekt zu deaktivieren ist, wobei eine acht oder zwölf Oktett lange Schlüsselreferenz im Datenteil der Kommandonachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_15942)<b>A_15942 - (N036.022) K_externeWelt {K_Karte}</b>
PAR Der Parameter reference MUSS eine acht oder zwölf Oktett lange Schlüsselreferenz mit beliebigem Inhalt enthalten. <b>[<=]</b>

REQ(ids=A_15943)<b>A_15943 - (N036.024) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_ac5 verwendet werden.
PAR (ids=Tabelle-104,-CosT_ac5)Tabelle 104, CosT_ac5: DEACTIVATE öffentliches Schlüsselobjekt

TABLE(rows=6,cols=48+62+634)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '04' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '21' TD(3,2/1/1)->PAR mode, hier: Schlüsselreferenz im Datenteil
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR -
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '83 – I2OS(OctetLength(reference), 1) – reference'
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.3.4)14.2.3.4 CosK_e9c Use Case Deaktivieren eines Passwortobjektes
PAR In dieser Variante wird ein Passwortobjekt deaktiviert und die APDU des DEACTIVATE-Kommandos enthält zwei Parameter:
REQ(ids=A_15944)<b>A_15944 - (N036.030) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode MUSS anzeigen, dass ein Passwortobjekt zu deaktivieren ist, wobei eine ein Oktett lange Passwortreferenz im Kommandoheader enthalten ist. <b>[<=]</b>

REQ(ids=A_15945)<b>A_15945 - (N036.032) K_externeWelt {K_Karte}</b>
PAR Der Parameter reference enthält eine Passwortreferenz. Wert und Codierung MÜSSEN gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_15946)<b>A_15946 - (N036.034) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_e19 verwendet werden.
PAR (ids=Tabelle-105,-CosT_e19)Tabelle 105, CosT_e19: DEACTIVATE Passwortobjekt

TABLE(rows=5,cols=44+59+641)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '04' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '10' TD(3,2/1/1)->PAR mode, hier: Ein Oktett lange Passwortreferenz im Parameter P2
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR reference auf ein Passwortobjekt
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.3.5)14.2.3.5 Antwort der Karte auf Deaktivieren eines Files
PAR (ids=Tabelle-106,-CosT_294)Tabelle 106, CosT_294: DEACTIVATE Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+185+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiche Deaktivierung
PAR (ids=Tabelle-107,-CosT_93a)Tabelle 107, CosT_93a: DEACTIVATE Antwort-APDU im Fehlerfall

TABLE(rows=7,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '64 00' TD(1,1/1/1)->PAR ObjectTerminated TD(1,2/1/1)->PAR Objekt befindet sich im Zustand "Termination state"
TR-> TD(2,0/1/1)->PAR '65 81' TD(2,1/1/1)->PAR MemoryFailure TD(2,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(3,0/1/1)->PAR '69 81' TD(3,1/1/1)->PAR VolatileKeyWithoutLCS TD(3,2/1/1)->PAR volatile Schlüssel vom Kommando nicht unterstützt
TR-> TD(4,0/1/1)->PAR '69 82' TD(4,1/1/1)->PAR SecurityStatusNotSatisfied TD(4,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(5,0/1/1)->PAR '6A 88' TD(5,1/1/1)->PAR KeyNotFound TD(5,2/1/1)->PAR Schlüsselobjekt nicht gefunden
TR-> TD(6,0/1/1)->PAR '6A 88' TD(6,1/1/1)->PAR PasswordNotFound TD(6,2/1/1)->PAR Adressiertes Passwort wurde nicht gefunden
PAR Hinweis CosH_94c: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_15947)<b>A_15947 - (N036.100) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando DEACTIVATE verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.2.3.6)14.2.3.6 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N036.200.a)<b>G2_N036.200.a - (N036.200)a K_COS</b>
PAR Das COS MUSS die DEACTIVATE-Varianten aus (N036.000), (N036.014), (N036.024) und (N036.034) unterstützen. <b>[<=]</b>

REQ(ids=A_15948)<b>A_15948 - (N036.200)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere DEACTIVATE-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N036.300.a.1)<b>G2_N036.300.a.1 - (N036.300)a.1 K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '00' besitzt und channelContext.currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N036.300.a.2)<b>G2_N036.300.a.2 - (N036.300)a.2 K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '00' besitzt und channelContext.currentEF (siehe (N029.900)m) nicht auf eine Datei zeigt, dann MUSS affectedObject gleich currentFolder gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N036.300.b)<b>G2_N036.300.b - (N036.300)b K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '20' oder '21' besitzt, dann gilt<br>affectedObject = SearchKey(<br>    channelContext.currentFolder,<br>    reference,<br>   "WildCard"     <br>). Gemäß CosT_08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N036.300.c)<b>G2_N036.300.c - (N036.300)c K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '10' besitzt, dann gilt<br>affectedObject = SearchPwd( currentFolder, reference ). Wenn die Passwortsuche mit einem Fehler abbricht, genau dann MUSS das Kommando mit dem Trailer PasswordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N036.310)<b>G2_N036.310 - (N036.310) K_COS</b>
PAR Wenn affectedObject zu einem Eintrag in volatileCache gehört, dann MUSS das Kommando mit dem Trailer VolatileKeyWithoutLCS terminieren. <b>[<=]</b>

REQ(ids=G2_N036.400)<b>G2_N036.400 - (N036.400) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N036.500.a)<b>G2_N036.500.a - (N036.500)a K_COS</b>
PAR Wenn der physikalische Wert von lifeCycleStatus von affectedObject den Wert "Termination state" besitzt, genau dann MUSS das Kommando mit dem Trailer ObjectTerminated terminieren. <b>[<=]</b>

REQ(ids=G2_N036.500.b)<b>G2_N036.500.b - (N036.500)b K_COS</b>
PAR Wenn der physikalische Wert von lifeCycleStatus von affectedObject den Wert "Operational state (deactived)" besitzt, dann MUSS als Trailer NoError verwendet werden. <b>[<=]</b>

REQ(ids=G2_N036.600)<b>G2_N036.600 - (N036.600) K_COS</b>
PAR Der physikalische Wert von lifeCycleStatus von affectedObject MUSS mittels Transaktionsschutz auf den Wert "Operational state (deactivated)" gesetzt werden. <b>[<=]</b>

REQ(ids=A_15949)<b>A_15949 - (N036.700) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_15950)<b>A_15950 - (N036.800) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N036.900)<b>G2_N036.900 - (N036.900) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_15951)<b>A_15951 - (N037.000) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>a. Die Priorität der Trailer in CosT_93a ist herstellerspezifisch.<br>b. Jeder Trailer in CosT_93a MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>c. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.2.4)14.2.4 CosK_da3 DELETE
PAR Das Kommando DELETE löscht Objekte aus dem Objektsystem. Ein zu löschendes File wird vor der Operation ausgewählt. Dies geschieht vor dem Senden dieses DELETE-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier). Welches Schlüsselobjekt oder welches Passwortobjekt vom Kommando betroffen ist, wird durch eine Schlüssel- oder Passwortreferenz bestimmt, die in der Kommandonachricht enthalten ist. Für dieses Kommando gelten Restriktionen, siehe (N099.500).
PAR -HEADING(ids=14.2.4.1)14.2.4.1 CosK_024 Use Case Löschen eines Ordners oder einer Datei
PAR In dieser Variante wird ein Ordner oder eine Datei gelöscht und die APDU des DELETE-Kommandos enthält einen Parameter:
REQ(ids=A_15952)<b>A_15952 - (N037.098) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode MUSS anzeigen, dass das aktuelle File zu löschen ist. <b>[<=]</b>

REQ(ids=A_15953)<b>A_15953 - (N037.100) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_799 verwendet werden.
PAR (ids=Tabelle-108,-CosT_799)Tabelle 108, CosT_799: DELETE aktuelles File

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'E4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR mode, der Wert '00' zeigt an, dass das aktuelle File zu löschen ist
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR –
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.4.2)14.2.4.2 CosK_0a2 Use Case Löschen eines privaten oder symmetrischen Schlüsselobjektes
PAR In dieser Variante wird ein privates Schlüsselobjekt oder ein symmetrisches Authentisierungsobjekt gelöscht und die APDU des DELETE-Kommandos enthält zwei Parameter:
REQ(ids=A_15954)<b>A_15954 - (N037.110) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode MUSS anzeigen, dass ein privates oder symmetrisches Schlüsselobjekt zu löschen ist, wobei eine ein Oktett lange Schlüsselreferenz im Kommandoheader enthalten ist. <b>[<=]</b>

REQ(ids=A_15955)<b>A_15955 - (N037.112) K_externeWelt {K_Karte}</b>
PAR Der Parameter reference enthält eine Schlüsselreferenz. Wert und Codierung MÜSSEN gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=A_15956)<b>A_15956 - (N037.114) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_57c verwendet werden.
PAR (ids=Tabelle-109,-CosT_57c)Tabelle 109, CosT_57c: DELETE privates oder symmetrisches Schlüsselobjekt

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'E4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '20' TD(3,2/1/1)->PAR mode, hier: Ein Oktett lange Schlüsselreferenz im Parameter P2
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR reference auf ein Schlüsselobjekt
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.4.3)14.2.4.3 CosK_f8f Use Case Löschen eines öffentlichen Schlüsselobjektes
PAR In dieser Variante wird ein öffentliches Schlüsselobjekt gelöscht und die APDU des DELETE-Kommandos enthält zwei Parameter:
REQ(ids=A_15957)<b>A_15957 - (N037.120) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode MUSS anzeigen, dass ein Schlüsselobjekt zu löschen ist, wobei eine acht oder zwölf Oktett lange Schlüsselreferenz im Datenteil der Kommandonachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_15958)<b>A_15958 - (N037.122) K_externeWelt {K_Karte}</b>
PAR Der Parameter reference MUSS eine acht oder zwölf Oktett lange Schlüsselreferenz mit beliebigem Inhalt enthalten. <b>[<=]</b>

REQ(ids=A_15959)<b>A_15959 - (N037.124) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_57b verwendet werden.
PAR (ids=Tabelle-110,-CosT_57b)Tabelle 110, CosT_57b: DELETE öffentliches Schlüsselobjekt

TABLE(rows=6,cols=63+86+442)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'E4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '21' TD(3,2/1/1)->PAR mode, hier: Schlüsselreferenz im Datenteil
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR -
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '83 –I2OS(OctetLength(reference), 1) – reference'
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.4.4)14.2.4.4 CosK_0ea Use Case Löschen eines Passwortobjektes
PAR In dieser Variante wird ein Passwortobjekt gelöscht und die APDU des DELETE-Kommandos enthält zwei Parameter:
REQ(ids=A_15960)<b>A_15960 - (N037.130) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode MUSS anzeigen, dass ein Passwortobjekt zu löschen ist, wobei eine ein Oktett lange Passwortreferenz im Kommandoheader enthalten ist. <b>[<=]</b>

REQ(ids=A_15961)<b>A_15961 - (N037.132) K_externeWelt {K_Karte}</b>
PAR Der Parameter reference enthält eine Passwortreferenz. Wert und Codierung MÜSSEN gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_15962)<b>A_15962 - (N037.134) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_4e7 verwendet werden.
PAR (ids=Tabelle-111,-CosT_4e7)Tabelle 111, CosT_4e7: DELETE Passwortobjekt

TABLE(rows=5,cols=63+86+442)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'E4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '10' TD(3,2/1/1)->PAR mode, hier: Ein Oktett lange Passwortreferenz im Parameter P2
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR reference auf ein Passwortobjekt
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.4.5)14.2.4.5 Antwort der Karte auf Löschen eines Files
PAR (ids=Tabelle-112,-CosT_ee2)Tabelle 112, CosT_ee2: DELETE Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+185+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiche Löschoperation
PAR (ids=Tabelle-113,-CosT_6c1)Tabelle 113, CosT_6c1: DELETE Antwort-APDU im Fehlerfall

TABLE(rows=5,cols=64+250+0+430)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/2)->PAR Inhalt TH(0,3/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/2)->PAR MemoryFailure TD(1,3/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/2)->PAR SecurityStatusNotSatisfied TD(2,3/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '6A 88' TD(3,1/1/1)->PAR KeyNotFound TD(3,2/1/2)->PAR Schlüsselobjekt nicht gefunden
TR-> TD(4,0/1/1)->PAR '6A 88' TD(4,1/1/2)->PAR PasswordNotFound TD(4,3/1/1)->PAR Adressiertes Passwort wurde nicht gefunden
PAR Hinweis CosH_14b: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_15963)<b>A_15963 - (N037.200) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando DELETE verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.2.4.6)14.2.4.6 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N037.300.a)<b>G2_N037.300.a - (N037.300)a K_COS</b>
PAR Das COS MUSS die DELETE-Varianten aus (N037.100), (N037.114), (N037.124) und (N037.134) unterstützen. <b>[<=]</b>

REQ(ids=A_15964)<b>A_15964 - (N037.300)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere DELETE-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N037.400.a.1)<b>G2_N037.400.a.1 - (N037.400)a.1 K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '00' besitzt und channelContext.currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N037.400.a.2)<b>G2_N037.400.a.2 - (N037.400)a.2 K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '00' besitzt und channelContext.currentEF (siehe (N029.900)m) nicht auf eine Datei zeigt, dann MUSS affectedObject gleich currentFolder gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N037.400.b)<b>G2_N037.400.b - (N037.400)b K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '20' oder '21' besitzt, dann gilt<br>affectedObject = SearchKey(<br>    channelContext.currentFolder,<br>    reference,<br>   "WildCard"     <br>). Gemäß CosT_08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N037.400.c)<b>G2_N037.400.c - (N037.400)c K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '10' besitzt, dann gilt<br>affectedObject = SearchPwd( currentFolder, reference ). Wenn die Passwortsuche mit einem Fehler abbricht, genau dann MUSS das Kommando mit dem Trailer PasswordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N037.500)<b>G2_N037.500 - (N037.500) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N037.600)<b>G2_N037.600 - (N037.600) K_COS</b>
PAR Die Löschoperation MUSS mit Transaktionsschutz durchgeführt werden. <b>[<=]</b>

REQ(ids=G2_N037.690)<b>G2_N037.690 - (N037.690) K_COS</b>
PAR Wenn die Kommandos-APDU dieses DELETE-Kommandos gemäß CosK_842 mittels Sessionkeys gesichert war, dann MUSS die korrespondierende Antwort-APDU gemäß CosK_c3a mit denselben Sessionkeys gesichert sein, auch wenn als Seiteneffekt von (N037.700) Sessionkeys gelöscht werden. <b>[<=]</b>

REQ(ids=A_15965)<b>A_15965 - (N037.700)a K_COS</b>
PAR Wenn affectedObject vom Typ Ordner ist, dann MÜSSEN die folgenden Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N037.700.a.1)<b>G2_N037.700.a.1 - (N037.700)a.1 K_COS</b>
PAR Schritt 1:clearSecurityStatusFolder( affectedObject ) MUSS ausgeführt werden. <b>[<=]</b>

REQ(ids=G2_N037.700.a.2)<b>G2_N037.700.a.2 - (N037.700)a.2 K_COS</b>
PAR Aus dfSpecificPasswordList MÜSSEN alle Einträge entfernt werden, die zu affectedObject oder einem seiner Unterordner gehören. <b>[<=]</b>

REQ(ids=G2_N037.700.a.3)<b>G2_N037.700.a.3 - (N037.700)a.3 K_COS</b>
PAR In keyReferenceList MÜSSEN alle Einträge auf den Wert "leer" gesetzt werden, die auf Schlüsselobjekte verweisen, die affectedObject oder einem seiner Unterodner zugeordnet sind. <b>[<=]</b>

REQ(ids=G2_N037.700.a.4)<b>G2_N037.700.a.4 - (N037.700)a.4 K_COS</b>
PAR currentEF MUSS auf den Wert "undefined" gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N037.700.a.5)<b>G2_N037.700.a.5 - (N037.700)a.5 K_COS</b>
PAR currentFolder MUSS auf den Vater von affectedObject gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N037.700.a.6)<b>G2_N037.700.a.6 - (N037.700)a.6 K_COS</b>
PAR Aus allPublicKeyList MÜSSEN alle Einträge entfernt werden, die affectedObject oder einem seiner Unterodner zugeordnet sind. <b>[<=]</b>

REQ(ids=G2_N037.700.a.7)<b>G2_N037.700.a.7 - (N037.700)a.7 K_COS</b>
PAR affectedObject MUSS inklusive Subtree (also rekursiv aller seiner Kinder) gelöscht werden. <b>[<=]</b>

REQ(ids=G2_N037.700.b)<b>G2_N037.700.b - (N037.700)b K_COS</b>
PAR Wenn affectedObject vom Typ Datei ist, dann MUSS<br>1. currentEF auf den Wert "undefined" gesetzt werden und<br>2. affectedObject gelöscht werden. <b>[<=]</b>

REQ(ids=G2_N037.700.c)<b>G2_N037.700.c - (N037.700)c K_COS</b>
PAR Wenn affectedObject vom Typ Symmetrisches Authentisierungsobjekt oder symmetrisches Kartenverbindungsobjekt ist, dann MUSS<br>1. clearSecurityStatusKey( affectedObject ) ausgeführt werden und<br>2. affectedObject gelöscht werden. <b>[<=]</b>

REQ(ids=G2_N037.700.d)<b>G2_N037.700.d - (N037.700)d K_COS</b>
PAR Wenn affectedObject vom Typ Passwortobjekt ist, dann MUSS<br>1. clearPasswordStatus( affectedObject ) ausgeführt werden und<br>2. affectedObject gelöscht werden. <b>[<=]</b>

REQ(ids=G2_N037.700.e)<b>G2_N037.700.e - (N037.700)e K_COS</b>
PAR Wenn affectedObject vom einen anderen Typ besitzt, als die zuvor genannten, dann MUSS affectedObject gelöscht werden. <b>[<=]</b>

REQ(ids=G2_N037.800.a)<b>G2_N037.800.a - (N037.800)a K_COS</b>
PAR Wenn affectedObject vom Typ Ordner oder Datei ist, dann MUSS vormals von diesem Objekt allokierter Speicher so freigegeben werden, dass er zum Anlegen anderer Objekte verwendbar ist. <b>[<=]</b>

REQ(ids=A_15966)<b>A_15966 - (N037.800)b.1 K_COS</b>
PAR Wenn affectedObject nicht vom Typ Ordner oder Datei ist, dann SOLL vormals von diesem Objekt allokierter Speicher so freigegeben werden, dass er zum Anlegen anderer Objekte verwendbar ist. <b>[<=]</b>

REQ(ids=A_15967)<b>A_15967 - (N037.800)b.2 K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden beim Löschen von Objekten des Typs Symmetrisches Authentisierungsobjekt oder Passwortobjekt würden allokierter Speicher nicht freigegeben. <b>[<=]</b>

REQ(ids=A_15968)<b>A_15968 - (N037.850) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden beim Löschen eines Schlüssel, der in einem Element von keyReferenceList eingetragen ist, würde der zum gelöschten Schlüssel gehörende Eintrag in keyReferenceList<br>a. gelöscht oder<br>b. bliebe bestehen. <b>[<=]</b>

REQ(ids=A_15969)<b>A_15969 - (N037.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_15970)<b>A_15970 - (N038.000) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N038.100)<b>G2_N038.100 - (N038.100) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_15971)<b>A_15971 - (N038.200) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>a. Die Priorität der Trailer in CosT_6c1 ist herstellerspezifisch.<br>b. Jeder Trailer in CosT_6c1 MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>c. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

REQ(ids=G2_N038.300)<b>G2_N038.300 - (N038.300) K_COS</b>
PAR Im Fehlerfall MÜSSEN currentFolder und currentEF unverändert auf dem Wert vor Ausführung des Kommandos belassen werden. <b>[<=]</b>

PAR -HEADING(ids=14.2.5)14.2.5 CosK_74a LOAD APPLICATION
PAR Das Kommando LOAD APPLICATION wird verwendet, um neue Files im Objektsystem anzulegen. So ist es möglich,    

LIST->
LITEM->PAR einen neuen Ordner inklusive Subtree,LITEM->PAR eine neue Datei inklusive Inhalt (transparent oder strukturiert)
PAR anzulegen. Das neu angelegte File wird im currentFolder gespeichert. Typischerweise ist die beim Anlegen neuer Files zur Karte transferierte Datenmenge so groß, dass sie nicht in einer einzigen Kommando-APDU übertragbar ist. Deshalb unterstützt dieses Kommando "Command Chaining".
PAR -HEADING(ids=14.2.5.1)14.2.5.1 CosK_206 Use Case Anlegen neues Objekt, nicht Ende der Kommandokette
PAR Diese Variante ist zu wählen, wenn die Datenmenge nicht in einer Kommando-APDU übertragbar ist. Sie kommt zum Einsatz von der ersten bis zur vorletzten Kommando-APDU. Die letzte Kommando-APDU wird gemäß (N038.800) übertragen. In der hier beschriebenen Variante enthält die APDU des LOAD APPLICATION-Kommandos zwei Parameter.
REQ(ids=A_15973)<b>A_15973 - (N038.400) K_externeWelt {K_Karte}</b>
PAR Das CLA-Byte MUSS anzeigen, dass diese Kommando-APDU nicht die letzte einer Command-Chaining-Kette ist. Dies wird durch den Wert CLA = '10' codiert. <b>[<=]</b>

REQ(ids=A_15974)<b>A_15974 - (N038.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter cmdData enthält Daten, welche das neu anzulegende File beschreiben. Der Parameter cmdData ist ein Oktettstring mit beliebigem, herstellerspezifischem Inhalt. Die Länge von cmdData MUSS aus dem in (N026.900) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_15975)<b>A_15975 - (N038.600) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 oder eine Case 3E Kommando-APDU gemäß CosK_afd über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_7b8 verwendet werden.
PAR (ids=Tabelle-114,-CosT_7b8)Tabelle 114, CosT_7b8: LOAD APPLICATION mit Command Chaining

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '10' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4], Chaining Bit b5 gesetzt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'EA' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-13]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR –
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR –
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR cmdData
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.5.2)14.2.5.2 CosK_02c Use Case Anlegen neues Objekt, Ende der Kommandokette
PAR Diese Variante ist zu wählen, wenn die Datenmenge in einer Kommando-APDU transferierbar ist, oder das letzte Kommando einer Chaining-Kette zu übertragen ist. In dieser Variante enthält die APDU des LOAD APPLICATION-Kommandos einen Parameter.
REQ(ids=A_15976)<b>A_15976 - (N038.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter cmdData enthält Daten, welche das neu anzulegende File beschreiben. Der Parameter cmdData ist ein Oktettstring mit beliebigem, herstellerspezifischem Inhalt. Die Länge von cmdData MUSS aus dem in (N026.900) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_15977)<b>A_15977 - (N038.800) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 oder eine Case 3E Kommando-APDU gemäß CosK_afd über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_253 verwendet werden.
PAR (ids=Tabelle-115,-CosT_253)Tabelle 115, CosT_253: LOAD APPLICATION ohne Command Chaining

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'EA' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-13]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR –
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR –
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR cmdData
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.5.3)14.2.5.3 Antwort der Karte auf Anlegen neues Objekt
PAR (ids=Tabelle-116,-CosT_faf)Tabelle 116, CosT_faf: LOAD APPLICATION Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreicher Ladevorgang
PAR (ids=Tabelle-117,-CosT_df0)Tabelle 117, CosT_df0: LOAD APPLICATION Antwort-APDU im Fehlerfall

TABLE(rows=7,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '6A 84' TD(3,1/1/1)->PAR OutOfMemory TD(3,2/1/1)->PAR Zu wenig Speicherplatz für neues Objekt
TR-> TD(4,0/1/1)->PAR '6A 89' TD(4,1/1/1)->PAR DuplicatedObject TD(4,2/1/1)->PAR Identifier des neuen Objektes wird bereits verwendet
TR-> TD(5,0/1/1)->PAR '6A 8A' TD(5,1/1/1)->PAR DfNameExists TD(5,2/1/1)->PAR AID des neuen Objektes wird bereits verwendet
TR-> TD(6,0/1/1)->PAR '6D 00' TD(6,1/1/1)->PAR InstructionNotSupported TD(6,2/1/1)->PAR Die Karte befindet sich im Zustand "Termination state"
PAR Hinweis CosH_c44: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_15978)<b>A_15978 - (N038.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando LOAD APPLICATION verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.2.5.4)14.2.5.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N039.000.a)<b>G2_N039.000.a - (N039.000)a K_COS</b>
PAR Das COS MUSS die LOAD APPLICATION-Varianten aus (N038.600) und (N038.800) unterstützen. <b>[<=]</b>

REQ(ids=A_15979)<b>A_15979 - (N039.000)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere LOAD APPLICATION-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_15980)<b>A_15980 - (N039.010) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Attribut lifeCycleStatus des Objektsystems (siehe (N019.900)i) besitze den Wert "Termination state" und das Kommando terminiere mit dem Trailer InstructionNotSupported. <b>[<=]</b>

REQ(ids=G2_N039.100)<b>G2_N039.100 - (N039.100) K_COS</b>
PAR Als affectedObject MUSS channelContext.currentFolder verwendet werden. <b>[<=]</b>

REQ(ids=G2_N039.200)<b>G2_N039.200 - (N039.200) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=A_15981)<b>A_15981 - (N039.300) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden ein Kommando oder eine eventuell aktive Chaining-Kette würde wegen einer der folgenden Fälle akzeptiert oder abgelehnt: Das neu anzulegende File ist

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR ein Ordner und besitzt ein Attribut applicationIdentifier und dieser applicationIdentifier ist bereits einem anderen Ordner innerhalb des Objektsystems zugeordnet.LITEM->PAR ein Ordner und besitzt ein Attribut fileIdentifier besitzt und dieser fileIdentifier ist bereits einem anderen File innerhalb von affectedObject zugeordnet.LITEM->PAR eine Datei und deren Attribut fileIdentifier ist bereits einem anderen File innerhalb von affectedObject zugeordnet.LITEM->PAR eine Datei und deren Attribut shortFileIdentifier ist bereits einer anderen Datei innerhalb von affectedObject zugeordnet.
PAR <b>[<=]</b>

REQ(ids=G2_N039.300.a)<b>G2_N039.300.a - (N039.300)a K_COS</b>
PAR Wenn das Kommando abgelehnt wird, weil das neu anzulegende File ein Ordner ist und ein Attribut applicationIdentifier besitzt und dieser applicationIdentifier ist bereits einem anderen Ordner innerhalb des Objektsystems zugeordnet, genau dann MUSS das Kommando mit dem Trailer DfNameExists terminieren. <b>[<=]</b>

REQ(ids=G2_N039.300.b)<b>G2_N039.300.b - (N039.300)b K_COS</b>
PAR Wenn das Kommando abgelehnt wird, weil das neu anzulegende File ein Ordner ist und ein Attribut fileIdentifier besitzt und dieser fileIdentifier ist bereits einem anderen File in affectedObject zugeordnet, dann MUSS das Kommando mit dem Trailer DuplicatedObject terminieren. <b>[<=]</b>

REQ(ids=G2_N039.300.c)<b>G2_N039.300.c - (N039.300)c K_COS</b>
PAR Wenn das Kommando abgelehnt wird, weil das neu anzulegende File eine Datei ist, deren Attribut fileIdentifier bereits einem anderen File in affectedObject zugeordnet ist, dann MUSS das Kommando mit dem Trailer DuplicatedObject terminieren. <b>[<=]</b>

REQ(ids=G2_N039.300.d)<b>G2_N039.300.d - (N039.300)d K_COS</b>
PAR Wenn das Kommando abgelehnt wird, weil das neu anzulegende File eine Datei ist und ein Attribut shortFileIdentifier besitzt und dieser shortFileIdentifier ist bereits einer anderen Datei in affectedObject zugeordnet, dann MUSS das Kommando mit dem Trailer DuplicatedObject terminieren. <b>[<=]</b>

REQ(ids=G2_N039.400.a)<b>G2_N039.400.a - (N039.400)a K_COS</b>
PAR Das Kommando MUSS akzeptiert werden, wenn das neu anzulegende Objekt ein Ordner ist und ein Attribut applicationIdentifier besitzt und dieser applicationIdentifier keinem anderen Ordner innerhalb des Objektsystems zugeordnet ist. <b>[<=]</b>

REQ(ids=G2_N039.400.b)<b>G2_N039.400.b - (N039.400.)b K_COS</b>
PAR Das Kommando MUSS akzeptiert werden, wenn das neu anzulegende Objekt ein Ordner ist und ein Attribut fileIdentifier besitzt und dieser fileIdentifier keinem anderen File innerhalb von affectedObject zugeordnet ist. <b>[<=]</b>

REQ(ids=G2_N039.400.c)<b>G2_N039.400.c - (N039.400)c K_COS</b>
PAR Das Kommando MUSS akzeptiert werden, wenn das neu anzulegende Objekt eine Datei ist, deren Attribut fileIdentifier keinem anderen File innerhalb von affectedObject zugeordnet ist. <b>[<=]</b>

REQ(ids=G2_N039.400.d)<b>G2_N039.400.d - (N039.400)d K_COS</b>
PAR Das Kommando MUSS akzeptiert werden, wenn das neu anzulegende Objekt eine Datei ist und ein Attribut shortFileIdentifier besitzt und dieser shortFileIdentifier keiner anderen Datei innerhalb von affectedObject zugeordnet ist. <b>[<=]</b>

REQ(ids=G2_N039.500)<b>G2_N039.500 - (N039.500) K_COS</b>
PAR Wenn insgesamt ausreichender, aber nicht genügend zusammenhängender Speicherplatz vorhanden ist, dann MUSS das COS intern dafür sorgen, dass diese Operation trotzdem erfolgreich durchführbar ist. Typischerweise wird diese Operation als "Defragmentieren" bezeichnet. <b>[<=]</b>

REQ(ids=G2_N039.600)<b>G2_N039.600 - (N039.600) K_COS</b>
PAR Wenn nicht genügend Speicherplatz zum Anlegen des neuen Objektes vorhanden ist, genau dann MUSS das Kommando mit dem Trailer OutOfMemory terminieren. <b>[<=]</b>

REQ(ids=A_15982)<b>A_15982 - (N039.700) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_15983)<b>A_15983 - (N039.800) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N039.900)<b>G2_N039.900 - (N039.900) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_15984)<b>A_15984 - (N040.000) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>a. Die Priorität der Trailer in CosT_df0 ist herstellerspezifisch.<br>b. Jeder Trailer in CosT_df0 MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>c. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

REQ(ids=G2_N040.100.a)<b>G2_N040.100.a - (N040.100)a K_COS</b>
PAR Wenn dies das einzige oder letzte Kommando einer Command-Chaining-Kette ist und das neu angelegte Objekt ist ein Ordner, dann MUSS im Erfolgsfall channelContext.currentFolder auf den neu angelegten Ordner gesetzt werden. Dabei sind die Regeln zum Setzen des Kanalkontextes für den neuen Ordner zu berücksichtigen (siehe (N048.200)b). <b>[<=]</b>

REQ(ids=G2_N040.100.b)<b>G2_N040.100.b - (N040.100)b K_COS</b>
PAR Wenn dies das einzige oder letzte Kommando einer Command-Chaining-Kette ist und das neu angelegte Objekt ist eine Datei, dann MUSS im Erfolgsfall currentEF auf die neu angelegte Datei gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N040.200.a)<b>G2_N040.200.a - (N040.200)a K_COS</b>
PAR Wenn das Kommando nicht erfolgreich verlief, dann DÜRFEN currentFolder und currentEF NICHT verändert werden, auch wenn ein LOAD APPLICATION-Kommando mit einem Trailer aus CosT_df0 terminierte, sondern MÜSSEN denselben Wert besitzen, wie vor der Ausführung dieses LOAD APPLICATION-Kommandos. <b>[<=]</b>

REQ(ids=G2_N040.200.b)<b>G2_N040.200.b - (N040.200)b K_COS</b>
PAR Wenn das Kommando nicht erfolgreich verlief, dann DÜRFEN currentFolder und currentEF NICHT verändert werden, auch wenn eine Command-Chaining-Kette abgebrochen wird (siehe (N029.874)), sondern MÜSSEN denselben Wert besitzen, wie vor dem Start dieser Command-Chaining-Kette. <b>[<=]</b>

REQ(ids=G2_N040.300)<b>G2_N040.300 - (N040.300) K_COS</b>
PAR Wenn dieses LOAD APPLICATION-Kommando mit einem Trailer aus CosT_df0 terminierte, dann MUSS ein eventuell aktives Command Chaining abgebrochen werden. <b>[<=]</b>

REQ(ids=A_15985)<b>A_15985 - (N040.400) K_COS</b>
PAR Das neu angelegte bzw. neu anzulegende Objekt MUSS inklusive Freigabe eines eventuell von ihm allokierten Speichers aus dem Objektsystem gelöscht werden (komplettes Roll-Back der Chaining-Kette), wenn <b>[<=]</b>

REQ(ids=G2_N040.400.a)<b>G2_N040.400.a - (N040.400)a K_COS</b>
PAR das LOAD APPLICATION-Kommando mit einem Trailer aus CosT_df0 terminierte. <b>[<=]</b>

REQ(ids=G2_N040.400.b)<b>G2_N040.400.b - (N040.400)b K_COS</b>
PAR das LOAD APPLICATION-Kommando während der Kommandobearbeitung durch einen Reset abgebrochen wird. <b>[<=]</b>

REQ(ids=G2_N040.400.c)<b>G2_N040.400.c - (N040.400)c K_COS</b>
PAR eine Command-Chaining-Kette abgebrochen wird (siehe (N029.874)). <b>[<=]</b>

PAR Hinweis CosH_27f: Es ist denkbar, dass Anforderung (N039.500) wie folgt getestet wird:

ORDERED-LIST->
LITEM->PAR Ausgangspunkt sei eine Smartcard, deren Objektsystem nur eine sehr geringe (minimale) Anzahl von Objekten enthält.LITEM->PAR Schritt 1: Per LOAD APPLICATION-Kommando werde eine Datei (transparent oder strukturiert wird zufällig bestimmt) mit 200 Oktett Nutzdaten angelegt.LITEM->PAR Schritt 2: Schritt 1 wird so lange wiederholt, bis das LOAD APPLICATION-Kommando mit dem Trailer OutOfMemory terminiert.LITEM->PAR Schritt 3: Es werden zwei der zuvor angelegten Dateien zufällig ausgewählt und gelöscht (DELETE-Kommando). Anschließend werde per LOAD APPLICATION eine neue Datei (transparent oder strukturiert wird zufällig bestimmt) angelegt. Wenn die Summe der Nutzdaten der in diesem Schritt gelöschten Dateien x ist, dann werde als Größe der Nutzdaten der in diesem Schritt neu angelegten Datei ebenfalls x gewählt. Es wird erwartet, dass dieses LOAD APPLICATION-Kommando nicht mit OutOfMemory terminiert.LITEM->PAR Schritt 4: Schritt 3 werde so lange wiederholt, bis nur noch eine Datei übrig ist, welche durch diesen Algorithmus angelegt wurde, oder nur noch Dateien übrig sind, welche die maximal mögliche Dateigröße gemäß (N011.500) bzw. (N013.000) besitzen. Zwar bezieht sich (N013.000) nur auf linear variable EF, ist aber analog übertragbar auf andere lineare EF.
PAR -HEADING(ids=14.2.6)14.2.6 CosK_119 SELECT
PAR Das Kommando SELECT sucht im Objektsystem nach einem File (Ordner oder Datei) und wählt dieses aus. Das Auswählen ist vielfach Voraussetzung, damit andere Use Cases (Lesen, Schreiben, …) erfolgreich durchführbar sind. Optional ist es möglich, in den Antwortdaten die wesentlichen Attribute des Files zurückzumelden. Welches File selektiert wird, bestimmen Parameter in der Kommandonachricht.
PAR -HEADING(ids=14.2.6.1)14.2.6.1 CosK_650 Use Case Selektieren ohne AID, first, keine Antwortdaten
PAR Diese Variante selektiert das Wurzelverzeichnis des Objektsystems. In dieser Variante enthält die APDU des SELECT-Kommandos drei Parameter:
REQ(ids=A_15986)<b>A_15986 - (N040.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter selectionMode bestimmt die Art der Suche. Für diesen Use Case MUSS selectionMode = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_15987)<b>A_15987 - (N040.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter fileOccurrence bestimmt, welches File aus einer Liste von passenden Files gefunden wird. Für diesen Use Case MUSS fileOccurrence = '0' gewählt werden. <b>[<=]</b>

REQ(ids=A_15988)<b>A_15988 - (N040.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter responseType bestimmt die Art der Antwortdaten. Für diesen Use Case MUSS responseType = '0C' gewählt werden. <b>[<=]</b>

REQ(ids=A_15989)<b>A_15989 - (N040.800) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_d79 verwendet werden.
PAR (ids=Tabelle-118,-CosT_d79)Tabelle 118, CosT_d79: SELECT, kein AID, first occurrence, keine Antwortdaten

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '04' TD(3,2/1/1)->PAR selectionMode = Ordnerselektion mit applicationIdentifier (hier leer)
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '0C' TD(4,2/1/1)->PAR fileOccurrence + responseType = first occurrence, keine Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.6.2)14.2.6.2 CosK_a3f Use Case Selektieren ohne AID, first, Antwortdaten mit FCP
PAR Diese Variante selektiert das Wurzelverzeichnis des Objektsystems. In dieser Variante enthält die APDU des SELECT-Kommandos vier Parameter:
REQ(ids=A_15990)<b>A_15990 - (N040.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter selectionMode bestimmt die Art der Suche. Für diesen Use Case MUSS selectionMode = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_15991)<b>A_15991 - (N041.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter fileOccurrence bestimmt, welches File aus einer Liste von passenden Files gefunden wird. Für diesen Use Case MUSS fileOccurrence = '0' gewählt werden. <b>[<=]</b>

REQ(ids=A_15992)<b>A_15992 - (N041.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter responseType bestimmt die Art der Antwortdaten. Für diesen Use Case MUSS responseType = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_15993)<b>A_15993 - (N041.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus dem in (N027.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_15994)<b>A_15994 - (N041.300) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d oder eine Case 2E Kommando-APDU gemäß CosK_f88 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_4c6 verwendet werden.
PAR (ids=Tabelle-119,-CosT_4c6)Tabelle 119, CosT_4c6: SELECT, kein AID, first occurrence, Antwortdaten mit FCP

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '04' TD(3,2/1/1)->PAR selectionMode = Ordnerselektion mit applicationIdentifier (hier leer)
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '04' TD(4,2/1/1)->PAR fileOccurrence + responseType = first occurrence, Antwortdaten mit FCP
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR length TD(5,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.6.3)14.2.6.3 CosK_3ec Use Case Selektieren ohne AID, next, keine Antwortdaten
PAR Der wiederholte Aufruf dieser Variante selektiert nacheinander alle Ordner, die das Attribut applicationIdentifier besitzen (Applikationen gemäß CosK_ad6 und ADF gemäß CosK_356). In dieser Variante enthält die APDU des SELECT-Kommandos drei Parameter:
REQ(ids=A_15995)<b>A_15995 - (N041.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter selectionMode bestimmt die Art der Suche. Für diesen Use Case MUSS selectionMode = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_15996)<b>A_15996 - (N041.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter fileOccurrence bestimmt, welches File aus einer Liste von passenden Files gefunden wird. Für diesen Use Case MUSS fileOccurrence = '2' gewählt werden. <b>[<=]</b>

REQ(ids=A_15997)<b>A_15997 - (N041.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter responseType bestimmt die Art der Antwortdaten. Für diesen Use Case MUSS responseType = '0C' gewählt werden. <b>[<=]</b>

REQ(ids=A_15998)<b>A_15998 - (N041.700) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_b77 verwendet werden.
PAR (ids=Tabelle-120,-CosT_b77)Tabelle 120, CosT_b77: SELECT, kein AID, next occurrence, keine Antwortdaten

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '04' TD(3,2/1/1)->PAR selectionMode = Ordnerselektion mit applicationIdentifier (hier leer)
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '0E' TD(4,2/1/1)->PAR fileOccurrence + responseType = next occurrence, keine Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.6.4)14.2.6.4 CosK_aba Use Case Selektieren ohne AID, next, Antwortdaten mit FCP
PAR Der wiederholte Aufruf dieser Variante selektiert nacheinander alle Ordner, die das Attribut applicationIdentifier besitzen (Applikationen gemäß CosK_ad6 und ADF gemäß CosK_356). In dieser Variante enthält die APDU des SELECT-Kommandos vier Parameter:
REQ(ids=A_15999)<b>A_15999 - (N041.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter selectionMode bestimmt die Art der Suche. Für diesen Use Case MUSS selectionMode = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_16000)<b>A_16000 - (N041.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter fileOccurrence bestimmt, welches File aus einer Liste von passenden Files gefunden wird. Für diesen Use Case MUSS fileOccurrence = '2' gewählt werden. <b>[<=]</b>

REQ(ids=A_16001)<b>A_16001 - (N042.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter responseType bestimmt die Art der Antwortdaten. Für diesen Use Case MUSS responseType = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_16002)<b>A_16002 - (N042.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus dem in (N027.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16003)<b>A_16003 - (N042.200) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d oder eine Case 2E Kommando-APDU gemäß CosK_f88 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_cfb verwendet werden.
PAR (ids=Tabelle-121,-CosT_cfb)Tabelle 121, CosT_cfb: SELECT, kein AID, next occurrence, Antwortdaten mit FCP

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '04' TD(3,2/1/1)->PAR selectionMode = Ordnerselektion mit applicationIdentifier (hier leer)
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '06' TD(4,2/1/1)->PAR fileOccurrence + responseType = next occurrence, FCP-Antwortdaten
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR length TD(5,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.6.5)14.2.6.5 CosK_96a Use Case Selektieren per AID, first, keine Antwortdaten
PAR In dieser Variante enthält die APDU des SELECT-Kommandos vier Parameter:
REQ(ids=A_16004)<b>A_16004 - (N042.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter selectionMode bestimmt die Art der Suche. Für diesen Use Case MUSS selectionMode = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_16005)<b>A_16005 - (N042.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter fileOccurrence bestimmt, welches File aus einer Liste von passenden Files gefunden wird. Für diesen Use Case MUSS fileOccurrence = '0' gewählt werden. <b>[<=]</b>

REQ(ids=A_16006)<b>A_16006 - (N042.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter aid MUSS einen Oktettstring gemäß (N010.200) oder dessen Anfang enthalten. Im Objektsystem wird nach einem Ordner mit dazu passendem Attribut applicationIdentifier gesucht. <b>[<=]</b>

REQ(ids=A_16007)<b>A_16007 - (N042.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter responseType bestimmt die Art der Antwortdaten. Für diesen Use Case MUSS responseType = '0C' gewählt werden. <b>[<=]</b>

REQ(ids=A_16008)<b>A_16008 - (N042.700) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_e60 verwendet werden.
PAR (ids=Tabelle-122,-CosT_e60)Tabelle 122, CosT_e60: SELECT, AID, first occurrence, keine Antwortdaten

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '04' TD(3,2/1/1)->PAR selectionMode = Ordnerselektion mit applicationIdentifier
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '0C' TD(4,2/1/1)->PAR fileOccurrence + responseType = first occurrence, keine Antwortdaten
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR aid, Oktettstring, Anzahl Oktette aus dem Intervall [1, 16]
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.6.6)14.2.6.6 CosK_93f Use Case Selektieren per AID, first, Antwortdaten mit FCP
PAR In dieser Variante enthält die APDU des SELECT-Kommandos fünf Parameter:
REQ(ids=A_16009)<b>A_16009 - (N042.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter selectionMode bestimmt die Art der Suche. Für diesen Use Case MUSS selectionMode = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_16010)<b>A_16010 - (N042.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter fileOccurrence bestimmt, welches File aus einer Liste von passenden Files gefunden wird. Für diesen Use Case MUSS fileOccurrence = '0' gewählt werden. <b>[<=]</b>

REQ(ids=A_16011)<b>A_16011 - (N043.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter aid MUSS einen Oktettstring gemäß (N010.200) oder dessen Anfang enthalten. Im Objektsystem wird nach einem Ordner mit dazu passendem Attribut applicationIdentifier gesucht. <b>[<=]</b>

REQ(ids=A_16012)<b>A_16012 - (N043.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter responseType bestimmt die Art der Antwortdaten. Für diesen Use Case MUSS responseType = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_16013)<b>A_16013 - (N043.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus dem in (N027.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16014)<b>A_16014 - (N043.300) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 oder eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_18c verwendet werden.
PAR (ids=Tabelle-123,-CosT_18c)Tabelle 123, CosT_18c: SELECT, AID, first occurrence, Antwortdaten mit FCP

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '04' TD(3,2/1/1)->PAR selectionMode = Ordnerselektion mit applicationIdentifier
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '04' TD(4,2/1/1)->PAR fileOccurrence + responseType = first occurrence, Antwortdaten mit FCP
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR aid, Oktettstring, Anzahl Oktette aus dem Intervall [1, 16]
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.6.7)14.2.6.7 CosK_339 Use Case Selektieren per AID, next, keine Antwortdaten
PAR In dieser Variante enthält die APDU des SELECT-Kommandos vier Parameter:
REQ(ids=A_16015)<b>A_16015 - (N043.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter selectionMode bestimmt die Art der Suche. Für diesen Use Case MUSS selectionMode = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_16016)<b>A_16016 - (N043.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter fileOccurrence bestimmt, welches File aus einer Liste von passenden Files gefunden wird. Für diesen Use Case MUSS fileOccurrence = '2' gewählt werden. <b>[<=]</b>

REQ(ids=A_16017)<b>A_16017 - (N043.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter aid enthält einen Oktettstring gemäß (N010.200) oder dessen Anfang. Im Objektsystem wird nach einem Ordner mit dazu passendem Attribut applicationIdentifier gesucht. <b>[<=]</b>

REQ(ids=A_16018)<b>A_16018 - (N043.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter responseType bestimmt die Art der Antwortdaten. Für diesen Use Case MUSS responseType = '0C' gewählt werden. <b>[<=]</b>

REQ(ids=A_16019)<b>A_16019 - (N043.800) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_776 verwendet werden.
PAR (ids=Tabelle-124,-CosT_776)Tabelle 124, CosT_776: SELECT, AID, next occurrence, keine Antwortdaten

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '04' TD(3,2/1/1)->PAR selectionMode = Ordnerselektion mit applicationIdentifier
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '0E' TD(4,2/1/1)->PAR fileOccurrence + responseType = next occurrence, keine Antwortdaten
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR aid, Oktettstring, Anzahl Oktette aus dem Intervall [1, 16]
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.6.8)14.2.6.8 CosK_813 Use Case Selektieren per AID, next, Antwortdaten mit FCP
PAR In dieser Variante enthält die APDU des SELECT-Kommandos fünf Parameter:
REQ(ids=A_16020)<b>A_16020 - (N043.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter selectionMode bestimmt die Art der Suche. Für diesen Use Case MUSS selectionMode = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_16021)<b>A_16021 - (N044.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter fileOccurrence bestimmt, welches File aus einer Liste von passenden Files gefunden wird. Für diesen Use Case MUSS fileOccurrence = '2' gewählt werden. <b>[<=]</b>

REQ(ids=A_16022)<b>A_16022 - (N044.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter aid enthält einen Oktettstring gemäß (N010.200) oder dessen Anfang. Im Objektsystem wird nach einem Ordner mit dazu passendem Attribut applicationIdentifier gesucht. <b>[<=]</b>

REQ(ids=A_16023)<b>A_16023 - (N044.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter responseType bestimmt die Art der Antwortdaten. Für diesen Use Case MUSS responseType = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_16024)<b>A_16024 - (N044.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus dem in (N027.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16025)<b>A_16025 - (N044.400) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 oder eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_203 verwendet werden.
PAR (ids=Tabelle-125,-CosT_203)Tabelle 125, CosT_203: SELECT, AID, next occurrence, Antwortdaten mit FCP

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '04' TD(3,2/1/1)->PAR selectionMode = Ordnerselektion mit applicationIdentifier
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '06' TD(4,2/1/1)->PAR fileOccurrence + responseType = next occurrence,Antwortdaten mit FCP
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR aid, Oktettstring, Anzahl Oktette aus dem Intervall [1, 16]
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.6.9)14.2.6.9 CosK_58e Use Case Selektieren, DF oder ADF, keine Antwortdaten
PAR In dieser Variante enthält die APDU des SELECT-Kommandos vier Parameter:
REQ(ids=A_16026)<b>A_16026 - (N044.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter selectionMode bestimmt die Art der Suche. Für diesen Use Case MUSS selectionMode = '01' gewählt werden. <b>[<=]</b>

REQ(ids=A_16027)<b>A_16027 - (N044.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter fileOccurrence bestimmt, welches File aus einer Liste von passenden Files gefunden wird. Für diesen Use Case MUSS fileOccurrence = '0' gewählt werden. <b>[<=]</b>

REQ(ids=A_16028)<b>A_16028 - (N044.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter fid MUSS einen Oktettstring gemäß (N006.700) enthalten. Im currentFolder wird nach einem Ordner mit dazu passendem Attribut fileIdentifier gesucht. <b>[<=]</b>

REQ(ids=A_16029)<b>A_16029 - (N044.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter responseType bestimmt die Art der Antwortdaten. Für diesen Use Case MUSS responseType = '0C' gewählt werden. <b>[<=]</b>

REQ(ids=A_16030)<b>A_16030 - (N044.900) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_28f verwendet werden.
PAR (ids=Tabelle-126,-CosT_28f)Tabelle 126, CosT_28f: SELECT, DF oder ADF mit FID, keine Antwortdaten

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '01' TD(3,2/1/1)->PAR selectionMode = Selektion eines Ordners mit fileIdentifier
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '0C' TD(4,2/1/1)->PAR fileOccurrence + responseType = first occurrence, keine Antwortdaten
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XXXX' TD(5,2/1/1)->PAR fid
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.6.10)14.2.6.10 CosK_08f Use Case Selektieren, DF oder ADF, Antwortdaten mit FCP
PAR In dieser Variante enthält die APDU des SELECT-Kommandos fünf Parameter:
REQ(ids=A_16031)<b>A_16031 - (N045.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter selectionMode bestimmt die Art der Suche. Für diesen Use Case MUSS selectionMode = '01' gewählt werden. <b>[<=]</b>

REQ(ids=A_16032)<b>A_16032 - (N045.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter fileOccurrence bestimmt, welches File aus einer Liste von passenden Files gefunden wird. Für diesen Use Case MUSS fileOccurrence = '0' gewählt werden. <b>[<=]</b>

REQ(ids=A_16033)<b>A_16033 - (N045.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter fid MUSS einen Oktettstring gemäß (N006.700) enthalten. Im currentFolder wird nach einem Ordner mit dazu passendem Attribut fileIdentifier gesucht. <b>[<=]</b>

REQ(ids=A_16034)<b>A_16034 - (N045.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter responseType bestimmt die Art der Antwortdaten. Für diesen Use Case MUSS responseType = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_16035)<b>A_16035 - (N045.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus dem in (N027.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16036)<b>A_16036 - (N045.500) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 oder eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_19d verwendet werden.
PAR (ids=Tabelle-127,-CosT_19d)Tabelle 127, CosT_19d: SELECT, DF oder ADF mit FID, Antwortdaten mit FCP

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '01' TD(3,2/1/1)->PAR selectionMode = Ordnerselektion mit fileIdentifier
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '04' TD(4,2/1/1)->PAR fileOccurrence + responseType = first occurrence, Antwortdaten mit FCP
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XXXX' TD(5,2/1/1)->PAR fid
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.6.11)14.2.6.11 CosK_274 Use Case Selektieren übergeordnetes Verzeichnis ohne FCP
PAR Diese Variante selektiert den eine Ebene höher liegenden Ordner (siehe (N020.000), (N020.100)). In dieser Variante enthält die APDU des SELECT-Kommandos zwei Parameter:
REQ(ids=A_16037)<b>A_16037 - (N045.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter selectionMode bestimmt die Art der Suche. Für diesen Use Case MUSS selectionMode = '03' gewählt werden. <b>[<=]</b>

REQ(ids=A_16038)<b>A_16038 - (N045.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter responseType bestimmt die Art der Antwortdaten. Für diesen Use Case MUSS responseType = '0C' gewählt werden. <b>[<=]</b>

REQ(ids=A_16039)<b>A_16039 - (N045.800) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_0e5 verwendet werden.
PAR (ids=Tabelle-128,-CosT_0e5)Tabelle 128, CosT_0e5: SELECT, höhere Ebene keine Antwortdaten

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '03' TD(3,2/1/1)->PAR selectionMode = Selektion des eine Ebene höheren Ordners
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '0C' TD(4,2/1/1)->PAR responseType = keine Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.6.12)14.2.6.12 CosK_df1 Use Case Selektieren übergeordnetes Verzeichnis mit FCP
PAR Diese Variante selektiert den eine Ebene höher liegenden Ordner (siehe (N020.000), (N020.100)). In dieser Variante enthält die APDU des SELECT-Kommandos drei Parameter:
REQ(ids=A_16040)<b>A_16040 - (N045.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter selectionMode bestimmt die Art der Suche. Für diesen Use Case MUSS selectionMode = '03' gewählt werden. <b>[<=]</b>

REQ(ids=A_16041)<b>A_16041 - (N046.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter responseType bestimmt die Art der Antwortdaten. Für diesen Use Case MUSS responseType = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_16042)<b>A_16042 - (N046.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus dem in (N027.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16043)<b>A_16043 - (N046.200) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d oder eine Case 2E Kommando-APDU gemäß CosK_f88 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_e82 verwendet werden.
PAR (ids=Tabelle-129,-CosT_e82)Tabelle 129, CosT_e82: SELECT, höhere Ebene, Antwortdaten mit FCP

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '03' TD(3,2/1/1)->PAR selectionMode = Selektion des eine Ebene höheren Ordners
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '04' TD(4,2/1/1)->PAR responseType = Antwortdaten mit FCP
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR length TD(5,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.6.13)14.2.6.13 CosK_c1a Use Case Selektieren einer Datei, keine Antwortdaten
PAR In dieser Variante enthält die APDU des SELECT-Kommandos vier Parameter:
REQ(ids=A_16050)<b>A_16050 - (N046.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter selectionMode bestimmt die Art der Suche. Für diesen Use Case MUSS selectionMode = '02' gewählt werden. <b>[<=]</b>

REQ(ids=A_16051)<b>A_16051 - (N046.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter fileOccurrence bestimmt, welches File aus einer Liste von passenden Files gefunden wird. Für diesen Use Case MUSS fileOccurrence = '0' gewählt werden. <b>[<=]</b>

REQ(ids=A_16052)<b>A_16052 - (N046.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter fid MUSS einen Oktettstring gemäß (N006.700) enthalten. Im currentFolder wird nach einer Datei mit dazu passendem Attribut fileIdentifier gesucht. <b>[<=]</b>

REQ(ids=A_16053)<b>A_16053 - (N046.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter responseType bestimmt die Art der Antwortdaten. Für diesen Use Case MUSS responseType = '0C' gewählt werden. <b>[<=]</b>

REQ(ids=A_16054)<b>A_16054 - (N046.700) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_e0d verwendet werden.
PAR (ids=Tabelle-130,-CosT_e0d)Tabelle 130, CosT_e0d: SELECT, EF mit FID, keine Antwortdaten

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '02' TD(3,2/1/1)->PAR selectionMode = Selektion einer Datei mit fileIdentifier
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '0C' TD(4,2/1/1)->PAR fileOccurrence + responseType = first occurrence, keine Antwortdaten
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XXXX' TD(5,2/1/1)->PAR fid
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.6.14)14.2.6.14 CosK_16c Use Case Selektieren einer Datei, Antwortdaten mit FCP
PAR In dieser Variante enthält die APDU des SELECT-Kommandos fünf Parameter:
REQ(ids=A_16055)<b>A_16055 - (N046.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter selectionMode bestimmt die Art der Suche. Für diesen Use Case MUSS selectionMode = '02' gewählt werden. <b>[<=]</b>

REQ(ids=A_16056)<b>A_16056 - (N046.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter fileOccurrence bestimmt, welches File aus einer Liste von passenden Files gefunden wird. Für diesen Use Case MUSS fileOccurrence = '0' gewählt werden. <b>[<=]</b>

REQ(ids=A_16057)<b>A_16057 - (N047.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter fid enthält einen Oktettstring gemäß (N006.700). Im currentFolder wird nach einer Datei mit dazu passendem Attribut fileIdentifier gesucht. <b>[<=]</b>

REQ(ids=A_16058)<b>A_16058 - (N047.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter responseType bestimmt die Art der Antwortdaten. Für diesen Use Case MUSS responseType = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_16059)<b>A_16059 - (N047.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus dem in (N027.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16060)<b>A_16060 - (N047.300) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 oder eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_55b verwendet werden.
PAR (ids=Tabelle-131,-CosT_55b)Tabelle 131, CosT_55b: SELECT, EF mit FID, Antwortdaten mit FCP

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '02' TD(3,2/1/1)->PAR selectionMode = Selektion einer Datei mit fileIdentifier
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '04' TD(4,2/1/1)->PAR fileOccurrence + responseType = first occurrence, Antwortdaten mit FCP
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XXXX' TD(5,2/1/1)->PAR fid
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.6.15)14.2.6.15 Zusammenfassung der SELECT-Kommando-Varianten
PAR Wegen der Vielzahl an Varianten für dieses Kommando werden hier alle auf einen Blick dargestellt. Es sei darauf hingewiesen, dass nicht alle Kombinationen der folgenden Tabelle in den vorangegangenen Kapiteln enthalten sind. Deshalb sind solche nicht zwingend zu unterstützen.
PAR (ids=Tabelle-132,-CosT_59c)Tabelle 132, CosT_59c: SELECT, Kommandoparameter im Überblick

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A4' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '01'<br>'02'<br>'03'<br>'04' TD(3,2/1/1)->PAR Selektion eines Ordners mit fileIdentifier<br>Selektion einer Datei mit fileIdentifier<br>Selektion des eine Ebene höher liegenden Ordners<br>Selektion eines Ordners mit (möglicherweise leerem) applicationIdentifier
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '04'<br>'06'<br>'0C'<br>'0E' TD(4,2/1/1)->PAR first occurrence,    Antwortdaten mit FCP<br>next occurrence,   Antwortdaten mit FCP<br>first occurrence,    keine Antwortdaten<br>next occurrence,   keine Antwortdaten
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR P1 = '01': zwei Byte fid<br>P1 = '02': zwei Byte fid<br>P1 = '03': abwesend<br>P1 = '04': abwesend, oder bis zu 16 Oktette aid
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR P2 = '04': Anzahl der erwarteten Oktette in den Antwortdaten<br>P2 = '06': Anzahl der erwarteten Oktette in den Antwortdaten<br>P2 = '0C': abwesend<br>P2 = '0E': abwesend
PAR -HEADING(ids=14.2.6.16)14.2.6.16 Antwort der Karte auf Selektieren eines Files
PAR (ids=Tabelle-133,-CosT_906)Tabelle 133, CosT_906: SELECT Antwort-APDU im Erfolgsfall

TABLE(rows=6,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)->PAR FCP TD(1,2/1/1)->PAR Abwesend, oder File Control Parameter
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '62 83' TD(3,1/1/1)->PAR FileDeactivated TD(3,2/1/1)->PAR Selektiertes File ist logisch oder physikalisch deaktiviert
TR-> TD(4,0/1/1)->PAR '62 85' TD(4,1/1/1)->PAR FileTerminated TD(4,2/1/1)->PAR Selektiertes File ist logisch oder physikalisch terminiert
TR-> TD(5,0/1/1)->PAR '90 00' TD(5,1/1/1)->PAR NoError TD(5,2/1/1)->PAR Erfolgreiche Selektion eines Files
PAR (ids=Tabelle-134,-CosT_0dc)Tabelle 134, CosT_0dc: SELECT Antwort-APDU im Fehlerfall

TABLE(rows=3,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalte TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '6A 82' TD(1,1/1/1)->PAR FileNotFound TD(1,2/1/1)->PAR Zu selektierendes File wurde nicht gefunden
TR-> TD(2,0/1/1)->PAR '6D 00' TD(2,1/1/1)->PAR InstructionNotSupported TD(2,2/1/1)->PAR Die Karte befindet sich im Zustand "Termination state"
PAR Hinweis CosH_237: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16061)<b>A_16061 - (N047.400) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando SELECT verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.2.6.17)14.2.6.17 Kommandoabarbeitung innerhalb der Karte
PAR Zur Beschreibung der Kommandobearbeitung werden folgende Definitionen eingeführt:
PAR (ids=Tabelle-135,-CosT_e2e)Tabelle 135, CosT_e2e: Innerhalb der Beschreibung des SELECT-Kommanods verwendete Definitionen

TABLE(rows=4,cols=85+511)->
TR-> TH(0,0/1/1)->PAR Entität TH(0,1/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR oldFolder TD(1,1/1/1)->PAR Dies ist die Bezeichnung von currentFolder vor Ausführung dieses SELECT-Kommandos
TR-> TD(2,0/1/1)->PAR newFile TD(2,1/1/1)->PAR Dies ist die Bezeichnung für das File (Ordner oder Datei), welches im Rahmen der Selektion ausgewählt wird
TR-> TD(3,0/1/1)->PAR path(folder) TD(3,1/1/1)->PAR Pfad eines Ordners mit Namen folder. Zum Pfad gehören nach dieser Definition sowohl der Ordner folder als auch alle seine übergeordneten Verzeichnisse einschließlich root.
REQ(ids=G2_N047.500.a)<b>G2_N047.500.a - (N047.500)a K_COS</b>
PAR Das COS MUSS die Select-Varianten aus (N040.800), (N041.300), (N042.700), (N043.300), (N044.900), (N045.500), (N045.800), (N046.200), (N046.700) und (N047.300) unterstützen. <b>[<=]</b>

REQ(ids=A_16062)<b>A_16062 - (N047.500)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere SELECT-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N047.590)<b>G2_N047.590 - (N047.590) K_COS</b>
PAR Wenn das Attribut lifeCycleStatus des Objektsystems (siehe (N019.900)i) den Wert "Termination state" besitzt, genau dann MUSS das Kommando mit dem Trailer InstructionNotSupported terminieren. <b>[<=]</b>

REQ(ids=A_16063)<b>A_16063 - (N047.600) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden im Rahmen der Bearbeitung des SELECT-Kommandos<br>a. würden Zugriffsregeln ausgewertet oder<br>b. würde als Zugriffsbedingung eines SELECT-Kommandos stets ALWAYS verwendet. <b>[<=]</b>

REQ(ids=G2_N047.700)<b>G2_N047.700 - (N047.700) K_COS</b>
PAR Wenn der Parameter P1 den Wert '01' besitzt, dann MUSS in oldFolder.children nach einem Ordner gesucht werden, der ein Attribut fileIdentifier besitzt, dessen Wert mit dem Parameter fid aus den Kommandodaten übereinstimmt. Wenn ein solcher Ordner existiert, dann MUSS newFile auf den gefundenen Ordner gesetzt werden. Andernfalls ist die Suche erfolglos. <b>[<=]</b>

REQ(ids=G2_N047.800)<b>G2_N047.800 - (N047.800) K_COS</b>
PAR Wenn der Parameter P1 den Wert '02' besitzt, dann MUSS in oldFolder.children nach einer Datei gesucht werden, deren Attribut fileIdentifier mit dem Parameter fid aus den Kommandodaten übereinstimmt. Wenn eine solche Datei existiert, dann MUSS newFile auf die gefundene Datei gesetzt werden. Andernfalls ist die Suche erfolglos. <b>[<=]</b>

REQ(ids=G2_N047.900.a)<b>G2_N047.900.a - (N047.900)a K_COS</b>
PAR Wenn der Parameter P1 den Wert '03' besitzt, und currentFolder ist gleich root, dann MUSS das Kommando mit dem Trailer FileNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N047.900.b)<b>G2_N047.900.b - (N047.900)b K_COS</b>
PAR Wenn der Parameter P1 den Wert '03' besitzt, und currentFolder ist nicht root, dann ist newFile der im Vergleich zu currentFolder eine Ebene höher liegende Ordner (siehe (N020.000), (N020.100)). <b>[<=]</b>

REQ(ids=A_16064)<b>A_16064 - (N048.000) K_COS</b>
PAR Wenn der Parameter P1 den Wert '04' besitzt, dann enthält die Kommandonachricht einen (möglicherweise leeren) Parameter aid. In diesem Fall ist folgender Algorithmus abzuarbeiten: <b>[<=]</b>

REQ(ids=G2_N048.000.a)<b>G2_N048.000.a - (N048.000)a K_COS</b>
PAR Schritt 1: Im gesamten Objektsystem wird nach Ordnern gesucht, die ein Attribut applicationIdentifier besitzen, welches zu aid passt. Ein Attribut applicationIdentifier MUSS als passend betrachtet werden, wenn<br>1.  applicationIdentifier identisch zu aid ist.<br>2. aid leer ist. <b>[<=]</b>

REQ(ids=A_16065)<b>A_16065 - (N048.000)a.3 K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden, falls die Most Significant Byte eines Attributes applicationIdentifier mit aid übereinstimmen und dies als<br>i.  passend betrachtet wird.<br>ii. unpassend betrachtet wird. <b>[<=]</b>

REQ(ids=G2_N048.000.b)<b>G2_N048.000.b - (N048.000)b K_COS</b>
PAR Schritt 2: Alle passenden Ordner werden zu einer Liste zusammengestellt.<br>1. Ist root in dieser Liste enthalten, dann MUSS es das erste Listenelement sein.<br>2. Solange das Objektsystem nicht verändert wird (DELETE oder LOAD APPLICATION) MUSS bei identischem aid stets dieselbe Liste erstellt werden. <b>[<=]</b>

REQ(ids=G2_N048.000.c)<b>G2_N048.000.c - (N048.000)c K_COS</b>
PAR Schritt 3.1: Hat P2 einen Wert aus der Menge {'04', '0C'}, dann MUSS newFile auf das erste Listenelement gesetzt werden. <b>[<=]</b>

REQ(ids=A_16066)<b>A_16066 - (N048.000)d K_COS</b>
PAR Schritt 3.2: Hat P2 einen Wert aus der Menge {'06', '0E'} und<br>    1. oldFolder ist ebenfalls in der Liste und oldFolder ist<br>        i.  nicht das letzte Listenelement, dann MUSS newFile auf das nächste Listenelement gesetzt werden.<br>        ii. das letzte Listenelement, dann MUSS die Suche erfolglos sein.<br>    2. oldFolder ist nicht in der Liste enthalten, dann MUSS entweder<br>        i.  newFile auf irgendein Listenelement gesetzt werden, oder<br>        ii. die Suche erfolglos sein. <b>[<=]</b>

REQ(ids=G2_N048.100)<b>G2_N048.100 - (N048.100) K_COS</b>
PAR Wenn die Suche erfolglos war, genau dann MUSS das Kommando mit dem Trailer FileNotFound terminieren. Dabei DÜRFEN currentFolder, currentEF sowie der Kanalkontext (siehe CosK_6b7) NICHT verändert werden. <b>[<=]</b>

REQ(ids=G2_N048.200.a)<b>G2_N048.200.a - (N048.200)a K_COS</b>
PAR Wenn newFile eine Datei ist, dann MUSS currentEF auf newFile gesetzt werden. <b>[<=]</b>

REQ(ids=A_16067)<b>A_16067 - (N048.200)b K_COS</b>
PAR Wenn newFile ein Ordner ist, dann MUSS folgender Algorithmus abgearbeitet werden: <b>[<=]</b>

REQ(ids=G2_N048.200.b.1)<b>G2_N048.200.b.1 - (N048.200)b.1 K_COS</b>
PAR Schritt 1: currentFolder MUSS gleich newFile gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N048.200.b.2)<b>G2_N048.200.b.2 - (N048.200)b.2 K_COS</b>
PAR Schritt 2: currentEF MUSS auf den Wert "undefiniert" gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N048.200.b.3)<b>G2_N048.200.b.3 - (N048.200)b.3 K_COS</b>
PAR Schritt 3: In allen Ordnern, die sowohl zu path(oldFolder) als auch zu path(newFile) gehören, MUSS seIdentifier unverändert bleiben. <b>[<=]</b>

REQ(ids=G2_N048.200.b.4)<b>G2_N048.200.b.4 - (N048.200)b.4 K_COS</b>
PAR Schritt 4: In allen anderen Ordnern MUSS seIdentifier auf den Wert 1 gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N048.200.b.5)<b>G2_N048.200.b.5 - (N048.200)b.5 K_COS</b>
PAR Schritt 5: Die Funktion clearSecurityStatusFolder( folder ) MUSS für alle Ordner ausgeführt werden, die nicht zu path(newFile) gehören. <b>[<=]</b>

REQ(ids=G2_N048.200.b.6)<b>G2_N048.200.b.6 - (N048.200)b.6 K_COS, Option_Kryptobox</b>
PAR Schritt 6: Die Funktion clearSessionkeys( ) MUSS ausgeführt werden, falls SessionkeyContext.folderSessionkeys nicht zu path(newFile) gehört. <b>[<=]</b>

REQ(ids=G2_N048.200.b.7)<b>G2_N048.200.b.7 - (N048.200)b.7 K_COS</b>
PAR Schritt 7: Aus dfSpecificPasswordList MÜSSEN mittels clearPasswordStatus(…) alle Einträge entfernt werden, die nicht zu path(newFile) gehören. <b>[<=]</b>

REQ(ids=G2_N048.200.b.8)<b>G2_N048.200.b.8 - (N048.200)b.8 K_COS</b>
PAR Schritt 8: Jedes Element von keyReferenceList, welches ein Schlüsselobjekt referenziert, das zu einem Ordner außerhalb von path(newFile) gehört, MUSS auf den Wert "leer" gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N048.300.a)<b>G2_N048.300.a - (N048.300).a K_COS</b>
PAR Wenn P2 einen Wert aus der Menge {'04', '06'} hat, genau dann MUSS das Datenfeld rspData der Antwortnachricht die File Control Parameter gemäß (N013.900) wie folgt enthalten: Sei FCP ein Oktettstring, der die File Control Parameter gemäß (N013.900) enthält, dann gilt: Wenn OctetLength( FCP ) kleiner Nr gemäß (N027.200),<br>1. dann  rspData = FCP.<br>2. sonst rspData = Extract_MSByte( FCP, Nr ). <b>[<=]</b>

REQ(ids=G2_N048.300.b)<b>G2_N048.300.b - (N048.300)b K_COS</b>
PAR Wenn P2 keinen Wert aus der Menge {'04', '06'} hat, dann MUSS das Datenfeld rspData der Antwortnachricht fehlen. <b>[<=]</b>

REQ(ids=G2_N048.400.a)<b>G2_N048.400.a - (N048.400)a K_COS</b>
PAR Wenn der logische Wert von newFile.lifeCycleStatus (siehe (N020.600)) den Wert "Operational state (deactivated)" hat, genau dann MUSS als Trailer FileDeactivated gewählt werden. <b>[<=]</b>

REQ(ids=G2_N048.400.b)<b>G2_N048.400.b - (N048.400)b K_COS</b>
PAR Wenn der logische Wert von newFile.lifeCycleStatus (siehe (N020.600)) den Wert "Termination state" hat, genau dann MUSS als Trailer FileTerminated gewählt werden. <b>[<=]</b>

REQ(ids=G2_N048.500)<b>G2_N048.500 - (N048.500) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16069)<b>A_16069 - (N048.600)a K_COS</b>
PAR Die Priorität der Trailer in CosT_0dc MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N048.600.b)<b>G2_N048.600.b - (N048.600)b K_COS</b>
PAR Jeder Trailer in CosT_0dc MUSS eine höhere Priorität als FileDeactivated haben. <b>[<=]</b>

REQ(ids=G2_N048.600.c)<b>G2_N048.600.c - (N048.600)c K_COS</b>
PAR FileDeactivated MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR Hinweis CosH_213: Gemäß den Regeln dieses Dokumentes ist es zulässig, in deaktivierten oder terminierten Ordnern Unterordner oder Dateien mittels SELECT-Kommando zu selektieren.
PAR -HEADING(ids=14.2.7)14.2.7 CosK_cd6 TERMINATE CARD USAGE
PAR Das Kommando TERMINATE CARD USAGE überführt eine Karte irreversibel in den Zustand "Termination state". Das Kommando ist unabhängig vom aktuellen Wert von currentFolder und currentEF ausführbar. Während der Kommandoausführung wird im Objektsystem das Attribut lifeCycleStatus auf den Wert "Termination state" gesetzt und, mit Ausnahme des Basiskanals, werden alle weiteren logischen Kanäle geschlossen. Anschließend ist die Funktionalität des SELECT-Kommandos nicht mehr verfügbar (siehe (N047.590)).
PAR -HEADING(ids=14.2.7.1)14.2.7.1 CosK_512 Use Case Terminieren der Karte
PAR In dieser Variante enthält die APDU des TERMINATE CARD USAGE-Kommandos keinen Parameter:
REQ(ids=A_16070)<b>A_16070 - (N048.700) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_6fa verwendet werden.
PAR (ids=Tabelle-136,-CosT_6fa)Tabelle 136, CosT_6fa: TERMINATE CARD USAGE

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'FE' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR –
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR –
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.7.2)14.2.7.2 Antwort der Karte auf Terminieren der Karte
PAR (ids=Tabelle-137;-CosT_fc1)Tabelle 137; CosT_fc1: TERMINATE CARD USAGE Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiche Terminierung
PAR (ids=Tabelle-138,-CosT_d53)Tabelle 138, CosT_d53: TERMINATE CARD USAGE Antwort-APDU im Fehlerfall

TABLE(rows=3,cols=63+185+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
PAR Hinweis CosH_0b8: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16071)<b>A_16071 - (N048.738) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando TERMINATE CARD USAGE verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.2.7.3)14.2.7.3 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N048.740.a)<b>G2_N048.740.a - (N048.740)a K_COS</b>
PAR Das COS MUSS die TERMINATE CARD USAGE-Variante aus (N048.700) unterstützen. <b>[<=]</b>

REQ(ids=A_16072)<b>A_16072 - (N048.740)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere TERMINATE CARD USAGE-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N048.742)<b>G2_N048.742 - (N048.742) K_COS</b>
PAR affectedObject MUSS gleich root gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N048.744)<b>G2_N048.744 - (N048.744) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N048.748)<b>G2_N048.748 - (N048.748) K_COS</b>
PAR Wenn die Kommandos-APDU dieses TERMINATE CARD USAGE-Kommandos gemäß CosK_842 mittels Sessionkeys gesichert war, dann MUSS die korrespondierende Antwort-APDU gemäß CosK_c3a mit denselben Sessionkeys gesichert sein, auch wenn als Seiteneffekt von (N048.756)b oder (N048.756)c Sessionkeys gelöscht werden. <b>[<=]</b>

REQ(ids=G2_N048.752)<b>G2_N048.752 - (N048.752) K_COS</b>
PAR Wenn der physikalische Wert von lifeCycleStatus des Objektsystems den Wert "Termination state" besitzt, dann MUSS als Trailer NoError verwendet werden. <b>[<=]</b>

REQ(ids=G2_N048.756.a)<b>G2_N048.756.a - (N048.756)a K_COS</b>
PAR Der physikalische Wert von lifeCycleStatus des Objektsystems (siehe (N019.900)i) MUSS mittels Transaktionsschutz auf den Wert "Termination state" gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N048.756.b)<b>G2_N048.756.b - (N048.756)b K_COS</b>
PAR Bis auf den Basiskanal MÜSSEN alle anderen logischen Kanäle geschlossen werden. <b>[<=]</b>

REQ(ids=G2_N048.756.c)<b>G2_N048.756.c - (N048.756)c K_COS</b>
PAR Im Basiskanal MUSS channelContext gemäß (N030.100) gesetzt werden. <b>[<=]</b>

REQ(ids=A_16073)<b>A_16073 - (N048.760) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_16074)<b>A_16074 - (N048.762) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N048.764)<b>G2_N048.764 - (N048.764) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16075)<b>A_16075 - (N048.766) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>a. Die Priorität der Trailer in CosT_d53 ist herstellerspezifisch.<br>b. Jeder Trailer in CosT_d53 MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>c. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.2.8)14.2.8 CosK_150 TERMINATE DF
PAR Das Kommando TERMINATE DF überführt einen Ordner irreversibel in den Zustand "Termination state". Der betroffene Ordner wird vor der Operation ausgewählt. Dies geschieht vor dem Senden dieses TERMINATE DF-Kommandos durch eine Select-Operation (SELECT-Kommandos).
PAR -HEADING(ids=14.2.8.1)14.2.8.1 CosK_e42 Use Case Terminieren eines Ordners
PAR In dieser Variante enthält die APDU des TERMINATE DF-Kommandos keinen Parameter:
REQ(ids=A_16079)<b>A_16079 - (N048.800) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_f82 verwendet werden.
PAR (ids=Tabelle-139,-CosT_f82)Tabelle 139, CosT_f82: TERMINATE DF aktueller Ordner

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'E6' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR –
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR –
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.8.2)14.2.8.2 Antwort der Karte auf Terminieren eines Ordners
PAR (ids=Tabelle-140,-CosT_8b0)Tabelle 140, CosT_8b0: TERMINATE DF Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiche Terminierung
PAR (ids=Tabelle-141,-CosT_f24)Tabelle 141, CosT_f24: TERMINATE DF Antwort-APDU im Fehlerfall

TABLE(rows=3,cols=63+185+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
PAR Hinweis CosH_3ff: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16080)<b>A_16080 - (N048.838) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando TERMINATE DF verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.2.8.3)14.2.8.3 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N048.840.a)<b>G2_N048.840.a - (N048.840)a K_COS</b>
PAR Das COS MUSS die TERMINATE DF-Variante aus (N048.800) unterstützen. <b>[<=]</b>

REQ(ids=A_16081)<b>A_16081 - (N048.840)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere TERMINATE DF-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N048.842)<b>G2_N048.842 - (N048.842) K_COS</b>
PAR affectedObject MUSS gleich currentFolder gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N048.844)<b>G2_N048.844 - (N048.844) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N048.852)<b>G2_N048.852 - (N048.852) K_COS</b>
PAR Wenn der physikalische Wert von lifeCycleStatus von affectedObject den Wert "Termination state" besitzt, dann MUSS als Trailer NoError verwendet werden. <b>[<=]</b>

REQ(ids=G2_N048.856)<b>G2_N048.856 - (N048.856) K_COS</b>
PAR Der physikalische Wert von lifeCycleStatus von affectedObject MUSS mittels Transaktionsschutz auf den Wert "Termination state" gesetzt werden. <b>[<=]</b>

REQ(ids=A_16082)<b>A_16082 - (N048.860) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_16083)<b>A_16083 - (N048.862) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N048.864)<b>G2_N048.864 - (N048.864) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16084)<b>A_16084 - (N048.866) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>a. Die Priorität der Trailer in CosT_f24 ist herstellerspezifisch.<br>b. Jeder Trailer in CosT_f24 MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>c. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.2.9)14.2.9 CosK_406 TERMINATE
PAR Das Kommando TERMINATE überführt eine Datei, ein Schlüsselobjekt oder ein Passwortobjekt irreversibel in den Zustand "Termination state". Eine betroffene Datei wird vor der Operation ausgewählt. Dies geschieht vor dem Senden dieses TERMINATE-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier). Wenn ein Schlüsselobjekt oder ein Passwortobjekt vom Kommando betroffen ist, dann wird dieses durch eine Schlüssel- oder Passwortreferenz bestimmt, die in der Kommandonachricht enthalten ist.
PAR -HEADING(ids=14.2.9.1)14.2.9.1 CosK_f3b Use Case Terminieren einer Datei
PAR In dieser Variante wird eine Datei terminiert und die APDU des TERMINATE-Kommandos enthält einen Parameter.
REQ(ids=A_16085)<b>A_16085 - (N048.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode MUSS anzeigen, dass currentEF zu terminieren ist. <b>[<=]</b>

REQ(ids=A_16086)<b>A_16086 - (N048.903) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_847 verwendet werden.
PAR (ids=Tabelle-142,-CosT_847)Tabelle 142, CosT_847: TERMINATE aktuelle Datei

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'E8' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR mode, der Wert '00' zeigt an, dass currentEF terminiert wird
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR –
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.9.2)14.2.9.2 CosK_4ae Use Case Terminieren eines privaten oder symmetrischen Schlüsselobjektes
PAR In dieser Variante wird ein privates Schlüsselobjekt oder ein symmetrisches Authentisierungsobjekt terminiert und die APDU des TERMINATE-Kommandos enthält zwei Parameter:
REQ(ids=A_16087)<b>A_16087 - (N048.910) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode zeigt an, dass ein Schlüsselobjekt zu terminieren ist, wobei eine ein Oktett lange Schlüsselreferenz im Kommandoheader enthalten ist. <b>[<=]</b>

REQ(ids=A_16088)<b>A_16088 - (N048.912) K_externeWelt {K_Karte}</b>
PAR Der Parameter reference enthält eine Schlüsselreferenz. Wert und Codierung MÜSSEN gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=A_16089)<b>A_16089 - (N048.914) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_1cd verwendet werden.
PAR (ids=Tabelle-143,-CosT_1cd)Tabelle 143, CosT_1cd: TERMINATE privates oder symmetrisches Schlüsselobjekt

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'E8' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '20' TD(3,2/1/1)->PAR mode, hier: Ein Oktett lange Schlüsselreferenz im Parameter P2
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR reference auf ein Schlüsselobjekt
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.9.3)14.2.9.3 CosK_a6c Use Case Terminieren eines öffentlichen Schlüsselobjektes
PAR In dieser Variante wird ein öffentliches Schlüsselobjekt terminiert und die APDU des TERMINATE-Kommandos enthält zwei Parameter:
REQ(ids=A_16090)<b>A_16090 - (N048.920) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode zeigt an, dass ein Schlüsselobjekt zu terminieren ist, wobei eine acht oder zwölf Oktett lange Schlüsselreferenz im Datenteil der Kommandonachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_16091)<b>A_16091 - (N048.922) K_externeWelt {K_Karte}</b>
PAR Der Parameter reference enthält eine acht oder zwölf Oktett lange Schlüsselreferenz mit beliebigem Inhalt. <b>[<=]</b>

REQ(ids=A_16092)<b>A_16092 - (N048.924) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_26d verwendet werden.
PAR (ids=Tabelle-144,-CosT_26d)Tabelle 144, CosT_26d: TERMINATE öffentliches Schlüsselobjekt

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'E8' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '21' TD(3,2/1/1)->PAR mode, hier: Schlüsselreferenz im Datenteil
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR -
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '83 –I2OS(OctetLength(reference), 1) – reference'
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.9.4)14.2.9.4 CosK_4d0 Use Case Terminieren eines Passwortobjektes
PAR In dieser Variante wird ein Passwortobjekt terminiert und die APDU des TERMINATE-Kommandos enthält zwei Parameter:
REQ(ids=A_16093)<b>A_16093 - (N048.930) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode zeigt an, dass ein Passwortobjekt zu terminieren ist, wobei eine ein Oktett lange Passwortreferenz im Kommandoheader enthalten ist. <b>[<=]</b>

REQ(ids=A_16094)<b>A_16094 - (N048.932) K_externeWelt {K_Karte}</b>
PAR Der Parameter reference enthält eine Passwortreferenz. Wert und Codierung MÜSSEN gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_16095)<b>A_16095 - (N048.934) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_770 verwendet werden.
PAR (ids=Tabelle-145,-CosT_770)Tabelle 145, CosT_770: TERMINATE Passwortobjekt

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'E8' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '10' TD(3,2/1/1)->PAR mode, hier: Ein Oktett lange Passwortreferenz im Parameter P2
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR reference auf ein Passwortobjekt
PAR <b>[<=]</b>

PAR -HEADING(ids=14.2.9.5)14.2.9.5 Antwort der Karte auf Terminieren von Datei, Schlüssel- oder Passwortobjekt
PAR (ids=Tabelle-146,-CosT_722)Tabelle 146, CosT_722: TERMINATE Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=66+180+498)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiche Terminierung
PAR (ids=Tabelle-147,-CosT_6af)Tabelle 147, CosT_6af: TERMINATE Antwort-APDU im Fehlerfall

TABLE(rows=7,cols=64+185+0+495)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/2)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/2)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 81' TD(2,1/1/1)->PAR VolatileKeyWithoutLCS TD(2,2/1/2)->PAR volatile Schlüssel vom Kommando nicht unterstützt
TR-> TD(3,0/1/1)->PAR '69 82' TD(3,1/1/1)->PAR SecurityStatusNotSatisfied TD(3,2/1/2)->PAR Zugriffsregel nicht erfüllt
TR-> TD(4,0/1/1)->PAR '69 86' TD(4,1/1/1)->PAR NoCurrentEF TD(4,2/1/2)->PAR Es ist kein EF ausgewählt
TR-> TD(5,0/1/1)->PAR '6A 88' TD(5,1/1/1)->PAR KeyNotFound TD(5,2/1/2)->PAR Schlüsselobjekt nicht gefunden
TR-> TD(6,0/1/1)->PAR '6A 88' TD(6,1/1/2)->PAR PasswordNotFound TD(6,3/1/1)->PAR Adressiertes Passwort wurde nicht gefunden
PAR Hinweis CosH_8f6: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16096)<b>A_16096 - (N048.948) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando TERMINATE verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.2.9.6)14.2.9.6 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N048.950.a)<b>G2_N048.950.a - (N048.950)a K_COS</b>
PAR Das COS MUSS die TERMINATE-Varianten aus (N048.903), (N048.914), (N048.924) und (N048.934) unterstützen. <b>[<=]</b>

REQ(ids=A_16097)<b>A_16097 - (N048.950)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere TERMINATE-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N048.954.a.1)<b>G2_N048.954.a.1 - (N048.954)a.1 K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '00' besitzt und channelContext.currentEF (siehe (N029.900)m) unbestimmt ist, genau dann MUSS das Kommando mit dem Trailer NoCurrentEF terminieren. <b>[<=]</b>

REQ(ids=G2_N048.954.a.2)<b>G2_N048.954.a.2 - (N048.954)a.2 K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '00' besitzt und channelContext.currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N048.954.b)<b>G2_N048.954.b - (N048.954)b K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '20' oder '21' besitzt, dann gilt<br>affectedObject = SearchKey(<br>    channelContext.currentFolder,<br>    reference,<br>   "WildCard"     <br>). Gemäß CosT_08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N048.954.c)<b>G2_N048.954.c - (N048.954)c K_COS</b>
PAR Wenn der Parameter mode in der Kommandonachricht den Wert '10' besitzt, dann gilt<br>affectedObject = SearchPwd( currentFolder, reference ). Wenn die Passwortsuche mit einem Fehler abbricht, genau dann MUSS das Kommando mit dem Trailer PasswordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N048.955)<b>G2_N048.955 - (N048.955) K_COS</b>
PAR Wenn affectedObject zu einem Eintrag in volatileCache gehört, dann MUSS das Kommando mit dem Trailer VolatileKeyWithoutLCS terminieren. <b>[<=]</b>

REQ(ids=G2_N048.957)<b>G2_N048.957 - (N048.957) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N048.960)<b>G2_N048.960 - (N048.960) K_COS</b>
PAR Wenn der physikalische Wert von lifeCycleStatus von affectedObject den Wert "Termination state" besitzt, dann MUSS als Trailer NoError verwendet werden. <b>[<=]</b>

REQ(ids=G2_N048.963)<b>G2_N048.963 - (N048.963) K_COS</b>
PAR Der physikalische Wert von lifeCycleStatus von affectedObject MUSS mittels Transaktionsschutz auf den Wert "Termination state" gesetzt werden. <b>[<=]</b>

REQ(ids=A_16098)<b>A_16098 - (N048.966) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_16099)<b>A_16099 - (N048.969) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N048.972)<b>G2_N048.972 - (N048.972) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16100)<b>A_16100 - (N048.975) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>a. Die Priorität der Trailer in CosT_6af ist herstellerspezifisch.<br>b. Jeder Trailer in CosT_6af MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>c. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.3)14.3 Zugriff auf Daten in transparenten EF
PAR Es ist möglich auf Daten im body eines transparenten EF lesend (READ BINARY-Kommando) oder schreibend (UPDATE BINARY-Kommando) zuzugreifen. Zudem ist es möglich den Dateninhalt von body durch nullen zu löschen (ERASE BINARY-Kommando). Sofern die maximale Dateigröße nicht erreicht ist, ist es möglich body um weitere Daten zu ergänzen (WRITE BINARY-Kommando). Die Größe von body lässt sich auch verringern (SET LOGIGAL EOF-Kommando).
PAR Die Kommandos in diesem Unterkapitel unterstützen zwei Varianten:

ORDERED-LIST->
LITEM->PAR Variante ohne shortFileIdentifier: Diese Variante ist dadurch gekennzeichnet, dass für eine erfolgreiche Kommandoabarbeitung currentEF notwendigerweise ein transparentes EF ist. Die Variable currentEF lässt sich unter anderem durch gewisse Varianten des SELECT-Kommandos setzen.LITEM->PAR Variante mit shortFileIdentifier: Diese Variante ist dadurch gekennzeichnet, dass das vom Kommando betroffene EF erst während der Kommandoabarbeitung gesetzt wird. Ein vorausgehendes SELECT-Kommando ist also nicht notwendig. In der Variante mit shortFileIdentifier lassen sich nur Dateien addressieren, die currentFolder zugeordnet sind.
PAR -HEADING(ids=14.3.1)14.3.1 CosK_a6a ERASE BINARY
PAR Das Kommando ERASE BINARY ersetzt bereits vorhandene Daten im body eines transparenten EF durch Oktette mit dem Wert '00'. Das betroffene transparente EF wird vor der Löschoperation ausgewählt. Dies geschieht entweder vor dem Senden dieses ERASE BINARY-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier), oder innerhalb dieses ERASE BINARY-Kommandos, falls diesem ein shortFileIdentifier als Parameter mitgeliefert wurde. Welche Informationen im body gelöscht werden, bestimmt der Offset, der als Parameter in der Kommandonachricht enthalten ist.
PAR -HEADING(ids=14.3.1.1)14.3.1.1 CosK_878 Use Case Löschen ohne shortFileIdentifier in transparenten EF
PAR In dieser Variante werden Daten in einem transparenten EF gelöscht, ohne das Attribut positionLogicalEndOfFile zu verändern. Die APDU des ERASE BINARY-Kommandos enthält einen Parameter:
REQ(ids=A_16101)<b>A_16101 - (N049.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter offset bestimmt, ab welcher Position gelöscht wird. Der Wert von offset MUSS eine ganze Zahl im Intervall [0, 32767] = [`0000', '7FFF'] sein (vergleiche (N011.500)a). <b>[<=]</b>

REQ(ids=A_16102)<b>A_16102 - (N049.100) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_238 verwendet werden.
PAR (ids=Tabelle-148,-CosT_238)Tabelle 148, CosT_238: ERASE BINARY, logical EOF unverändert, ohne shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4], positionLogicalEndOfFile konstant
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '0E' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR (offset – P2) / 256,  MSByte von offset
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR offset mod 256,       LSByte von offset
PAR <b>[<=]</b>

PAR -HEADING(ids=14.3.1.2)14.3.1.2 CosK_cee Use Case Löschen mit shortFileIdentifier in transparenten EF
PAR In dieser Variante werden Daten in einem transparenten EF gelöscht, ohne das Attribut positionLogicalEndOfFile zu verändern. Die APDU des ERASE BINARY-Kommandos enthält zwei Parameter:
REQ(ids=A_16103)<b>A_16103 - (N049.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter shortFileIdentifier wählt während der Kommandoabarbeitung ein EF aus. Der Wert von shortFileIdentifier MUSS aus dem in (N007.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16104)<b>A_16104 - (N049.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter offset bestimmt, ab welcher Position gelöscht wird. Der Wert von offset MUSS eine ganze Zahl im Intervall [0, 255] = ['00', 'FF'] sein. <b>[<=]</b>

REQ(ids=A_16105)<b>A_16105 - (N049.400) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_3f3 verwendet werden.
PAR (ids=Tabelle-149,-CosT_3f3)Tabelle 149, CosT_3f3: ERASE BINARY, logical EOF unverändert, mit shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4], positionLogicalEndOfFile konstant
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '0E' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR 128 + shortFileIdentifier, das heißt '80' + shortFileIdentifier
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR offset
PAR <b>[<=]</b>

PAR -HEADING(ids=14.3.1.3)14.3.1.3 Antwort der Karte auf Löschen in transparenten EF
PAR (ids=Tabelle-150,-CosT_adb)Tabelle 150, CosT_adb: ERASE BINARY Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreicher Löschvorgang
PAR (ids=Tabelle-151,-CosT_4c8)Tabelle 151, CosT_4c8: ERASE BINARY Antwort-APDU im Fehlerfall

TABLE(rows=7,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 81' TD(2,1/1/1)->PAR WrongFileType TD(2,2/1/1)->PAR Ausgewähltes EF ist nicht transparent
TR-> TD(3,0/1/1)->PAR '69 82' TD(3,1/1/1)->PAR SecurityStatusNotSatisfied TD(3,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(4,0/1/1)->PAR '69 86' TD(4,1/1/1)->PAR NoCurrentEF TD(4,2/1/1)->PAR Es ist kein EF ausgewählt
TR-> TD(5,0/1/1)->PAR '6A 82' TD(5,1/1/1)->PAR FileNotFound TD(5,2/1/1)->PAR Per shortFileIdentifier adressiertes EF nicht gefunden
TR-> TD(6,0/1/1)->PAR '6B 00' TD(6,1/1/1)->PAR OffsetTooBig TD(6,2/1/1)->PAR Parameter offset in Kommando–APDU ist zu groß
PAR Hinweis CosH_2f9: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16106)<b>A_16106 - (N049.500) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando ERASE BINARY verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.3.1.4)14.3.1.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N049.600.a)<b>G2_N049.600.a - (N049.600)a K_COS</b>
PAR Das COS MUSS die ERASE BINARY-Varianten aus (N049.100) und (N049.400) unterstützen. <b>[<=]</b>

REQ(ids=A_16107)<b>A_16107 - (N049.600)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere ERASE BINARY-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16108)<b>A_16108 - (N049.700) a K_COS</b>
PAR Wenn die APDU des ERASE BINARY-Kommandos einen shortFileIdentifier enthält, dann MUSS innerhalb von currentFolder.children nach einem EF mit diesem shortFileIdentifier gesucht werden. <b>[<=]</b>

REQ(ids=G2_N049.700.a.1)<b>G2_N049.700.a.1 - (N049.700)a.1 K_COS</b>
PAR Wenn die Suche erfolgreich verlief, dann MUSS<br>i.  affectedObject auf dieses EF gesetzt werden und<br>ii. currentEF auf dieses EF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N049.700.a.2)<b>G2_N049.700.a.2 - (N049.700)a.2 K_COS</b>
PAR Wenn die Suche nicht erfolgreich verlief, genau dann MUSS<br>i.  currentEF unverändert bleiben und<br>ii. das Kommando mit dem Trailer FileNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N049.700.b.1)<b>G2_N049.700.b.1 - (N049.700)b.1 K_COS</b>
PAR Wenn die APDU des ERASE BINARY-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) unbestimmt ist, genau dann MUSS das Kommando mit dem Trailer NoCurrentEF terminieren. <b>[<=]</b>

REQ(ids=G2_N049.700.b.2)<b>G2_N049.700.b.2 - (N049.700)b.2 K_COS</b>
PAR Wenn die APDU des ERASE BINARY-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N049.800)<b>G2_N049.800 - (N049.800) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N049.900)<b>G2_N049.900 - (N049.900) K_COS</b>
PAR Wenn affectedObject nicht vom Typ transparent EF ist, genau dann MUSS das Kommando mit dem Trailer WrongFileType terminieren. <b>[<=]</b>

REQ(ids=G2_N050.000)<b>G2_N050.000 - (N050.000) K_COS</b>
PAR Wenn offset größer oder gleich affectedObject.numberOfOctet ist, genau dann MUSS das Kommando mit dem Trailer OffsetTooBig terminieren. <b>[<=]</b>

REQ(ids=G2_N050.100.a)<b>G2_N050.100.a - (N050.100)a K_COS</b>
PAR Wenn affectedObject.flagTransactionMode den Wert True hat, genau dann MUSS affectedObject.body mit Transaktionsschutz geändert werden. Der Transaktionsschutz MUSS auch die Anpassung der Checksumme zu affectedObject.body umfassen, sofern diese vorhanden ist. <b>[<=]</b>

REQ(ids=A_16109)<b>A_16109 - (N050.100)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden für den Fall, dass affectedObject.flagTransactionMode den Wert False habe, würde affectedObject.body<br>1. mit Transaktionsschutz geändert, oder<br>2. ohne Transaktionsschutz geändert. <b>[<=]</b>

REQ(ids=A_16110)<b>A_16110 - (N050.190) K_COS</b>
PAR Wenn affectedObject.body durch eine Checksumme geschützt ist, dann MUSS das COS auf eine der in diesem Punkt genannten Arten reagieren: Eine Inkonsistenz zwischen dieser Checksumme und affectedObject.body<br>a. DARF NICHT zum Abbruch des Kommandos führen.<br>b. MUSS die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N050.200.a)<b>G2_N050.200.a - (N050.200)a K_COS</b>
PAR Wenn offset kleiner als affectedObject.positionLogicalEndOfFile ist, dann MÜSSEN die durch offset gekennzeichnete Stelle und alle weiteren Oktette in affectedObject.body auf den Wert '00' gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N050.200.b)<b>G2_N050.200.b - (N050.200)b K_COS</b>
PAR Wenn offset kleiner als affectedObject.positionLogicalEndOfFile ist und affectedObject.body ist durch eine Checksumme geschützt ist, dann MUSS diese Checksumme auf einen Wert gesetzt werden, der konsistent zum geänderten Inhalt von affectedObject.body ist. <b>[<=]</b>

REQ(ids=A_16111)<b>A_16111 - (N050.300) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_16112)<b>A_16112 - (N050.400) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N050.500)<b>G2_N050.500 - (N050.500) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16113)<b>A_16113 - (N050.600) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>a. Die Priorität der Trailer in CosT_4c8 ist herstellerspezifisch.<br>b. Jeder Trailer in CosT_4c8 MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>c. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR (N050.700) Diese Anforderung ist absichtlich leer.
PAR (N050.800) Diese Anforderung ist absichtlich leer.    
PAR Hinweis CosH_3ae: Es ist aus funktionaler Sicht irrelevant, ob die in (N050.200)a beschriebene erase-Funktion an der Stelle affectedObject.positionLogicalEndOfFile stoppt, oder bis zum Ende von affectedObject.body weiterarbeitet, weil sich diese beiden Fälle an der Kartenschnittstelle nicht unterscheiden.
PAR -HEADING(ids=14.3.2)14.3.2 CosK_052 READ BINARY
PAR Das Kommando READ BINARY dient dem Auslesen von Informationen aus dem body eines transparenten EF. Deshalb enthält das Datenfeld der Antwortnachricht (Teile von) body. Das betroffene transparente EF wird vor der Leseoperation ausgewählt. Dies geschieht entweder vor dem Senden dieses READ BINARY-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier), oder innerhalb dieses READ BINARY-Kommandos, falls diesem ein shortFileIdentifier als Parameter mitgeliefert wurde. Welche Informationen aus body ausgelesen werden, bestimmen Offset und Länge, die als Parameter in der Kommandonachricht enthalten sind.
PAR -HEADING(ids=14.3.2.1)14.3.2.1 CosK_05a Use Case Lesen ohne shortFileIdentifier in transparenten EF
PAR In dieser Variante enthält die APDU des READ BINARY-Kommandos zwei Parameter:
REQ(ids=A_16116)<b>A_16116 - (N050.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter offset bestimmt, ab welcher Position gelesen wird. Der Wert von offset MUSS eine ganze Zahl im Intervall [0, 32767] = ['0000', '7FFF'] sein (vergleiche (N011.500)a). <b>[<=]</b>

REQ(ids=A_16119)<b>A_16119 - (N051.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus dem in (N027.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16120)<b>A_16120 - (N051.100) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d oder eine Case 2E Kommando-APDU gemäß CosK_f88 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_a50 verwendet werden.
PAR (ids=Tabelle-152,-CosT_a50)Tabelle 152, CosT_a50: READ BINARY ohne shortFileIdentifier

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'B0' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR (offset – P2) / 256,  MSByte von offset
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR offset mod 256,       LSByte von offset
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR length TD(5,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.3.2.2)14.3.2.2 CosK_1f5 Use Case Lesen mit shortFileIdentifier in transparenten EF
PAR In dieser Variante enthält die APDU des READ BINARY-Kommandos drei Parameter:
REQ(ids=A_16121)<b>A_16121 - (N051.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter shortFileIdentifier wählt während der Kommandoabarbeitung ein EF aus. Der Wert von shortFileIdentifier MUSS aus dem in (N007.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16122)<b>A_16122 - (N051.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter offset bestimmt, ab welcher Position gelesen wird. Der Wert von offset MUSS eine ganze Zahl im Intervall [0, 255] = ['00', 'FF'] sein. <b>[<=]</b>

REQ(ids=A_16123)<b>A_16123 - (N051.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus dem in (N027.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16124)<b>A_16124 - (N051.500) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d oder eine Case 2E Kommando-APDU gemäß CosK_f88 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_301 verwendet werden.
PAR (ids=Tabelle-153,-CosT_301)Tabelle 153, CosT_301: READ BINARY mit shortFileIdentifier

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'B0' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR 128 + shortFileIdentifier, das heißt '80' + shortFileIdentifier
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR offset
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR length TD(5,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.3.2.3)14.3.2.3 Antwort der Karte auf Lesen in transparenten EF
PAR (ids=Tabelle-154,-CosT_1a8)Tabelle 154, CosT_1a8: READ BINARY Antwort-APDU im Erfolgsfall

TABLE(rows=6,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)-> TD(1,2/1/1)->PAR Ausgelesene Daten
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '62 81' TD(3,1/1/1)->PAR CorruptDataWarning TD(3,2/1/1)->PAR Möglicherweise sind die Antwortdaten korrupt
TR-> TD(4,0/1/1)->PAR '62 82' TD(4,1/1/1)->PAR EndOfFileWarning TD(4,2/1/1)->PAR Weniger Daten vorhanden, als mittels Ne angefordert
TR-> TD(5,0/1/1)->PAR '90 00' TD(5,1/1/1)->PAR NoError TD(5,2/1/1)->PAR Erfolgreiche Leseoperation
PAR (ids=Tabelle-155,-CosT_1b0)Tabelle 155, CosT_1b0: READ BINARY Antwort-APDU im Fehlerfall

TABLE(rows=6,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '69 81' TD(1,1/1/1)->PAR WrongFileType TD(1,2/1/1)->PAR Ausgewähltes EF ist nicht transparent
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '69 86' TD(3,1/1/1)->PAR NoCurrentEF TD(3,2/1/1)->PAR Es ist kein EF ausgewählt
TR-> TD(4,0/1/1)->PAR '6A 82' TD(4,1/1/1)->PAR FileNotFound TD(4,2/1/1)->PAR Per shortFileIdentifier adressiertes EF nicht gefunden
TR-> TD(5,0/1/1)->PAR '6B 00' TD(5,1/1/1)->PAR OffsetTooBig TD(5,2/1/1)->PAR Parameter offset in Kommando-APDU ist zu groß
PAR Hinweis CosH_782: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16125)<b>A_16125 - (N051.600) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando READ BINARY verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.3.2.4)14.3.2.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N051.700.a)<b>G2_N051.700.a - (N051.700).a K_COS</b>
PAR Das COS MUSS die READ BINARY-Varianten aus (N051.100) und (N51.500) unterstützen. <b>[<=]</b>

REQ(ids=A_16126)<b>A_16126 - (N051.700)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere READ BINARY-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16127)<b>A_16127 - (N051.800)a K_COS</b>
PAR Wenn die APDU des READ BINARY-Kommandos einen shortFileIdentifier enthält, dann MUSS innerhalb von currentFolder.children nach einem EF mit diesem shortFileIdentifier gesucht werden. <b>[<=]</b>

REQ(ids=G2_N051.800.a(.1))<b>G2_N051.800.a(.1) - (N051.800)a.1 K_COS</b>
PAR Wenn die Suche erfolgreich verlief, dann MUSS<br>i.  affectedObject auf dieses EF gesetzt werden und<br>ii. currentEF auf dieses EF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N051.800.a.2)<b>G2_N051.800.a.2 - (N051.800)a.2 K_COS</b>
PAR Wenn die Suche nicht erfolgreich verlief, genau dann MUSS<br>i.  currentEF unverändert bleiben und<br>ii. das Kommando mit dem Trailer FileNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N051.800.b.1)<b>G2_N051.800.b.1 - (N051.800)b.1 K_COS</b>
PAR Wenn die APDU des READ BINARY-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) unbestimmt ist, genau dann MUSS das Kommando mit dem Trailer NoCurrentEF terminieren. <b>[<=]</b>

REQ(ids=G2_N051.800.b.2)<b>G2_N051.800.b.2 - (N051.800)b.2 k_COS</b>
PAR Wenn die APDU des READ BINARY-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N051.900)<b>G2_N051.900 - (N051.900) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N052.000)<b>G2_N052.000 - (N052.000) K_COS</b>
PAR Wenn affectedObject nicht vom Typ transparent EF ist, genau dann MUSS das Kommando mit dem Trailer WrongFileType terminieren. <b>[<=]</b>

REQ(ids=G2_N052.100)<b>G2_N052.100 - (N052.100) K_COS</b>
PAR Wenn offset größer oder gleich affectedObject.positionLogicalEndOfFile ist, genau dann MUSS das Kommando mit dem Trailer OffsetTooBig terminieren. <b>[<=]</b>

REQ(ids=A_16128)<b>A_16128 - (N052.200)a K_COS</b>
PAR Wenn affectedObject.flagChecksum den Wert True hat und die Daten von affectedObject.body inkonsistent zur Checksumme sind, genau dann MUSS eine der beiden folgenden Verhaltensweisen implementiert sein: <b>[<=]</b>

REQ(ids=G2_N052.200.a)<b>G2_N052.200.a - (N052.200)a K_COS</b>
PAR Möglichkeit 1: Als Trailer MUSS CorruptDataWarning gewählt werden. <b>[<=]</b>

REQ(ids=A_16129)<b>A_16129 - (N052.200)b K_COS</b>
PAR Möglichkeit 2: Die Kommandobearbeitung MUSS gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N052.300)<b>G2_N052.300 - (N052.300) K_COS</b>
PAR Wenn das LeFeld der Kommando-APDU keine WildCard enthält und (offset + length) größer als affectedObject.positionLogicalEndOfFile ist, genau dann MUSS als Trailer EndOfFileWarning gewählt werden. <b>[<=]</b>

REQ(ids=G2_N052.400)<b>G2_N052.400 - (N052.400) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=G2_N052.500.a)<b>G2_N052.500.a - (N052.500)a K_COS</b>
PAR Aus dem Oktettstring von affectedObject.body MÜSSEN die durch offset gekennzeichnete Position und die nachfolgenden Oktette übernommen werden. <b>[<=]</b>

REQ(ids=A_16130)<b>A_16130 - (N052.500)b K_COS</b>
PAR Es DÜRFEN NICHT mehr Oktette übernommen werden, als durch Ne angegeben. <b>[<=]</b>

REQ(ids=G2_N052.500.c)<b>G2_N052.500.c - (N052.500)c K_COS</b>
PAR Die Übernahme der Oktette MUSS so gestoppt werden, dass weder das Oktett an der Position affectedObject.positionLogicalEndOfFile noch nachfolgende Oktette übernommen werden. <b>[<=]</b>

REQ(ids=A_16131)<b>A_16131 - (N052.600)a K_TST</b>
PAR Die Priorität der Trailer in CosT_1b0 MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N052.600.b)<b>G2_N052.600.b - (N052.600)b K_COS</b>
PAR Jeder Trailer in CosT_1b0 MUSS eine höhere Priorität als CorruptDataWarning haben. <b>[<=]</b>

REQ(ids=G2_N052.600.c)<b>G2_N052.600.c - (N052.600)c K_COS</b>
PAR CorruptDataWarning MUSS eine höhere Priorität als EndOfFileWarning haben. <b>[<=]</b>

REQ(ids=G2_N052.600.d)<b>G2_N052.600.d - (N052.600)d K_COS</b>
PAR EndOfFileWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR (N052.700) Diese Anforderung ist absichtlich leer.
PAR (N052.800) Diese Anforderung ist absichtlich leer.    
PAR -HEADING(ids=14.3.3)14.3.3 CosK_d46 SEARCH BINARY
REQ(ids=A_16132)<b>A_16132 - (N052.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das SEARCH BINARY-Kommando gemäß [ISO/IEC 7816-4] würde<br>a. unterstützt oder<br>b. abgelehnt. <b>[<=]</b>

PAR -HEADING(ids=14.3.4)14.3.4 CosK_427 SET LOGICAL EOF
PAR Hinweis CosH_756: Dieses Kommando ist nicht in der Normenreihe ISO/IEC 7816 enthalten. Wegen ähnlicher Funktionalität teilt sich dieses Kommando das INS Byte mit ERASE BINARY.
PAR Das Kommando SET LOGICAL EOF verändert den Wert des Attributes positionLogicalEndOfFile eines transparenten EF, wodurch Daten gelöscht werden. Das betroffene transparente EF wird vor der Löschoperation ausgewählt. Dies geschieht entweder vor dem Senden dieses SET LOGICAL EOF-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier), oder innerhalb dieses SET LOGICAL EOF-Kommandos, falls diesem ein shortFileIdentifier als Parameter mitgeliefert wurde. Auf welchen Wert das Attribut positionLogicalEndOfFile gesetzt wird und damit welche Daten in body gelöscht werden, bestimmt der Offset, der als Parameter in der Kommandonachricht enthalten ist.
PAR -HEADING(ids=14.3.4.1)14.3.4.1 CosK_7e8 Use Case Setzen logical EOF ohne shortFileIdentifier
PAR In dieser Variante werden Daten in einem transparenten EF gelöscht und das Attribut positionLogicalEndOfFile wird verändert.
REQ(ids=A_16133)<b>A_16133 - (N052.930) K_externeWelt {K_Karte}</b>
PAR Die APDU des SET LOGICAL EOF-Kommandos enthält einen Parameter:<br>a. Der Parameter offset bestimmt, ab welcher Position gelöscht wird. Der Wert von offset MUSS eine ganze Zahl im Intervall [0, 32767] = [`0000', '7FFF'] sein (vergleiche (N011.500)). <b>[<=]</b>

REQ(ids=A_16134)<b>A_16134 - (N052.932) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_be2 verwendet werden.
PAR (ids=Tabelle-156,-CosT_be2)Tabelle 156, CosT_be2: SET LOGICAL EOF  ohne shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '80' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4] wird hier "proprietary" angezeigt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '0E' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR (offset – P2) / 256,  MSByte von offset
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR offset mod 256,       LSByte von offset
PAR <b>[<=]</b>

PAR -HEADING(ids=14.3.4.2)14.3.4.2 CosK_a7e Use Case Setzen logical EOF mit shortFileIdentifier
PAR In dieser Variante werden Daten in einem transparenten EF gelöscht und das Attribut positionLogicalEndOfFile wird verändert.
REQ(ids=A_16135)<b>A_16135 - (N052.934) K_externeWelt {K_Karte}</b>
PAR Die APDU des SET LOGICAL EOF-Kommandos enthält zwei Parameter:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter shortFileIdentifier wählt während der Kommandoabarbeitung ein EF aus. Der Wert von shortFileIdentifier MUSS aus dem in (N007.000) definierten Bereich gewählt werden.LITEM->PAR Der Parameter offset bestimmt, ab welcher Position gelöscht wird. Der Wert von offset MUSS eine ganze Zahl im Intervall [0, 255] = ['00', 'FF'] sein.
PAR <b>[<=]</b>

REQ(ids=A_16136)<b>A_16136 - (N052.936) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_164 verwendet werden.
PAR (ids=Tabelle-157,-CosT_164)Tabelle 157, CosT_164: SET LOGICAL EOF mit shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '80' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4] wird hier "proprietary" angezeigt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '0E' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR 128 + shortFileIdentifier, das heißt '80' + shortFileIdentifier
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR offset
PAR <b>[<=]</b>

PAR -HEADING(ids=14.3.4.3)14.3.4.3 Antwort der Karte auf Setzen logical EOF in transparenten EF
PAR (ids=Tabelle-158,-CosT_77c)Tabelle 158, CosT_77c: SET LOGICAL EOF Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreicher Löschvorgang
PAR (ids=Tabelle-159,-CosT_a26)Tabelle 159, CosT_a26: SET LOGICAL EOF Antwort-APDU im Fehlerfall

TABLE(rows=7,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 81' TD(2,1/1/1)->PAR WrongFileType TD(2,2/1/1)->PAR Ausgewähltes EF ist nicht transparent
TR-> TD(3,0/1/1)->PAR '69 82' TD(3,1/1/1)->PAR SecurityStatusNotSatisfied TD(3,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(4,0/1/1)->PAR '69 86' TD(4,1/1/1)->PAR NoCurrentEF TD(4,2/1/1)->PAR Es ist kein EF ausgewählt
TR-> TD(5,0/1/1)->PAR '6A 82' TD(5,1/1/1)->PAR FileNotFound TD(5,2/1/1)->PAR Per shortFileIdentifier adressiertes EF nicht gefunden
TR-> TD(6,0/1/1)->PAR '6B 00' TD(6,1/1/1)->PAR OffsetTooBig TD(6,2/1/1)->PAR Parameter offset in Kommando–APDU ist zu groß
PAR Hinweis CosH_a51: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16137)<b>A_16137 - (N052.938) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando SET LOGICAL EOF verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.3.4.4)14.3.4.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N052.940.a)<b>G2_N052.940.a - (N052.940)a K_COS</b>
PAR Das COS MUSS die SET LOGICAL EOF-Varianten aus (N052.932) und (N052.936) unterstützen. <b>[<=]</b>

REQ(ids=A_16138)<b>A_16138 - (N052.940)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere SET LOGICAL EOF-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16139)<b>A_16139 - (N053.942)a K_COS</b>
PAR Wenn die APDU des SET LOGICAL EOF-Kommandos einen shortFileIdentifier enthält, dann MUSS innerhalb von currentFolder.children nach einem EF mit diesem shortFileIdentifier gesucht werden. <b>[<=]</b>

REQ(ids=G2_N052.942.a.1)<b>G2_N052.942.a.1 - (N052.942)a.1 K_COS</b>
PAR Wenn die Suche erfolgreich verlief, dann MUSS<br>i.  affectedObject auf dieses EF gesetzt werden und<br>ii. currentEF auf dieses EF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N052.942.a.2)<b>G2_N052.942.a.2 - (N052.942)a.2 K_COS</b>
PAR Wenn die Suche nicht erfolgreich verlief, genau dann MUSS<br>i.  currentEF unverändert bleiben und<br>ii. das Kommando mit dem Trailer FileNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N052.942.b.1)<b>G2_N052.942.b.1 - (N052.942)b.1 K_COS</b>
PAR Wenn die APDU des SET LOGICAL EOF-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) unbestimmt ist, genau dann MUSS das Kommando mit dem Trailer NoCurrentEF terminieren. <b>[<=]</b>

REQ(ids=G2_N052.942.b.2)<b>G2_N052.942.b.2 - (N052.942)b.2 K_COS</b>
PAR Wenn die APDU des SET LOGICAL EOF-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N052.944)<b>G2_N052.944 - (N052.944) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N052.946)<b>G2_N052.946 - (N052.946) K_COS</b>
PAR Wenn affectedObject nicht vom Typ transparent EF ist, genau dann MUSS das Kommando mit dem Trailer WrongFileType terminieren. <b>[<=]</b>

REQ(ids=G2_N052.948)<b>G2_N052.948 - (N052.948) K_COS</b>
PAR Wenn offset größer oder gleich affectedObject.numberOfOctet ist, genau dann MUSS das Kommando mit dem Trailer OffsetTooBig terminieren. <b>[<=]</b>

REQ(ids=G2_N052.950.a)<b>G2_N052.950.a - (N052.950)a K_COS</b>
PAR Wenn affectedObject.flagTransactionMode den Wert True hat, genau dann MUSS affectedObject.body mit Transaktionsschutz geändert werden. Der Transaktionsschutz MUSS auch die Anpassung der Checksumme zu affectedObject.body umfassen, sofern diese vorhanden ist. <b>[<=]</b>

REQ(ids=A_16140)<b>A_16140 - (N052.950)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden für den Fall, dass affectedObject.flagTransactionMode den Wert False habe, würde affectedObject.body<br>1. mit Transaktionsschutz geändert, oder<br>2. ohne Transaktionsschutz geändert. <b>[<=]</b>

REQ(ids=A_16141)<b>A_16141 - (N052.952) K_COS</b>
PAR Wenn affectedObject.body durch eine Checksumme geschützt ist, dann MUSS das COS auf eine der in diesem Punkt genannten Arten reagieren: Eine Inkonsistenz zwischen dieser Checksumme und affectedObject.body<br>a. DARF NICHT zum Abbruch des Kommandos führen.<br>b. MUSS die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N052.954.a.1)<b>G2_N052.954.a.1 - (N052.954)a.1 K_COS</b>
PAR Wenn offset kleiner als affectedObject.positionLogicalEndOfFile ist, dann MUSS, falls affectedObject.body durch eine Checksumme geschützt ist, diese Checksumme auf einen Wert gesetzt werden, der konsistent zum geänderten Inhalt von affectedObject.body ist. <b>[<=]</b>

REQ(ids=G2_N052.954.a.2)<b>G2_N052.954.a.2 - (N052.954)a.2 K_COS</b>
PAR Wenn offset kleiner als affectedObject.positionLogicalEndOfFile ist, dann MUSS affectedObject.positionLogicalEndOfFile auf den Wert von offset geändert werden.  <b>[<=]</b>

PAR Hinweis CosH_d76: Aus Sicherheitsgründen erscheint es sinnvoll, die durch offset gekennzeichnete Stelle und alle weiteren Oktette in affectedObject.body auf den Wert '00' zu setzten. Ob so eine Aktion erfolgt, ist mit den normativen Mitteln aus diesem Dokument nicht testbar, vergleiche auch (N054.500)a und (N055.258).
REQ(ids=G2_N052.954.b)<b>G2_N052.954.b - (N052.954)b K_COS</b>
PAR Wenn offset größer gleich als affectedObject.positionLogicalEndOfFile ist, dann DARF affectedObject.positionLogicalEndOfFile NICHT geändert werden. <b>[<=]</b>

REQ(ids=A_16142)<b>A_16142 - (N052.956) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_16143)<b>A_16143 - (N052.958) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N052.960)<b>G2_N052.960 - (N052.960) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16144)<b>A_16144 - (N052.962) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>a. Die Priorität der Trailer in CosT_a26 ist herstellerspezifisch.<br>b. Jeder Trailer in CosT_a26 MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>c. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR Hinweis CosH_c51: Es ist aus funktionaler Sicht irrelevant, ob die in (N052.954) beschriebene erase-Funktion an der Stelle positionLogicalEndOfFile stoppt, oder bis zum Ende von affectedObject.body weiterarbeitet, weil sich diese beiden Fälle an der Kartenschnittstelle nicht unterscheiden.
PAR -HEADING(ids=14.3.5)14.3.5 CosK_721 UPDATE BINARY
PAR Das Kommando UPDATE BINARY ersetzt Daten im body eines transparenten EF durch Daten, die im Datenfeld der Kommandonachricht enthalten sind. Das betroffene transparente EF wird vor der Schreiboperation ausgewählt. Dies geschieht entweder vor dem Senden dieses UPDATE BINARY-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier), oder innerhalb dieses UPDATE BINARY-Kommandos, falls diesem ein shortFileIdentifier als Parameter mitgeliefert wurde. Welche Informationen im body geändert werden, bestimmen Offset und Schreibdaten, die als Parameter in der Kommandonachricht enthalten sind.
PAR -HEADING(ids=14.3.5.1)14.3.5.1 CosK_c15 Use Case Schreiben ohne shortFileIdentifier in transparenten EF
PAR In dieser Variante enthält die APDU des UPDATE BINARY-Kommandos zwei Parameter:
REQ(ids=A_16145)<b>A_16145 - (N053.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter offset bestimmt, ab welcher Position geschrieben wird. Der Wert von offset MUSS eine ganze Zahl im Intervall [0, 32767] = [`0000', '7FFF'] sein (vergleiche (N011.500)). <b>[<=]</b>

REQ(ids=A_16146)<b>A_16146 - (N053.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter newData enthält die neuen Daten, welche die, ab der durch offset gekennzeichneten Stelle, enthaltenen Daten in body ersetzen. Der Parameter newData ist ein Oktettstring mit beliebigem Inhalt. Die Länge von newData MUSS aus dem in (N026.900) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16147)<b>A_16147 - (N053.200) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 oder eine Case 3E Kommando-APDU gemäß CosK_afd über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_cdb verwendet werden.
PAR (ids=Tabelle-160,-CosT_cdb)Tabelle 160, CosT_cdb: UPDATE BINARY ohne shortFileIdentifier

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'D6' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR (offset – P2) / 256,   MSByte von offset
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR offset mod 256,        LSByte von offset
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR newData
PAR <b>[<=]</b>

PAR -HEADING(ids=14.3.5.2)14.3.5.2 CosK_6cf Use Case Schreiben mit shortFileIdentifier in transparenten EF
PAR In dieser Variante enthält die APDU des UPDATE BINARY-Kommandos drei Parameter:
REQ(ids=A_16148)<b>A_16148 - (N053.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter shortFileIdentifier wählt während der Kommandoabarbeitung ein EF aus. Der Wert von shortFileIdentifier MUSS aus dem in (N007.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16149)<b>A_16149 - (N053.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter offset bestimmt, ab welcher Position geschrieben wird. Der Wert von offset MUSS eine ganze Zahl im Intervall [0, 255] = ['00', 'FF'] sein. <b>[<=]</b>

REQ(ids=A_16150)<b>A_16150 - (N053.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter newData enthält die neuen Daten, welche die ab der durch offset gekennzeichneten Stelle enthaltenen Daten in body ersetzen. Der Parameter newData ist ein Oktettstring mit beliebigem Inhalt. Die Länge von newData MUSS aus dem in (N026.900) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16151)<b>A_16151 - (N053.600) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 oder eine Case 3E Kommando-APDU gemäß CosK_afd über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_e25 verwendet werden.
PAR (ids=Tabelle-161,-CosT_e25)Tabelle 161, CosT_e25: UPDATE BINARY mit shortFileIdentifier

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'D6' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR 128 + shortFileIdentifier, das heißt '80' + shortFileIdentifier
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR offset
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR newData
PAR <b>[<=]</b>

PAR -HEADING(ids=14.3.5.3)14.3.5.3 Antwort der Karte auf Schreiben in transparenten EF
PAR (ids=Tabelle-162,-CosT_94b)Tabelle 162, CosT_94b: UPDATE BINARY Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreicher Schreibvorgang
PAR (ids=Tabelle-163,-CosT_c75)Tabelle 163, CosT_c75: UPDATE BINARY Antwort-APDU im Fehlerfall

TABLE(rows=8,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 81' TD(2,1/1/1)->PAR WrongFileType TD(2,2/1/1)->PAR Ausgewähltes EF ist nicht transparent
TR-> TD(3,0/1/1)->PAR '69 82' TD(3,1/1/1)->PAR SecurityStatusNotSatisfied TD(3,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(4,0/1/1)->PAR '69 86' TD(4,1/1/1)->PAR NoCurrentEF TD(4,2/1/1)->PAR Es ist kein EF ausgewählt
TR-> TD(5,0/1/1)->PAR '6A 82' TD(5,1/1/1)->PAR FileNotFound TD(5,2/1/1)->PAR Per shortFileIdentifier adressiertes EF nicht gefunden
TR-> TD(6,0/1/1)->PAR '6A 84' TD(6,1/1/1)->PAR DataTooBig TD(6,2/1/1)->PAR Parameter newData ragt über das Dateiende hinaus
TR-> TD(7,0/1/1)->PAR '6B 00' TD(7,1/1/1)->PAR OffsetTooBig TD(7,2/1/1)->PAR Parameter offset in Kommando–APDU ist zu groß
PAR Hinweis CosH_71e: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16152)<b>A_16152 - (N053.700) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando UPDATE BINARY verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.3.5.4)14.3.5.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N053.800.a)<b>G2_N053.800.a - (N053.800)a K_COS</b>
PAR Das COS MUSS die UPDATE BINARY-Varianten aus (N053.200) und (N053.600) unterstützen. <b>[<=]</b>

REQ(ids=A_16153)<b>A_16153 - (N053.800)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere UPDATE BINARY-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16154)<b>A_16154 - (N053.900)a K_COS</b>
PAR Wenn die APDU des UPDATE BINARY-Kommandos einen shortFileIdentifier enthält, dann MUSS innerhalb von currentFolder.children nach einem EF mit diesem shortFileIdentifier gesucht werden. <b>[<=]</b>

REQ(ids=G2_N053.900.a.1)<b>G2_N053.900.a.1 - (N053.900)a.1 K_COS</b>
PAR Wenn die Suche erfolgreich verlief, dann MUSS<br>i.  affectedObject auf dieses EF gesetzt werden und<br>ii. currentEF auf dieses EF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N053.900.a.2)<b>G2_N053.900.a.2 - (N053.900)a.2 K_COS</b>
PAR Wenn die Suche nicht erfolgreich verlief, genau dann MUSS<br>i.  currentEF unverändert bleiben und<br>ii. das Kommando mit dem Trailer FileNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N053.900.b.1)<b>G2_N053.900.b.1 - (N053.900)b.1 K_COS</b>
PAR Wenn die APDU des UPDATE BINARY-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) unbestimmt ist, genau dann MUSS das Kommando mit dem Trailer NoCurrentEF terminieren. <b>[<=]</b>

REQ(ids=G2_N053.900.b.2)<b>G2_N053.900.b.2 - (N053.900)b.2 K_COS</b>
PAR Wenn die APDU des UPDATE BINARY-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N054.000)<b>G2_N054.000 - (N054.000) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N054.100)<b>G2_N054.100 - (N054.100) K_COS</b>
PAR Wenn affectedObject nicht vom Typ transparent EF ist, genau dann MUSS das Kommando mit dem Trailer WrongFileType terminieren. <b>[<=]</b>

REQ(ids=G2_N054.200)<b>G2_N054.200 - (N054.200) K_COS</b>
PAR Wenn offset größer oder gleich affectedObject.numberOfOctet ist, genau dann MUSS das Kommando mit dem Trailer OffsetTooBig terminieren. <b>[<=]</b>

REQ(ids=G2_N054.300)<b>G2_N054.300 - (N054.300) K_COS</b>
PAR Wenn (offset + OctetLength(newData)) größer als affectedObject.numberOfOctet ist, genau dann MUSS das Kommando mit dem Trailer DataTooBig terminieren. <b>[<=]</b>

REQ(ids=G2_N054.400.a)<b>G2_N054.400.a - (N054.400)a K_COS</b>
PAR Wenn affectedObject.flagTransactionMode den Wert True hat, genau dann MUSS affectedObject.body und gegebenenfalls affectedObject.positionLogicalEndOfFile mit Transaktionsschutz geändert werden. Der Transaktionsschutz MUSS auch die Anpassung der Checksumme zu affectedObject.body umfassen, sofern diese vorhanden ist. <b>[<=]</b>

REQ(ids=A_16155)<b>A_16155 - (N054.400)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden für den Fall, dass affectedObject.flagTransactionMode den Wert False habe, würde affectedObject.body<br>1. mit Transaktionsschutz geändert, oder<br>2. ohne Transaktionsschutz geändert. <b>[<=]</b>

REQ(ids=A_16156)<b>A_16156 - (N054.490) K_COS</b>
PAR Wenn affectedObject.body durch eine Checksumme geschützt ist, dann MUSS das COS auf eine der in diesem Punkt genannten Arten reagieren: Eine Inkonsistenz zwischen dieser Checksumme und affectedObject.body<br>a. DARF NICHT zum Abbruch des Kommandos führen.<br>b. MUSS die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N054.500.a)<b>G2_N054.500.a - (N054.500)a K_COS</b>
PAR Wenn affectedObject.positionLogicalEndOfFile kleiner als offset ist, dann MUSS das Oktett an der Position affectedObject.positionLogicalEndOfFile und alle nachfolgenden Oktette bis zur Position (offset – 1) auf den Wert '00' gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N054.500.b)<b>G2_N054.500.b - (N054.500)b K_COS</b>
PAR Die durch offset gekennzeichnete Stelle in affectedObject.body und die folgenden Oktette MÜSSEN durch newData ersetzt werden. <b>[<=]</b>

REQ(ids=G2_N054.500.c)<b>G2_N054.500.c - (N054.500)c K_COS</b>
PAR Wenn positionLogicalEndOfFile kleiner als (offset + OctetLength(newData)) ist, dann MUSS positionLogicalEndOfFile = (offset + OctetLength(newData)) gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N054.500.d)<b>G2_N054.500.d - (N054.500)d K_COS</b>
PAR Wenn affectedObject.body durch eine Checksumme geschützt ist, dann MUSS diese Checksumme auf einen Wert gesetzt werden, der konsistent zum geänderten Inhalt von affectedObject.body ist. <b>[<=]</b>

REQ(ids=A_16157)<b>A_16157 - (N054.600) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_16158)<b>A_16158 - (N054.700) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N054.800)<b>G2_N054.800 - (N054.800) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16159)<b>A_16159 - (N054.900) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>a. Die Priorität der Trailer in CosT_c75 ist herstellerspezifisch.<br>b. Jeder Trailer in CosT_c75 MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>c. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR (N055.000) Diese Anforderung ist absichtlich leer.
PAR (N055.100) Diese Anforderung ist absichtlich leer.
PAR -HEADING(ids=14.3.6)14.3.6 CosK_a3c WRITE BINARY
PAR Das Kommando WRITE BINARY fügt den vorhandenen Daten im body eines transparenten EF Daten hinzu, die im Datenfeld der Kommandonachricht enthalten sind. Das betroffene transparente EF wird vor der Schreiboperation ausgewählt. Dies geschieht entweder vor dem Senden dieses WRITE BINARY-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier), oder innerhalb dieses WRITE BINARY-Kommandos, falls diesem ein shortFileIdentifier als Parameter mitgeliefert wurde. Wieviele Daten body hinzugefügt werden, bestimmen Schreibdaten, die als Parameter in der Kommandonachricht enthalten sind.
PAR -HEADING(ids=14.3.6.1)14.3.6.1 CosK_8e7 Use Case Anfügen ohne shortFileIdentifier in transparenten EF
PAR In dieser Variante enthält die APDU des WRITE BINARY-Kommandos einen Parameter:
REQ(ids=A_16160)<b>A_16160 - (N055.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter newData enthält die neuen Daten, welche die, ab der durch positionLogicalEndOfFile gekennzeichneten Stelle, enthaltenen Daten in body ergänzen. Der Parameter newData ist ein Oktettstring mit beliebigem Inhalt. Die Länge von newData MUSS aus dem in (N026.900) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16161)<b>A_16161 - (N055.205) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 oder eine Case 3E Kommando-APDU gemäß CosK_afd über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_17f verwendet werden.
PAR (ids=Tabelle-164,-CosT_17f)Tabelle 164, CosT_17f: WRITE BINARY ohne shortFileIdentifier

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'D0' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR Bit b8 = 0 => die Kommando APDU enthält keinen shortFileIdentifier
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR fester Wert
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR newData
PAR <b>[<=]</b>

PAR -HEADING(ids=14.3.6.2)14.3.6.2 CosK_290 Use Case Anfügen mit shortFileIdentifier in transparenten EF
PAR In dieser Variante enthält die APDU des WRITE BINARY-Kommandos zwei Parameter:
REQ(ids=A_16162)<b>A_16162 - (N055.220) K_externeWelt {K_Karte}</b>
PAR Der Parameter shortFileIdentifier wählt während der Kommandoabarbeitung ein EF aus. Der Wert von shortFileIdentifier MUSS aus dem in (N007.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16163)<b>A_16163 - (N055.223) K_externeWelt {K_Karte}</b>
PAR Der Parameter newData enthält die neuen Daten, welche die, ab der durch positionLogicalEndOfFile gekennzeichneten Stelle, enthaltenen Daten in body ergänzen. Der Parameter newData ist ein Oktettstring mit beliebigem Inhalt. Die Länge von newData MUSS aus dem in (N026.900) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16164)<b>A_16164 - (N055.226) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 oder eine Case 3E Kommando-APDU gemäß CosK_afd über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_415 verwendet werden.
PAR (ids=Tabelle-165,-CosT_415)Tabelle 165, CosT_415: WRITE BINARY mit shortFileIdentifier

TABLE(rows=6,cols=64+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'D0' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR 128 + shortFileIdentifier, das heißt '80' + shortFileIdentifier
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR fester Wert
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR newData
PAR <b>[<=]</b>

PAR -HEADING(ids=14.3.6.3)14.3.6.3 Antwort der Karte auf Anfügen in transparenten EF
PAR (ids=Tabelle-166,-CosT_e5e)Tabelle 166, CosT_e5e: WRITE BINARY Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreicher Schreibvorgang
PAR (ids=Tabelle-167,-CosT_507)Tabelle 167, CosT_507: WRITE BINARY Antwort-APDU im Fehlerfall

TABLE(rows=7,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 81' TD(2,1/1/1)->PAR WrongFileType TD(2,2/1/1)->PAR Ausgewähltes EF ist nicht transparent
TR-> TD(3,0/1/1)->PAR '69 82' TD(3,1/1/1)->PAR SecurityStatusNotSatisfied TD(3,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(4,0/1/1)->PAR '69 86' TD(4,1/1/1)->PAR NoCurrentEF TD(4,2/1/1)->PAR Es ist kein EF ausgewählt
TR-> TD(5,0/1/1)->PAR '6A 82' TD(5,1/1/1)->PAR FileNotFound TD(5,2/1/1)->PAR Per shortFileIdentifier adressiertes EF nicht gefunden
TR-> TD(6,0/1/1)->PAR '6A 84' TD(6,1/1/1)->PAR DataTooBig TD(6,2/1/1)->PAR Parameter newData ragt über das Dateiende hinaus
PAR Hinweis CosH_cc5: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16165)<b>A_16165 - (N055.240) K_COS</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando WRITE BINARY verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.3.6.4)14.3.6.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N055.244.a)<b>G2_N055.244.a - (N055.244)a K_COS</b>
PAR Das COS MUSS die WRITE BINARY-Varianten aus (N055.205) und (N055.226) unterstützen. <b>[<=]</b>

REQ(ids=A_16166)<b>A_16166 - (N055.224)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere WRITE BINARY-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16167)<b>A_16167 - (N055.246)a K_COS</b>
PAR Wenn die APDU des WRITE BINARY-Kommandos einen shortFileIdentifier enthält, dann MUSS innerhalb von currentFolder.children nach einem EF mit diesem shortFileIdentifier gesucht werden. <b>[<=]</b>

REQ(ids=G2_N055.246.a.1)<b>G2_N055.246.a.1 - (N055.246)a.1 K_COS</b>
PAR Wenn die Suche erfolgreich verlief, dann MUSS<br>i.  affectedObject auf dieses EF gesetzt werden und<br>ii. currentEF auf dieses EF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N055.246.a.2)<b>G2_N055.246.a.2 - (N055.246)a.2 K_COS</b>
PAR Wenn die Suche nicht erfolgreich verlief, genau dann MUSS<br>i.  currentEF unverändert bleiben und<br>ii. das Kommando mit dem Trailer FileNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N055.246.b.1)<b>G2_N055.246.b.1 - (N055.246)b.1 K_COS</b>
PAR Wenn die APDU des WRITE BINARY-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) unbestimmt ist, genau dann MUSS das Kommando mit dem Trailer NoCurrentEF terminieren. <b>[<=]</b>

REQ(ids=G2_N055.246.b.2)<b>G2_N055.246.b.2 - (N055.246)b.2 K_COS</b>
PAR Wenn die APDU des WRITE BINARY-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N055.248)<b>G2_N055.248 - (N055.248) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N055.250)<b>G2_N055.250 - (N055.250) K_COS</b>
PAR Wenn affectedObject nicht vom Typ transparent EF ist, genau dann MUSS das Kommando mit dem Trailer WrongFileType terminieren. <b>[<=]</b>

REQ(ids=G2_N055.252)<b>G2_N055.252 - (N055.252) K_COS</b>
PAR Wenn (positionLogicalEndOfFile + OctetLength(newData)) größer als affectedObject.numberOfOctet ist, genau dann MUSS das Kommando mit dem Trailer DataTooBig terminieren. <b>[<=]</b>

REQ(ids=G2_N055.254.a)<b>G2_N055.254.a - (N055.254)a K_COS</b>
PAR Wenn affectedObject.flagTransactionMode den Wert True hat, genau dann MÜSSEN affectedObject.body und affectedObject.positionLogicalEndOfFile mit Transaktionsschutz geändert werden. Der Transaktionsschutz MUSS auch die Anpassung der Checksumme zu affectedObject.body umfassen, sofern diese vorhanden ist. <b>[<=]</b>

REQ(ids=A_16168)<b>A_16168 - (N055.254)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden für den Fall, dass affectedObject.flagTransactionMode den Wert False habe, würde affectedObject.body<br>1. mit Transaktionsschutz geändert, oder<br>2. ohne Transaktionsschutz geändert. <b>[<=]</b>

REQ(ids=A_16169)<b>A_16169 - (N055.256) K_COS</b>
PAR Wenn affectedObject.body durch eine Checksumme geschützt ist, dann MUSS das COS auf eine der in diesem Punkt genannten Arten reagieren: Eine Inkonsistenz zwischen dieser Checksumme und affectedObject.body<br>a. DARF NICHT zum Abbruch des Kommandos führen.<br>b. MUSS die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N055.258.a)<b>G2_N055.258.a - (N055.258)a K_COS</b>
PAR Die durch positionLogicalEndOfFile gekennzeichnete Stelle in affectedObject.body und die folgenden Oktette MÜSSEN durch newData ersetzt werden. <b>[<=]</b>

REQ(ids=G2_N055.258.b)<b>G2_N055.258.b - (N055.258)b K_COS</b>
PAR Das Attribut positionLogicalEndOfFile MUSS um OctetLength(newData) inkrementiert werden. <b>[<=]</b>

REQ(ids=A_16170)<b>A_16170 - (N055.258)c K_COS</b>
PAR Wenn affectedObject.body durch eine Checksumme geschützt ist, dann MUSS diese Checksumme auf einen Wert gesetzt werden, der konsistent zum geänderten Inhalt von affectedObject.body ist. <b>[<=]</b>

REQ(ids=A_16171)<b>A_16171 - (N055.260) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_16172)<b>A_16172 - (N055.262) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N055.264)<b>G2_N055.264 - (N055.264) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16173)<b>A_16173 - (N055.266) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>a. Die Priorität der Trailer in CosT_507 ist herstellerspezifisch.<br>b. Jeder Trailer in CosT_507 MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>c. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR (N055.268) Diese Anforderung ist absichtlich leer.
PAR (N055.270) Diese Anforderung ist absichtlich leer.
PAR -HEADING(ids=14.4)14.4 Zugriff auf strukturierte Daten
PAR Es ist möglich auf Listenelemente von recordList in strukturierten EF lesend (READ RECORD) oder schreibend (UPDATE RECORD) zuzugreifen. Zudem lassen sich neue Listenelemente anlegen (APPEND RECORD). Es ist möglich, ein Listenelement (DELETE RECORD) oder dessen Inhalt zu löschen (ERASE RECORD). Listenelemente lassen sich aktivieren (ACTIVATE RECORD) und deaktivieren (DEACTIVATE RECORD), was sich auf die Nutzung des Rekordinhaltes auswirkt. Des Weiteren ist es möglich, in der Liste nach Elementen zu suchen, deren Inhalt zu einem frei wählbaren Suchmuster passt (SEARCH RECORD).
PAR Die Kommandos in diesem Unterkapitel unterstützen zwei Varianten:

ORDERED-LIST->
LITEM->PAR Variante ohne shortFileIdentifier: Diese Variante ist dadurch gekennzeichnet, dass für eine erfolgreiche Kommandoabarbeitung currentEF notwendigerweise ein strukturiertes EF ist. Die Variable currentEF lässt sich unter anderem durch gewisse Varianten des SELECT-Kommandos setzen.LITEM->PAR Variante mit shortFileIdentifier: Diese Variante ist dadurch gekennzeichnet, dass das vom Kommando betroffene EF erst während der Kommandoabarbeitung gesetzt wird. Ein vorausgehendes SELECT-Kommando ist also nicht notwendig. In der Variante mit shortFileIdentifier lassen sich keine Dateien addressieren, die nicht currentFolder zugeordnet sind.
PAR -HEADING(ids=14.4.1)14.4.1 CosK_18e ACTIVATE RECORD
PAR Das Kommando ACTIVATE RECORD aktiviert ein oder mehrere Listenelemente aus recordList eines strukturierten EF. Das betroffene strukturierte EF wird vor der Operation ausgewählt. Dies geschieht entweder vor dem Senden dieses ACTIVATE RECORD-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier), oder innerhalb dieses ACTIVATE RECORD-Kommandos, falls diesem ein shortFileIdentifier als Parameter mitgeliefert wurde. Welche Listenelemente aktiviert werden, bestimmen Rekordnummer und Modus, welche als Parameter in der Kommandonachricht enthalten sind.
PAR -HEADING(ids=14.4.1.1)14.4.1.1 CosK_916 Use Case Aktivieren eines Rekords ohne shortFileIdentifier
PAR In dieser Variante enthält die APDU des ACTIVATE RECORD-Kommandos zwei Parameter:
REQ(ids=A_16223)<b>A_16223 - (N055.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16224)<b>A_16224 - (N055.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode bestimmt die Art der Aktion. Für diesen Use Case MUSS mode = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_16225)<b>A_16225 - (N055.500) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_498 verwendet werden.
PAR (ids=Tabelle-168,-CosT_498)Tabelle 168, CosT_498: ACTIVATE RECORD, ein Rekord, ohne shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '08' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '04' TD(4,2/1/1)->PAR mode, Codierung '04' bedeutet "nutze Listenelement P1"
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.1.2)14.4.1.2 CosK_cba Use Case Aktivieren eines Rekords mit shortFileIdentifier
PAR In dieser Variante enthält die APDU des ACTIVATE RECORD-Kommandos drei Parameter:
REQ(ids=A_16226)<b>A_16226 - (N055.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter shortFileIdentifier wählt während der Kommandoabarbeitung ein EF aus. Der Wert von shortFileIdentifier MUSS aus dem in (N007.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16227)<b>A_16227 - (N055.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16228)<b>A_16228 - (N055.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode bestimmt die Art der Aktion. Für diesen Use Case MUSS mode = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_16229)<b>A_16229 - (N055.900) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_5ce verwendet werden.
PAR (ids=Tabelle-169,-CosT_5ce)Tabelle 169, CosT_5ce: ACTIVATE RECORD, ein Rekord, mit shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '08' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR 8 shortFileIdentifier + mode, das heißt (shortFileIdentifier << 3) + '04'<br>Codierung '04' bedeutet "nutze Listenelement P1"
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.1.3)14.4.1.3 CosK_f42 Use Case Aktivieren aller Rekords ab P1 ohne shortFileIdentifier
PAR In dieser Variante enthält die APDU des ACTIVATE RECORD-Kommandos zwei Parameter:
REQ(ids=A_16230)<b>A_16230 - (N056.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das erste betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16231)<b>A_16231 - (N056.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode bestimmt die Art der Aktion. Für diesen Use Case MUSS mode = '05' gewählt werden. <b>[<=]</b>

REQ(ids=A_16232)<b>A_16232 - (N056.200) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_ff2 verwendet werden.
PAR (ids=Tabelle-170,-CosT_ff2)Tabelle 170, CosT_ff2: ACTIVATE RECORD, alle Rekords ab P1, ohne shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '08' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '05' TD(4,2/1/1)->PAR mode, Codierung '05' bedeutet "nutze Listenelemente ab P1"
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.1.4)14.4.1.4 CosK_a69 Use Case Aktivieren aller Rekords ab P1 mit shortFileIdentifier
PAR In dieser Variante enthält die APDU des ACTIVATE RECORD-Kommandos drei Parameter:
REQ(ids=A_16233)<b>A_16233 - (N056.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter shortFileIdentifier wählt während der Kommandoabarbeitung ein EF aus. Der Wert von shortFileIdentifier MUSS aus dem in (N007.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16234)<b>A_16234 - (N056.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das erste betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16235)<b>A_16235 - (N056.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode bestimmt die Art der Aktion. Für diesen Use Case MUSS mode = '05' gewählt werden. <b>[<=]</b>

REQ(ids=A_16236)<b>A_16236 - (N056.600) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_7b6 verwendet werden.
PAR (ids=Tabelle-171,-CosT_7b6)Tabelle 171, CosT_7b6: ACTIVATE RECORD, alle Rekords ab P1, mit shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '08' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR 8 shortFileIdentifier + mode, das heißt (shortFileIdentifier << 3) + '05'<br>Codierung '05' bedeutet "nutze Listenelemente ab P1"
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.1.5)14.4.1.5 Antwort der Karte auf Aktivieren von Rekords
PAR (ids=Tabelle-172,-CosT_066)Tabelle 172, CosT_066: ACTIVATE RECORD Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiche Aktivierung
PAR (ids=Tabelle-173,-CosT_180)Tabelle 173, CosT_180: ACTIVATE RECORD Antwort-APDU im Fehlerfall

TABLE(rows=8,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 81' TD(2,1/1/1)->PAR WrongFileType TD(2,2/1/1)->PAR Ausgewähltes EF ist nicht strukturiert
TR-> TD(3,0/1/1)->PAR '69 82' TD(3,1/1/1)->PAR SecurityStatusNotSatisfied TD(3,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(4,0/1/1)->PAR '69 85' TD(4,1/1/1)->PAR NoRecordLifeCycleStatus TD(4,2/1/1)->PAR Rekords in ausgewähltem EF besitzen keinen LCS
TR-> TD(5,0/1/1)->PAR '69 86' TD(5,1/1/1)->PAR NoCurrentEF TD(5,2/1/1)->PAR Es ist kein EF ausgewählt
TR-> TD(6,0/1/1)->PAR '6A 82' TD(6,1/1/1)->PAR FileNotFound TD(6,2/1/1)->PAR Per shortFileIdentifier adressiertes EF nicht gefunden
TR-> TD(7,0/1/1)->PAR '6A 83' TD(7,1/1/1)->PAR RecordNotFound TD(7,2/1/1)->PAR Listenelement recordNumber existiert nicht
PAR Hinweis CosH_c79: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16237)<b>A_16237 - (N056.700) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando ACTIVATE RECORD verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.4.1.6)14.4.1.6 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N056.800.a)<b>G2_N056.800.a - (N056.800)a K_COS</b>
PAR Das COS MUSS die ACTIVATE RECORD-Varianten aus (N055.500), (N055.900), (N056.200) und (N056.600) unterstützen. <b>[<=]</b>

REQ(ids=A_16238)<b>A_16238 - (N056.800)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere ACTIVATE RECORD-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16239)<b>A_16239 - (N056.900)a K_COS</b>
PAR Wenn die APDU des ACTIVATE RECORD-Kommandos einen shortFileIdentifier enthält, dann MUSS innerhalb von currentFolder.children nach einem EF mit diesem shortFileIdentifier gesucht werden. <b>[<=]</b>

REQ(ids=G2_N056.900.a.1)<b>G2_N056.900.a.1 - (N056.900)a.1 K_COS</b>
PAR Wenn die Suche erfolgreich verlief, dann MUSS<br>i.  affectedObject auf dieses EF gesetzt werden und<br>ii. currentEF auf dieses EF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N056.900.a.2)<b>G2_N056.900.a.2 - (N056.900)a.2 K_COS</b>
PAR Wenn die Suche nicht erfolgreich verlief, genau dann MUSS<br>i.  currentEF unverändert bleiben und<br>ii. das Kommando mit dem Trailer FileNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N056.900.b.1)<b>G2_N056.900.b.1 - (N056.900)b.1 K_COS</b>
PAR Wenn die APDU des ACTIVATE RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) unbestimmt ist, genau dann MUSS das Kommando mit dem Trailer NoCurrentEF terminieren. <b>[<=]</b>

REQ(ids=G2_N056.900.b.2)<b>G2_N056.900.b.2 - (N056.900)b.2 K_COS</b>
PAR Wenn die APDU des ACTIVATE RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N057.000)<b>G2_N057.000 - (N057.000) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N057.100)<b>G2_N057.100 - (N057.100) K_COS</b>
PAR Wenn affectedObject nicht vom Typ strukturiertes EF ist, genau dann MUSS das Kommando mit dem Trailer WrongFileType terminieren. <b>[<=]</b>

REQ(ids=G2_N057.200)<b>G2_N057.200 - (N057.200) K_COS</b>
PAR Wenn affectedObject.flagRecordLifeCycleStatus den Wert False besitzt, genau dann MUSS das Kommando mit dem Trailer NoRecordLifeCycleStatus terminieren. <b>[<=]</b>

REQ(ids=G2_N057.300)<b>G2_N057.300 - (N057.300) K_COS</b>
PAR Wenn recordNumber größer als die Anzahl der Listenelemente in affectedObject.recordList ist, genau dann MUSS das Kommando mit dem Trailer RecordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N057.400.a)<b>G2_N057.400.a - (N057.400)a K_COS</b>
PAR Wenn affectedObject.flagTransactionMode den Wert True hat, genau dann MUSS der lifecycleStatus mit Transaktionsschutz geändert werden. <b>[<=]</b>

REQ(ids=A_16240)<b>A_16240 - (N057.400)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden für den Fall, dass affectedObject.flagTransactionMode den Wert False habe, würde der lifecycleStatus<br>1. mit Transaktionsschutz geändert, oder<br>2. ohne Transaktionsschutz geändert. <b>[<=]</b>

REQ(ids=G2_N057.500)<b>G2_N057.500 - (N057.500) K_COS</b>
PAR Wenn mode = '04' ist und der physikalische Wert von lifeCycleStatus des durch recordNumber adressierten record in affectedObject.recordList bereits den Wert "Operational state (active)" besitzt, dann MUSS als Trailer NoError verwendet werden. <b>[<=]</b>

REQ(ids=A_16241)<b>A_16241 - (N057.600) K_COS</b>
PAR Die physikalischen Werte von lifeCycleStatus der durch recordNumber und mode adressierten record in affectedObject.recordList MÜSSEN auf den Wert "Operational state (active)" gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N057.600.a)<b>G2_N057.600.a - (N057.600)a K_COS</b>
PAR Wenn mode den Wert '04' besitzt, dann DARF NUR nur das durch recordNumber adressierte Listenelement betroffen sein. <b>[<=]</b>

REQ(ids=G2_N057.600.b)<b>G2_N057.600.b - (N057.600)b K_COS</b>
PAR Wenn mode den Wert '05' besitzt, dann MUSS das durch recordNumber adressierte Listenelement und alle folgenden betroffen sein. <b>[<=]</b>

REQ(ids=A_16242)<b>A_16242 - (N057.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_16244)<b>A_16244 - (N058.000)a K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>1.  entweder als Trailer MemoryFailureverwendet werden,<br>2. oder die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N058.000.b)<b>G2_N058.000.b - (N058.000)b K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16245)<b>A_16245 - (N058.000)c</b>
PAR Für die Priorität der Trailer gilt:<br>1. Die Priorität der Trailer in CosT_180 ist herstellerspezifisch.<br>2. Jeder Trailer in CosT_180 MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>3. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR (N058.100) Diese Anforderung ist absichtlich leer.
PAR (N058.200) Diese Anforderung ist absichtlich leer.
PAR -HEADING(ids=14.4.2)14.4.2 CosK_b11 APPEND RECORD
PAR Das Kommando APPEND RECORD fügt ein neues Listenelement an recordList eines strukturierten EF an, wobei die Daten für den Oktettstring des neuen Listenelementes im Datenfeld der Kommandonachricht enthalten sind. Das betroffene strukturierte EF wird vor der Operation ausgewählt. Dies geschieht entweder vor dem Senden dieses APPEND RECORD-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier), oder innerhalb dieses APPEND RECORD-Kommandos, falls diesem ein shortFileIdentifier als Parameter mitgeliefert wurde.
PAR -HEADING(ids=14.4.2.1)14.4.2.1 CosK_5b8 Use Case Anlegen neuer Rekord, ohne shortFileIdentifier
PAR Diese Variante stellt entweder das Ende einer Kommandokette dar, oder das einzige Kommando einer "Kette". Die APDU des APPEND RECORD-Kommandos enthält einen Parameter:
REQ(ids=A_16247)<b>A_16247 - (N058.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordData enthält die Daten des neuen Rekords. Der Parameter recordData ist ein Oktettstring mit beliebigem Inhalt. Die Länge von recordData MUSS aus dem in (N007.700)a definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16248)<b>A_16248 - (N058.400) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_74c verwendet werden.
PAR (ids=Tabelle-174,-CosT_74c)Tabelle 174, CosT_74c: APPEND RECORD, ohne shortFileIdentifier

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'E2' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR Parameter ohne Bedeutung
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR Parameter ohne Bedeutung
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR recordData
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.2.2)14.4.2.2 CosK_932 Use Case Anlegen neuer Rekords, mit shortFileIdentifier
PAR Diese Variante stellt entweder das Ende einer Kommandokette dar, oder das einzige Kommando einer "Kette". Die APDU des APPEND RECORD-Kommandos enthält zwei Parameter:
REQ(ids=A_16249)<b>A_16249 - (N058.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter shortFileIdentifier wählt während der Kommandoabarbeitung ein EF aus. Der Wert von shortFileIdentifier MUSS aus dem in (N007.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16250)<b>A_16250 - (N058.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordData enthält die Daten des neuen Rekords. Der Parameter recordData ist ein Oktettstring mit beliebigem Inhalt. Die Länge von recordData MUSS aus dem in (N007.700)a definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16251)<b>A_16251 - (N058.700) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_057 verwendet werden.
PAR (ids=Tabelle-175,-CosT_057)Tabelle 175, CosT_057: APPEND RECORD, mit shortFileIdentifier

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'E2' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR Parameter ohne Bedeutung
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR 8 shortFileIdentifier, das heißt shortFileIdentifier << 3
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR recordData
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.2.3)14.4.2.3 Antwort der Karte auf Anlegen eines neuen Rekords
PAR (ids=Tabelle-176,-CosT_71a)Tabelle 176, CosT_71a: APPEND RECORD Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiches Hinzufügen eines Rekords
PAR (ids=Tabelle-177,-CosT_8cd)Tabelle 177, CosT_8cd: APPEND RECORD Antwort-APDU im Fehlerfall

TABLE(rows=9,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '67 00' TD(2,1/1/1)->PAR WrongRecordLength TD(2,2/1/1)->PAR recordData hat nicht die richtige Länge
TR-> TD(3,0/1/1)->PAR '69 81' TD(3,1/1/1)->PAR WrongFileType TD(3,2/1/1)->PAR Ausgewähltes EF ist nicht strukturiert
TR-> TD(4,0/1/1)->PAR '69 82' TD(4,1/1/1)->PAR SecurityStatusNotSatisfied TD(4,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(5,0/1/1)->PAR '69 86' TD(5,1/1/1)->PAR NoCurrentEF TD(5,2/1/1)->PAR Es ist kein EF ausgewählt
TR-> TD(6,0/1/1)->PAR '6A 82' TD(6,1/1/1)->PAR FileNotFound TD(6,2/1/1)->PAR Per shortFileIdentifier adressiertes EF nicht gefunden
TR-> TD(7,0/1/1)->PAR '6A 84' TD(7,1/1/1)->PAR FullRecordList TD(7,2/1/1)->PAR Rekordliste lässt keine weiteren Elemente zu
TR-> TD(8,0/1/1)->PAR '6A 84' TD(8,1/1/1)->PAR OutOfMemory TD(8,2/1/1)->PAR Zu viele Oktette in recordData
PAR Hinweis CosH_5a5: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16252)<b>A_16252 - (N058.800) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando APPEND RECORD verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.4.2.4)14.4.2.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N058.900.a)<b>G2_N058.900.a - (N058.900)a K_COS</b>
PAR Das COS MUSS die APPEND RECORD-Varianten aus (N058.400) und (N058.700) unterstützen. <b>[<=]</b>

REQ(ids=A_16253)<b>A_16253 - (N058.900)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere APPEND RECORD-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16254)<b>A_16254 - (N059.000)a K_COS</b>
PAR Wenn die APDU des APPEND RECORD-Kommandos einen shortFileIdentifier enthält, dann MUSS innerhalb von currentFolder.children nach einem EF mit diesem shortFileIdentifier gesucht werden. <b>[<=]</b>

REQ(ids=G2_N059.000.a.1)<b>G2_N059.000.a.1 - (N059.000)a.1 K_COS</b>
PAR Wenn die Suche erfolgreich verlief, dann MUSS<br>i.  affectedObject auf dieses EF gesetzt werden und<br>ii. currentEF auf dieses EF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N059.000.a.2)<b>G2_N059.000.a.2 - (N059.000)a.2 K_COS</b>
PAR Wenn die Suche nicht erfolgreich verlief, genau dann MUSS<br>i.  currentEF unverändert bleiben und<br>ii. das Kommando mit dem Trailer FileNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N059.000.b.1)<b>G2_N059.000.b.1 - (N059.000)b.1 K_COS</b>
PAR Wenn die APDU des APPEND RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) unbestimmt ist, genau dann MUSS das Kommando mit dem Trailer NoCurrentEF terminieren. <b>[<=]</b>

REQ(ids=G2_N059.000.b.2)<b>G2_N059.000.b.2 - (N059.000)b.2 K_COS</b>
PAR Wenn die APDU des APPEND RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N059.100)<b>G2_N059.100 - (N059.100) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N059.200)<b>G2_N059.200 - (N059.200) K_COS</b>
PAR Wenn affectedObject nicht vom Typ strukturiertes EF ist, genau dann MUSS das Kommando mit dem Trailer WrongFileType terminieren. <b>[<=]</b>

PAR (N059.300) Diese Anforderung ist absichtlich leer.
REQ(ids=G2_N059.400)<b>G2_N059.400 - (N059.400) K_COS</b>
PAR Wenn die Anzahl der Listenelemente in affectedObject.recordList gleich affectedObject.maximumNumberOfRecords ist und affectedObject vom Typ linear fixes EF oder linear variables EF ist, genau dann MUSS das Kommando mit dem Trailer FullRecordList terminieren. <b>[<=]</b>

PAR (N059.500) Diese Anforderung ist absichtlich leer.
PAR (N059.600) Diese Anforderung ist absichtlich leer.
REQ(ids=A_16255)<b>A_16255 - (N059.650) K_COS</b>
PAR Das COS MUSS folgende Schritte ausführen: <b>[<=]</b>

REQ(ids=A_16256)<b>A_16256 - (N059.650)a K_COS</b>
PAR Schritt 1: Das COS MUSS die Anzahl der Oktette in recordData mit affectedObject.maximumRecordLength vergleichen. <b>[<=]</b>

REQ(ids=G2_N059.650.a.1)<b>G2_N059.650.a.1 - (N059.650)a.1 K_COS</b>
PAR Wenn affectedObject vom Typ linear fixes EF ist und die Anzahl Oktette in recordData ungleich affectedObject.maximumRecordLength ist, dann MUSS das Kommando mit dem Trailer WrongRecordLength terminieren. <b>[<=]</b>

REQ(ids=G2_N059.650.a.2)<b>G2_N059.650.a.2 - (N059.650)a.2 K_COS</b>
PAR Wenn affectedObject vom Typ zyklisches EF ist und die Anzahl Oktette in recordData ungleich affectedObject.maximumRecordLength ist, dann MUSS das Kommando mit dem Trailer WrongRecordLength terminieren. <b>[<=]</b>

REQ(ids=G2_N059.650.a.3.i)<b>G2_N059.650.a.3.i - (N059.650)a.3.i</b>
PAR Wenn affectedObject vom Typ linear variables EF ist und die Anzahl Oktette in recordData größer als affectedObject.maximumRecordLength ist, dann MUSS das Kommando mit dem Trailer WrongRecordLength terminieren. <b>[<=]</b>

REQ(ids=G2_N059.650.a.3.ii)<b>G2_N059.650.a.3.ii - (N059.650)a.3.ii K_COS</b>
PAR Wenn affectedObject vom Typ linear variables EF ist die Anzahl Oktette in den Oktettstrings aller record von recordList nach durchgeführter Listenerweiterung größer als affectedObject.numberOfOctet wäre, genau dann MUSS das Kommando mit dem Trailer OutOfMemory terminieren. <b>[<=]</b>

REQ(ids=A_16257)<b>A_16257 - (N059.650)b K_COS</b>
PAR Schritt 2: Das COS MUSS die Art des Transaktionsschutzes festlegen. <b>[<=]</b>

REQ(ids=G2_N059.650.b.1)<b>G2_N059.650.b.1 - (N059.650)b.1 K_COS</b>
PAR Wenn affectedObject.flagTransactionMode den Wert True hat, dann MUSS affectedObject.recordList mit Transaktionsschutz geändert werden. Der Transaktionsschutz MUSS auch die Anpassung der Checksumme zu affectedObject.recordList oder der Checksumme des neu angelegten Rekords umfassen, sofern diese vorhanden sind. <b>[<=]</b>

REQ(ids=A_16258)<b>A_16258 - (N059.650)b.2 K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden für den Fall, dass affectedObject.flagTransactionMode den Wert False habe, würde affectedObject.recordList oder Checksumme<br>i.  mit Transaktionsschutz geändert, oder<br>ii. ohne Transaktionsschutz geändert. <b>[<=]</b>

REQ(ids=A_16259)<b>A_16259 - (N059.650)c K_COS</b>
PAR Schritt 3: Wenn affectedObject.recordList durch eine Checksumme geschützt ist, dann MUSS das COS auf eine der in diesem Punkt genannten Arten reagieren: Eine Inkonsistenz zwischen dieser Checksumme und affectedObject.recordList<br>1. DARF NICHT zum Abbruch des Kommandos führen.<br>2. MUSS die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=A_16263)<b>A_16263 - (N059.650)d K_COS</b>
PAR Schritt 4: Das COS MUSS affectedObject.recordList wie folgt einen neuen Eintrag hinzufügen: <b>[<=]</b>

REQ(ids=G2_N059.650.d.1)<b>G2_N059.650.d.1 - (N059.650)d.1 K_COS</b>
PAR Wenn affectedObject vom Typ linear fixes EF oder linear variables EF ist, dann wird ein neuer Rekord an das Ende von affectedObject.recordList angehängt. <b>[<=]</b>

REQ(ids=G2_N059.650.d.2)<b>G2_N059.650.d.2 - (N059.650)d.2 K_COS</b>
PAR Wenn affectedObject vom Typ zyklische EF ist, dann wird ein neuer Rekord am Anfang von affectedObject.recordList eingefügt. Wenn dadurch die Anzahl der Listenelemente größer als affectedObject.maximumNumberOfRecords wird, genau dann MUSS das letzte Element in affectedObject.recordList gelöscht werden. <b>[<=]</b>

REQ(ids=G2_N059.650.e)<b>G2_N059.650.e - (N059.650)e K_COS</b>
PAR Schritt 5: Wenn affectedObject.recordList durch eine Checksumme geschützt ist, dann MUSS das COS diese Checksumme auf einen Wert setzen, der konsistent zum geänderten Inhalt von affectedObject.recordList ist. <b>[<=]</b>

REQ(ids=G2_N059.650.f)<b>G2_N059.650.f - (N059.650)f K_COS</b>
PAR Schritt 6: Wenn der neu angelegte record in affectedObject.recordList durch eine Checksumme geschützt ist, dann MUSS das COS dessen Checksumme auf einen Wert setzen, der konsistent zum Inhalt des neuen Rekords ist. <b>[<=]</b>

REQ(ids=G2_N059.650.g)<b>G2_N059.650.g - (N059.650.)g K_COS</b>
PAR Schritt 7: Als Oktettstring des neuen Rekords MUSS recordData verwendet werden. <b>[<=]</b>

REQ(ids=G2_N059.650.h)<b>G2_N059.650.h - (N059.650)h K_COS</b>
PAR Schritt 8: Wenn affectedObject.flagRecordLifeCycleStatus den Wert True besitzt, dann MUSS der physikalische Wert des lifeCycleStatus des neuen Rekords auf "Operational state (active)" gesetzt werden. <b>[<=]</b>

PAR (N059.700) Diese Anforderung ist absichtlich leer.
PAR (N059.800) Diese Anforderung ist absichtlich leer.
REQ(ids=A_16264)<b>A_16264 - (N059.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_16265)<b>A_16265 - (N060.000) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>1.  entweder als Trailer MemoryFailureverwendet werden,<br>2. oder die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N060.100)<b>G2_N060.100 - (N060.100) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16266)<b>A_16266 - (N060.200) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>1. Die Priorität der Trailer in CosT_8cd ist herstellerspezifisch.<br>2. Jeder Trailer in CosT_8cd MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>3. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR (N060.300) Diese Anforderung ist absichtlich leer.
PAR (N060.400) Diese Anforderung ist absichtlich leer.
PAR -HEADING(ids=14.4.3)14.4.3 CosK_419 DEACTIVATE RECORD
PAR Das Kommando DEACTIVATE RECORD deaktiviert ein oder mehrere Listenelemente aus recordList eines strukturierten EF. Das betroffene strukturierte EF wird vor der Operation ausgewählt. Dies geschieht entweder vor dem Senden dieses DEACTIVATE RECORD-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier), oder innerhalb dieses DEACTIVATE RECORD-Kommandos, falls diesem ein shortFileIdentifier als Parameter mitgeliefert wurde. Welche Listenelemente deaktiviert werden, bestimmen Rekordnummer und Modus, welche als Parameter in der Kommandonachricht enthalten sind.
PAR -HEADING(ids=14.4.3.1)14.4.3.1 CosK_f16 Use Case Deaktivieren eines Rekords ohne shortFileIdentifier
PAR In dieser Variante enthält die APDU des DEACTIVATE RECORD-Kommandos zwei Parameter:
REQ(ids=A_16267)<b>A_16267 - (N060.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16268)<b>A_16268 - (N060.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode bestimmt die Art der Aktion. Für diesen Use Case MUSS mode = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_16269)<b>A_16269 - (N060.700) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_7b1 verwendet werden.
PAR (ids=Tabelle-178,-CosT_7b1)Tabelle 178, CosT_7b1: DEACTIVATE RECORD, ein Rekord, ohne shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '06' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '04' TD(4,2/1/1)->PAR mode, Codierung '04' bedeutet "nutze Listenelement P1"
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.3.2)14.4.3.2 CosK_0de Use Case Deaktivieren eines Rekords mit shortFileIdentifier
PAR In dieser Variante enthält die APDU des DEACTIVATE RECORD-Kommandos drei Parameter:
REQ(ids=A_16270)<b>A_16270 - (N060.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter shortFileIdentifier wählt während der Kommandoabarbeitung ein EF aus. Der Wert von shortFileIdentifier MUSS aus dem in (N007.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16271)<b>A_16271 - (N060.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16272)<b>A_16272 - (N061.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode bestimmt die Art der Aktion. Für diesen Use Case MUSS mode = '04' gewählt werden. <b>[<=]</b>

REQ(ids=A_16273)<b>A_16273 - (N061.100) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_869 verwendet werden.
PAR (ids=Tabelle-179,-CosT_869)Tabelle 179, CosT_869: DEACTIVATE RECORD, ein Rekord, mit shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '06' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR 8 shortFileIdentifier + mode, das heißt (shortFileIdentifier << 3) + '04'<br>Codierung '04' bedeutet "nutze Listenelement P1"
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.3.3)14.4.3.3 CosK_a61 Use Case Deaktivieren aller Rekords ab P1 ohne shortFileIdentifier
PAR In dieser Variante enthält die APDU des DEACTIVATE RECORD-Kommandos zwei Parameter:
REQ(ids=A_16274)<b>A_16274 - (N061.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das erste betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16275)<b>A_16275 - (N061.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode bestimmt die Art der Aktion. Für diesen Use Case MUSS mode = '05' gewählt werden. <b>[<=]</b>

REQ(ids=A_16276)<b>A_16276 - (N061.400) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_f8e verwendet werden.
PAR (ids=Tabelle-180,-CosT_f8e)Tabelle 180, CosT_f8e: DEACTIVATE RECORD, alle Rekords ab P1, ohne shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '06' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '05' TD(4,2/1/1)->PAR mode, Codierung '05' bedeutet "nutze Listenelemente ab P1"
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.3.4)14.4.3.4 CosK_13e Use Case Deaktivieren aller Rekords ab P1 mit shortFileIdentifier
PAR In dieser Variante enthält die APDU des DEACTIVATE RECORD-Kommandos drei Parameter:
REQ(ids=A_16277)<b>A_16277 - (N061.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter shortFileIdentifier wählt während der Kommandoabarbeitung ein EF aus. Der Wert von shortFileIdentifier MUSS aus dem in (N007.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16278)<b>A_16278 - (N061.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das erste betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16279)<b>A_16279 - (N061.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter mode bestimmt die Art der Aktion. Für diesen Use Case MUSS mode = '05' gewählt werden. <b>[<=]</b>

REQ(ids=A_16280)<b>A_16280 - (N061.800) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_9ec verwendet werden.
PAR (ids=Tabelle-181,-CosT_9ec)Tabelle 181, CosT_9ec: DEACTIVATE RECORD, alle Rekords ab P1, mit shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '06' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR 8 shortFileIdentifier + mode, das heißt (shortFileIdentifier << 3) + '05'<br>Codierung '05' bedeutet "nutze Listenelemente ab P1"
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.3.5)14.4.3.5 Antwort der Karte auf Deaktivieren von Rekords
PAR (ids=Tabelle-182,-CosT_453)Tabelle 182, CosT_453: DEACTIVATE RECORD Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiches Deaktivieren
PAR (ids=Tabelle-183,-CosT_563)Tabelle 183, CosT_563: DEACTIVATE RECORD Antwort-APDU im Fehlerfall

TABLE(rows=8,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 81' TD(2,1/1/1)->PAR WrongFileType TD(2,2/1/1)->PAR Ausgewähltes EF ist nicht strukturiert
TR-> TD(3,0/1/1)->PAR '69 82' TD(3,1/1/1)->PAR SecurityStatusNotSatisfied TD(3,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(4,0/1/1)->PAR '69 85' TD(4,1/1/1)->PAR NoRecordLifeCycleStatus TD(4,2/1/1)->PAR Rekords in ausgewähltem EF besitzen keinen LCS
TR-> TD(5,0/1/1)->PAR '69 86' TD(5,1/1/1)->PAR NoCurrentEF TD(5,2/1/1)->PAR Es ist kein EF ausgewählt
TR-> TD(6,0/1/1)->PAR '6A 82' TD(6,1/1/1)->PAR FileNotFound TD(6,2/1/1)->PAR Per shortFileIdentifier adressiertes EF nicht gefunden
TR-> TD(7,0/1/1)->PAR '6A 83' TD(7,1/1/1)->PAR RecordNotFound TD(7,2/1/1)->PAR Listenelement recordNumber existiert nicht
PAR Hinweis CosH_648: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16281)<b>A_16281 - (N061.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando DEACTIVATE RECORD verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.4.3.6)14.4.3.6 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N062.000.a)<b>G2_N062.000.a - (N062.000)a K_COS</b>
PAR Das COS MUSS die DEACTIVATE RECORD-Varianten aus (N060.700), (N061.100), (N061.400) und (N061.800) unterstützen. <b>[<=]</b>

REQ(ids=A_16282)<b>A_16282 - (N062.000)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere DEACTIVATE RECORD-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16283)<b>A_16283 - (N062.100)a K_COS</b>
PAR Wenn die APDU des DEACTIVATE RECORD-Kommandos einen shortFileIdentifier enthält, genau dann MUSS innerhalb von currentFolder.children nach einem EF mit diesem shortFileIdentifier gesucht werden. <b>[<=]</b>

REQ(ids=G2_N062.100.a.1)<b>G2_N062.100.a.1 - (N062.100)a.1 K_COS</b>
PAR Wenn die Suche erfolgreich verlief, dann MUSS<br>i.  affectedObject auf dieses EF gesetzt werden und<br>ii. currentEF auf dieses EF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N062.100.a.2)<b>G2_N062.100.a.2 - (N062.100)a.2 K_COS</b>
PAR Wenn die Suche nicht erfolgreich verlief, genau dann MUSS<br>i.  currentEF unverändert bleiben und<br>ii. das Kommando mit dem Trailer FileNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N062.100.b.1)<b>G2_N062.100.b.1 - (N062.100)b.1 K_COS</b>
PAR Wenn die APDU des DEACTIVATE RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) unbestimmt ist, genau dann MUSS das Kommando mit dem Trailer NoCurrentEF terminieren. <b>[<=]</b>

REQ(ids=G2_N062.100.b.2)<b>G2_N062.100.b.2 - (N062.100)b.2 K_COS</b>
PAR Wenn die APDU des DEACTIVATE RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N062.200)<b>G2_N062.200 - (N062.200) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N062.300)<b>G2_N062.300 - (N062.300) K_COS</b>
PAR Wenn affectedObject nicht vom Typ strukturiertes EF ist, genau dann MUSS das Kommando mit dem Trailer WrongFileType terminieren. <b>[<=]</b>

REQ(ids=G2_N062.400)<b>G2_N062.400 - (N062.400) K_COS</b>
PAR Wenn affectedObject.flagRecordLifeCycleStatus den Wert False besitzt, genau dann MUSS das Kommando mit dem Trailer NoRecordLifeCycleStatus terminieren. <b>[<=]</b>

REQ(ids=G2_N062.500)<b>G2_N062.500 - (N062.500) K_COS</b>
PAR Wenn recordNumber größer als die Anzahl der Listenelemente in affectedObject.recordList ist, genau dann MUSS das Kommando mit dem Trailer RecordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N062.600.a)<b>G2_N062.600.a - (N062.600)a K_COS</b>
PAR Wenn affectedObject.flagTransactionMode den Wert True hat, dann MUSS der lifecycleStatus mit Transaktionsschutz geändert werden. <b>[<=]</b>

REQ(ids=A_16284)<b>A_16284 - (N062.600)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden für den Fall, dass affectedObject.flagTransactionMode den Wert False habe, würde der lifecycleStatus<br>1. mit Transaktionsschutz geändert, oder<br>2. ohne Transaktionsschutz geändert. <b>[<=]</b>

REQ(ids=G2_N062.700)<b>G2_N062.700 - (N062.700) K_COS</b>
PAR Wenn mode = '04' ist und der physikalische Wert von lifeCycleStatus des durch recordNumber adressierten record in affectedObject.recordList bereits den Wert "Operational state (deactivated)" besitzt, dann MUSS als Trailer NoError verwendet werden. <b>[<=]</b>

REQ(ids=A_16285)<b>A_16285 - (N062.800) K_COS</b>
PAR Die physikalischen Werte von lifeCycleStatus der durch recordNumber und mode adressierten record in affectedObject.recordList MÜSSEN auf den Wert "Operational state (deactivated)" gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N062.800.a)<b>G2_N062.800.a - (N062.800)a K_COS</b>
PAR Wenn mode den Wert '04' besitzt, dann DARF NUR nur das durch recordNumber adressierte Listenelement betroffen sein. <b>[<=]</b>

REQ(ids=G2_N062.800.b)<b>G2_N062.800.b - (N062.800)b K_COS</b>
PAR Wenn mode den Wert '05' besitzt, dann MUSS das durch recordNumber adressierte Listenelement und alle folgenden betroffen sein. <b>[<=]</b>

REQ(ids=A_16286)<b>A_16286 - (N062.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_16287)<b>A_16287 - (N063.000) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>1.  entweder als Trailer MemoryFailureverwendet werden,<br>2. oder die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N063.100)<b>G2_N063.100 - (N063.100) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16288)<b>A_16288 - (N063.200) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>1. Die Priorität der Trailer in CosT_563 ist herstellerspezifisch.<br>2. Jeder Trailer in CosT_563 MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>3. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR (N063.300) Diese Anforderung ist absichtlich leer.
PAR (N063.400) Diese Anforderung ist absichtlich leer.
PAR -HEADING(ids=14.4.4)14.4.4 CosK_e30 DELETE RECORD
PAR Das Kommando DELETE RECORD entfernt ein bereits vorhandenes Listenelemente aus recordList eines strukturierten EF. Das betroffene strukturierte EF wird vor der Operation ausgewählt. Dies geschieht entweder vor dem Senden dieses DELETE RECORD-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier), oder innerhalb dieses DELETE RECORD-Kommandos, falls diesem ein shortFileIdentifier als Parameter mitgeliefert wurde. Welches Listenelement betroffen ist, bestimmt die Rekordnummer, welche als Parameter in der Kommandonachricht enthalten ist.
PAR Hinweis CosH_5b3: Durch das Entfernen eines Elementes aus einer Liste ändert sich die Adressierung nachfolgender Listenelemente. Enthält beispielsweise eine strukturierte Datei eine Liste mit drei Rekords gemäß '01''02''03' wird ein READ RECORD-Kommando für Rekord zwei (Kommando APDU = '00B2020400') Listenelement 2 liefern (Response APDU = '029000'). Nach einem DELETE RECORD (Kommando APDU = '800C0204') enthält die Datei folgende Liste: '01''03'. Ein READ RECORD-Kommando für Rekord zwei liefert dann: '039000').
PAR -HEADING(ids=14.4.4.1)14.4.4.1 CosK_2cc Use Case Entfernen eines Rekords ohne shortFileIdentifier
PAR In dieser Variante wird ein Rekord aus der Liste recordList gelöscht und die betroffene Datei ist zuvor auszuwählen.
REQ(ids=A_16293)<b>A_16293 - (N063.420) K_externeWelt {K_Karte}</b>
PAR Die APDU des DELETE RECORD-Kommandos MUSS einen Parameter enthalten:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter recordNumber bestimmt das betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden.
PAR <b>[<=]</b>

REQ(ids=A_16294)<b>A_16294 - (N063.422) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_be4 verwendet werden.
PAR (ids=Tabelle-184,-CosT_be4)Tabelle 184, CosT_be4: DELETE RECORD, ohne shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '80' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4] wird hier "proprietary" angezeigt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '0C' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '04' TD(4,2/1/1)->PAR Codierung für "nutze Listenelement P1"
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.4.2)14.4.4.2 CosK_e1e Use Case Entfernen eines Rekords mit shortFileIdentifier
PAR In dieser Variante wird ein Rekord aus der Liste recordList gelöscht und die betroffene Datei wird im Kommanod adressiert.
REQ(ids=A_16295)<b>A_16295 - (N063.424) K_externeWelt {K_Karte}</b>
PAR Die APDU des DELETE RECORD-Kommandos MUSS zwei Parameter enthalten:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter shortFileIdentifier wählt während der Kommandoabarbeitung ein EF aus. Der Wert von shortFileIdentifier MUSS aus dem in (N007.000) definierten Bereich gewählt werden.LITEM->PAR Der Parameter recordNumber bestimmt das betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden.
PAR <b>[<=]</b>

REQ(ids=A_16296)<b>A_16296 - (N063.426) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_157 verwendet werden.
PAR (ids=Tabelle-185,-CosT_157)Tabelle 185, CosT_157: DELETE RECORD, mit shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '80' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4] wird hier "proprietary" angezeigt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '0C' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR 8 shortFileIdentifier + mode, das heißt (shortFileIdentifier << 3) + '04'<br>Codierung '04' bedeutet "nutze Listenelement P1"
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.4.3)14.4.4.3 Antwort der Karte auf Entfernen eines Rekords
PAR (ids=Tabelle-186,-CosT_fcd)Tabelle 186, CosT_fcd: DELETE RECORD Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiches Entfernen eines Rekords
PAR (ids=Tabelle-187,-CosT_91a)Tabelle 187, CosT_91a: DELETE RECORD Antwort-APDU im Fehlerfall

TABLE(rows=8,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '62 87' TD(1,1/1/1)->PAR RecordDeactivated TD(1,2/1/1)->PAR Adressierter Rekord ist deaktiviert
TR-> TD(2,0/1/1)->PAR '65 81' TD(2,1/1/1)->PAR MemoryFailure TD(2,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(3,0/1/1)->PAR '69 81' TD(3,1/1/1)->PAR WrongFileType TD(3,2/1/1)->PAR Ausgewähltes EF ist nicht strukturiert
TR-> TD(4,0/1/1)->PAR '69 82' TD(4,1/1/1)->PAR SecurityStatusNotSatisfied TD(4,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(5,0/1/1)->PAR '69 86' TD(5,1/1/1)->PAR NoCurrentEF TD(5,2/1/1)->PAR Es ist kein EF ausgewählt
TR-> TD(6,0/1/1)->PAR '6A 82' TD(6,1/1/1)->PAR FileNotFound TD(6,2/1/1)->PAR Per shortFileIdentifier adressiertes EF nicht gefunden
TR-> TD(7,0/1/1)->PAR '6A 83' TD(7,1/1/1)->PAR RecordNotFound TD(7,2/1/1)->PAR Listenelement recordNumber existiert nicht
PAR Hinweis CosH_684: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16297)<b>A_16297 - (N063.428) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando DELETE RECORD verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.4.4.4)14.4.4.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N063.430.a)<b>G2_N063.430.a - (N063.430)a K_COS</b>
PAR Das COS MUSS die DELETE RECORD-Varianten aus (N063.422) und (N063.426) unterstützen. <b>[<=]</b>

REQ(ids=A_16298)<b>A_16298 - (N063.430)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere DELETE RECORD-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16299)<b>A_16299 - (N063.432)a K_COS</b>
PAR Wenn die APDU des DELETE RECORD-Kommandos einen shortFileIdentifier enthält, dann MUSS innerhalb von currentFolder.children nach einem EF mit diesem shortFileIdentifier gesucht werden. <b>[<=]</b>

REQ(ids=G2_N063.432.a.1)<b>G2_N063.432.a.1 - (N063.432)a.1 K_COS</b>
PAR Wenn die Suche erfolgreich verlief, dann MUSS<br>i.  affectedObject auf dieses EF gesetzt werden und<br>ii. currentEF auf dieses EF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N063.432.a.2)<b>G2_N063.432.a.2 - (N063.432)a.2 K_COS</b>
PAR Wenn die Suche nicht erfolgreich verlief, genau dann MUSS<br>i.  currentEF unverändert bleiben und<br>ii. das Kommando mit dem Trailer FileNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N063.432.b.1)<b>G2_N063.432.b.1 - (N063.432)b.1 K_COS</b>
PAR Wenn die APDU des DELETE RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) unbestimmt ist, genau dann MUSS das Kommando mit dem Trailer NoCurrentEF terminieren. <b>[<=]</b>

REQ(ids=G2_N063.432.b.2)<b>G2_N063.432.b.2 - (N063.432)b.2 K_COS</b>
PAR Wenn die APDU des DELETE RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N063.434)<b>G2_N063.434 - (N063.434) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N063.436)<b>G2_N063.436 - (N063.436) K_COS</b>
PAR Wenn affectedObject nicht vom Typ strukturiertes EF ist, genau dann MUSS das Kommando mit dem Trailer WrongFileType terminieren. <b>[<=]</b>

REQ(ids=G2_N063.438)<b>G2_N063.438 - (N063.438) K_COS</b>
PAR Wenn recordNumber größer als die Anzahl der Listenelemente in affectedObject.recordList ist, genau dann MUSS das Kommando mit dem Trailer RecordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N063.440)<b>G2_N063.440 - (N063.440) K_COS</b>
PAR Wenn der physikalische Wert von lifeCycleStatus des adressierten record den Zustand "Operational state (deactivated)" hat, genau dann MUSS das Kommando mit dem Trailer RecordDeactivated terminieren. <b>[<=]</b>

REQ(ids=A_16300)<b>A_16300 - (N063.442) K_COS</b>
PAR Wenn affectedObject.recordList oder der durch recordNumber adressierte record in affectedObject.recordList durch eine Checksumme geschützt ist, dann MUSS das COS auf eine der in diesem Punkt genannten Arten reagieren: Eine Inkonsistenz zwischen dieser Checksumme und den Daten, die sie schützt,<br>1. DARF NICHT zum Abbruch des Kommandos führen.<br>2. MUSS die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N063.446.a)<b>G2_N063.446.a - (N063.446)a K_COS</b>
PAR Der durch recordNumber adressierte record MUSS mit Transaktionsschutz aus affectedObject.recordList entfernt werden. Der Transaktionsschutz MUSS auch die Anpassung der Checksumme zu affectedObject.recordList beinhalten, sofern eine solche vorhanden ist. <b>[<=]</b>

REQ(ids=A_16301)<b>A_16301 - (N063.446)b K_COS</b>
PAR Wenn affectedObject.recordList durch eine Checksumme geschützt ist, dann MUSS diese Checksumme auf einen Wert gesetzt werden, der konsistent zum geänderten Inhalt von affectedObject.recordList ist. <b>[<=]</b>

REQ(ids=A_16302)<b>A_16302 - (N063.448) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_16303)<b>A_16303 - (N063.450) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>1.  entweder als Trailer MemoryFailureverwendet werden,<br>2. oder die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N063.452)<b>G2_N063.452 - (N063.452) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16304)<b>A_16304 - (N063.454) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>1. Die Priorität der Trailer in CosT_91a ist herstellerspezifisch.<br>2. Jeder Trailer in CosT_91a MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>3. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.4.5)14.4.5 CosK_645 ERASE RECORD
PAR Das Kommando ERASE RECORD setzt jedes Oktett eines bereits vorhandenen Listenelementes in recordList eines strukturierten EF auf den Wert '00'. Das betroffene strukturierte EF wird vor der Operation ausgewählt. Dies geschieht entweder vor dem Senden dieses ERASE RECORD-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier), oder innerhalb dieses ERASE RECORD-Kommandos, falls diesem ein shortFileIdentifier als Parameter mitgeliefert wurde. Welches Listenelement betroffen ist, bestimmt die Rekordnummer, welche als Parameter in der Kommandonachricht enthalten ist.
PAR -HEADING(ids=14.4.5.1)14.4.5.1 CosK_e69 Use Case Löschen eines Rekordinhaltes ohne shortFileIdentifier
PAR In dieser Variante werden Daten in einem Rekord durch Oktette mit dem Wert '00' ersetzt und die betroffene Datei ist zuvor auszuwählen. Der Rekord selbst verbleibt in der Liste recordList. Die APDU des ERASE RECORD-Kommandos enthält einen Parameter:
REQ(ids=A_16305)<b>A_16305 - (N063.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16306)<b>A_16306 - (N063.600) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_e66 verwendet werden.
PAR (ids=Tabelle-188,-CosT_e66)Tabelle 188, CosT_e66: ERASE RECORD, ohne shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4], adressierter Rekord bleibt erhalten
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '0C' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '04' TD(4,2/1/1)->PAR Codierung für "nutze Listenelement P1"
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.5.2)14.4.5.2 CosK_1ec Use Case Löschen eines Rekordinhaltes mit shortFileIdentifier
PAR In dieser Variante werden Daten in einem Rekord durch Oktette mit dem Wert '00' ersetzt und die betroffene Datei wird im Kommanod adressiert. Der Rekord selbst verbleibt in der Liste recordList. Die APDU des ERASE RECORD-Kommandos enthält zwei Parameter:
REQ(ids=A_16307)<b>A_16307 - (N063.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter shortFileIdentifier wählt während der Kommandoabarbeitung ein EF aus. Der Wert von shortFileIdentifier MUSS aus dem in (N007.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16308)<b>A_16308 - (N063.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16309)<b>A_16309 - (N063.900) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_124 verwendet werden.
PAR (ids=Tabelle-189,-CosT_124)Tabelle 189, CosT_124: ERASE RECORD, mit shortFileIdentifier

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4], adressierter Rekord bleibt erhalten
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '0C' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR 8 shortFileIdentifier + mode, das heißt (shortFileIdentifier << 3) + '04'<br>Codierung '04' bedeutet "nutze Listenelement P1"
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.5.3)14.4.5.3 Antwort der Karte auf Löschen eines Rekordinhaltes
PAR (ids=Tabelle-190,-CosT_e14)Tabelle 190, CosT_e14: ERASE RECORD Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiches Löschen eines Rekordinhaltes
PAR (ids=Tabelle-191,-CosT_173)Tabelle 191, CosT_173: ERASE RECORD Antwort-APDU im Fehlerfall

TABLE(rows=8,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '62 87' TD(1,1/1/1)->PAR RecordDeactivated TD(1,2/1/1)->PAR Adressierter Rekord ist deaktiviert
TR-> TD(2,0/1/1)->PAR '65 81' TD(2,1/1/1)->PAR MemoryFailure TD(2,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(3,0/1/1)->PAR '69 81' TD(3,1/1/1)->PAR WrongFileType TD(3,2/1/1)->PAR Ausgewähltes EF ist nicht strukturiert
TR-> TD(4,0/1/1)->PAR '69 82' TD(4,1/1/1)->PAR SecurityStatusNotSatisfied TD(4,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(5,0/1/1)->PAR '69 86' TD(5,1/1/1)->PAR NoCurrentEF TD(5,2/1/1)->PAR Es ist kein EF ausgewählt
TR-> TD(6,0/1/1)->PAR '6A 82' TD(6,1/1/1)->PAR FileNotFound TD(6,2/1/1)->PAR Per shortFileIdentifier adressiertes EF nicht gefunden
TR-> TD(7,0/1/1)->PAR '6A 83' TD(7,1/1/1)->PAR RecordNotFound TD(7,2/1/1)->PAR Listenelement recordNumber existiert nicht
PAR Hinweis CosH_d9b: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16310)<b>A_16310 - (N064.000) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando ERASE RECORD verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.4.5.4)14.4.5.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N064.100.a)<b>G2_N064.100.a - (N064.100)a K_COS</b>
PAR Das COS MUSS die ERASE RECORD-Varianten aus (N063.600) und (N063.900) unterstützen. <b>[<=]</b>

REQ(ids=A_16311)<b>A_16311 - (N064.100)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere ERASE RECORD-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16312)<b>A_16312 - (N064.200)a K_COS</b>
PAR Wenn die APDU des ERASE RECORD-Kommandos einen shortFileIdentifier enthält, dann MUSS innerhalb von currentFolder.children nach einem EF mit diesem shortFileIdentifier gesucht werden. <b>[<=]</b>

REQ(ids=G2_N064.200.a.1)<b>G2_N064.200.a.1 - (N064.200)a.1 K_COS</b>
PAR Wenn die Suche erfolgreich verlief, dann MUSS<br>i.  affectedObject auf dieses EF gesetzt werden und<br>ii. currentEF auf dieses EF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N064.200.a.2)<b>G2_N064.200.a.2 - (N064.200)a.2 K_COS</b>
PAR Wenn die Suche nicht erfolgreich verlief, genau dann MUSS<br>i.  currentEF unverändert bleiben und<br>ii. das Kommando mit dem Trailer FileNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N064.200.b.1)<b>G2_N064.200.b.1 - (N064.200)b.1 K_COS</b>
PAR Wenn die APDU des ERASE RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) unbestimmt ist, genau dann MUSS das Kommando mit dem Trailer NoCurrentEF terminieren. <b>[<=]</b>

REQ(ids=G2_N064.200.b.2)<b>G2_N064.200.b.2 - (N064.200)b.2 K_COS</b>
PAR Wenn die APDU des ERASE RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N064.300)<b>G2_N064.300 - (N064.300) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N064.400)<b>G2_N064.400 - (N064.400) K_COS</b>
PAR Wenn affectedObject nicht vom Typ strukturiertes EF ist, genau dann MUSS das Kommando mit dem Trailer WrongFileType terminieren. <b>[<=]</b>

REQ(ids=G2_N064.500)<b>G2_N064.500 - (N064.500) K_COS</b>
PAR Wenn recordNumber größer als die Anzahl der Listenelemente in affectedObject.recordList ist, genau dann MUSS das Kommando mit dem Trailer RecordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N064.600)<b>G2_N064.600 - (N064.600) K_COS</b>
PAR Wenn der physikalische Wert von lifeCycleStatus des adressierten record den Zustand "Operational state (deactivated)" hat, genau dann MUSS das Kommando mit dem Trailer RecordDeactivated terminieren. <b>[<=]</b>

REQ(ids=A_16313)<b>A_16313 - (N064.700) K_COS</b>
PAR Das COS MUSS die Art des Transaktionsschutzes festlegen. <b>[<=]</b>

REQ(ids=G2_N064.700.a)<b>G2_N064.700.a - (N064.700)a K_COS</b>
PAR Wenn affectedObject.flagTransactionMode den Wert True hat, dann MUSS der Inhalt des adressierten Rekords mit Transaktionsschutz geändert werden. Der Transaktionsschutz MUSS auch die Anpassung der Checksumme zu affectedObject.recordList oder der Checksumme des durch recordNumber adressierten record in affectedObject.recordList umfassen, sofern diese vorhanden sind. <b>[<=]</b>

REQ(ids=A_16314)<b>A_16314 - (N064.700)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden für den Fall, dass affectedObject.flagTransactionMode den Wert False habe, würde affectedObject<br>1. mit Transaktionsschutz geändert, oder<br>2. ohne Transaktionsschutz geändert. <b>[<=]</b>

REQ(ids=A_16315)<b>A_16315 - (N064.710) K_COS</b>
PAR Falls affectedObject.recordList oder der durch recordNumber adressierte record in affectedObject.recordList durch eine Checksumme geschützt ist, dann MUSS das COS auf eine der in diesem Punkt genannten Arten reagieren: Eine Inkonsistenz zwischen dieser Checksumme und den Daten, die sie schützt,<br>a. DARF NICHT zum Kommandoabbruch führen.<br>b. MUSS die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=A_16316)<b>A_16316 - (N064.800) K_COS</b>
PAR Das COS MUSS den Rekordinhalt durch folgende Aktionen löschen: <b>[<=]</b>

REQ(ids=G2_N064.800.a)<b>G2_N064.800.a - (N064.800)a K_COS</b>
PAR Das COS MUSS alle Oktette im Oktettstring des durch recordNumber adressierten record in affectedObject.recordList auf den Wert '00' setzen. <b>[<=]</b>

REQ(ids=A_16317)<b>A_16317 - (N064.800)b K_COS</b>
PAR Wenn affectedObject.recordList durch eine Checksumme geschützt ist, dann MUSS diese Checksumme auf einen Wert gesetzt werden, der konsistent zum geänderten Inhalt von affectedObject.recordList ist. <b>[<=]</b>

REQ(ids=A_16318)<b>A_16318 - (N064.800)c K_COS</b>
PAR Wenn der durch recordNumber adressierte record in affectedObject.recordList durch eine Checksumme geschützt ist, dann MUSS dessen Checksumme auf einen Wert gesetzt werden, der konsistent zum neuen Inhalt von diesem Rekord ist. <b>[<=]</b>

REQ(ids=A_16319)<b>A_16319 - (N064.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_16320)<b>A_16320 - (N065.000) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>1.  entweder als Trailer MemoryFailureverwendet werden,<br>2. oder die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N065.100)<b>G2_N065.100 - (N065.100) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16321)<b>A_16321 - (N065.200) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>1. Die Priorität der Trailer in CosT_173 ist herstellerspezifisch.<br>2. Jeder Trailer in CosT_173 MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>3. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR (N065.300) Diese Anforderung ist absichtlich leer.
PAR (N065.400) Diese Anforderung ist absichtlich leer.
PAR -HEADING(ids=14.4.6)14.4.6 CosK_52e READ RECORD
PAR Das Kommando READ RECORD dient dem Auslesen (des Anfangs) eines Listenelementes aus recordList eines strukturierten EF. Das betroffene strukturierte EF wird vor der Leseoperation ausgewählt. Dies geschieht entweder vor dem Senden dieses READ RECORD-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier), oder innerhalb dieses READ RECORD-Kommandos, falls diesem ein shortFileIdentifier als Parameter mitgeliefert wurde. Welches Listenelement (oder dessen Anfang) ausgelesen wird, bestimmen Rekordnummer und Länge, die als Parameter in der Kommandonachricht enthalten sind.
PAR -HEADING(ids=14.4.6.1)14.4.6.1 CosK_751 Use Case Lesen ohne shortFileIdentifier in strukturierten EF
PAR In dieser Variante enthält die APDU des READ RECORD-Kommandos zwei Parameter:
REQ(ids=A_16324)<b>A_16324 - (N065.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16325)<b>A_16325 - (N065.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus dem in (N027.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16326)<b>A_16326 - (N065.700) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_dd7 verwendet werden.
PAR (ids=Tabelle-192,-CosT_dd7)Tabelle 192, CosT_dd7: READ RECORD ohne shortFileIdentifier

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'B2' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '04' TD(4,2/1/1)->PAR Codierung für "nutze Listenelement P1"
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR length TD(5,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.6.2)14.4.6.2 CosK_ebc Use Case Lesen mit shortFileIdentifier in strukturierten EF
PAR In dieser Variante enthält die APDU des READ RECORD-Kommandos drei Parameter:
REQ(ids=A_16327)<b>A_16327 - (N065.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter shortFileIdentifier wählt während der Kommandoabarbeitung ein EF aus. Der Wert von shortFileIdentifier MUSS aus dem in (N007.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16328)<b>A_16328 - (N065.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16329)<b>A_16329 - (N066.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus dem in (N027.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16330)<b>A_16330 - (N066.100) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_b99 verwendet werden.
PAR (ids=Tabelle-193,-CosT_b99)Tabelle 193, CosT_b99: READ RECORD mit shortFileIdentifier

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'B2' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR 8 shortFileIdentifier + mode, das heißt (shortFileIdentifier << 3) + '04'<br>Codierung '04' bedeutet "nutze Listenelement P1"
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR length TD(5,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.6.3)14.4.6.3 Antwort der Karte auf Lesen in strukturierten EF
PAR (ids=Tabelle-194,-CosT_bb0)Tabelle 194, CosT_bb0: READ RECORD Antwort-APDU im Erfolgsfall

TABLE(rows=6,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)-> TD(1,2/1/1)->PAR Ausgelesene Daten
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '62 81' TD(3,1/1/1)->PAR CorruptDataWarning TD(3,2/1/1)->PAR Möglicherweise sind die Antwortdaten korrupt
TR-> TD(4,0/1/1)->PAR '62 82' TD(4,1/1/1)->PAR EndOfRecordWarning TD(4,2/1/1)->PAR Mittels Ne mehr Daten angefordert, als vorhanden sind
TR-> TD(5,0/1/1)->PAR '90 00' TD(5,1/1/1)->PAR NoError TD(5,2/1/1)->PAR Erfolgreiche Leseoperation
PAR (ids=Tabelle-195,-CosT_b05)Tabelle 195, CosT_b05: READ RECORD Antwort-APDU im Fehlerfall

TABLE(rows=7,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '62 87' TD(1,1/1/1)->PAR RecordDeactivated TD(1,2/1/1)->PAR Adressierter Rekord ist deaktiviert
TR-> TD(2,0/1/1)->PAR '69 81' TD(2,1/1/1)->PAR WrongFileType TD(2,2/1/1)->PAR Ausgewähltes EF ist nicht strukturiert
TR-> TD(3,0/1/1)->PAR '69 82' TD(3,1/1/1)->PAR SecurityStatusNotSatisfied TD(3,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(4,0/1/1)->PAR '69 86' TD(4,1/1/1)->PAR NoCurrentEF TD(4,2/1/1)->PAR Es ist kein EF ausgewählt
TR-> TD(5,0/1/1)->PAR '6A 82' TD(5,1/1/1)->PAR FileNotFound TD(5,2/1/1)->PAR Per shortFileIdentifier adressiertes EF nicht gefunden
TR-> TD(6,0/1/1)->PAR '6A 83' TD(6,1/1/1)->PAR RecordNotFound TD(6,2/1/1)->PAR Listenelement recordNumber existiert nicht
PAR Hinweis CosH_758: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16331)<b>A_16331 - (N066.200) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando READ RECORD verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.4.6.4)14.4.6.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N066.300.a)<b>G2_N066.300.a - (N066.300)a K_COS</b>
PAR Das COS MUSS die READ RECORD-Varianten aus (N065.700) und (N066.100) unterstützen. <b>[<=]</b>

REQ(ids=A_16332)<b>A_16332 - (N066.300)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere READ RECORD-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16333)<b>A_16333 - (N066.400)a K_COS</b>
PAR Wenn die APDU des READ RECORD-Kommandos einen shortFileIdentifier enthält, dann MUSS innerhalb von currentFolder.children nach einem EF mit diesem shortFileIdentifier gesucht werden. <b>[<=]</b>

REQ(ids=G2_N066.400.a.1)<b>G2_N066.400.a.1 - (N066.400)a.1 K_COS</b>
PAR Wenn die Suche erfolgreich verlief, dann MUSS<br>i.  affectedObject auf dieses EF gesetzt werden und<br>ii. currentEF auf dieses EF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N066.400.a.2)<b>G2_N066.400.a.2 - (N066.400)a.2 K_COS</b>
PAR Wenn die Suche nicht erfolgreich verlief, genau dann MUSS<br>i.  currentEF unverändert bleiben und<br>ii. das Kommando mit dem Trailer FileNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N066.400.b.1)<b>G2_N066.400.b.1 - (N066.400)b.1 K_COS</b>
PAR Wenn die APDU des READ RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) unbestimmt ist, genau dann MUSS das Kommando mit dem Trailer NoCurrentEF terminieren. <b>[<=]</b>

REQ(ids=G2_N066.400.b.2)<b>G2_N066.400.b.2 - (N066.400)b.2 K_COS</b>
PAR Wenn die APDU des READ RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N066.500)<b>G2_N066.500 - (N066.500) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N066.600)<b>G2_N066.600 - (N066.600) K_COS</b>
PAR Wenn affectedObject nicht vom Typ strukturiertes EF ist, genau dann MUSS das Kommando mit dem Trailer WrongFileType terminieren. <b>[<=]</b>

REQ(ids=G2_N066.700)<b>G2_N066.700 - (N066.700) K_COS</b>
PAR Wenn recordNumber größer als die Anzahl der Listenelemente in affectedObject.recordList ist, genau dann MUSS das Kommando mit dem Trailer RecordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N066.800)<b>G2_N066.800 - (N066.800) K_COS</b>
PAR Wenn der physikalische Wert von lifeCycleStatus des adressierten record den Zustand "Operational state (deactivated)" hat, genau dann MUSS das Kommando mit dem Trailer RecordDeactivated terminieren. <b>[<=]</b>

REQ(ids=A_16334)<b>A_16334 - (N066.900) K_COS</b>
PAR Wenn affectedObject.flagChecksum den Wert True hat und die Daten des adressierten Listenelementes inkonsistent zur Checksumme sind, genau dann MUSS<br>a. entweder als Trailer CorruptDataWarning gewählt werden,<br>b. oder die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N067.000)<b>G2_N067.000 - (N067.000) K_COS</b>
PAR Wenn das LeFeld der Kommando-APDU keine WildCard enthält und length größer als die Länge des adressierten Listenelementes in affectedObject.numberOfOctet ist, genau dann MUSS als Trailer EndOfRecordWarning gewählt werden. <b>[<=]</b>

REQ(ids=G2_N067.100)<b>G2_N067.100 - (N067.100) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=G2_N067.200.a)<b>G2_N067.200.a - (N067.200)a K_COS</b>
PAR Aus dem Oktettstring des adressierten record MÜSSEN vom ersten Oktett an die nachfolgenden Oktette in das Datenfeld der Antwortnachricht übernommen werden. <b>[<=]</b>

REQ(ids=G2_N067.200.b)<b>G2_N067.200.b - (N067.200)b K_COS</b>
PAR Es DÜRFEN NICHT mehr Oktette übernommen werden, als durch length angegeben. <b>[<=]</b>

REQ(ids=G2_N067.200.c)<b>G2_N067.200.c - (N067.200)c K_COS</b>
PAR Die Übernahme MUSS am Ende von record stoppen. <b>[<=]</b>

REQ(ids=A_16335)<b>A_16335 - (N067.300)a K_TST</b>
PAR Die Priorität der Trailer in CosT_b05 MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N067.300.b)<b>G2_N067.300.b - (N067.300)b K_COS</b>
PAR Jeder Trailer in CosT_b05 MUSS eine höhere Priorität als CorruptDataWarning haben. <b>[<=]</b>

REQ(ids=G2_N067.300.c)<b>G2_N067.300.c - (N067.300)c K_COS</b>
PAR CorruptDataWarning MUSS eine höhere Priorität als EndOfRecordWarning haben. <b>[<=]</b>

REQ(ids=G2_N067.300.d)<b>G2_N067.300.d - (N067.300)d K_COS</b>
PAR EndOfRecordWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR (N067.400) Diese Anforderung ist absichtlich leer.
PAR (N067.500) Diese Anforderung ist absichtlich leer.
PAR -HEADING(ids=14.4.7)14.4.7 CosK_cde SEARCH RECORD
PAR Das Kommando SEARCH RECORD sucht in den Listenelementen von recordList eines strukturierten EF nach einem Muster, welches im Datenfeld der Kommandonachricht übergeben wird. Die Antwortdaten enthalten die Nummern der Rekords, welche das Muster enthalten. Das betroffene, strukturierte EF wird vor der Suchoperation ausgewählt. Dies geschieht entweder vor dem Senden dieses SEARCH RECORD-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier), oder innerhalb dieses SEARCH RECORD-Kommandos, falls diesem ein shortFileIdentifier als Parameter mitgeliefert wurde. Bei welchem Listenelement in recordList die Suche startet, wird durch die Rekordnummer bestimmt, die als Parameter in der Kommandonachricht enthalten ist.
PAR -HEADING(ids=14.4.7.1)14.4.7.1 CosK_766 Use Case Suchen ohne shortFileIdentifier in strukturierten EF
PAR In dieser Variante enthält die APDU des SEARCH RECORD-Kommandos drei Parameter:
REQ(ids=A_16337)<b>A_16337 - (N067.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das Listenelement, welches als erstes von der Suche betroffen ist. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16338)<b>A_16338 - (N067.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter searchString enthält das Muster, nach welchem in den Oktettstrings der Listenelemente gesucht wird. Der Parameter searchString ist ein Oktettstring mit beliebigem Inhalt. Die Länge von searchString MUSS im Intervall [1, 255] Oktett sein. <b>[<=]</b>

REQ(ids=A_16339)<b>A_16339 - (N067.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus dem in (N027.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16340)<b>A_16340 - (N067.900) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_597 verwendet werden.
PAR (ids=Tabelle-196,-CosT_597)Tabelle 196, CosT_597: SEARCH RECORD ohne shortFileIdentifier

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A2' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '04' TD(4,2/1/1)->PAR Codierung für "suche in Listenelement P1 und allen folgenden"
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR searchString
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.7.2)14.4.7.2 CosK_03b Use Case Suchen mit shortFileIdentifier in strukturierten EF
PAR In dieser Variante enthält die APDU des SEARCH RECORD-Kommandos vier Parameter:
REQ(ids=A_16341)<b>A_16341 - (N068.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter shortFileIdentifier wählt während der Kommandoabarbeitung ein EF aus. Der Wert von shortFileIdentifier MUSS aus dem in (N007.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16342)<b>A_16342 - (N068.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das Listenelement, welches als erstes von der Suche betroffen ist. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16343)<b>A_16343 - (N068.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter searchString enthält das Muster, nach welchem in den Oktettstrings der Listenelemente gesucht wird. Der Parameter searchString ist ein Oktettstring mit beliebigem Inhalt. Die Länge von searchString MUSS im Intervall [1, 255] Oktett sein. <b>[<=]</b>

REQ(ids=A_16344)<b>A_16344 - (N068.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus dem in (N027.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16345)<b>A_16345 - (N068.400) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_771 verwendet werden.
PAR (ids=Tabelle-197,-CosT_771)Tabelle 197, CosT_771: SEARCH RECORD mit shortFileIdentifier

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'A2' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR 8 shortFileIdentifier + mode, das heißt (shortFileIdentifier << 3) + '04'<br>'04' bedeutet: "suche in Listenelement P1 und allen folgenden"
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR searchString
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.7.3)14.4.7.3 Antwort der Karte auf Suchen in strukturierten EF
PAR (ids=Tabelle-198,-CosT_13d)Tabelle 198, CosT_13d: SEARCH RECORD Antwort-APDU im Erfolgsfall

TABLE(rows=6,cols=62+136+546)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)->PAR rspData TD(1,2/1/1)->PAR Nummern der Listenelemente, in denen das Muster gefunden wurde
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '62 81' TD(3,1/1/1)->PAR CorruptDataWarning TD(3,2/1/1)->PAR Möglicherweise sind Antwortdaten korrupt
TR-> TD(4,0/1/1)->PAR '62 82' TD(4,1/1/1)->PAR UnsuccessfulSearch TD(4,2/1/1)->PAR Erfolglose Suche in adressierten Rekords
TR-> TD(5,0/1/1)->PAR '90 00' TD(5,1/1/1)->PAR NoError TD(5,2/1/1)->PAR Erfolgreiche Suchoperation
PAR (ids=Tabelle-199,-CosT_8b8)Tabelle 199, CosT_8b8: SEARCH RECORD Antwort-APDU im Fehlerfall

TABLE(rows=6,cols=61+168+515)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '69 81' TD(1,1/1/1)->PAR WrongFileType TD(1,2/1/1)->PAR Ausgewähltes EF ist nicht strukturiert
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '69 86' TD(3,1/1/1)->PAR NoCurrentEF TD(3,2/1/1)->PAR Es ist kein EF ausgewählt
TR-> TD(4,0/1/1)->PAR '6A 82' TD(4,1/1/1)->PAR FileNotFound TD(4,2/1/1)->PAR Per shortFileIdentifier ausgewähltes EF nicht gefunden
TR-> TD(5,0/1/1)->PAR '6A 83' TD(5,1/1/1)->PAR RecordNotFound TD(5,2/1/1)->PAR Listenelement recordNumber existiert nicht
PAR Hinweis CosH_9cc: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16346)<b>A_16346 - (N068.500) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando SEARCH RECORD verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.4.7.4)14.4.7.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N068.600.a)<b>G2_N068.600.a - (N068.600)a K_COS</b>
PAR Das COS MUSS die SEARCH RECORD-Varianten aus (N067.900) und (N068.400) unterstützen. <b>[<=]</b>

REQ(ids=A_16347)<b>A_16347 - (N068.600)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere SEARCH RECORD-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16348)<b>A_16348 - (N068.700)a K_COS</b>
PAR Wenn die APDU des SEARCH RECORD-Kommandos einen shortFileIdentifier enthält, dann MUSS innerhalb von currentFolder.children nach einem EF mit diesem shortFileIdentifier gesucht werden. <b>[<=]</b>

REQ(ids=G2_N068.700.a.1)<b>G2_N068.700.a.1 - (N068.700)a.1 K_COS</b>
PAR Wenn die Suche erfolgreich verlief, dann MUSS<br>i.  affectedObject auf dieses EF gesetzt werden und<br>ii. currentEF auf dieses EF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N068.700.a.2)<b>G2_N068.700.a.2 - (N068.700)a.2 K_COS</b>
PAR Wenn die Suche nicht erfolgreich verlief, genau dann MUSS<br>i.  currentEF unverändert bleiben und<br>ii. das Kommando mit dem Trailer FileNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N068.700.b.1)<b>G2_N068.700.b.1 - (N068.700)b.1 K_COS</b>
PAR Wenn die APDU des SEARCH RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) unbestimmt ist, genau dann MUSS das Kommando mit dem Trailer NoCurrentEF terminieren. <b>[<=]</b>

REQ(ids=G2_N068.700.b.2)<b>G2_N068.700.b.2 - (N068.700)b.2 K_COS</b>
PAR Wenn die APDU des SEARCH RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N068.800)<b>G2_N068.800 - (N068.800) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N068.900)<b>G2_N068.900 - (N068.900) K_COS</b>
PAR Wenn affectedObject nicht vom Typ strukturiertes EF ist, genau dann MUSS das Kommando mit dem Trailer WrongFileType terminieren. <b>[<=]</b>

REQ(ids=G2_N069.000)<b>G2_N069.000 - (N069.000) K_COS</b>
PAR Wenn recordNumber größer als die Anzahl der Listenelemente in affectedObject.recordList ist, genau dann MUSS das Kommando mit dem Trailer RecordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N069.100)<b>G2_N069.100 - (N069.100) K_COS</b>
PAR Im Oktettstring des durch recordNumber adressierten record in affectedObject.recordList und allen folgenden Elementen der Liste MUSS nach dem Muster searchString gesucht werden. <b>[<=]</b>

REQ(ids=G2_N069.200)<b>G2_N069.200 - (N069.200) K_COS</b>
PAR Die Suche in einem Listenelement MUSS genau dann erfolgreich sein, wenn<br>a. der physikalische Wert des lifeCycleStatus des Listenelementes den Wert "Operational state (active)" hat UND<br>b. searchString im Oktettstring des Listenelementes vollständig enthalten ist. <b>[<=]</b>

REQ(ids=G2_N069.300)<b>G2_N069.300 - (N069.300) K_COS</b>
PAR Wenn die Suche in einem Listenelement erfolgreich war, dann MUSS die Nummer des Rekords (siehe (N007.600)a) in einem Oktett (gemäß I2OS(recordNumber, 1)) codiert zum Datenfeld rspData der Antwortnachricht hinzugefügt werden. <b>[<=]</b>

REQ(ids=G2_N069.400)<b>G2_N069.400 - (N069.400) K_COS</b>
PAR Die Oktette im Datenfeld rspData MÜSSEN aufsteigend sortiert sein. <b>[<=]</b>

REQ(ids=A_16349)<b>A_16349 - (N069.500) K_COS</b>
PAR Wenn affectedObject.flagChecksum den Wert True hat und die Daten wenigstens eines adressierten Listenelementes inkonsistent zur Checksumme sind, genau dann MUSS<br>a. entweder als Trailer CorruptDataWarning gewählt werden,<br>b. oder die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N069.600)<b>G2_N069.600 - (N069.600) K_COS</b>
PAR Wenn das Datenfeld rspData leer ist, das heißt die Suche war in keinem der adressierten Listenelemente erfolgreich, genau dann MUSS als Trailer UnsuccessfulSearch verwendet werden. <b>[<=]</b>

REQ(ids=G2_N069.700)<b>G2_N069.700 - (N069.700) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=G2_N069.710)<b>G2_N069.710 - (N069.710) K_COS</b>
PAR Für das Datenfeld rspData der Antwortnachricht gilt: Wenn OctetLength( rspData ) kleiner Nr gemäß (N027.200) ist,<br>a. dann rspData = rspData,<br>b. sonst rspData = Extract_MSByte( rspData, Nr ). <b>[<=]</b>

REQ(ids=A_16350)<b>A_16350 - (N069.800)a K_TST</b>
PAR Die Priorität der Trailer in CosT_8b8 MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N069.800.b)<b>G2_N069.800.b - (N069.800)b K_COS</b>
PAR Jeder Trailer in CosT_8b8 MUSS eine höhere Priorität als CorruptDataWarning haben. <b>[<=]</b>

REQ(ids=G2_N069.800.c)<b>G2_N069.800.c - (N069.800)c K_COS</b>
PAR CorruptDataWarning MUSS eine höhere Priorität als UnsuccessfulSearch haben. <b>[<=]</b>

REQ(ids=G2_N069.800.d)<b>G2_N069.800.d - (N069.800)d K_COS</b>
PAR UnsuccessfulSearch MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR (N069.900) Diese Anforderung ist absichtlich leer.
PAR (N070.000) Diese Anforderung ist absichtlich leer.
PAR -HEADING(ids=14.4.8)14.4.8 CosK_aaa UPDATE RECORD
PAR Das Kommando UPDATE RECORD ersetzt den Oktettstring eines bereits vorhandenen Listenelementes in recordList eines strukturierten EF durch Daten, die im Datenfeld der Kommandonachricht enthalten sind. Das betroffene strukturierte EF wird vor der Schreiboperation ausgewählt. Dies geschieht entweder vor dem Senden dieses UPDATE RECORD-Kommandos durch eine Select-Operation (SELECT-Kommando oder Kommando mit shortFileIdentifier), oder innerhalb dieses UPDATE RECORD-Kommandos, falls diesem ein shortFileIdentifier als Parameter mitgeliefert wurde. Welches Listenelement in recordList ersetzt wird, bestimmt die Rekordnummer, die als Parameter in der Kommandonachricht enthalten ist.
PAR -HEADING(ids=14.4.8.1)14.4.8.1 CosK_647 Use Case Rekordinhalt schreiben, ohne shortFileIdentifier
PAR Diese Variante stellt entweder das Ende einer Kommandokette dar, oder das einzige Kommando einer "Kette". Die APDU des UPDATE RECORD-Kommandos enthält zwei Parameter:
REQ(ids=A_16353)<b>A_16353 - (N070.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16354)<b>A_16354 - (N070.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter newData enthält die neuen Daten, welche den Oktettstring des adressierten record ersetzen. Der Parameter newData ist ein Oktettstring mit beliebigem Inhalt. Die Länge von newData MUSS aus dem in (N007.700)a definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16355)<b>A_16355 - (N070.300) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_dc9 verwendet werden.
PAR (ids=Tabelle-200,-CosT_dc9)Tabelle 200, CosT_dc9: UPDATE RECORD, ohne shortFileIdentifier

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'DC' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '04' TD(4,2/1/1)->PAR Codierung für "nutze Listenelement P1"
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR newData
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.8.2)14.4.8.2 CosK_810 Use Case Rekordinhalt schreiben, mit shortFileIdentifier
PAR Diese Variante stellt entweder das Ende einer Kommandokette dar, oder das einzige Kommando einer "Kette". Die APDU des UPDATE RECORD-Kommandos enthält drei Parameter:
REQ(ids=A_16356)<b>A_16356 - (N070.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter shortFileIdentifier wählt während der Kommandoabarbeitung ein EF aus. Der Wert von shortFileIdentifier MUSS aus dem in (N007.000) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16357)<b>A_16357 - (N070.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter recordNumber bestimmt das betroffene Listenelement. Der Wert von recordNumber MUSS konform zu (N007.600)a gewählt werden. <b>[<=]</b>

REQ(ids=A_16358)<b>A_16358 - (N070.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter newData enthält die neuen Daten, welche den Oktettstring des adressierten record ersetzen. Der Parameter newData ist ein Oktettstring mit beliebigem Inhalt. Die Länge von newData MUSS aus dem in (N007.700)a definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16359)<b>A_16359 - (N070.700) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_df8 verwendet werden.
PAR (ids=Tabelle-201,-CosT_df8)Tabelle 201, CosT_df8: UPDATE RECORD mit shortFileIdentifier

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'DC' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'XX' TD(3,2/1/1)->PAR recordNumber
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR 8 shortFileIdentifier + mode, das heißt (shortFileIdentifier << 3) + '04'<br>Codierung '04' bedeutet "nutze Listenelement P1"
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR newData
PAR <b>[<=]</b>

PAR -HEADING(ids=14.4.8.3)14.4.8.3 Antwort der Karte auf Schreiben in strukturierten EF
PAR (ids=Tabelle-202,-CosT_d43)Tabelle 202, CosT_d43: UPDATE RECORD Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreicher Schreibvorgang
PAR (ids=Tabelle-203,-CosT_aff)Tabelle 203, CosT_aff: UPDATE RECORD Antwort-APDU im Fehlerfall

TABLE(rows=10,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '62 87' TD(1,1/1/1)->PAR RecordDeactivated TD(1,2/1/1)->PAR Adressierter Rekord ist deaktiviert
TR-> TD(2,0/1/1)->PAR '65 81' TD(2,1/1/1)->PAR MemoryFailure TD(2,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(3,0/1/1)->PAR '67 00' TD(3,1/1/1)->PAR WrongRecordLength TD(3,2/1/1)->PAR newData hat nicht die richtige Länge
TR-> TD(4,0/1/1)->PAR '69 81' TD(4,1/1/1)->PAR WrongFileType TD(4,2/1/1)->PAR Ausgewähltes EF ist nicht strukturiert
TR-> TD(5,0/1/1)->PAR '69 82' TD(5,1/1/1)->PAR SecurityStatusNotSatisfied TD(5,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(6,0/1/1)->PAR '69 86' TD(6,1/1/1)->PAR NoCurrentEF TD(6,2/1/1)->PAR Es ist kein EF ausgewählt
TR-> TD(7,0/1/1)->PAR '6A 82' TD(7,1/1/1)->PAR FileNotFound TD(7,2/1/1)->PAR Per shortFileIdentifier ausgewähltes EF nicht gefunden
TR-> TD(8,0/1/1)->PAR '6A 83' TD(8,1/1/1)->PAR RecordNotFound TD(8,2/1/1)->PAR Listenelement recordNumber existiert nicht
TR-> TD(9,0/1/1)->PAR '6A 84' TD(9,1/1/1)->PAR OutOfMemory TD(9,2/1/1)->PAR Zu viele Oktette in newData
PAR Hinweis CosH_789: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16360)<b>A_16360 - (N070.800) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando UPDATE RECORD verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.4.8.4)14.4.8.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N070.900.a)<b>G2_N070.900.a - (N070.900)a K_COS</b>
PAR Das COS MUSS die UPDATE RECORD-Varianten aus (N070.300) und (N070.700) unterstützen. <b>[<=]</b>

REQ(ids=A_16361)<b>A_16361 - (N070.900)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere UPDATE RECORD-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16362)<b>A_16362 - (N071.000)a K_COS</b>
PAR Wenn die APDU des UPDATE RECORD-Kommandos einen shortFileIdentifier enthält, dann MUSS innerhalb von currentFolder.children nach einem EF mit diesem shortFileIdentifier gesucht werden. <b>[<=]</b>

REQ(ids=G2_N071.000.a.1)<b>G2_N071.000.a.1 - (N071.000)a.1 K_COS</b>
PAR Wenn die Suche erfolgreich verlief, dann MUSS<br>i.  affectedObject auf dieses EF gesetzt werden und<br>ii. currentEF auf dieses EF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N071.000.a.2)<b>G2_N071.000.a.2 - (N071.000)a.2 K_COS</b>
PAR Wenn die Suche nicht erfolgreich verlief, genau dann MUSS<br>i.  currentEF unverändert bleiben und<br>ii. das Kommando mit dem Trailer FileNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N071.000.b.1)<b>G2_N071.000.b.1 - (N071.000)b.1 K_COS</b>
PAR Wenn die APDU des UPDATE RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) unbestimmt ist, genau dann MUSS das Kommando mit dem Trailer NoCurrentEF terminieren. <b>[<=]</b>

REQ(ids=G2_N071.000.b.2)<b>G2_N071.000.b.2 - (N071.000)b.2 K_COS</b>
PAR Wenn die APDU des UPDATE RECORD-Kommandos keinen shortFileIdentifier enthält und currentEF (siehe (N029.900)m) auf eine Datei zeigt, dann MUSS affectedObject gleich currentEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N071.100)<b>G2_N071.100 - (N071.100) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N071.200)<b>G2_N071.200 - (N071.200) K_COS</b>
PAR Wenn affectedObject nicht vom Typ strukturiertes EF ist, genau dann MUSS das Kommando mit dem Trailer WrongFileType terminieren. <b>[<=]</b>

REQ(ids=G2_N071.300)<b>G2_N071.300 - (N071.300) K_COS</b>
PAR Wenn recordNumber größer als die Anzahl der Listenelemente in affectedObject.recordList ist, genau dann MUSS das Kommando mit dem Trailer RecordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N071.400)<b>G2_N071.400 - (N071.400) K_COS</b>
PAR Wenn der physikalische Wert von lifeCycleStatus des adressierten record den Zustand "Operational state (deactivated)" hat, genau dann MUSS das Kommando mit dem Trailer RecordDeactivated terminieren. <b>[<=]</b>

PAR (N071.500) Diese Anforderung ist absichtlich leer.
PAR (N071.600) Diese Anforderung ist absichtlich leer.
PAR (N071.700) Diese Anforderung ist absichtlich leer.
REQ(ids=A_16363)<b>A_16363 - (N071.750) K_COS</b>
PAR Das COS MUSS folgende Schritte ausführen: <b>[<=]</b>

REQ(ids=A_16364)<b>A_16364 - (N071.750)a K_COS</b>
PAR Schritt 1: Das COS MUSS die Anzahl der Oktette in recordData mit affectedObject.maximumRecordLength vergleichen. <b>[<=]</b>

REQ(ids=G2_N071.750.a.1)<b>G2_N071.750.a.1 - (N071.750)a.1</b>
PAR Wenn affectedObject vom Typ linear fixes EF ist und die Anzahl Oktette in newData ungleich affectedObject.maximumRecordLength ist, dann MUSS das Kommando mit dem Trailer WrongRecordLength terminieren. <b>[<=]</b>

REQ(ids=G2_N071.750.a.2)<b>G2_N071.750.a.2 - (N071.750)a.2 K_COS</b>
PAR Wenn affectedObject vom Typ zyklisches EF ist und die Anzahl Oktette in newData ungleich affectedObject.maximumRecordLength ist, dann MUSS das Kommando mit dem Trailer WrongRecordLength terminieren. <b>[<=]</b>

REQ(ids=G2_N071.750.a.3.i)<b>G2_N071.750.a.3.i - (N071.750)a.3.i K_COS</b>
PAR Wenn affectedObject vom Typ linear variables EF ist und die Anzahl Oktette in newData größer als affectedObject.maximumRecordLength ist, dann MUSS das Kommando mit dem Trailer WrongRecordLength terminieren. <b>[<=]</b>

REQ(ids=G2_N071.750.a.3.ii)<b>G2_N071.750.a.3.ii - (N071.750)a.3.ii K_COS</b>
PAR Wenn affectedObject vom Typ linear variables EF ist die Anzahl Oktette in den Oktettstrings aller record von recordList nach durchgeführter Ersetzung größer als affectedObject.numberOfOctet wäre, genau dann MUSS das Kommando mit dem Trailer OutOfMemory terminieren. <b>[<=]</b>

REQ(ids=A_16365)<b>A_16365 - (N071.750)b K_COS</b>
PAR Schritt 2: Das COS MUSS die Art des Transaktionsschutzes festlegen. <b>[<=]</b>

REQ(ids=G2_N071.750.b.1)<b>G2_N071.750.b.1 - (N071.750)b.1 K_COS</b>
PAR Wenn affectedObject.flagTransactionMode den Wert True hat, dann MUSS der Rekordinhalt mit Transaktionsschutz geändert werden. Der Transaktionsschutz MUSS auch die Anpassung der Checksumme zu affectedObject.recordList oder der Checksumme des geänderten Rekords umfassen, sofern diese vorhanden sind. <b>[<=]</b>

REQ(ids=A_16366)<b>A_16366 - (N071.750)b.2 K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden für den Fall, dass affectedObject.flagTransactionMode den Wert False habe, würden Rekordinhalt oder Checksumme<br>i.  mit Transaktionsschutz geändert, oder<br>ii. ohne Transaktionsschutz geändert. <b>[<=]</b>

REQ(ids=A_16367)<b>A_16367 - (N071.750)c K_COS</b>
PAR Schritt 3: Wenn affectedObject.recordList oder der durch recordNumber adressierte record in affectedObject.recordList durch eine Checksumme geschützt ist, dann MUSS das COS auf eine der in diesem Punkt genannten Arten reagieren: Eine Inkonsistenz zwischen dieser Checksumme und affectedObject.recordList<br>1. DARF NICHT zum Abbruch des Kommandos führen.<br>2. MUSS die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=A_16368)<b>A_16368 - (N071.750)d K_COS</b>
PAR Schritt 4: Das COS MUSS den Inhalt des betroffenen Rekords wie folgt ändern: <b>[<=]</b>

REQ(ids=G2_N071.750.d.1)<b>G2_N071.750.d.1 - (N071.750)d.1 K_COS</b>
PAR Der Oktettstring des durch recordNumber adressierten record in affectedObject.recordList wird durch newData ersetzt. <b>[<=]</b>

REQ(ids=G2_N071.750.d.2)<b>G2_N071.750.d.2 - (N071.750)d.2 K_COS</b>
PAR Falls affectedObject.recordList durch eine Checksumme geschützt ist, dann MUSS diese Checksumme auf einen Wert gesetzt werden, der konsistent zum geänderten Inhalt von affectedObject.recordList ist. <b>[<=]</b>

REQ(ids=G2_N071.750.d.3)<b>G2_N071.750.d.3 - (N071.750)d.3 K_COS</b>
PAR Falls der durch recordNumber adressierte record in affectedObject.recordList durch eine Checksumme geschützt ist, dann MUSS dessen Checksumme auf einen Wert gesetzt werden, der konsistent zum neuen Inhalt von diesem Rekord ist. <b>[<=]</b>

REQ(ids=A_16369)<b>A_16369 - (N071.800) K_COS</b>
PAR Falls affectedObject vom Typ linear variables EF ist, dann MÜSSEN alle folgenden Fälle unterstützt werden: newData enthält im Vergleich zum alten Inhalt von record, der durch recordNumber adressiert wird <b>[<=]</b>

REQ(ids=G2_N071.800.a)<b>G2_N071.800.a - (N071.800)a K_COS</b>
PAR weniger Oktette, <b>[<=]</b>

REQ(ids=G2_N071.800.b)<b>G2_N071.800.b - (N071.800)b K_COS</b>
PAR gleich viele Oktette, oder <b>[<=]</b>

REQ(ids=G2_N071.800.c)<b>G2_N071.800.c - (N071.800)c K_COS</b>
PAR mehr Oktette. <b>[<=]</b>

REQ(ids=A_16370)<b>A_16370 - (N071.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_16371)<b>A_16371 - (N072.000) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>1.  entweder als Trailer MemoryFailureverwendet werden,<br>2. oder die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N072.100)<b>G2_N072.100 - (N072.100) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16372)<b>A_16372 - (N072.200) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>a. Die Priorität der Trailer in CosT_aff ist herstellerspezifisch.<br>b. Jeder Trailer in CosT_aff MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>c. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR (N072.300) Diese Anforderung ist absichtlich leer.
PAR (N072.400) Diese Anforderung ist absichtlich leer
PAR -HEADING(ids=14.4.9)14.4.9 CosK_de2 WRITE RECORD
REQ(ids=A_16373)<b>A_16373 - (N072.500) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das WRITE RECORD-Kommando gemäß [ISO/IEC 7816-4] würde<br>a. unterstützt oder<br>b. abgelehnt. <b>[<=]</b>

PAR -HEADING(ids=14.5)14.5 CosK_798 Zugriff auf Datenobjekte
PAR Hinweis CosH_dfd. Die in diesem Kapitel behandelten Kommandos sind nicht verpflichtend, siehe auch CosK_d51.
PAR -HEADING(ids=14.5.1)14.5.1 CosK_c53 GET DATA
REQ(ids=A_16374)<b>A_16374 - (N072.600) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das GET DATA-Kommando gemäß [ISO/IEC 7816-4] würde<br>a. unterstützt oder<br>b. abgelehnt. <b>[<=]</b>

PAR -HEADING(ids=14.5.2)14.5.2 CosK_c47 PUT DATA
REQ(ids=A_16375)<b>A_16375 - (N072.700) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das PUT DATA-Kommando gemäß [ISO/IEC 7816-4] würde<br>a. unterstützt oder<br>b. abgelehnt. <b>[<=]</b>

PAR -HEADING(ids=14.6)14.6 CosK_bd8 Zugriff auf Passwortobjekte
PAR Alle Kommandos dieses Kapitels benutzen bei der Kommandobearbeitung Passwortobjekte gemäß CosK_d13 oder CosK_7f0. Welches Passwortobjekt betroffen ist, bestimmt eine Passwortreferenz, die als Parameter in den Kommandodaten enthalten ist. Für diese Passwortreferenz gilt:
REQ(ids=A_16376)<b>A_16376 - (N072.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter passwordReference besteht aus den zwei Teilen location und identifier. location zeigt an, ob ein globales oder DF-spezifisches Passwort von der Aktion betroffen ist. Als Wert für location MUSS ein Element der Menge {0, 128} = {'00', '80'} verwendet werden. Dabei gilt:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Wert location = '00' MUSS verwendet werden, wenn ein globales Passwortobjekt betroffen ist (siehe (N020.800)).LITEM->PAR Der Wert location = '80' MUSS verwendet werden, wenn ein DF-spezifisches Passwortobjekt betroffen ist (siehe (N020.900)).LITEM->PAR Der Parameter identifier bestimmt das betroffene Passwortobjekt. Der Wert von identifier MUSS konform zu (N015.000)a gewählt werden.LITEM->PAR Der Parameter passwordReference MUSS in einem Oktett mit folgendem Wert codiert werden: passwordReference = location + identifier.
PAR <b>[<=]</b>

PAR -HEADING(ids=14.6.1)14.6.1 CosK_f67 CHANGE REFERENCE DATA
PAR Das Kommando CHANGE REFERENCE DATA ersetzt das Attribut secret eines Passwortobjektes durch Daten, die im Datenfeld der Kommandonachricht enthalten sind. Welches Passwortobjekt betroffen ist, bestimmt eine Passwortreferenz, die als Parameter in der Kommandonachricht enthalten ist. Dieses Dokument spezifiziert die folgenden Varianten:

LIST->
LITEM->PAR Das Kommandodatenfeld enthält das alte und neue Benutzergeheimnis.LITEM->PAR Das Kommandodatenfeld enthält nur das neue Benutzergeheimnis.
PAR -HEADING(ids=14.6.1.1)14.6.1.1 CosK_260 Use Case Ändern eines Benutzergeheimnisses
PAR In dieser Variante enthält die APDU des CHANGE REFERENCE DATA-Kommandos drei Parameter:
REQ(ids=A_16377)<b>A_16377 - (N072.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter passwordReference referenziert das von der Aktion betroffene Passwort und MUSS gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_16378)<b>A_16378 - (N073.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter oldSecret enthält das alte Benutzergeheimnis. <b>[<=]</b>

REQ(ids=A_16379)<b>A_16379 - (N073.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter newSecret enthält das neue Benutzergeheimnis. <b>[<=]</b>

REQ(ids=A_16380)<b>A_16380 - (N073.200) K_externeWelt {K_Karte}</b>
PAR Die Parameter oldSecret und newSecret MÜSSEN gemäß (N008.100) codiert sein. <b>[<=]</b>

REQ(ids=A_16381)<b>A_16381 - (N073.300) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_204 verwendet werden.
PAR (ids=Tabelle-204,-CosT_204)Tabelle 204, CosT_204: CHANGE REFERENCE DATA mit altem und neuem Benutzergeheimnis

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '24' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR Data enthält altes und neues Benutzergeheimnis
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR passwordReference
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR oldSecret   ||   newSecret
PAR <b>[<=]</b>

PAR -HEADING(ids=14.6.1.2)14.6.1.2 CosK_5c3 Use Case Setzen eines Benutzergeheimnisses
PAR In dieser Variante enthält die APDU des CHANGE REFERENCE DATA-Kommandos zwei Parameter:
REQ(ids=A_16382)<b>A_16382 - (N073.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter passwordReference referenziert das von der Aktion betroffene Passwort und MUSS gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_16383)<b>A_16383 - (N073.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter newSecret enthält das neue Benutzergeheimnis. <b>[<=]</b>

REQ(ids=A_16384)<b>A_16384 - (N073.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter newSecret MUSS gemäß (N008.100) codiert sein. <b>[<=]</b>

REQ(ids=A_16385)<b>A_16385 - (N073.700) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_95c verwendet werden.
PAR (ids=Tabelle-205,-CosT_95c)Tabelle 205, CosT_95c: CHANGE REFERENCE DATA, nur neues Benutzergeheimnis

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '24' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '01' TD(3,2/1/1)->PAR Data enthält neues Benutzergeheimnis
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR passwordReference
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR newSecret
PAR <b>[<=]</b>

PAR -HEADING(ids=14.6.1.3)14.6.1.3 Antwort der Karte auf Ändern eines Benutzergeheimnisses
PAR (ids=Tabelle-206,-CosT_24b)Tabelle 206, CosT_24b: CHANGE REFERENCE DATA Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR WrongSecretWarning TD(1,2/1/1)->PAR oldSecret ist falsch
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiches Ändern des Benutzergeheimnisses
PAR (ids=Tabelle-207,-CosT_1d0)Tabelle 207, CosT_1d0: CHANGE REFERENCE DATA Antwort-APDU im Fehlerfall

TABLE(rows=7,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '69 83' TD(3,1/1/1)->PAR PasswordBlocked TD(3,2/1/1)->PAR Abgelaufener Fehlbedienungszähler
TR-> TD(4,0/1/1)->PAR '69 85' TD(4,1/1/1)->PAR LongPassword TD(4,2/1/1)->PAR newData enthält ein zu langes Passwort
TR-> TD(5,0/1/1)->PAR '69 85' TD(5,1/1/1)->PAR ShortPassword TD(5,2/1/1)->PAR newData enthält ein zu kurzes Passwort
TR-> TD(6,0/1/1)->PAR '6A 88' TD(6,1/1/1)->PAR PasswordNotFound TD(6,2/1/1)->PAR Adressiertes Passwort wurde nicht gefunden
PAR Hinweis CosH_371: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16386)<b>A_16386 - (N073.800) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando CHANGE REFERENCE DATA verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.6.1.4)14.6.1.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N073.900)<b>G2_N073.900 - (N073.900) K_COS</b>
PAR Das COS MUSS die CHANGE REFERENCE DATA-Varianten aus (N073.300) und (N073.700) unterstützen. <b>[<=]</b>

PAR (N074.000) Diese Anforderung ist absichtlich leer.
REQ(ids=A_16387)<b>A_16387 - (N074.100) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere CHANGE REFERENCE DATA-Varianten würden<br>a. unterstützt oder<br>b. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N074.200)<b>G2_N074.200 - (N074.200) K_COS</b>
PAR Es gilt affectedObject = SearchPwd(currentFolder, passwordReference ). Wenn die Passwortsuche mit einem Fehler abbricht, genau dann MUSS das Kommando mit dem Trailer PasswordNotFound terminieren. <b>[<=]</b>

PAR (N074.250) Diese Anforderung ist absichtlich leer.
REQ(ids=G2_N074.300)<b>G2_N074.300 - (N074.300) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N074.400)<b>G2_N074.400 - (N074.400) K_COS</b>
PAR Wenn affectedObject.retryCounter den Wert null hat, genau dann MUSS das Kommando mit dem Trailer PasswordBlocked terminieren. <b>[<=]</b>

REQ(ids=G2_N074.500.a)<b>G2_N074.500.a - (N074.500)a K_COS</b>
PAR Wenn die in newSecret codierte Ziffernfolge für das Attribut secret des Passwortobjektes eine Länge hat, die kleiner als affectedObject.minimumLength ist, genau dann MUSS das Kommando mit dem Trailer ShortPassword terminieren. <b>[<=]</b>

REQ(ids=G2_N074.500.b)<b>G2_N074.500.b - (N074.500)b K_COS</b>
PAR Wenn die in newSecret codierte Ziffernfolge für das Attribut secret des Passwortobjektes eine Länge hat, die größer als affectedObject.maximumLength ist, genau dann MUSS das Kommando mit dem Trailer LongPassword terminieren. <b>[<=]</b>

PAR (N074.600) Diese Anforderung ist absichtlich leer.
PAR Hinweis CosH_b4d: Die Aussage in (N074.700)a.1 bezieht sich bewusst nur auf den momentan aktiven logischen Kanal. Daraus folgt, dass Sicherheitszustände in anderen logischen Kanälen von der dort beschriebenen Aktion unberührt bleiben.
REQ(ids=A_16388)<b>A_16388 - (N074.700) K_COS</b>
PAR Wenn das Datenfeld der Kommandonachricht oldSecret enthält, genau dann MUSS das Attribut affectedObject.secret mit oldSecret verglichen werden. <b>[<=]</b>

REQ(ids=G2_N074.700.a)<b>G2_N074.700.a - (N074.700)a K_COS</b>
PAR Wenn der Vergleich fehlschlägt, genau dann MUSS

ORDERED-LIST->
LITEM->PAR der Sicherheitszustand im channelContext des momentan aktiven logischen Kanals mittels<br>clearPasswordStatus( affectedObject ) zurückgesetzt werden,LITEM->PAR affectedObject.retryCounter um eins dekrementiert werden undLITEM->PAR das Kommando mit dem Trailer WrongSecretWarning terminieren. Das Lownibble des Trailers MUSS dabei auf den Wert 'F' gesetzt werden, wenn affectedObject.retryCounter größer als fünfzehn ist, andernfalls auf den Wert von affectedObject.retryCounter.
PAR <b>[<=]</b>

REQ(ids=G2_N074.700.b)<b>G2_N074.700.b - (N074.700)b K_COS</b>
PAR Wenn der Vergleich erfolgreich ist, genau dann MUSS das Attribut affectedObject.retryCounter auf den Wert affectedObject.startRetryCounter gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N074.700.c)<b>G2_N074.700.c - (N074.700)c K_COS</b>
PAR Wenn die Vergleichsoperation durch einen Reset abgebrochen wird, dann MUSS affectedObject.retryCounter um eins dekrementiert werden. <b>[<=]</b>

REQ(ids=G2_N074.710)<b>G2_N074.710 - (N074.710) K_COS</b>
PAR Das Attribut affectedObject.secret MUSS auf den in newSecret codierten Wert gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N074.720)<b>G2_N074.720 - (N074.720) K_COS</b>
PAR Das Attribut affectedObject.transportStatus MUSS auf den Wert regularPassword geändert werden (siehe (N009.500)a). <b>[<=]</b>

REQ(ids=G2_N074.800)<b>G2_N074.800 - (N074.800) K_COS</b>
PAR Alle persistenten Änderungen in (N074.700)b, (N074.710) und (N074.720) MÜSSEN mit Transaktionsschutz ausgeführt werden. <b>[<=]</b>

PAR (N074.900) Diese Anforderung ist absichtlich leer.
REQ(ids=A_16389)<b>A_16389 - (N075.000) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N075.100)<b>G2_N075.100 - (N075.100) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16390)<b>A_16390 - (N075.200)a K_TST</b>
PAR Die Priorität der Trailer in CosT_1d0 MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N075.200.b)<b>G2_N075.200.b - (N075.200)b K_COS</b>
PAR Jeder Trailer in CosT_1d0 MUSS eine höhere Priorität als WrongSecretWarning haben. <b>[<=]</b>

REQ(ids=G2_N075.300.d)<b>G2_N075.300.d - (N075.300)d K_COS</b>
PAR WrongSecretWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR Wenn die Ausführung dieses Kommandos durch einen Reset abgebrochen wird, dann gilt für konditionale Änderung von affectedObject.retryCounter und die Änderung von affectedObject.transportStatus und affectedObject.secret:
REQ(ids=A_16391)<b>A_16391 - (N075.300)a K_COS</b>
PAR Alle Attribute SOLLEN gemeinsam in einer Transaktion geändert werden. <b>[<=]</b>

REQ(ids=A_16392)<b>A_16392 - (N075.300)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Attribut retryCounter würde in einer eigenen Transaktion zeitlich vor den anderen Attributen geändert. <b>[<=]</b>

REQ(ids=A_16393)<b>A_16393 - (N075.300)c K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Attribut secret würde in einer eigenen Transaktion zeitlich vor transportStatus geändert. <b>[<=]</b>

REQ(ids=A_16394)<b>A_16394 - (N075.300)d K_COS</b>
PAR Das Attribut transportStatus DARF NICHT persistent geändert sein, wenn nicht auch secret persistent geändert ist. <b>[<=]</b>

PAR -HEADING(ids=14.6.2)14.6.2 CosK_3ee DISABLE VERIFICATION REQUIREMENT
PAR Das Kommando DISABLE VERIFICATION REQUIREMENT ändert das Attribut flagEnabled eines Passwortobjektes (siehe CosK_d13 und CosK_7f0) so, dass das COS sich so verhält, als sei der Sicherheitszustand des Passwortes ständig gesetzt. Welches Passwortobjekt betroffen ist, bestimmt eine Passwortreferenz, die als Parameter in der Kommandonachricht enthalten ist. Dieses Kommando gibt es in den Varianten mit und ohne Verifikationsdaten.
PAR -HEADING(ids=14.6.2.1)14.6.2.1 CosK_c3d Use Case Abschalten der Benutzerverifikation mit Benutzergeheimnis
PAR In dieser Variante wird der Zwang zur Benutzerverifiaktion nicht abgeschaltet, wenn das übergebene Benutzergeheimnis nicht korrekt ist. Die APDU des DISABLE VERIFICATION REQUIREMENT-Kommandos enthält zwei Parameter:
REQ(ids=A_16396)<b>A_16396 - (N075.380) K_externeWelt {K_Karte}</b>
PAR Der Parameter passwordReference referenziert das von der Aktion betroffene Passwort und MUSS gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_16397)<b>A_16397 - (N075.382) K_externeWelt {K_Karte}</b>
PAR Der Parameter verificationData enthält das Benutzergeheimnis. <b>[<=]</b>

REQ(ids=A_16398)<b>A_16398 - (N075.384) K_externeWelt {K_Karte}</b>
PAR Der Parameter verificationData MUSS gemäß (N008.100) codiert sein. <b>[<=]</b>

REQ(ids=A_16399)<b>A_16399 - (N075.386) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_b4f verwendet werden.
PAR (ids=Tabelle-208,-CosT_b4f)Tabelle 208, CosT_b4f: DISABLE VERIFICATION REQUIREMENT mit Verifikationsdaten

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '26' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR Verifikationsdaten
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR passwordReference
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR verificationData
PAR <b>[<=]</b>

PAR -HEADING(ids=14.6.2.2)14.6.2.2 CosK_5f4 Use Case Abschalten der Benutzerverifikation ohne Benutzergeheimnis
PAR In dieser Variante enthält die APDU des DISABLE VERIFICATION REQUIREMENT-Kommandos einen Parameter:
REQ(ids=A_16400)<b>A_16400 - (N075.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter passwordReference referenziert das von der Aktion betroffene Passwort und MUSS gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_16401)<b>A_16401 - (N075.500) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_a7f verwendet werden.
PAR (ids=Tabelle-209,-CosT_a7f)Tabelle 209, CosT_a7f: DISABLE VERIFICATION REQUIREMENT ohne Verifikationsdaten

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '26' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '01' TD(3,2/1/1)->PAR Keine Verifikationsdaten
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR passwordReference
PAR <b>[<=]</b>

PAR -HEADING(ids=14.6.2.3)14.6.2.3 Antwort der Karte auf Abschalten der Benutzerverifikation
PAR (ids=Tabelle-210,-CosT_b71)Tabelle 210, CosT_b71: DISABLE VERIFICATION REQUIREMENT Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR WrongSecretWarning TD(1,2/1/1)->PAR verificationData ist falsch
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiches Abschalten des Passwortobjektes
PAR (ids=Tabelle-211,-CosT_255)Tabelle 211, CosT_255: DISABLE VERIFICATION REQUIREMENT Antwort-APDU im Fehlerfall

TABLE(rows=6,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '69 83' TD(3,1/1/1)->PAR PasswordBlocked TD(3,2/1/1)->PAR Abgelaufener Fehlbedienungszähler
TR-> TD(4,0/1/1)->PAR '69 85' TD(4,1/1/1)->PAR PasswordNotUsable TD(4,2/1/1)->PAR Passwort mit Transportschutz versehen
TR-> TD(5,0/1/1)->PAR '6A 88' TD(5,1/1/1)->PAR PasswordNotFound TD(5,2/1/1)->PAR Adressiertes Passwort wurde nicht gefunden
PAR Hinweis CosH_d77: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16402)<b>A_16402 - (N075.600) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando DISABLE VERIFICATION REQUIREMENT verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.6.2.4)14.6.2.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N075.700.a)<b>G2_N075.700.a - (N075.700)a K_COS</b>
PAR Das COS MUSS die DISABLE VERIFICATION REQUIREMENT-Variante aus (N075.386) und (N075.500) unterstützen. <b>[<=]</b>

REQ(ids=A_16403)<b>A_16403 - (N075.700)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere DISABLE VERIFICATION REQUIREMENT-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N075.800)<b>G2_N075.800 - (N075.800) K_COS</b>
PAR Es gilt affectedObject = SearchPwd(currentFolder, passwordReference ). Wenn die Passwortsuche mit einem Fehler abbricht, genau dann MUSS das Kommando mit dem Trailer PasswordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N075.900)<b>G2_N075.900 - (N075.900) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

PAR (N076.000) Diese Anforderung ist absichtlich leer.
REQ(ids=A_16404)<b>A_16404 - (N076.100)a K_COS</b>
PAR Wenn der Parameter P1 den Wert '00' besitzt, dann MÜSSEN folgende Schritte abgearbeitet werden: <b>[<=]</b>

REQ(ids=G2_N076.100.a.1)<b>G2_N076.100.a.1 - (N076.100)a.1 K_COS</b>
PAR Schritt 1: Wenn affectedObject.retryCounter den Wert null besitzt, genau dann MUSS das Kommando mit dem Trailer PasswordBlocked terminieren. <b>[<=]</b>

REQ(ids=G2_N076.100.a.2)<b>G2_N076.100.a.2 - (N076.100)a.2 K_COS</b>
PAR Schritt 2: Wenn affectedObject.transportStatus nicht den Wert regularPassword besitzt, genau dann MUSS das Kommando mit dem Trailer PasswordNotUsable terminieren. <b>[<=]</b>

REQ(ids=A_16405)<b>A_16405 - (N076.100)a.3 K_COS</b>
PAR Schritt 3: Das Attribut affectedObject.secret MUSS mit verificationData verglichen werden. <b>[<=]</b>

REQ(ids=G2_N076.100.a.3.i)<b>G2_N076.100.a.3.i - (N076.100)a.3.i K_COS</b>
PAR Wenn der Vergleich fehlschlägt, genau dann MUSS<br>A. affectedObject.retryCounter um eins dekrementiert werden und<br>B. clearPasswordStatus( affectedObject ) ausgeführt werden und<br>C. das Kommando mit dem Trailer WrongSecretWarning terminieren. Das Lownibble des Trailers MUSS dabei auf den Wert 'F' gesetzt werden, wenn affectedObject.retryCounter größer als fünfzehn ist, andernfalls auf den Wert von affectedObject.retryCounter. <b>[<=]</b>

REQ(ids=A_16406)<b>A_16406 - (N076.100)a.3.ii K_COS</b>
PAR Wenn die Vergleichsoperation durch einen Reset abgebrochen wird, dann MUSS affectedObject.retryCounter um eins dekrementiert werden. <b>[<=]</b>

REQ(ids=G2_N076.100.a.3.iii)<b>G2_N076.100.a.3.iii - (N076.100)a.3.iii K_COS</b>
PAR Wenn der Vergleich erfolgreich ist, genau dann MUSS<br>A. das Attribut affectedObject.flagEnabled auf den Wert False gesetzt werden und<br>B. das Attribut affectedObject.retryCounter auf den Wert affectedObject.startRetryCounter gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N076.100.b)<b>G2_N076.100.b - (N076.100)b K_COS</b>
PAR Falls der Parameter P1 den Wert '01'besitzt, dann MUSS das Attribut affectedObject.flagEnabled auf den Wert False gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N076.110)<b>G2_N076.110 - (N076.110) K_COS</b>
PAR Alle persistenten Änderungen in (N076.100) MÜSSEN mit Transaktionsschutz ausgeführt werden. <b>[<=]</b>

PAR Wenn die Ausführung dieses Kommandos durch einen Reset abgebrochen wird, dann gilt für konditionale Änderung von affectedObject.retryCounter und die Änderung von affectedObject.flagEnabled:
REQ(ids=A_16407)<b>A_16407 - (N076.120)a K_COS</b>
PAR Alle Attribute SOLLEN gemeinsam in einer Transaktion geändert werden. <b>[<=]</b>

REQ(ids=A_16408)<b>A_16408 - (N076.120)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Attribut retryCounter würde in einer eigenen Transaktion zeitlich vor den anderen Attributen geändert. <b>[<=]</b>

PAR (N076.200) Diese Anforderung ist absichtlich leer.
REQ(ids=A_16409)<b>A_16409 - (N076.300) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

PAR (N076.400) Diese Anforderung ist absichtlich leer.
REQ(ids=G2_N076.500.a)<b>G2_N076.500.a - (N076.500)a K_COS</b>
PAR Wenn affectedObject.flagEnabled den Wert False besitzt, genau dann MUSS als Trailer NoError verwendet werden. <b>[<=]</b>

REQ(ids=A_16410)<b>A_16410 - (N076.500)b K_COS</b>
PAR Wenn affectedObject.flagEnabled den Wert True besitzt, dann ist MUSS PasswordBlocked eine höhere Priorität als PasswordNotUsable haben. Die Priorität der übrigen Trailer in CosT_255 ist bis auf folgende Ausnahme herstellerspezifisch.<br>1. PasswordBlocked MUSS eine höhere Priorität als PasswordNotUsable haben. <b>[<=]</b>

REQ(ids=G2_N076.500.c)<b>G2_N076.500.c - (N076.500)c K_COS</b>
PAR Jeder Trailer in CosT_255 MUSS eine höhere Priorität als WrongSecretWarning haben. <b>[<=]</b>

PAR -HEADING(ids=14.6.3)14.6.3 CosK_fc7 ENABLE VERIFICATION REQUIREMENT
PAR Das Kommando ENABLE VERIFICATION REQUIREMENT ändert das Attribut flagEnabled eines Passwortobjektes (siehe CosK_d13 und CosK_7f0) so, dass der Sicherheitszustand des Passwortes nur durch eine erfolgreiche Benutzerverifikation gesetzt wird. Welches Passwortobjekt betroffen ist, bestimmt eine Passwortreferenz, die als Parameter in der Kommandonachricht enthalten ist. Dieses Kommando gibt es in den Varianten mit und ohne Verifikationsdaten.
PAR -HEADING(ids=14.6.3.1)14.6.3.1 CosK_4e9 Use Case Einschalten der Benutzerverifikation mit Benutzergeheimnis
PAR In dieser Variante wird der Zwang zur Benutzerverifiaktion nicht eingeschaltet, falls das Benutzergeheimnis nicht korrekt ist. Die APDU des ENABLE VERIFICATION REQUIREMENT-Kommandos enthält zwei Parameter:
REQ(ids=A_16414)<b>A_16414 - (N076.580) K_externeWelt {K_Karte}</b>
PAR Der Parameter passwordReference referenziert das von der Aktion betroffene Passwort und MUSS gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_16415)<b>A_16415 - (N076.582) K_externeWelt {K_Karte}</b>
PAR Der Parameter verificationData enthält das Benutzergeheimnis. <b>[<=]</b>

REQ(ids=A_16416)<b>A_16416 - (N076.584) K_externeWelt {K_Karte}</b>
PAR Der Parameter verificationData MUSS gemäß (N008.100) codiert sein. <b>[<=]</b>

REQ(ids=A_16417)<b>A_16417 - (N076.586) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_887 verwendet werden.
PAR (ids=Tabelle-212,-CosT_887)Tabelle 212, CosT_887: ENABLE VERIFICATION REQUIREMENT mit Verifikationsdaten

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '28' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR Verifikationsdaten
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR passwordReference
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR verificationData
PAR <b>[<=]</b>

PAR -HEADING(ids=14.6.3.2)14.6.3.2 CosK_ceb Use Case Einschalten der Benutzerverifikation ohne Benutzergeheimnis
PAR In dieser Variante enthält die APDU des ENABLE VERIFICATION REQUIREMENT-Kommandos einen Parameter:
REQ(ids=A_16418)<b>A_16418 - (N076.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter passwordReference referenziert das von der Aktion betroffene Passwort und MUSS gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_16419)<b>A_16419 - (N076.700) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_44c verwendet werden.
PAR (ids=Tabelle-213,-CosT_44c)Tabelle 213, CosT_44c: ENABLE VERIFICATION REQUIREMENT ohne Verifikationsdaten

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '28' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '01' TD(3,2/1/1)->PAR Keine Verifikationsdaten
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR passwordReference
PAR <b>[<=]</b>

PAR -HEADING(ids=14.6.3.3)14.6.3.3 Antwort der Karte auf Einschalten der Benutzerverifikation
PAR (ids=Tabelle-214,-CosT_2a1)Tabelle 214, CosT_2a1: ENABLE VERIFICATION REQUIREMENT Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR WrongSecretWarning TD(1,2/1/1)->PAR verificationData ist falsch
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiches Einschalten des Passwortobjektes
PAR (ids=Tabelle-215,-CosT_903)Tabelle 215, CosT_903: ENABLE VERIFICATION REQUIREMENT Antwort-APDU im Fehlerfall

TABLE(rows=6,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '69 83' TD(3,1/1/1)->PAR PasswordBlocked TD(3,2/1/1)->PAR Abgelaufener Fehlbedienungszähler
TR-> TD(4,0/1/1)->PAR '69 85' TD(4,1/1/1)->PAR PasswordNotUsable TD(4,2/1/1)->PAR Passwort mit Transportschutz versehen
TR-> TD(5,0/1/1)->PAR '6A 88' TD(5,1/1/1)->PAR PasswordNotFound TD(5,2/1/1)->PAR Adressiertes Passwort wurde nicht gefunden
PAR Hinweis CosH_7c7: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16420)<b>A_16420 - (N076.800) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando ENABLE VERIFICATION REQUIREMENT verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.6.3.4)14.6.3.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N076.900.a)<b>G2_N076.900.a - (N076.900)a K_COS</b>
PAR Das COS MUSS die ENABLE VERIFICATION REQUIREMENT-Variante aus (N076.586) und (N076.700) unterstützen. <b>[<=]</b>

REQ(ids=A_16421)<b>A_16421 - (N076.900)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere ENABLE VERIFICATION REQUIREMENT-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N077.000)<b>G2_N077.000 - (N077.000) K_COS</b>
PAR Es gilt affectedObject = SearchPwd(currentFolder, passwordReference ). Wenn die Passwortsuche mit einem Fehler abbricht, genau dann MUSS das Kommando mit dem Trailer PasswordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N077.100)<b>G2_N077.100 - (N077.100) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

PAR (N077.200) Diese Anforderung ist absichtlich leer.
REQ(ids=A_16422)<b>A_16422 - (N077.300)a K_COS</b>
PAR Wenn der Parameter P1 den Wert '00' besitzt, dann MÜSSEN folgende Schritte abgearbeitet werden: <b>[<=]</b>

REQ(ids=G2_N077.300.a.1)<b>G2_N077.300.a.1 - (N077.300)a.1 K_COS</b>
PAR Schritt 1: Wenn affectedObject.retryCounter den Wert null besitzt, genau dann MUSS das Kommando mit dem Trailer PasswordBlocked terminieren. <b>[<=]</b>

REQ(ids=G2_N077.300.a.2)<b>G2_N077.300.a.2 - (N077.300)a.2 K_COS</b>
PAR Schritt 2: Wenn affectedObject.transportStatus nicht den Wert regularPassword besitzt, genau dann MUSS das Kommando mit dem Trailer PasswordNotUsable terminieren. <b>[<=]</b>

REQ(ids=A_16423)<b>A_16423 - (N077.300)a.3 K_COS</b>
PAR Schritt 3: Das Attribut affectedObject.secret MUSS mit verificationData verglichen werden. <b>[<=]</b>

REQ(ids=G2_N077.300.a.3.i)<b>G2_N077.300.a.3.i - (N077.300)a.3.i K_COS</b>
PAR Wenn der Vergleich fehlschlägt, genau dann MUSS<br>A. affectedObject.retryCounter um eins dekrementiert werden und<br>B. clearPasswordStatus( affectedObject ) ausgeführt werden und<br>C. das Kommando mit dem Trailer WrongSecretWarning terminieren. Das Lownibble des Trailers MUSS dabei auf den Wert 'F' gesetzt werden, wenn affectedObject.retryCounter größer als fünfzehn ist, andernfalls auf den Wert von affectedObject.retryCounter. <b>[<=]</b>

REQ(ids=A_16424)<b>A_16424 - (N077.300)a.3.ii K_COS</b>
PAR Wenn die Vergleichsoperation durch einen Reset abgebrochen wird, dann MUSS affectedObject.retryCounter um eins dekrementiert werden. <b>[<=]</b>

REQ(ids=G2_N077.300.a.3.iii)<b>G2_N077.300.a.3.iii - (N077.300)a.3.iii K_COS</b>
PAR Wenn der Vergleich erfolgreich ist, genau dann MUSS<br>A. das Attribut affectedObject.flagEnabled auf den Wert True gesetzt werden und<br>B. das Attribut affectedObject.retryCounter auf den Wert affectedObject.startRetryCounter gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N077.300.b)<b>G2_N077.300.b - (N077.300)b K_COS</b>
PAR Falls der Parameter P1 den Wert '01'besitzt, dann MUSS das Attribut affectedObject.flagEnabled auf den Wert True gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N077.310)<b>G2_N077.310 - (N077.310) K_COS</b>
PAR Alle persistenten Änderungen in (N077.300) MÜSSEN mit Transaktionsschutz ausgeführt werden. <b>[<=]</b>

PAR Wenn die Ausführung dieses Kommandos durch einen Reset abgebrochen wird, dann gilt für konditionale Änderung von affectedObject.retryCounter und die Änderung von affectedObject.flagEnabled:
REQ(ids=A_16425)<b>A_16425 - (N077.320)a K_COS</b>
PAR Alle Attribute SOLLEN gemeinsam in einer Transaktion geändert werden. <b>[<=]</b>

REQ(ids=A_16426)<b>A_16426 - (N077.320)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Attribut retryCounter würde in einer eigenen Transaktion zeitlich vor den anderen Attributen geändert. <b>[<=]</b>

PAR (N077.400) Diese Anforderung ist absichtlich leer.
REQ(ids=A_16427)<b>A_16427 - (N077.500) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

PAR (N077.600) Diese Anforderung ist absichtlich leer.
REQ(ids=G2_N077.700.a)<b>G2_N077.700.a - (N077.700)a K_COS</b>
PAR Wenn affectedObject.flagEnabled den Wert True besitzt, genau dann MUSS als Trailer NoError verwendet werden. <b>[<=]</b>

REQ(ids=A_16428)<b>A_16428 - (N077.700)b K_COS</b>
PAR Wenn affectedObject.flagEnabled den Wert False besitzt, dann ist MUSS PasswordBlocked eine höhere Priorität als PasswordNotUsable haben. Die Priorität der übrigen Trailer in CosT_903 ist bis auf folgende Ausnahme herstellerspezifisch.<br>1. PasswordBlocked MUSS eine höhere Priorität als PasswordNotUsable haben. <b>[<=]</b>

REQ(ids=G2_N077.700.c)<b>G2_N077.700.c - (N077.700)c K_COS</b>
PAR Jeder Trailer in CosT_903 MUSS eine höhere Priorität als WrongSecretWarning haben. <b>[<=]</b>

PAR -HEADING(ids=14.6.4)14.6.4 CosK_348 GET PIN STATUS
PAR Hinweis CosH_470: Dieses Kommando ist nicht in der Normenreihe ISO/IEC 7816 enthalten. Es ließe sich kombinieren mit dem Kommando VERIFY (leere Kommandodaten). Einem DIN NIA17.4 Votum gemäß wurde auf eine derartige Kombination verzichtet.
PAR Das Kommando GET PIN STATUS zeigt in den Antwortdaten an,

LIST->
LITEM->PAR ob der Sicherheitszustand des Passwortobjektes gesetzt ist.LITEM->PAR welchen Wert das Attribut retryCounter besitzt.LITEM->PAR ob ein Passwortobjekt mit einem Transportschutz versehen ist und falls ja, welches Transportschutzverfahren vom Passwortobjekt verwendet wird.LITEM->PAR ob eine Benutzerverifikation zum Setzen des Sicherheitsstatus erforderlich ist.
PAR Welches Passwortobjekt von diesem Kommando betroffen ist, bestimmt eine Passwortreferenz, die als Parameter in der Kommandonachricht enthalten ist.
PAR -HEADING(ids=14.6.4.1)14.6.4.1 CosK_e38 Use Case Auslesen des Status eines Passwortobjektes
PAR In dieser Variante enthält die APDU des GET PIN STATUS-Kommandos einen Parameter:
REQ(ids=A_16429)<b>A_16429 - (N077.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter passwordReference referenziert das von der Aktion betroffene Passwort und MUSS gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_16430)<b>A_16430 - (N077.900) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_891 verwendet werden.
PAR (ids=Tabelle-216,-CosT_891)Tabelle 216, CosT_891: GET PIN STATUS

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '80' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4], hier wird "proprietary" angezeigt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '20' TD(2,2/1/1)->PAR Instruction Byte (dies ist derselbe Wert wie beim Kommando VERIFY)
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR –
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR passwordReference
PAR <b>[<=]</b>

PAR -HEADING(ids=14.6.4.2)14.6.4.2 Antwort der Karte auf Auslesen des PIN Status
PAR (ids=Tabelle-217,-CosT_a97)Tabelle 217, CosT_a97: GET PIN STATUS Antwort-APDU im Erfolgsfall

TABLE(rows=5,cols=51+113+541)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '62 Cx':<br>'62 C1'<br>'62 C7' TD(1,1/1/1)->PAR TransportStatus<br>Transport–PIN<br>Leer–PIN TD(1,2/1/1)->PAR Passwortobjekt eingeschaltet, Passwortobjekt ist mit Transportschutz versehen, Transportschutzverfahren enthalten im Least Significant Nibble (siehe auch CosK_6b8)
TR-> TD(2,0/1/1)->PAR '62 D0' TD(2,1/1/1)->PAR PasswordDisabled TD(2,2/1/1)->PAR Passwortobjekt ausgeschaltet, Verifikation nicht erforderlich
TR-> TD(3,0/1/1)->PAR '63 Cx' TD(3,1/1/1)->PAR RetryCounter,<br>x ungleich null TD(3,2/1/1)->PAR Passwortobjekt eingeschaltet, Passwortobjekt ohne Transportschutz (das bedeutet regularPassword), Wert des Fehlbedienungszählers enthalten im Least Significant Nibble
TR-> TD(4,0/1/1)->PAR '90 00' TD(4,1/1/1)->PAR NoError TD(4,2/1/1)->PAR Passwortobjekt eingeschaltet, Sicherheitszustand gesetzt
PAR (ids=Tabelle-218, CosT_973)Tabelle 218, CosT_973: GET PIN STATUS Antwort-APDU im Fehlerfall

TABLE(rows=4,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 C0' TD(1,1/1/1)->PAR '63 Cx' = RetryCounter,<br>x gleich null TD(1,2/1/1)->PAR Passwortobjekt eingeschaltet, Passwortobjekt wegen Wert des Fehlbedienungszählers blockiert
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '6A 88' TD(3,1/1/1)->PAR PasswordNotFound TD(3,2/1/1)->PAR Adressiertes Passwort wurde nicht gefunden
PAR Hinweis CosH_971: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16431)<b>A_16431 - (N078.000) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando GET PIN STATUS verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.6.4.3)14.6.4.3 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N078.100.a)<b>G2_N078.100.a - (N078.100)a K_COS</b>
PAR Das COS MUSS die GET PIN STATUS-Variante aus (N077.900) unterstützen. <b>[<=]</b>

REQ(ids=A_16432)<b>A_16432 - (N078.100)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere GET PIN STATUS-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N078.200)<b>G2_N078.200 - (N078.200) K_COS</b>
PAR Es gilt affectedObject = SearchPwd(currentFolder, passwordReference ). Wenn die Passwortsuche mit einem Fehler abbricht, genau dann MUSS das Kommando mit dem Trailer PasswordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N078.300)<b>G2_N078.300 - (N078.300) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=A_18043)<b>A_18043 - (N078.350) K_COS</b>
PAR Wenn affectedObject.retryCounter den Wert null hat, genau dann MUSS das Kommando mit dem Trailer '63 C0' terminieren. <b>[<=]</b>

REQ(ids=G2_N078.400)<b>G2_N078.400 - (N078.400) K_COS</b>
PAR Wenn das Attribut affectedObject.flagEnabled (siehe (N015.700)) den Wert False besitzt, genau dann MUSS als Trailer PasswordDisabled verwendet werden. <b>[<=]</b>

REQ(ids=G2_N078.500)<b>G2_N078.500 - (N078.500) K_COS</b>
PAR Wenn affectedObject.flagEnabled (siehe (N015.700)) den Wert True besitzt und affectedObject in globalPasswordList (siehe (N029.900)i) oder in dfSpecificPasswordList (siehe (N029.900)j) enthalten ist und dort das Attribut securityStatusEvaluationCounter (siehe (N029.900)k) einen Wert ungleich null besitzt, genau dann MUSS als Trailer NoError verwendet werden. <b>[<=]</b>

REQ(ids=G2_N078.600)<b>G2_N078.600 - (N078.600) K_COS</b>
PAR Wenn das Attribut affectedObject.transportStatus (siehe (N015.600)) einen Wert ungleich regularPassword besitzt, genau dann MUSS als Trailer TransportStatus verwendet werden mit TransportStatus = '62 Cx'. Dabei ist 'x' durch die Codierung von affectedObject.transportStatus gemäß CosT_a97 zu ersetzen. <b>[<=]</b>

REQ(ids=G2_N078.700)<b>G2_N078.700 - (N078.700) K_COS</b>
PAR Wenn das Attribut affectedObject.transportStatus (siehe (N015.600)) den Wert regularPassword besitzt, genau dann MUSS als Trailer RetryCounter verwendet werden mit RetryCounter = '63 Cx'. Dabei ist 'x' zu ersetzen durch das Minimum der beiden Zahlen 15 = 'F' und affectedObject.retryCounter. <b>[<=]</b>

REQ(ids=A_16433)<b>A_16433 - (N078.800)a K_TST</b>
PAR Die Priorität der Trailer in CosT_973 MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N078.800.b)<b>G2_N078.800.b - (N078.800)b K_COS</b>
PAR Jeder Trailer in CosT_973 MUSS eine höhere Priorität als PasswordDisabled haben. <b>[<=]</b>

REQ(ids=G2_N078.800.c)<b>G2_N078.800.c - (N078.800)c K_COS</b>
PAR PasswordDisabled MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

REQ(ids=G2_N078.800.d)<b>G2_N078.800.d - (N078.800)d K_COS</b>
PAR NoError MUSS eine höhere Priorität als TransportStatus haben. <b>[<=]</b>

REQ(ids=G2_N078.800.e)<b>G2_N078.800.e - (N078.800)e K_COS</b>
PAR TransportStatus MUSS eine höhere Priorität als RetryCounter haben. <b>[<=]</b>

PAR Hinweis CosH_73f: Gemäß (N078.600), (N078.700) und (N078.800) ist es nicht möglich den Fehlbedienungszähler auszulesen, wenn Transportschutz besteht. Gemäß (N078.350) und (N078.800)b wird ein blockiertes Passwortobjekt auch bei bestehendem Transportschutz erkannt.
PAR -HEADING(ids=14.6.5)14.6.5 CosK_5e0 RESET RETRY COUNTER
PAR Das Kommando RESET RETRY COUNTER setzt das Attribut retryCounter eines Passwortobjektes auf den Startwert startRetryCounter. Welches Passwortobjekt betroffen ist, bestimmt eine Passwortreferenz, die als Parameter in der Kommandonachricht enthalten ist. Dieses Kommando gibt es in den Varianten

LIST->
LITEM->PAR mit   PUK, mit    neuem Wert für das Attribut secret des PasswortobjektesLITEM->PAR mit   PUK, ohne neuem Wert für das Attribut secret des PasswortobjektesLITEM->PAR ohne PUK, mit   neuem Wert für das Attribut secret des PasswortobjektesLITEM->PAR ohne PUK, ohne neuem Wert für das Attribut secret des Passwortobjektes
PAR Die Variante "mit PUK" wird typischerweise verwendet, wenn eine Person (etwa der Karteninhaber) das Recht zur Durchführung dieser Aktion besitzt.
PAR Die Variante "ohne PUK" wird typischerweise verwendet, wenn eine technische Instanz (etwa das CMS) diese Aktion durchzuführen hat. In den Zugriffsbedingungen wird dann typischerweise zumindest eine Rollenauthentisierung gefordert.
PAR Die Variante "mit neuem Geheimnis" wird typischerweise gewählt, wenn der Karteninhaber sein Passwort definitiv vergessen hat.
PAR Die Variante "ohne neues Geheimnis" wird typischerweise gewählt, wenn es der Instanz, welche zum Rücksetzen des Fehlbedienungszählers berechtigt ist, verboten ist, durch das Passwort geschützte Aktionen auszuführen. Dies ist häufig im Umfeld qualifizierter Signaturanwendungen und dem Signaturpasswort anzutreffen.
PAR -HEADING(ids=14.6.5.1)14.6.5.1 CosK_b08 Use Case Entsperren mit PUK, mit neuem Geheimnis
PAR In dieser Variante enthält die APDU des RESET RETRY COUNTER-Kommandos drei Parameter:
REQ(ids=A_16444)<b>A_16444 - (N078.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter passwordReference referenziert das von der Aktion betroffene Passwort und MUSS gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_16445)<b>A_16445 - (N079.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter PUK MUSS ein Geheimnis enthalten, welches diese Aktion autorisiert. <b>[<=]</b>

REQ(ids=A_16446)<b>A_16446 - (N079.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter newSecret MUSS das neue Benutzergeheimnis enthalten. <b>[<=]</b>

REQ(ids=A_16447)<b>A_16447 - (N079.200) K_externeWelt {K_Karte}</b>
PAR Die Parameter PUK und newSecret MÜSSEN gemäß (N008.100) codiert sein. <b>[<=]</b>

REQ(ids=A_16448)<b>A_16448 - (N079.300) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_0d1 verwendet werden.
PAR (ids=Tabelle-219,-CosT_0d1)Tabelle 219, CosT_0d1: RESET RETRY COUNTER, mit PUK, mit newSecret

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2C' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR Data enthält PUK und neues Benutzergeheimnis
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR passwordReference
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR PUK   ||   newSecret
PAR <b>[<=]</b>

PAR -HEADING(ids=14.6.5.2)14.6.5.2 CosK_454 Use Case Entsperren mit PUK, ohne neues Geheimnis
PAR In dieser Variante enthält die APDU des RESET RETRY COUNTER-Kommandos zwei Parameter:
REQ(ids=A_16449)<b>A_16449 - (N079.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter passwordReference referenziert das von der Aktion betroffene Passwort und MUSS gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_16450)<b>A_16450 - (N079.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter PUK enthält ein Geheimnis, welches diese Aktion autorisiert. <b>[<=]</b>

REQ(ids=A_16451)<b>A_16451 - (N079.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter PUK MUSS gemäß (N008.100) codiert sein. <b>[<=]</b>

REQ(ids=A_16452)<b>A_16452 - (N079.700) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_f19 verwendet werden.
PAR (ids=Tabelle-220,-CosT_f19)Tabelle 220, CosT_f19: RESET RETRY COUNTER, mit PUK, ohne newSecret

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2C' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '01' TD(3,2/1/1)->PAR Data enthält nur PUK
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR passwordReference
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR PUK
PAR <b>[<=]</b>

PAR -HEADING(ids=14.6.5.3)14.6.5.3 CosK_803 Use Case Entsperren ohne PUK, mit neuem Geheimnis
PAR In dieser Variante enthält die APDU des RESET RETRY COUNTER-Kommandos zwei Parameter:
REQ(ids=A_16453)<b>A_16453 - (N079.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter passwordReference referenziert das von der Aktion betroffene Passwort und MUSS gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_16454)<b>A_16454 - (N079.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter newSecret enthält das neue Benutzergeheimnis. <b>[<=]</b>

REQ(ids=A_16455)<b>A_16455 - (N080.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter newSecret MUSS gemäß (N008.100) codiert sein. <b>[<=]</b>

REQ(ids=A_16456)<b>A_16456 - (N080.100) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_a37 verwendet werden.
PAR (ids=Tabelle-221,-CosT_a37)Tabelle 221, CosT_a37: RESET RETRY COUNTER, ohne PUK, mit newSecret

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2C' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '02' TD(3,2/1/1)->PAR Data enthält nur neues Benutzergeheimnis
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR passwordReference
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR newSecret
PAR <b>[<=]</b>

PAR -HEADING(ids=14.6.5.4)14.6.5.4 CosK_3ad Use Case Entsperren ohne PUK, ohne neues Geheimnis
PAR In dieser Variante enthält die APDU des RESET RETRY COUNTER-Kommandos einen Parameter:
REQ(ids=A_16457)<b>A_16457 - (N080.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter passwordReference referenziert das von der Aktion betroffene Passwort und MUSS gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_16458)<b>A_16458 - (N080.300) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_551 verwendet werden.
PAR (ids=Tabelle-222,-CosT_551)Tabelle 222, CosT_551: RESET RETRY COUNTER, ohne PUK, ohne newSecret

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2C' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '03' TD(3,2/1/1)->PAR Kommandodatenfeld fehlt
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR passwordReference
PAR <b>[<=]</b>

PAR -HEADING(ids=14.6.5.5)14.6.5.5 Antwort der Karte auf Entsperren eines Benutzergeheimnisses
PAR (ids=Tabelle-223,-CosT_f92)Tabelle 223, CosT_f92: RESET RETRY COUNTER Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR WrongSecretWarning TD(1,2/1/1)->PAR PUK ist falsch
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiches Rücksetzen des Fehlbedienungszählers
PAR (ids=Tabelle-224,-CosT_a92)Tabelle 224, CosT_a92: RESET RETRY COUNTER Antwort-APDU im Fehlerfall

TABLE(rows=7,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '69 83' TD(3,1/1/1)->PAR CommandBlocked TD(3,2/1/1)->PAR Bedienungszähler der PUK abgelaufen
TR-> TD(4,0/1/1)->PAR '69 85' TD(4,1/1/1)->PAR LongPassword TD(4,2/1/1)->PAR newData enthält ein zu langes Passwort
TR-> TD(5,0/1/1)->PAR '69 85' TD(5,1/1/1)->PAR ShortPassword TD(5,2/1/1)->PAR newData enthält ein zu kurzes Passwort
TR-> TD(6,0/1/1)->PAR '6A 88' TD(6,1/1/1)->PAR PasswordNotFound TD(6,2/1/1)->PAR Adressiertes Passwort wurde nicht gefunden
PAR Hinweis CosH_775: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16459)<b>A_16459 - (N080.400) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando RESET RETRY COUNTERverwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.6.5.6)14.6.5.6 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N080.500.a)<b>G2_N080.500.a - (N080.500)a K_COS</b>
PAR Das COS MUSS die RESET RETRY COUNTER-Varianten aus (N079.300), (N079.700), (N080.100) und (N080.300) unterstützen. <b>[<=]</b>

REQ(ids=A_16460)<b>A_16460 - (N080.500)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere RESET RETRY COUNTER-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N080.600)<b>G2_N080.600 - (N080.600) K_COS</b>
PAR Es gilt affectedObject = SearchPwd(currentFolder, passwordReference ). Wenn die Passwortsuche mit einem Fehler abbricht, genau dann MUSS das Kommando mit dem Trailer PasswordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N080.700)<b>G2_N080.700 - (N080.700) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N080.800.a)<b>G2_N080.800.a - (N080.800)a K_COS</b>
PAR Wenn die konditional vorhandene und in newSecret codierte Ziffernfolge für das Attribut secret des Passwortobjektes eine Länge hat, die kleiner als affectedObject.minimumLength ist, genau dann MUSS das Kommando mit dem Trailer ShortPassword terminieren. <b>[<=]</b>

REQ(ids=G2_N080.800.b)<b>G2_N080.800.b - (N080.800)b K_COS</b>
PAR Wenn die konditional vorhandene und in newSecret codierte Ziffernfolge für das Attribut secret des Passwortobjektes eine Länge hat, die größer als affectedObject.maximumLength ist, genau dann MUSS das Kommando mit dem Trailer LongPassword terminieren. <b>[<=]</b>

REQ(ids=G2_N080.900)<b>G2_N080.900 - (N080.900) K_COS</b>
PAR Mittels clearPasswordStatus( affectedObject ) MUSS der Sicherheitsstatus zurückgesetzt werden. <b>[<=]</b>

REQ(ids=A_16461)<b>A_16461 - (N081.000) K_COS</b>
PAR Wenn das Kommandodatenfeld einen Parameter PUK enthält, genau dann MUSS dieser mit dem Attribut affectedObject.PUK verglichen werden. <b>[<=]</b>

REQ(ids=G2_N081.000.a)<b>G2_N081.000.a - (N081.000)a K_COS</b>
PAR Wenn affectedObject.pukUsage den Wert null besitzt, genau dann MUSS das Kommando mit dem Trailer CommandBlocked terminieren. <b>[<=]</b>

REQ(ids=A_16462)<b>A_16462 - (N081.000)b K_COS</b>
PAR affectedObject.pukUsage MUSS mit Transaktionsschutz um eins dekrementiert werden. <b>[<=]</b>

REQ(ids=G2_N081.000.c)<b>G2_N081.000.c - (N081.000)c K_COS</b>
PAR Wenn der Vergleich fehlschlägt, genau dann MUSS das Kommando mit dem Trailer WrongSecretWarning terminieren. Das Lownibble des Trailers MUSS dabei auf den Wert 'F' gesetzt werden, wenn affectedObject.pukUsage größer als fünfzehn ist, andernfalls auf den Wert von affectedObject.pukUsage. <b>[<=]</b>

PAR Hinweis CosH_b46: Die Bearbeitungsreihenfolge der Punkte (N080.700), (N080.800), (N080.900) und (N081.000) ist COS spezifisch. Deshalb ist es COS spezifisch, ob in gewissen Fehlerfällen der Sicherheitsstatus von affectedObject zurückgesetzt wird oder nicht.
REQ(ids=G2_N081.100)<b>G2_N081.100 - (N081.100) K_COS</b>
PAR Das Attribut affectedObject.retryCounter MUSS auf den Wert affectedObject.startRetryCounter gesetzt werden. <b>[<=]</b>

REQ(ids=A_16463)<b>A_16463 - (N081.200) K_COS</b>
PAR Wenn das Kommandodatenfeld einen Parameter newSecret enthält, genau dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N081.200.a)<b>G2_N081.200.a - (N081.200)a K_COS</b>
PAR Schritt 1: affectedObject.secret MUSS auf den in newSecret codierten Wert gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N081.200.b)<b>G2_N081.200.b - (N081.200)b K_COS</b>
PAR Schritt 2: affectedObject.transportStatus MUSS auf den Wert "regularPassword" (siehe (N009.500)) gesetzt werden, falls dieses Attribut einen anderen Wert besitzt. <b>[<=]</b>

REQ(ids=G2_N081.300)<b>G2_N081.300 - (N081.300) K_COS</b>
PAR Die persistenten Änderungen in (N081.000), (N081.100) und (N081.200) MÜSSEN mit Transaktionsschutz ausgeführt werden. <b>[<=]</b>

PAR (N081.400) Diese Anforderung ist absichtlich leer.
REQ(ids=A_16464)<b>A_16464 - (N081.500) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N081.600)<b>G2_N081.600 - (N081.600) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16465)<b>A_16465 - (N081.700)a K_TST</b>
PAR Die Priorität der Trailer in CosT_a92 MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N081.700.b)<b>G2_N081.700.b - (N081.700)b K_COS</b>
PAR Jeder Trailer in CosT_a92 MUSS eine höhere Priorität als WrongSecretWarning haben. <b>[<=]</b>

REQ(ids=G2_N081.700.c)<b>G2_N081.700.c - (N081.700)c K_COS</b>
PAR WrongSecretWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR Wenn die Ausführung dieses Kommandos durch einen Reset abgebrochen wird, dann gilt für die möglichen Änderungen von secret, transportStatus und retryCounter:
REQ(ids=G2_N081.800.a)<b>G2_N081.800.a - (N081.800)a K_COS</b>
PAR Alle Änderungen SOLLEN gemeinsam in einer Transaktion geändert werden. <b>[<=]</b>

REQ(ids=A_16466)<b>A_16466 - (N081.800)b.1 K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden die Änderungen von secret, transportStatus oder retryCounter fänden in eigenen Transaktionen statt. <b>[<=]</b>

REQ(ids=G2_N081.800.b)<b>G2_N081.800.b - (N081.800)b.2 K_COS</b>
PAR Wenn die Änderungen von secret, transportStatus oder retryCounter in eigenen Transaktionen stattfinden, dann MUSS retryCounter als letztes geändert werden. <b>[<=]</b>

PAR -HEADING(ids=14.6.6)14.6.6 CosK_2ec VERIFY
PAR Das Kommando VERIFY vergleicht das Attribut secret eines Passwortobjektes mit Daten, die im Datenfeld der Kommandonachricht enthalten sind. Falls der Vergleich erfolgreich ist, wird der Sicherheitszustand der Karte geändert. Welches Passwortobjekt betroffen ist, bestimmt eine Passwortreferenz, die als Parameter in der Kommandonachricht enthalten ist.
PAR -HEADING(ids=14.6.6.1)14.6.6.1 CosK_271 Use Case Vergleich eines Benutzergeheimnisses
PAR In dieser Variante enthält die APDU des VERIFY Kommandos zwei Parameter:
REQ(ids=A_16467)<b>A_16467 - (N081.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter passwordReference referenziert das von der Aktion betroffene Passwort und MUSS gemäß (N072.800) gewählt werden. <b>[<=]</b>

REQ(ids=A_16468)<b>A_16468 - (N082.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter verificationData enthält das Benutzergeheimnis. <b>[<=]</b>

REQ(ids=A_16469)<b>A_16469 - (N082.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter verificationData MUSS gemäß (N008.100) codiert sein. <b>[<=]</b>

REQ(ids=A_16470)<b>A_16470 - (N082.200) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_3b5 verwendet werden.
PAR (ids=Tabelle-225,-CosT_3b5)Tabelle 225, CosT_3b5: VERIFY, Vergleich eines Benutzergeheimnisses

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '20' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR Data enthält Verifikationsdaten
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR passwordReference
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR verificationData
PAR <b>[<=]</b>

PAR -HEADING(ids=14.6.6.2)14.6.6.2 Antwort der Karte auf Vergleich eines Benutzergeheimnisses
PAR (ids=Tabelle-226,-CosT_148)Tabelle 226, CosT_148: VERIFY Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR WrongSecretWarning TD(1,2/1/1)->PAR verificationData ist falsch
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreicher Vergleich
PAR (ids=Tabelle-227,-CosT_49d)Tabelle 227, CosT_49d: VERIFY Antwort-APDU im Fehlerfall

TABLE(rows=6,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '69 83' TD(3,1/1/1)->PAR PasswordBlocked TD(3,2/1/1)->PAR Abgelaufener Fehlbedienungszähler
TR-> TD(4,0/1/1)->PAR '69 85' TD(4,1/1/1)->PAR PasswordNotUsable TD(4,2/1/1)->PAR Passwort mit Transportschutz versehen
TR-> TD(5,0/1/1)->PAR '6A 88' TD(5,1/1/1)->PAR PasswordNotFound TD(5,2/1/1)->PAR Adressiertes Passwort wurde nicht gefunden
PAR Hinweis CosH_839: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16471)<b>A_16471 - (N082.300) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando VERIFY verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.6.6.3)14.6.6.3 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N082.400.a)<b>G2_N082.400.a - (N082.400)a K_COS</b>
PAR Das COS MUSS die VERIFY-Variante aus (N082.200) unterstützen. <b>[<=]</b>

REQ(ids=A_16472)<b>A_16472 - (N082.400)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere VERIFY-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N082.500)<b>G2_N082.500 - (N082.500) K_COS</b>
PAR Es gilt affectedObject = SearchPwd(currentFolder, passwordReference ). Wenn die Passwortsuche mit einem Fehler abbricht, genau dann MUSS das Kommando mit dem Trailer PasswordNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N082.600)<b>G2_N082.600 - (N082.600) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N082.700)<b>G2_N082.700 - (N082.700) K_COS</b>
PAR Wenn affectedObject.retryCounter den Wert null besitzt, genau dann MUSS das Kommando mit dem Trailer PasswordBlocked terminieren. <b>[<=]</b>

REQ(ids=G2_N082.800)<b>G2_N082.800 - (N082.800) K_COS</b>
PAR Wenn affectedObject.transportStatus nicht den Wert regularPassword besitzt, genau dann MUSS das Kommando mit dem Trailer PasswordNotUsable terminieren. <b>[<=]</b>

REQ(ids=A_16473)<b>A_16473 - (N082.900) K_COS</b>
PAR Das Attribut affectedObject.secret MUSS mit verificationData verglichen werden. <b>[<=]</b>

REQ(ids=G2_N082.900.a)<b>G2_N082.900.a - (N082.900)a K_COS</b>
PAR Wenn der Vergleich fehlschlägt, genau dann MUSS<br>1. affectedObject.retryCounter um eins dekrementiert werden und<br>2. clearPasswordStatus( affectedObject ) ausgeführt werden und<br>3. das Kommando mit dem Trailer WrongSecretWarning terminieren. Das Lownibble des Trailers MUSS dabei auf den Wert 'F' gesetzt werden, wenn affectedObject.retryCounter größer als fünfzehn ist, andernfalls auf den Wert von affectedObject.retryCounter. <b>[<=]</b>

REQ(ids=G2_N082.900.b)<b>G2_N082.900.b - (N082.900)b K_COS</b>
PAR Wenn die Vergleichsoperation durch einen Reset abgebrochen wird, dann MUSS affectedObject.retryCounter um eins dekrementiert werden. <b>[<=]</b>

REQ(ids=A_16474)<b>A_16474 - (N082.900)c K_COS</b>
PAR Wenn der Vergleich erfolgreich ist, genau dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N082.900.c.1)<b>G2_N082.900.c.1 - (N082.900)c.1 K_COS</b>
PAR Schritt 1: Es MUSS setPasswordStatus( affectedObject ) ausgeführt werden. <b>[<=]</b>

REQ(ids=G2_N082.900.c.2)<b>G2_N082.900.c.2 - (N082.900)c.2 K_COS</b>
PAR Schritt 2: Das Attribut MUSS affectedObject.retryCounter auf den Wert affectedObject.startRetryCounter gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N082.900.c.3)<b>G2_N082.900.c.3 - (N082.900)c.3 K_COS</b>
PAR Die Änderung von affectedObject.retryCounter MUSS mit Transaktionsschutz ausgeführt werden. <b>[<=]</b>

PAR (N083.000) Diese Anforderung ist absichtlich leer.
REQ(ids=A_16475)<b>A_16475 - (N083.100) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N083.200)<b>G2_N083.200 - (N083.200) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16476)<b>A_16476 - (N083.300)a K_COS</b>
PAR PasswordBlocked MUSS eine höhere Priorität als PasswordNotUsable haben. Die Priorität der übrigen Trailer in CosT_49d ist bis auf folgende Ausnahme herstellerspezifisch.<br> 1. PasswordBlocked MUSS eine höhere Priorität als PasswordNotUsable haben. <b>[<=]</b>

REQ(ids=G2_N083.300.b)<b>G2_N083.300.b - (N083.300).b K_COS</b>
PAR Jeder Trailer in CosT_49d MUSS eine höhere Priorität als WrongSecretWarning haben. <b>[<=]</b>

REQ(ids=A_16477)<b>A_16477 - (N083.300)c) K_COS</b>
PAR WrongSecretWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.7)14.7 Komponentenauthentisierung
PAR -HEADING(ids=14.7.1)14.7.1 CosK_e22 EXTERNAL AUTHENTICATE / MUTUAL AUTHENTICATE
PAR Die Kommandos EXTERNAL AUTHENTICATE und MUTUAL AUTHENTICATE prüfen die Authentizität einer externen Instanz anhand der Antwort auf ein von der Karte generiertes Token, mittels eines symmetrischen oder öffentlichen Schlüssels. Der Schlüssel wird vor der Authentisierungsoperation ausgewählt. Dies geschieht vor dem Senden dieses Kommandos durch ein MSE-Set-Kommando (siehe (N101.400), (N101.900), (N102.400)). Die Antwort der externen Instanz auf das von der Karte generierte Token ist als Parameter in der Kommandonachricht enthalten.
PAR Hinweis CosH_233: In [gemSpec_eGK_P1] wurden die Varianten EXTERNAL versus MUTUAL anhand eines Algorithm Identifiers unterschieden. Hier werden die Varianten, wie schon in [HBA_P1], anhand des LeFeldes unterschieden
PAR Hinweis CosH_e15: Der Wert '82' für das INS-Byte wird für die Kommandovarianten EXTERNAL AUTHENTICATE und MUTUAL AUTHENTICATE verwendet. Die Varianten lassen sich anhand der Existenz des LeFeldes unterscheiden. Davon wird in (N084.400) und (N084.410) Gebrauch gemacht. Dies schließt die Verwendung des Protokolls T=0 für Karten in der Telematikinfrastruktur aus. Dies erscheint vertretbar, da es derzeit für die Verwendung des Protokolls T=0 keine Anforderung gibt.
PAR -HEADING(ids=14.7.1.1)14.7.1.1 CosK_021 Use Case Externes Authentisieren ohne Antwortdaten
PAR In dieser Variante enthält die APDU des EXTERNAL AUTHENTICATE-Kommandos einen Parameter:
REQ(ids=A_16479)<b>A_16479 - (N083.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter cmdData enthält die Antwort der externen Instanz. Der Parameter cmdData ist ein Oktettstring mit beliebigem Inhalt. Die Länge von cmdData MUSS abhängig von der mittels (N101.300), (N101.800) oder (N102.300) ausgewählten algId gewählt werden. <b>[<=]</b>

REQ(ids=A_16480)<b>A_16480 - (N083.400)a K_externeWelt {K_Karte}</b>
PAR Wenn algId gleich elcRoleCheck ist, dann MUSS unter Hinzuziehung der Domainparameter des öffentlichen Schlüssels gelten: 8 OctetLength(cmdData) = 2 domainParameter.t. <b>[<=]</b>

PAR (N083.400)b ist absichtlich leer.<br>(N083.400)c ist absichtlich leer.
REQ(ids=A_16481)<b>A_16481 - (N083.400)b K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Wenn algId gleich rsaRoleCheck ist, dann MUSS cmdData genauso viele Oktette enthalten, wie der Modulus des Authentisierungsschlüssels. <b>[<=]</b>

REQ(ids=A_16482)<b>A_16482 - (N083.400)c K_externeWelt {K_Karte}, Option_DES</b>
PAR Wenn algId gleich rsaSessionkey4SM ist, dann MUSS cmdData genauso viele Oktette enthalten, wie der Modulus des Authentisierungsschlüssels. <b>[<=]</b>

REQ(ids=A_16483)<b>A_16483 - (N083.402)a K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Wenn algId gleich aesSessionkey4TC ist, dann MUSS cmdData gleich 120 Oktett lang sein. <b>[<=]</b>

PAR (N083.402)b ist absichtlich leer.<br>(N083.402)c ist absichtlich leer.
REQ(ids=A_16484)<b>A_16484 - (N083.402)b K_externeWelt {K_Karte}, Option_Kryptobox und Option_DES</b>
PAR Wenn algId gleich desSessionkey4TC ist, dann MUSS cmdData gleich 104 Oktett lang sein. <b>[<=]</b>

REQ(ids=A_16485)<b>A_16485 - (N083.402)c K_externeWelt {K_Karte}, Option_Kryptobox und Option_DES</b>
PAR Wenn algId gleich rsaSessionkey4TC ist, dann MUSS cmdData genauso viele Oktette enthalten, wie der Modulus des Authentisierungsschlüssels. <b>[<=]</b>

REQ(ids=A_16486)<b>A_16486 - (N083.500) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 oder eine Case 3E Kommando-APDU gemäß CosK_afd über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_c1c verwendet werden.
PAR (ids=Tabelle-228,-CosT_c1c)Tabelle 228, CosT_c1c: EXTERNAL AUTHENTICATE ohne Antwortdaten

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '82' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR Information zum Algorithmus bereits in der Karte vorhanden
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR Schlüsselreferenz bereits in der Karte vorhanden
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR cmdData
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.1.2)14.7.1.2 CosK_fe9 Use Case Externes Authentisieren mit Antwortdaten
PAR In dieser Variante enthält die APDU des MUTUAL AUTHENTICATE-Kommandos zwei Parameter:
REQ(ids=A_16491)<b>A_16491 - (N083.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter cmdData enthält die Antwort der externen Instanz. Der Parameter cmdData ist ein Oktettstring mit beliebigem Inhalt. Die Länge von cmdData MUSS abhängig von der mittels (N102.300) ausgewählten algId gewählt werden. <b>[<=]</b>

REQ(ids=A_16492)<b>A_16492 - (N083.600)a K_externeWelt {K_Karte}</b>
PAR Wenn algId gleich aesSessionkey4SM ist, dann MUSS cmdData 120 Oktett lang sein. <b>[<=]</b>

PAR (N083.600)b ist absichtlich leer.
REQ(ids=A_16493)<b>A_16493 - (N083.600)b K_externeWelt {K_Karte}, Option_DES</b>
PAR Wenn algId gleich desSessionkey4SM ist, dann MUSS cmdData 104 Oktett lang sein. <b>[<=]</b>

REQ(ids=A_16494)<b>A_16494 - (N083.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardShort sein. <b>[<=]</b>

REQ(ids=A_16495)<b>A_16495 - (N083.800) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_fe0 verwendet werden.
PAR (ids=Tabelle-229,-CosT_fe0)Tabelle 229, CosT_fe0: MUTUAL AUTHENTICATE mit Antwortdaten

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '82' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR Information zum Algorithmus bereits in der Karte vorhanden
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR Schlüsselreferenz bereits in der Karte vorhanden
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR cmdData
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '00' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.1.3)14.7.1.3 Antwort der Karte auf Externes Authentisieren
PAR (ids=Tabelle-230,-CosT_1fd)Tabelle 230, CosT_1fd: EXTERNAL AUTHENTICATE Antwort-APDU im Erfolgsfall

TABLE(rows=5,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)->PAR authData TD(1,2/1/1)->PAR Authentisierungsdaten (konditional, abhängig von algId)
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '63 00' TD(3,1/1/1)->PAR AuthenticationFailure TD(3,2/1/1)->PAR Authentisierung fehlgeschlagen
TR-> TD(4,0/1/1)->PAR '90 00' TD(4,1/1/1)->PAR NoError TD(4,2/1/1)->PAR Erfolgreiche Authentisierung
PAR (ids=Tabelle-231,-CosT_e88)Tabelle 231, CosT_e88: EXTERNAL AUTHENTICATE Antwort-APDU im Fehlerfall

TABLE(rows=10,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '69 82' TD(1,1/1/1)->PAR SecurityStatusNotSatisfied TD(1,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(2,0/1/1)->PAR '69 83' TD(2,1/1/1)->PAR KeyExpired TD(2,2/1/1)->PAR Gültigkeitszeitraum des Schlüssels ist abgelaufen
TR-> TD(3,0/1/1)->PAR '69 85' TD(3,1/1/1)->PAR NoKeyReference TD(3,2/1/1)->PAR Kein Authentisierungsschlüssel ausgewählt
TR-> TD(4,0/1/1)->PAR '69 85' TD(4,1/1/1)->PAR NoPrkReference TD(4,2/1/1)->PAR Kein Entschlüsselungsschlüssel ausgewählt
TR-> TD(5,0/1/1)->PAR '69 85' TD(5,1/1/1)->PAR NoRandom TD(5,2/1/1)->PAR Keine Zufallszahl vorhanden (siehe auch CosK_9bd)
TR-> TD(6,0/1/1)->PAR '69 85' TD(6,1/1/1)->PAR WrongRandomLength TD(6,2/1/1)->PAR Zufallszahl hat die falsche Länge
TR-> TD(7,0/1/1)->PAR '6A 81' TD(7,1/1/1)->PAR UnsupportedFunction TD(7,2/1/1)->PAR Schlüssel unterstützt den angegeben Algorithmus nicht
TR-> TD(8,0/1/1)->PAR '6A 88' TD(8,1/1/1)->PAR KeyNotFound TD(8,2/1/1)->PAR Authentisierungsschlüssel nicht gefunden
TR-> TD(9,0/1/1)->PAR '6A 88' TD(9,1/1/1)->PAR PrKNotFound TD(9,2/1/1)->PAR Entschlüsselungsschlüssel nicht gefunden
PAR Hinweis CosH_34e: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16496)<b>A_16496 - (N083.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando EXTERNAL AUTHENTICATE verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.7.1.4)14.7.1.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N084.000.a)<b>G2_N084.000.a - (N084.000)a K_COS</b>
PAR Das COS MUSS die EXTERNAL AUTHENTICATE-Variante aus (N083.500) und (N083.800) unterstützen. <b>[<=]</b>

REQ(ids=G2_N084.000.b)<b>G2_N084.000.b - (N084.000)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere EXTERNAL AUTHENTICATE-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N084.100)<b>G2_N084.100 - (N084.100) K_COS</b>
PAR Wenn RND.ICC den Wert "NoRandom" besitzt (siehe (N099.300), (N029.900)b und CosK_8e4), genau dann MUSS das Kommando mit dem Trailer NoRandom terminieren. <b>[<=]</b>

REQ(ids=G2_N084.200.a)<b>G2_N084.200.a - (N084.200)a K_COS</b>
PAR Wenn channelContext.keyReferenceList.externalAuthenticate leer ist, genau dann MUSS das Kommando mit dem Trailer NoKeyReference terminieren. <b>[<=]</b>

REQ(ids=A_16497)<b>A_16497 - (N084.200)b K_COS</b>
PAR Wenn channelContext.keyReferenceList.externalAuthenticate nicht leer ist, dann wird<br>affectedObject = SearchKey(    <br>    channelContext.currentFolder<br>    keyReferenceList.externalAuthenticate.keyReference,<br>    keyReferenceList.externalAuthenticate.algID<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. Wenn die Schlüsselsuche den Fehler<br>1. keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren.<br>2. notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N084.220.a)<b>G2_N084.220.a - (N084.220)a K_COS</b>
PAR Das Kommando MUSS mit dem Trailer WrongRandomLength terminieren, falls RND.ICC eine Länge ungleich 16 von acht Oktetten besitzt und keyReferenceList.externalAuthenticate.algID Element der folgenden Menge ist: {aesSessionkey4*, elcRoleCheck}. <b>[<=]</b>

PAR (N084.220)b ist absichtlich leer.
REQ(ids=G2_N084.220.b)<b>G2_N084.220.b - (N084.220)b K_COS, Option_DES, Option_RSA_CVC</b>
PAR Das Kommando MUSS mit dem Trailer WrongRandomLength terminieren, falls RND.ICC eine Länge von 16 Oktetten besitzt und keyReferenceList.externalAuthenticate.algID Element der folgenden Menge ist: {<br>    desSessionkey4* (Option_DES),<br>    rsa*                     (Option_RSA_CVC)<br>}. <b>[<=]</b>

REQ(ids=A_16498)<b>A_16498 - (N084.280) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden der Sicherheitszustand werde mittels clearSecurityStatusKey(affectedObject) vor der Auswertung der Zugriffsregel (siehe (N084.300)) oder vor der Auswertung der Kommandodaten (siehe (N084.400)) zurückgesetzt. In diesem Fall ist das Löschen des Sicherheitszustandes gemäß (N084.500) nicht erforderlich. <b>[<=]</b>

REQ(ids=G2_N084.300)<b>G2_N084.300 - (N084.300) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=A_16499)<b>A_16499 - (N084.400) K_COS</b>
PAR Die Antwort der externen Instanz ist in cmdData enthalten. Wenn die Kommando APDU kein LeFeld enthält, mithin also ein Case 3 gemäß CosK_914 vorliegt, dann handelt es sich um die EXTERNAL AUTHENTICATE-Variante des Kommandos und es gilt authData = '' (leerer Oktettstring). In diesem Fall MUSS das COS cmdData wie folgt verarbeiten: <b>[<=]</b>

REQ(ids=A_16500)<b>A_16500 - (N084.400)a K_COS</b>
PAR Wenn channelContext.keyReferenceList.externalAuthenticate.algorithmIdentifier den Wert elcRoleCheck besitzt, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N084.400.a.1)<b>G2_N084.400.a.1 - (N084.400)a.1 K_COS</b>
PAR Schritt 1: Wenn affectedObject.expirationDate kleiner als pointInTime ist (siehe (N019.900)j), genau dann MUSS das Kommando mit dem Trailer KeyExpired terminieren. <b>[<=]</b>

REQ(ids=G2_N084.400.a.2)<b>G2_N084.400.a.2 - (N084.400)a.2 K_COS</b>
PAR Schritt 2: cmdData MUSS wie folgt auf R und S aufgeteilt werden:<br>i.  cmdData = R   ||   S.<br>ii. OctetLength( R ) == OctetLength( S ). <b>[<=]</b>

REQ(ids=G2_N084.400.a.3)<b>G2_N084.400.a.3 - (N084.400)a.3 K_COS</b>
PAR Schritt 3: Setze PuK  = affectedObject.publicKey. <b>[<=]</b>

REQ(ids=G2_N084.400.a.4)<b>G2_N084.400.a.4 - (N084.400)a.4 K_COS</b>
PAR Schritt 4: Setze hash = I2OS(OS2I( RND.ICC || iccsn8 || elcRoleCheck), PuK.domainParameter.t / 8 ).<br>Hinweis CosH_438: iccsn8 ist in (N019.900)c definiert. <b>[<=]</b>

REQ(ids=G2_N084.400.a.5)<b>G2_N084.400.a.5 - (N084.400)a.5 K_COS</b>
PAR Schritt 5: Setze out = ELC_VER_SIG(PuK, R, S, hash).<br>Wenn out den Wert False besitzt, dann MUSS das Kommando mit dem Trailer AuthenticationFailure terminieren. <b>[<=]</b>

PAR (N084.400)b ist absichtlich leer.<br>(N084.400)c ist absichtlich leer.
REQ(ids=A_16501)<b>A_16501 - (N084.400)b K_COS, Option_RSA_CVC</b>
PAR Wenn channelContext.keyReferenceList.externalAuthenticate.algorithmIdentifier den Wert rsaRoleCheck besitzt, dann MÜSSEN mit der Definition PuK = affectedObject.publicKey folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N084.400.b.1)<b>G2_N084.400.b.1 - (N084.400)b.1 K_COS, Option_RSA_CVC</b>
PAR Schritt 1: Setze  M2 = RND.ICC   ||   iccsn8.<br>Hinweis CosH_cdd: iccsn8 ist in (N019.900)c definiert. <b>[<=]</b>

REQ(ids=G2_N084.400.b.2)<b>G2_N084.400.b.2 - (N084.400)b.2 K_COS, Option_RSA_CVC</b>
PAR Schritt 2: Setze ( out, M )  = RSA_ISO9796_2_DS1_VERIFY( PuK, cmdData, M2 ).<br>Wenn diese Operation mit einem Fehler abbricht, oder out gleich False ist, dann MUSS das Kommando mit dem Trailer AuthenticationFailure terminieren. <b>[<=]</b>

REQ(ids=A_16502)<b>A_16502 - (N084.400)c K_COS, Option_DES</b>
PAR Wenn channelContext.keyReferenceList.externalAuthenticate.algorithmIdentifier den Wert rsaSessionkey4SM besitzt, dann gilt authData = '' (leerer Oktettstring) und es MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N084.400.c.1.i)<b>G2_N084.400.c.1.i - (N084.400Kc.1.i K_COS, Option_DES</b>
PAR Schritt 1.i: Wenn channelContext.keyReferenceList.internalAuthenticate leer ist, genau dann MUSS das Kommando mit dem Trailer NoPrkReference terminieren. <b>[<=]</b>

REQ(ids=A_16503)<b>A_16503 - (N084.400)c.1.ii K_COS, Option_DES</b>
PAR Schritt 1.ii: Wenn channelContext.keyReferenceList.internalAuthenticate nicht leer ist, dann MUSS<br>mpObject = SearchKey(    <br>    channelContext.currentFolder,<br>    keyReferenceList.internalAuthenticate.keyReference,<br>    keyReferenceList.externalAuthenticate.algID<br>) gesetzt werden. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. <b>[<=]</b>

REQ(ids=G2_N084.400.c.1.ii.A)<b>G2_N084.400.c.1.ii.A - (N084.400)c.1.ii.A K_COS, Option_DES</b>
PAR Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer PrKNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N084.400.c.1.ii.B)<b>G2_N084.400.c.1.ii.B - (N084.400)c.1.ii.B K_COS, Option_DES</b>
PAR Wenn die Schlüsselsuche den Fehler notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=A_16504)<b>A_16504 - (N084.400)c.2 K_TST, Option_DES</b>
PAR Schritt 2: Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden für den privaten Schlüssel in tmpObject würde gemäß eine Zugriffsregelprüfung für AccessRuleEvaluation( tmpObject, CLA, INS, P1, P2 ) eine Prüfung der Zugriffsregeln stattfinden oder unterbleiben (siehe CosH_2bc). <b>[<=]</b>

REQ(ids=G2_N084.400.c.3)<b>G2_N084.400.c.3 - (N084.400)c.3 K_COS, Option_DES</b>
PAR Schritt 3 :Setze tmpData = cmdData<sup>PrK.d</sup> mod PrK.n, mit PrK = tmpObject.privateKey. <b>[<=]</b>

REQ(ids=G2_N084.400.c.4)<b>G2_N084.400.c.4 - (N084.400)c.4 K_COS, Option_DES</b>
PAR Schritt 4: Setze M2  = RND.ICC   ||   iccsn8. <b>[<=]</b>

REQ(ids=G2_N084.400.c.5)<b>G2_N084.400.c.5 - (N084.400)c.5 K_COS, Option_DES</b>
PAR Schritt 5: Setze ( out, M ) = RSA_ISO9796_2_DS1_VERIFY( PuK, tmpData, M2 ).<br>Wenn diese Operation mit einem Fehler abbricht, oder out gleich False ist, dann MUSS das Kommando mit dem Trailer AuthenticationFailure terminieren. <b>[<=]</b>

REQ(ids=G2_N084.400.c.6)<b>G2_N084.400.c.6 - (N084.400)c.6 K_COS, Option_DES</b>
PAR Schritt 6: M wird aufgeteilt in M = M1 || M2. Die 64 LSByte in M1 MÜSSEN als KD.e an den Secure Messaging Layer übergeben werden (siehe CosK_a2e). <b>[<=]</b>

REQ(ids=A_16505)<b>A_16505 - (N084.402) K_COS, Option_Kryptobox</b>
PAR Die Antwort der externen Instanz ist in cmdData enthalten. Falls die Kommando APDU kein LeFeld enthält, mithin also ein Case 3 gemäß CosK_914 vorliegt, dann handelt es sich um die EXTERNAL AUTHENTICATE-Variante des Kommandos und es gilt authData = '' (leerer Oktettstring). In diesem Fall MUSS cmdData wie folgt weiterverarbeitet werden: <b>[<=]</b>

REQ(ids=G2_N084.402.a)<b>G2_N084.402.a - (N084.402)a K_COS, Option_Kryptobox</b>
PAR Wenn channelContext.keyReferenceList.externalAuthenticate.algorithmIdentifier den Wert aesSessionkey4TC besitzt, dann MÜSSEN folgende Schritte in der angegebenen Reihenfolge ausgeführt werden:

ORDERED-LIST->
LITEM->PAR cmdData wird wie folgt aufgeteilt:<br>i.  cmdData == C1   ||   MAC1<br>ii. OctetLength( MAC1 ) == 8.LITEM->PAR out = VerifyCMAC_IsoPadding( affectedObject.macKey, MAC1, C1 )LITEM->PAR Wenn out den Wert INVALID besitzt, dann MUSS das Kommando mit dem Trailer AuthenticationFailure terminieren.LITEM->PAR R = AES_CBC_DEC( affectedObject.encKey, 0, C1 )LITEM->PAR R wird wie folgt aufgeteilt:<br>i.   R == RND.ext   ||   ICCSN8.ext   ||   RND.int   ||   ICCSN8.int   ||   KD.e<br>ii.  Es sei   16 == OctetLength( RND.ext )<br>iii. Es sei     8 == OctetLength( ICCSN8.ext )<br>iv. Es sei   16 == OctetLength( RND.int )<br>v.  Es sei     8 == OctetLength( ICCSN8.int )<br>vi. Es sei   64 == OctetLength( KD.e )LITEM->PAR Das Kommando MUSS mit AuthenticationFailure terminieren, wenn<br>i.  RND.int ungleich RND.ICC (siehe (N084.100)) ist, oder<br>ii.  ICCSN8.int ungleich iccsn8 (siehe (N019.900)c) ist, oder<br>iii. ICCSN8.int identisch zu ICCSN8.ext ist.LITEM->PAR KD.e MUSS an den Secure Messaging Layer übergeben werden (siehe CosT_a2e).
PAR <b>[<=]</b>

PAR (N084.402)b ist absichtlich leer.<br>(N084.402)c ist absichtlich leer.
REQ(ids=G2_N084.402.b)<b>G2_N084.402.b - (N084.402)b K_COS, Option_Kryptobox, Option_DES</b>
PAR Wenn channelContext.keyReferenceList.externalAuthenticate.algorithmIdentifier den Wert desSessionkey4TC besitzt, dann MÜSSEN folgende Schritte in der angegebenen Reihenfolge ausgeführt werden:

ORDERED-LIST->
LITEM->PAR cmdData wird wie folgt aufgeteilt:<br>i.  cmdData = C1   ||   MAC1<br>ii. OctetLength( MAC1 ) = 8.LITEM->PAR out = VERIFY_Retail_MAC( affectedObject.macKey, MAC1, C1 )LITEM->PAR Wenn out den Wert INVALID besitzt, dann MUSS das Kommando mit dem Trailer AuthenticationFailure terminieren.LITEM->PAR R = 3TDES_CBC_DEC( affectedObject.encKey, 0, C1 )LITEM->PAR R wird wie folgt aufgeteilt:<br>i.   R = RND.ext   ||   ICCSN8.ext   ||   RND.int   ||   ICCSN8.int   ||   KD.e<br>ii.  Es sei     8     = OctetLength( RND.ext )<br>iii. Es sei     8    = OctetLength( ICCSN8.ext )<br>iv. Es sei     8     = OctetLength( RND.int )<br>v.  Es sei     8    = OctetLength( ICCSN8.int )<br>vi. Es sei   64     = OctetLength( KD.e )LITEM->PAR Das Kommando MUSS mit AuthenticationFailure terminieren, wenn<br>i.   RND.int ungleich RND.ICC (siehe (N084.100)) ist, oder<br>ii.  ICCSN8.int ungleich iccsn8 (siehe (N019.900)c) ist, oder<br>iii. ICCSN8.int identisch zu ICCSN8.ext ist.LITEM->PAR KD.e MUSS an den Secure Messaging Layer übergeben werden (siehe CosK_a2e).
PAR <b>[<=]</b>

REQ(ids=G2_N084.402.c)<b>G2_N084.402.c - (N084.402)c K_COS, Option_Kryptobox, Option_DES</b>
PAR Wenn channelContext.keyReferenceList.externalAuthenticate.algorithmIdentifier den Wert rsaSessionkey4TC besitzt, dann MUSS im Rahmen der Kommandobearbeitung identisch zu rsaSessionkey4SM verfahren werden. <b>[<=]</b>

REQ(ids=A_16506)<b>A_16506 - (N084.410) K_COS</b>
PAR Die Antwort der externen Instanz ist in cmdData enthalten. Falls die Kommando APDU ein LeFeld enthält, mithin also ein Case 4S gemäß CosK_876 vorliegt, dann handelt es sich um die MUTUAL AUTHENTICATE-Variante des Kommandos. In diesem Fall MUSS cmdData wie folgt weiterverarbeitet werden, wobei authData berechnet wird: <b>[<=]</b>

REQ(ids=G2_N084.410.a)<b>G2_N084.410.a - (N084.410)a K_COS</b>
PAR Wenn channelContext.keyReferenceList.externalAuthenticate.algID den Wert aesSessionkey4SM besitzt, dann MÜSSEN folgende Schritte in der angegebenen Reihenfolge ausgeführt werden:

ORDERED-LIST->
LITEM->PAR cmdData wird wie folgt aufgeteilt:LITEM->PAR cmdData == C1  ||  MAC1LITEM->PAR OctetLength( MAC1 ) == 8LITEM->PAR out = VerifyCMAC_IsoPadding( affectedObject.macKey, MAC1, C1 )LITEM->PAR Wenn out den Wert INVALID besitzt, dann MUSS das Kommando mit dem Trailer AuthenticationFailure terminieren, sonst MÜSSEN die folgendene Schritte durchgeführt werden:LITEM->PAR S = AES_CBC_DEC( affectedObject.encKey, 0, C1 )<br>i.    S wird wie folgt aufgeteilt:<br>ii.   S == RND.ext   ||   ICCSN8.ext   ||   RND.int   ||   ICCSN8.int   ||   KD.e<br>iii.  Es sei   16 == OctetLength( RND.ext )<br>iv.  Es sei     8 == OctetLength( ICCSN8.ext )<br>v.   Es sei   16 == OctetLength( RND.int )<br>vi.  Es sei     8 == OctetLength( ICCSN8.int )<br>vi.. Es sei   64 == OctetLength( KD.e )LITEM->PAR Das Kommando MUSS mit AuthenticationFailure terminieren, wenn<br>i.   RND.int ungleich RND.ICC (siehe (N084.100)) ist, oder<br>ii.  ICCSN8.int ungleich iccsn8 (siehe (N019.900)c) ist.<br>iii. ICCSN8.int identisch zu ICCSN8.ext ist.LITEM->PAR Setze       KD.i      = RAND( 64 )LITEM->PAR Setze       R           = RND.int   ||   ICCSN8.int   ||   RND.ext   ||   ICCSN8.ext   ||   KD.iLITEM->PAR Setze      C2          = AES_CBC_ENC( affectedObject.encKey, 0, R )LITEM->PAR Setze      MAC2     = CalculateCMAC_IsoPadding( affectedObject.macKey, C2 )LITEM->PAR Setze      authData = C2   ||   MAC2LITEM->PAR Die Oktettstrings KD.e und KD.i MÜSSEN an den Secure Messaging Layer übergeben werden (siehe CosT_a2e).
PAR <b>[<=]</b>

PAR (N084.410)b ist absichtlich leer.
REQ(ids=G2_N084.410.b)<b>G2_N084.410.b - (N084.410)b K_COS, Option_DES</b>
PAR Wenn channelContext.keyReferenceList.externalAuthenticate.algID den Wert desSessionkey4SM besitzt, dann MÜSSEN folgende Schritte in der angegebenen Reihenfolge ausgeführt werden:

ORDERED-LIST->
LITEM->PAR cmdData wird wie folgt aufgeteilt:LITEM->PAR cmdData = C1  ||  MAC1LITEM->PAR OctetLength( MAC1 ) = 8.LITEM->PAR out = VERIFY_Retail_MAC( affectedObject.macKey, MAC1, C1 ). Wenn out den Wert INVALID besitzt, dann MUSS das Kommando mit dem Trailer AuthenticationFailure terminieren.LITEM->PAR Der Oktettstring C1 in den Kommandodaten wird wie folgt behandelt:<br>i.     S = 3TDES_CBC_DEC( affectedObject.encKey, 0, C1 )<br>ii.    S wird wie folgt aufgeteilt:<br>iii.   S = RND.ext   ||   ICCSN8.ext   ||   RND.int   ||   ICCSN8.int   ||   KD.e<br>iv.   Es sei  8  = OctetLength( RND.ext )<br>v.    Es sei  8 = OctetLength( ICCSN8.ext )<br>vi.   Es sei  8 = OctetLength( RND.int )<br>vii. Es sei  8  = OctetLength( ICCSN8.int )<br>viii. Es sei 64 = OctetLength( KD.e )LITEM->PAR Das Kommando MUSS mit AuthenticationFailure terminieren, wenn<br>i.   RND.int ungleich RND.ICC (siehe (N084.100)) ist, oder<br>ii.  ICCSN8.int ungleich iccsn8 (siehe (N019.900)c) ist.<br>iii. ICCSN8.int identisch zu ICCSN8.ext ist.LITEM->PAR Setze       KD.i      = RAND( 64 )LITEM->PAR Setze       R           = RND.int   ||   ICCSN8.int   ||   RND.ext   ||   ICCSN8.ext   ||   KD.iLITEM->PAR Setze      C2          = 3TDES_CBC_ENC( affectedObject.encKey, 0, R )LITEM->PAR Setze      MAC2     = CALCULATE_Retail_MAC( affectedObject.macKey, C2 )LITEM->PAR Setze      authData = C2   ||   MAC2LITEM->PAR Die Oktettstrings KD.e und KD.i MÜSSEN an den Secure Messaging Layer übergeben werden (siehe CosK_a2e).
PAR <b>[<=]</b>

REQ(ids=G2_N084.500)<b>G2_N084.500 - (N084.500) K_COS</b>
PAR Wenn das Kommando mit dem Trailer AuthenticationFailure terminiert, dann MUSS<br>clearSecurityStatusKey( affectedObject ) ausgeführt werden. <b>[<=]</b>

REQ(ids=G2_N084.600)<b>G2_N084.600 - (N084.600) K_COS</b>
PAR Wenn das Kommando mit dem Trailer NoError antwortet, genau dann MUSS setSecurityStatus( affectedObject ) ausgeführt werden. <b>[<=]</b>

REQ(ids=G2_N084.700)<b>G2_N084.700 - (N084.700) K_COS</b>
PAR Als Datenfeld der Antwortnachricht MUSS der (möglicherweise leere) Oktettstring authData verwendet werden. <b>[<=]</b>

REQ(ids=G2_N084.800)<b>G2_N084.800 - (N084.800) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16507)<b>A_16507 - (N084.900)a K_TST</b>
PAR Die Priorität der Trailer in CosT_e88 MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N084.900.b)<b>G2_N084.900.b - (N084.900)b K_COS</b>
PAR Jeder Trailer in CosT_e88 MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

REQ(ids=G2_N084.910)<b>G2_N084.910 - (N084.910) K_COS</b>
PAR Das COS MUSS spätestens nach dem Versenden der Antwort-APDU und vor dem Empfang der nächsten Kommando-APDU RND.ICC auf den Wert "NoRandom" setzen (siehe (N029.900)b). <b>[<=]</b>

PAR Hinweis CosH_2bc: Im Rahmen dieser Spezifikation sind Authentisierungssequenzen nicht unterbrechbar (siehe (N104.600)). Das Authentisierungsprotokoll rsaSessionkey4SM gemäß CosK_2da führt zunächst ein interne Authentisierung durch, wobei eine Zugriffsregelprüfung für den privaten Schlüssel stattfindet (siehe (N086.800)). Deshalb ergäbe eine Zugriffsregelprüfung gemäß (N084.400)c.2 in allen praxisrelevanten Fällen stets True. Funktional ist eine Zugriffsregelprüfung gemäß (N084.400)c.2 deshalb nicht erforderlich. Möglicherweise ist aber im Rahmen einer Evaluierung nachzuweisen, dass ein Unterlassen der Zugriffsregelprüfung gemäß (N084.400)c.2 die Sicherheit nicht unzulässig mindert.
PAR Hinweis CosH_812: Bei der Schlüsselsuche in (N084.400)c.1.ii wird nach einem privaten Schlüsselobjekt gesucht. Trotzdem wird algID aus keyReferenceList.externalAuthenticate entnommen, damit sicher gestellt ist, dass auch das private Schlüsselobjekt den hier zum Tragen kommenden Algorithmus unterstützt. Aus der übrigen Spezifikation ergibt sich, dass dieser Algorithmus Element von {rsaSessionkey4SM, rsaSessionkey4TC} ist.
PAR -HEADING(ids=14.7.2)14.7.2 CosK_72e GENERAL AUTHENTICATE
PAR Das Kommando GENERAL AUTHENTICATE wird in komplexen Authentisierungsprotokollen eingesetzt um die Authentizität einer Smartcard nachzuweisen oder um die Authentizität der "externen Welt" zu prüfen. Allen hier behandelten Authentisierungsprotokollen ist gemeinsam, dass sie aus mehr als einem Schritt bestehen und für jeden Schritt ein GENERAL AUTHENTICATE verwendet wird. Alle Kommandos der hier behandelten Authentisierungsprotokolle sind mittels Command Chaining (siehe CosK_c26) miteinander verknüpft. Anhand den Einträgen in channelContext.keyReferenceList und der Schrittnummer erkennt das COS, welche Aktion ansteht, wie die Daten in der Kommandonachricht zu verarbeiten sind und welche Antwortdaten zu erstellen sind. Von der externen Welt wird gefordert, dass sie die Abfolge des Authentisierungsprotokolls einhält.
PAR -HEADING(ids=14.7.2.1)14.7.2.1 CosK_e2b Gegenseitiges Authentisieren mittels PACE für Endnutzerkarten
PAR Dieser Abschnitt behandelt die Kommandonachrichten für die in CosA_8da mit "CosA_ PICC" bezeichnete Seite, die in [BSI-TR-03110-2#3.2] "eIDAS token (ICC)" genannt wird. Die Kommandonachrichten für die andere Seite werden in CosK_c57 beschrieben. Nach erfolgreichem Abschluss dieses Authentisierungsprotokolls liegen in "CosA_ PICC" Sessionkeys vor, die im Rahmen von Secure Messaging verwendbar sind.
PAR -HEADING(ids=14.7.2.1.1)14.7.2.1.1 CosK_9a2 Use Case PACE für Endnutzerkarten, Schritt 1a
PAR In dieser Variante wird der erste Schritt des PACE Authentisierungsprotokolls für eine Endnutzerkarte durchgeführt. Der komplette Ablauf ist in CosK_580 beschrieben. Der erste Schritt entspricht [BSI-TR-03110-3#B.1, Step 1, B.1.1] encrypted nonce.
REQ(ids=A_16520)<b>A_16520 - (N085.000) K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle</b>
PAR Die APDU des GENERAL AUTHENTICATE-Kommandos MUSS zwei Parameter enthalten:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter Chaining Bit im CLA-Byte zeigt an, dass diese Kommando-APDU nicht die letzte einer Command-Chaining-Kette ist.LITEM->PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardShort sein.
PAR <b>[<=]</b>

REQ(ids=A_16521)<b>A_16521 - (N085.001) K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_a9a verwendet werden.
PAR (ids=Tabelle-232,-CosT_a9a)Tabelle 232, CosT_a9a: GENERAL AUTHENTICATE PACE Endnutzerkarte, Schritt 1a

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '10' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4], Chaining Bit b5 gesetzt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '86' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR no information given
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR no information given
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '7C – 00'
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '00' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.2.1.2)14.7.2.1.2 CosK_7b3 Use Case PACE für Endnutzerkarten, Schritt 2a
PAR In dieser Variante wird der zweite Schritt von PACE für eine Endnutzerkarte durchgeführt, der [BSI-TR-03110-3#B.1, Step 2, B.1.2.1] entspricht, map nonce.
REQ(ids=A_16522)<b>A_16522 - (N085.002) K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle</b>
PAR Die APDU des GENERAL AUTHENTICATE-Kommandos MUSS drei Parameter enthalten:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter Chaining Bit im CLA-Byte zeigt an, dass diese Kommando-APDU nicht die letzte einer Command-Chaining-Kette ist.LITEM->PAR Der Parameter ~PK1<sub>PCD</sub> ist ein Punkt, der so gewählt werden MUSS, dass bei der Decodierung in (N085.064)b.2 kein Fehler auftritt.LITEM->PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardShort sein.
PAR <b>[<=]</b>

REQ(ids=A_16523)<b>A_16523 - (N085.003) K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_19a verwendet werden.
PAR (ids=Tabelle-233,-CosT_19a)Tabelle 233, CosT_19a: GENERAL AUTHENTICATE PACE Endnutzerkarte, Schritt 2a

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '10' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4], Chaining Bit b5 gesetzt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '86' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR no information given
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR no information given
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '7C – L<sub>7C</sub> – (81 – L<sub>81</sub> –  P2OS(~PK1<sub>PCD</sub>))', DER codiertes Datenfeld
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '00' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.2.1.3)14.7.2.1.3 CosK_e54 Use Case PACE für Endnutzerkarten, Schritt 3a
PAR In dieser Variante wird der dritte Schritt von PACE für eine Endnutzerkarte durchgeführt, der [BSI-TR-03110-3#B.1, Step 3] entspricht, perform key agreement.
REQ(ids=A_16524)<b>A_16524 - (N085.004) K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle</b>
PAR Die APDU des GENERAL AUTHENTICATE-Kommandos MUSS drei Parameter enthalten:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter Chaining Bit im CLA-Byte zeigt an, dass diese Kommando-APDU nicht die letzte einer Command-Chaining-Kette ist.LITEM->PAR Der Parameter ~PK2<sub>PCD</sub> ist ein Punkt, der so gewählt werden MUSS, dass bei der Decodierung in (N085.064)c.1 kein Fehler auftritt.LITEM->PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardShort sein.
PAR <b>[<=]</b>

REQ(ids=A_16525)<b>A_16525 - (N085.005) K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_29a verwendet werden.
PAR (ids=Tabelle-234,-CosT_29a)Tabelle 234, CosT_29a: GENERAL AUTHENTICATE PACE Endnutzerkarte, Schritt 3a

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '10' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4], Chaining Bit b5 gesetzt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '86' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR no information given
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR no information given
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '7C – L<sub>7C</sub> – (83 – L<sub>83</sub> –  P2OS(~PK2<sub>PCD</sub>))', DER codiertes Datenfeld
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '00' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.2.1.4)14.7.2.1.4 CosK_7ff Use Case PACE für Endnutzerkarten, Schritt 4a
PAR In dieser Variante wird der vierte und letzte Schritt von PACE für eine Endnutzerkarte durchgeführt, der [BSI-TR-03110-3#B.1, Step 4] entspricht, mutual authentication.
REQ(ids=A_16526)<b>A_16526 - (N085.006) K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle</b>
PAR Die APDU des GENERAL AUTHENTICATE-Kommandos MUSS zwei Parameter enthalten:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter T<sub>PCD</sub> ist ein Oktettstring der Länge acht mit beliebigem Inhalt.LITEM->PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardShort sein.
PAR <b>[<=]</b>

REQ(ids=A_16527)<b>A_16527 - (N085.007) K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_152 verwendet werden.
PAR (ids=Tabelle-235,-CosT_152)Tabelle 235, CosT_152: GENERAL AUTHENTICATE PACE Endnutzerkarte, Schritt 4a

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '86' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR no information given
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR no information given
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '7C – 0A – (85 – 08 – T<sub>PCD</sub>)'
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '00' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.2.2)14.7.2.2 CosK_65 Gegenseitiges Authentisieren mittels ELC Schlüsseln
PAR -HEADING(ids=14.7.2.2.1)14.7.2.2.1 CosK_e36 Use Case gegenseitige ELC-Authentisierung, Schritt 1
PAR In dieser Variante wird der erste Schritt einer gegenseitigen Authentisierung mittels ELC-Schlüssel durchgeführt, bei der auch Sessionkeys ausgehandelt werden. Der komplette Ablauf ist in CosK_2ed beschrieben.
REQ(ids=A_16528)<b>A_16528 - (N085.010) K_externeWelt {K_Karte}</b>
PAR Die APDU des GENERAL AUTHENTICATE-Kommandos MUSS drei Parameter enthalten:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter Chaining Bit im CLA-Byte zeigt an, dass diese Kommando-APDU nicht die letzte einer Command-Chaining-Kette ist.LITEM->PAR Der Parameter keyRef MUSS zwölf Oktett lang sein. Er enthält eine Schlüsselreferenz für einen öffentlichen Authentisierungsschlüssel, der beispielsweise mittels CV-Zertifikat importiert wurde.LITEM->PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardShort sein.
PAR <b>[<=]</b>

REQ(ids=A_16529)<b>A_16529 - (N085.012) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_d3c verwendet werden.
PAR (ids=Tabelle-236,-CosT_d3c)Tabelle 236, CosT_d3c: GENERAL AUTHENTICATE gegenseitige ELC-Authentisierung, Schritt 1

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '10' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4], Chaining Bit b5 gesetzt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '86' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR no information given
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR no information given
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '7C – 0E – ( C3 – 0C – keyRef )'
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '00' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.2.2.2)14.7.2.2.2 CosK_02d Use Case gegenseitige ELC-Authentisierung, Schritt 2
PAR In dieser Variante wird der zweite und letzte Schritt einer gegenseitigen Authentisierung mittels ELC-Schlüssel durchgeführt, bei der auch Sessionkeys ausgehandelt werden.
REQ(ids=A_16530)<b>A_16530 - (N085.014) K_externeWelt {K_Karte}</b>
PAR Die APDU des GENERAL AUTHENTICATE-Kommandos MUSS einen Parameter enthalten:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter ephemeralPK_oponent MUSS einen Punkt auf derselben elliptischen Kurve enthalten, wie der öffentliche Schlüssel, der in Schritt 1 selektiert wurde.
PAR <b>[<=]</b>

REQ(ids=A_16531)<b>A_16531 - (N085.016) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_aca verwendet werden.
PAR (ids=Tabelle-237,-CosT_aca)Tabelle 237, CosT_aca: GENERAL AUTHENTICATE gegenseitige ELC-Authentisierung, Schritt 2

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '86' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR no information given
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR no information given
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '7C – L<sub>7C</sub> – ( 85 – L<sub>85</sub> – ephemeralPK_oponent )', DER codiertes Datenfeld
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.2.3)14.7.2.3 CosK_9b4 Authentisieren für asynchrone, symmetrische Kartenadministration
PAR -HEADING(ids=14.7.2.3.1)14.7.2.3.1 CosK_f7c Use Case Authentisieren für asynchrone, sym. Administration, Schritt 1
PAR In dieser Variante wird der erste Schritt durchgeführt, bei der Sessionkeys symmetrisch übertragen werden. Der komplette Ablauf ist in CosK_07f beschrieben.
REQ(ids=A_16532)<b>A_16532 - (N085.020) K_externeWelt {K_Karte}</b>
PAR Die APDU des GENERAL AUTHENTICATE-Kommandos MUSS zwei Parameter enthalten:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter Chaining Bit im CLA-Byte zeigt an, dass diese Kommando-APDU nicht die letzte einer Command-Chaining-Kette ist.LITEM->PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardShort sein.
PAR <b>[<=]</b>

REQ(ids=A_16533)<b>A_16533 - (N085.022) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 über die Schnittstelle "Interpreter" in CosA__e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_d01 verwendet werden.
PAR (ids=Tabelle-238,-CosT_d01)Tabelle 238, CosT_d01: GENERAL AUTHENTICATE, asynchrone, symmetrische Administration, Schritt 1

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '10' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4], Chaining Bit b5 gesetzt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '86' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR no information given
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR no information given
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '7C – 02 – ( 81 – 00 )'
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '00' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.2.3.2)14.7.2.3.2 CosK_f11 Use Case Authentisieren für asynchrone, sym. Administration, Schritt 2
PAR In dieser Variante wird der zweite und letzte Schritt durchgeführt, bei der Sessionkeys symmetrisch übertragen werden. Der komplette Ablauf ist in CosK_07f beschrieben.
REQ(ids=A_16534)<b>A_16534 - (N085.024) K_externeWelt {K_Karte}</b>
PAR Die APDU des GENERAL AUTHENTICATE-Kommandos MUSS einen Parameter enthalten:<br>a. Der Parameter cmdData MUSS 76 Oktett lang sein. <b>[<=]</b>

REQ(ids=A_16535)<b>A_16535 - (N085.026) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_0d9 verwendet werden.
PAR (ids=Tabelle-239,-CosT_0d9)Tabelle 239, CosT_0d9: GENERAL AUTHENTICATE, asynchrone, symmetrische Administration, Schritt 2

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '86' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR no information given
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR no information given
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '7C – 4E – ( 82 – 4C – cmdData )'
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.2.4)14.7.2.4 CosK_c57 Gegenseitiges Authentisieren mittels PACE für Sicherheitsmodule
PAR Dieser Abchnitt behandelt die Kommandonachrichten für die in CosA_8da mit "COSb PCD" bezeichnete Seite, die in [BSI-TR-03110-2#3.2] "Terminal (PCD)" genannt wird. Die Kommandonachrichten für die andere Seite werden in CosK_e2b beschrieben. Nach erfolgreichem Abschluss dieses Authentisierungsprotokolls liegen in "COSb PCD" Sessionkeys vor, die im Rahmen von PSO-Kommandos einen Trusted Channel unterstützen.
PAR -HEADING(ids=14.7.2.4.1)14.7.2.4.1 CosK_f7b Use Case PACE für Sicherheitsmodule, Schritt 1b
PAR In dieser Variante wird der erste Schritt des PACE Authentisierungsprotokolls für ein Sicherheitsmodul durchgeführt. Der komplette Ablauf ist in CosK_580 beschrieben. Die Karte wird veranlasst ein ephemeres Schlüsselpaar zu generieren.
REQ(ids=A_16536)<b>A_16536 - (N085.030) K_externeWelt {K_Karte}, Option_PACE_PCD</b>
PAR Die APDU des GENERAL AUTHENTICATE-Kommandos MUSS zwei Parameter enthalten:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter Chaining Bit im CLA-Byte zeigt an, dass diese Kommando-APDU nicht die letzte einer Command-Chaining-Kette ist.LITEM->PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardShort sein.
PAR <b>[<=]</b>

REQ(ids=A_16537)<b>A_16537 - (N085.031) K_externeWelt {K_Karte}, Option_PACE_PCD</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_441 verwendet werden.
PAR (ids=Tabelle-240,-CosT_441)Tabelle 240, CosT_441: GENERAL AUTHENTICATE PACE Sicherheitsmodul, Schritt 1b

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '10' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4], Chaining Bit b5 gesetzt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '86' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR no information given
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR no information given
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '7C – 00'
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '00' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.2.4.2)14.7.2.4.2 CosK_ec8 Use Case PACE für Sicherheitsmodule, Schritt 2b
PAR In dieser Variante wird der zweite Schritt von PACE für ein Sicherheitsmodul durchgeführt. Die Karte wird veranlasst die nonce der Gegenseite zu rekonstruieren.
REQ(ids=A_16538)<b>A_16538 - (N085.032) K_externeWelt {K_Karte}, Option_PACE_PCD</b>
PAR Die APDU des GENERAL AUTHENTICATE-Kommandos MUSS drei Parameter enthalten:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter Chaining Bit im CLA-Byte zeigt an, dass diese Kommando-APDU nicht die letzte einer Command-Chaining-Kette ist.LITEM->PAR Der Parameter z ist ein Oktettstring der Länge 16 mit beliebigem Inhalt.LITEM->PAR Der Parameter CAN ist ein OktettString mit einer Länge aus dem Intervall [1, 16] und beliebigem Inhalt.
PAR <b>[<=]</b>

REQ(ids=A_16539)<b>A_16539 - (N085.033) K_externeWelt {K_Karte}, Option_PACE_PCD</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_b7a verwendet werden.
PAR (ids=Tabelle-241,-CosT_b7a)Tabelle 241, CosT_b7a: GENERAL AUTHENTICATE PACE Sicherheitsmodul, Schritt 2b

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '10' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4], Chaining Bit b5 gesetzt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '86' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR no information given
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR no information given
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '7C – L<sub>7C</sub> – [(80 – 10 – z) || (C0 – L<sub>C0</sub> – CAN)]', DER codiertes Datenfeld
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.2.4.3)14.7.2.4.3 CosK_b12 Use Case PACE für Sicherheitsmodule, Schritt 3b
PAR In dieser Variante wird der dritte Schritt von PACE für ein Sicherheitsmodul durchgeführt. Die Karte wird veranlasst ein ephemeres Schlüsselpaar für ephemere Domainparameter zu generieren.
REQ(ids=A_16540)<b>A_16540 - (N085.034) K_externeWelt {K_Karte}, Option_PACE_PCD</b>
PAR Die APDU des GENERAL AUTHENTICATE-Kommandos MUSS drei Parameter enthalten:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter Chaining Bit im CLA-Byte zeigt an, dass diese Kommando-APDU nicht die letzte einer Command-Chaining-Kette ist.LITEM->PAR Der Parameter ~PK1<sub>PICC</sub> ist ein Punkt, der so gewählt werden MUSS, dass bei der Decodierung in (N085.066)c.1 kein Fehler auftritt.LITEM->PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardShort sein.
PAR <b>[<=]</b>

REQ(ids=A_16541)<b>A_16541 - (N085.035) K_externeWelt {K_Karte}, Option_PACE_PCD</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_8b7 verwendet werden.
PAR (ids=Tabelle-242,-CosT_8b7)Tabelle 242, CosT_8b7: GENERAL AUTHENTICATE PACE Sicherheitsmodul, Schritt 3b

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '10' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4], Chaining Bit b5 gesetzt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '86' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR no information given
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR no information given
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '7C – L<sub>7C</sub> – (82 – L<sub>82</sub> –  P2OS(~PK1<sub>PICC</sub>))', DER codiertes Datenfeld
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '00' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.2.4.4)14.7.2.4.4 CosK_131 Use Case PACE für Sicherheitsmodule, Schritt 4b
PAR In dieser Variante wird der vierte Schritt von PACE für ein Sicherheitsmodul durchgeführt. Die Karte wird veranlasst Sessionkeys abzuleiten.
REQ(ids=A_16542)<b>A_16542 - (N085.036) K_externeWelt {K_Karte}, Option_PACE_PCD</b>
PAR Die APDU des GENERAL AUTHENTICATE-Kommandos MUSS drei Parameter enthalten:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter Chaining Bit im CLA-Byte zeigt an, dass diese Kommando-APDU nicht die letzte einer Command-Chaining-Kette ist.LITEM->PAR Der Parameter ~PK2<sub>PICC</sub> ist ein Punkt, der so gewählt werden MUSS, dass bei der Decodierung in (N085.066)d.1 kein Fehler auftritt.LITEM->PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardShort sein.
PAR <b>[<=]</b>

REQ(ids=A_16543)<b>A_16543 - (N085.037) K_externeWelt {K_Karte}, Option_PACE_PCD</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_d4f verwendet werden.
PAR (ids=Tabelle-243,-CosT_d4f)Tabelle 243, CosT_d4f: GENERAL AUTHENTICATE PACE Sicherheitsmodul, Schritt 4b

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '10' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4], Chaining Bit b5 gesetzt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '86' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR no information given
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR no information given
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '7C – L<sub>7C</sub> – (84 – L<sub>84</sub> –  P2OS(~PK2<sub>PICC</sub>))', DER codiertes Datenfeld
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '00' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.2.4.5)14.7.2.4.5 CosK_013 Use Case PACE für Sicherheitsmodule, Schritt 5b
PAR In dieser Variante wird der fünfte und letzte Schritt von PACE für ein Sicherheitsmodul durchgeführt. Die Karte überprüft den MAC der Gegenseite.
REQ(ids=A_16544)<b>A_16544 - (N085.038) K_externeWelt {K_Karte}, Option_PACE_PCD</b>
PAR Die APDU des GENERAL AUTHENTICATE-Kommandos MUSS einen Parameter enthalten:<br>a. Der Parameter T<sub>PICC</sub> ist ein Oktettstring der Länge acht mit beliebigem Inhalt. <b>[<=]</b>

REQ(ids=A_16545)<b>A_16545 - (N085.039) K_externeWelt {K_Karte}, Option_PACE_PCD</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_8fe verwendet werden.
PAR (ids=Tabelle-244,-CosT_8fe)Tabelle 244, CosT_8fe: GENERAL AUTHENTICATE PACE Sicherheitsmodul, Schritt 5b

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '86' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR no information given
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR no information given
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '7C – 0A – (86 – 08 –- T<sub>PICC</sub>)'
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.2.5)14.7.2.5 CosK_742 Authentisieren für asynchrone, asym. Kartenadministration
PAR -HEADING(ids=14.7.2.5.1)14.7.2.5.1 CosK_4e8 Use Case Authentisieren für asynchrone, asym. Administration, Schritt 1
PAR In dieser Variante wird der erste Schritt durchgeführt, bei der Sessionkeys asymmetrisch übertragen werden. Der komplette Ablauf ist in CosK_07f beschrieben. Die Kommando-APDU, deren Parameter und deren Bedeutung sind identisch zum Use Case in CosK_e36, damit gelten hier die Anforderungen (N085.010) und (N085.012).
PAR -HEADING(ids=14.7.2.5.2)14.7.2.5.2 CosK_23d Use Case Authentisieren für asynchrone, asym. Administration, Schritt 2
PAR In dieser Variante wird der zweite und letzte Schritt durchgeführt, bei der Sessionkeys asymmetrisch übertragen werden. Der komplette Ablauf ist in CosK_07f beschrieben.
REQ(ids=A_16546)<b>A_16546 - (N085.040) K_externeWelt {K_Karte}</b>
PAR Die APDU des GENERAL AUTHENTICATE-Kommandos MUSS einen Parameter enthalten:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter cmdData MUSS gemäß (N085.068)b.7 gewählt werden, wobei die Länge von KD.e in (N085.068)b.7.viii 64 Oktett betragen MUSS.
PAR <b>[<=]</b>

REQ(ids=A_16547)<b>A_16547 - (N085.041) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_45a verwendet werden.
PAR (ids=Tabelle-245,-CosT_45a)Tabelle 245, CosT_45a: GENERAL AUTHENTICATE, asynchrone, asymmetrische Administration, Schritt 2

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '86' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR no information given
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR no information given
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '7C – 81F8     – ( 82 – 81F5    – cmdData )'    falls brainpoolP256r1<br>'7C – 820139 – ( 82 – 820135 – cmdData )'    falls brainpoolP384r1<br>'7C – 82017B – ( 82 – 820177 – cmdData )'    falls brainpoolP512r1
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.2.6)14.7.2.6 Antwort der Karte auf Generelles Authentisieren
PAR (ids=Tabelle-246,-CosT_2e0)Tabelle 246, CosT_2e0: GENERAL AUTHENTICATE Antwort-APDU im Erfolgsfall

TABLE(rows=6,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)->PAR responseData TD(1,2/1/1)->PAR Antwortdaten vorhanden
TR-> TD(2,0/1/1)->PAR - TD(2,1/1/1)->PAR - TD(2,2/1/1)->PAR keine Antwortdaten
TR-> TD(3,0/1/1)->PAR Trailer TD(3,1/1/1)->PAR Inhalt TD(3,2/1/1)->PAR Beschreibung
TR-> TD(4,0/1/1)->PAR '63 00' TD(4,1/1/1)->PAR AuthenticationFailure TD(4,2/1/1)->PAR Authentisierung fehlgeschlagen
TR-> TD(5,0/1/1)->PAR '90 00' TD(5,1/1/1)->PAR NoError TD(5,2/1/1)->PAR Erfolgreiche Authentisierung
PAR (ids=Tabelle-247,-CosT_b4e)Tabelle 247, CosT_b4e: GENERAL AUTHENTICATE Antwort-APDU im Fehlerfall

TABLE(rows=11,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '64 00' TD(1,1/1/1)->PAR ParameterMismatch TD(1,2/1/1)->PAR Domainparameter passen nicht zusammen
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '69 83' TD(3,1/1/1)->PAR KeyExpired TD(3,2/1/1)->PAR Gültigkeitszeitraum des Schlüssels ist abgelaufen
TR-> TD(4,0/1/1)->PAR '69 85' TD(4,1/1/1)->PAR NoKeyReference TD(4,2/1/1)->PAR Keinen symmetrischen Schlüssel ausgewählt
TR-> TD(5,0/1/1)->PAR '69 85' TD(5,1/1/1)->PAR NoPrkReference TD(5,2/1/1)->PAR Keinen privaten Schlüssel ausgewählt
TR-> TD(6,0/1/1)->PAR '6A 80' TD(6,1/1/1)->PAR NumberPreconditionWrong TD(6,2/1/1)->PAR Vorbedingung zum Laden des Scenarios nicht erfüllt
TR-> TD(7,0/1/1)->PAR '6A 80' TD(7,1/1/1)->PAR NumberScenarioWrong TD(7,2/1/1)->PAR Scenario wurde bereits geladen
TR-> TD(8,0/1/1)->PAR '6A 81' TD(8,1/1/1)->PAR UnsupportedFunction TD(8,2/1/1)->PAR Schlüssel unterstützt den angegeben Algorithmus nicht
TR-> TD(9,0/1/1)->PAR '6A 88' TD(9,1/1/1)->PAR PrKNotFound TD(9,2/1/1)->PAR privaten Schlüssel nicht gefunden
TR-> TD(10,0/1/1)->PAR '6A 88' TD(10,1/1/1)->PAR KeyNotFound TD(10,2/1/1)->PAR Authentisierungsschlüssel nicht gefunden
PAR Hinweis CosH_c81: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16548)<b>A_16548 - (N085.048) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando GENERAL AUTHENTICATE verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.7.2.7)14.7.2.7 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N085.050.a)<b>G2_N085.050.a - (N085.050)a K_COS</b>
PAR Das COS MUSS die GENERAL AUTHENTICATE-Varianten aus<br>1. CosK_6b5 (Gegenseitige Authentisierung mittels ELC Schlüsseln, (N085.012) + (N085.016)),<br>2. CosK_9b4 (asynchrone, symmetrische Kartenadministration,         (N085.022) + (N085.026)) und<br>3. CosK_742 (asynchrone, asymmetrische Kartenadministration,       (N085.012) + (N085.041))<br>unterstützen. <b>[<=]</b>

REQ(ids=G2_N085.050.b)<b>G2_N085.050.b - (N085.050)b K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Das COS MUSS die GENERAL AUTHENTICATE-Variante aus<br>1. CosK_e2b (PACE für Endnutzerkarten, (N085.001) + (N085.003) + (N085.005) + (N085.007))<br>unterstützen. <b>[<=]</b>

REQ(ids=G2_N085.050.c)<b>G2_N085.050.c - (N085.050)c K_COS, Option_PACE_PCD</b>
PAR Das COS MUSS die GENERAL AUTHENTICATE-Variante aus<br>1. CosK_c57 (PACE für Sicherheitsmodule, (N085.031) + (N085.033) + (N085.035) + (N085.037) + (N085.039))<br>unterstützen. <b>[<=]</b>

REQ(ids=A_16549)<b>A_16549 - (N085.050)d K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere GENERAL AUTHENTICATE-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16550)<b>A_16550 - (N085.051) K_externeWelt {K_Karte}</b>
PAR Schlüsselauswahl in channelContext.keyReferenceList: Die externe Welt MUSS sicherstellen, dass bei Aufruf des Kommandos GENERAL AUTHENTICATE einer der folgenden Fälle vorliegt:<br>a. (Fall gegenseitige ELC-Authentisierung, Schlüsselauswahl gemäß (N100.900))<br>     1. In channelContext.keyReferenceList.internalAuthenticate ist<br>         i.  eine Schlüsselreferenz eingetragen ist, die auf ein privates ELC-Schlüsselobjekt verweist und<br>         ii. dort algID aus der Menge {elcSessionkey4SM, elcSessionkey4TC} ist und<br>     2. channelContext.keyReferenceList.externalAuthenticate leer ist.<br>b. (Fall asynchrone, symmetrische Administration, Schlüsselauswahl gemäß (N102.400))<br>    1. In channelContext.keyReferenceList.externalAuthenticate eine Schlüsselreferenz eingetragen ist und dort algID gleich aesSessionkey4SM ist und<br>     2. channelContext.keyReferenceList.internalAuthenticate leer ist.<br>c. (Fall PACE, Schlüsselauswahl gemäß (N102.448))    <br>    sowohl in channelContext.keyReferenceList.internalAuthenticate, als auch in channelContext.keyReferenceList.externalAuthenticate<br>    1. identische Schlüsselreferenzen und<br>    2. identische algID aus den in (N102.440) genannten Mengen eingetragen ist.<br>d. (Fall asynchrone, asymmetrische Administration, Schlüsselauswahl gemäß (N100.900))<br>    1. In channelContext.keyReferenceList.internalAuthenticate ist<br>        i.  eine Schlüsselreferenz eingetragen ist, die auf ein privates ELC-Schlüsselobjekt verweist und<br>       ii. dort algID aus der Menge {elcAsynchronAdmin} ist und<br>    2. channelContext.keyReferenceList.externalAuthenticate leer ist. <b>[<=]</b>

PAR Hinweis CosH_5ba: Gemäß (N085.051) findet das COS in channelContext.keyReferenceList hinreichend Information anhand derer die diversen Authentisierungsprotokolle unterscheidbar sind. Deshalb ist eine Unterscheidung der hier behandelten Authentisierungsprotokolle anhand von weiteren Kommandoparametern (etwa P1 und/oder P2) nicht erforderlich.
REQ(ids=A_16551)<b>A_16551 - (N085.052) K_COS</b>
PAR Falls dies der erste Schritt des Authentisierungsprotokolls für eine gegenseitige ELC-Authentisierung ist, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N085.052.a)<b>G2_N085.052.a - (N085.052)a K_COS</b>
PAR Schritt a: Wenn die acht LSByte von keyRef identisch sind zu iccsn8 (siehe (N019.900)c), dann MUSS das Kommando mit dem Trailer AuthenticationFailure terminieren. <b>[<=]</b>

REQ(ids=A_16552)<b>A_16552 - (N085.052)b K_COS</b>
PAR Schritt b: Wenn channelContext.keyReferenceList.internalAuthenticate nicht leer ist, dann wird<br>affectedObject_PrK = SearchKey(<br>    channelContext.currentFolder,<br>    channelContext.keyReferenceList.internalAuthenticate.keyReference,<br>    channelContext.keyReferenceList.internalAuthenticate.algID<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. <b>[<=]</b>

REQ(ids=G2_N085.052.b.1)<b>G2_N085.052.b.1 - (N085.052)b.1 K_COS</b>
PAR Schritt b.1: Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer PrKNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N085.052.b.2)<b>G2_N085.052.b.2 - (N085.052)b.2 K_COS</b>
PAR Schritt b.2: Wenn die Schlüsselsuche den Fehler notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=A_16553)<b>A_16553 - (N085.052)c K_COS</b>
PAR Schritt c: Es wird<br>affectedObject_PuK = SearchKey(<br>    channelContext.currentFolder,<br>    keyRef,<br>    channelContext.keyReferenceList.internalAuthenticate.algID<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. <b>[<=]</b>

REQ(ids=G2_N085.052.c.1)<b>G2_N085.052.c.1 - (N085.052)c.1 K_COS</b>
PAR Schritt c.1: Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N085.052.c.2)<b>G2_N085.052.c.2 - (N085.052)c.2 K_COS</b>
PAR Schirtt c.2: Wenn die Schlüsselsuche den Fehler notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N085.052.d)<b>G2_N085.052.d - (N085.052)d K_COS</b>
PAR Schritt d: Wenn affectedObject_PuK.expirationDate kleiner als pointInTime ist (siehe (N019.900)j), dann MUSS das Kommando mit dem Trailer KeyExpired terminieren. <b>[<=]</b>

REQ(ids=G2_N085.052.e)<b>G2_N085.052.e - (N085.052)e K_COS</b>
PAR Schritt e: Wenn affectedObject_PrK.domainParameter verschieden ist von affectedObject_PuK.domainParameter, dann MUSS das Kommando mit dem Trailer ParameterMismatch terminieren. <b>[<=]</b>

REQ(ids=G2_N085.052.f)<b>G2_N085.052.f - (N085.052)f K_COS</b>
PAR Schritt f: Zu den Domainparametern von affectedObject_PrK bzw. affectedObject_PuK wird ein ephemeres Schlüsselpaar (ephemeralSK_self, ephemeralPK_self) erzeugt. <b>[<=]</b>

REQ(ids=G2_N085.052.g)<b>G2_N085.052.g - (N085.052)g K_COS</b>
PAR Schritt g: Der private Schlüssel ephemeralSK_self MUSS mindestens bis zum nächsten Schritt dieses Authentisierungsprotokolls gespeichert werden. <b>[<=]</b>

REQ(ids=G2_N085.052.h)<b>G2_N085.052.h - (N085.052)h K_COS</b>
PAR Schritt h: Der öffentliche Schlüssel ephemeralPK_self MUSS DER codiert wie folgt in die Antwortdaten eingestellt werden:    <br> responseData = '7C-L<sub>7C</sub>-[ 85-L<sub>85</sub>-P2OS( ephemeralPK_self, affectedObject_PrK.domainParameter.L ) ]'. <b>[<=]</b>

REQ(ids=G2_N085.052.i)<b>G2_N085.052.i - (N085.052)i K_COS</b>
PAR TODO gematik-Testabteilung: Diese Anforderung gibt es in der COS-Spec nicht, prüfen, korrigieren. <b>[<=]</b>

REQ(ids=A_16554)<b>A_16554 - (N085.054) K_COS</b>
PAR Wenn dies der zweite Schritt des Authentisierungsprotokolls für eine gegenseitige ELC-Authentisierung ist und algId == elcSessionkey4SM ist, dann MÜSSEN die in (N085.052) ausgewählten Objekte affectedObject_PrK und affectedObject_PuK in den folgende Schritten verwendet werden: <b>[<=]</b>

REQ(ids=G2_N085.054.a)<b>G2_N085.054.a - (N085.054)a K_COS</b>
PAR Schritt a: Der ephemere öffentliche Schlüssel PK_oponent des Protokollpartners wird wie folgt aus den Kommandodaten extrahiert:    <br> PK_oponent = OS2P( ephemeralPK_oponent, affectedObject_PrK.domainParameter ). <b>[<=]</b>

PAR Hinweis CosH_f69: Falls (N085.014)a eingehalten wird, ist diese Operation stets fehlerfrei.
REQ(ids=G2_N085.054.b)<b>G2_N085.054.b - (N085.054)b K_COS</b>
PAR Schritt b: Wenn AccessRuleEvaluation( affectedObject_PrK, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N085.054.c)<b>G2_N085.054.c - (N085.054)c K_COS</b>
PAR Schritt c: Das COS MUSS die Werte zur Ableitung der Sessionkeys wie folgt berechnen:<br>1. K1     = ECKAvalue( affectedObject_PrK.d, PK_oponent, affectedObject_PrK.domainParameter ).<br>2. K2     = ECKAvalue( ephemeralSK_self, affectedObject_PuK, affectedObject_PrK.domainParameter ).<br>3. KD.i   = K1   ||   K2<br>4. KD.e  = I2OS(0, OctetLength(KD.i)) = '00…00'.<br>5. Die Oktettstrings KD.e und KD.i MÜSSEN an den Secure Messaging Layer übergeben werden (siehe CosT_a2e). <b>[<=]</b>

REQ(ids=G2_N085.054.d)<b>G2_N085.054.d - (N085.054)d K_COS</b>
PAR Schritt d: Es MUSS setSecurityStatus( affectedObject_PuK ) ausgeführt werden. <b>[<=]</b>

REQ(ids=G2_N085.054.e)<b>G2_N085.054.e - (N085.054)e K_COS</b>
PAR Schritt e: Die Antwortdaten MÜSSEN leer sein: responseData = ''. <b>[<=]</b>

REQ(ids=A_16555)<b>A_16555 - (N085.056) K_COS, Option_Kryptobox</b>
PAR Wenn dies der zweite Schritt des Authentisierungsprotokolls für eine gegenseitige ELC-Authentisierung ist und algId == elcSessionkey4TC ist, dann MÜSSEN die in (N085.052) ausgewählten Objekte affectedObject_PrK und affectedObject_PuK in den folgende Schritten verwendet: <b>[<=]</b>

REQ(ids=G2_N085.056.a)<b>G2_N085.056.a - (N085.056)a K_COS, Option_Kryptobox</b>
PAR Schritt a: Der ephemere öffentliche Schlüssel PK_oponent des Protokollpartners wird wie folgt aus den Kommandodaten extrahiert:    <br>PK_oponent = OS2P( ephemeralPK_oponent, affectedObject_PrK.domainParameter ). <b>[<=]</b>

PAR Hinweis CosH_e18: Falls (N085.014)a eingehalten wird, ist diese Operation stets fehlerfrei.
REQ(ids=G2_N085.056.b)<b>G2_N085.056.b - (N085.056)b K_COS, Option_Kryptobox</b>
PAR Schritt b: Wenn AccessRuleEvaluation( affectedObject_PrK, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=A_16556)<b>A_16556 - (N085.056)c K_COS, Option_Kryptobox</b>
PAR Schritt c: Das COS MUSS die Werte zur Ableitung der Sessionkeys wie folgt berechnen:<br>1. K1    = ECKAvalue( ephemeralSK_self, affectedObject_PuK, affectedObject_PrK.domainParameter ).<br>2. K2    = ECKAvalue( affectedObject_PrK.d, PK_oponent, affectedObject_PrK.domainParameter ).<br>3. KD.i  = K1   ||   K2<br>4. KD.e = I2OS(0, OctetLength(KD.i)) = '00…00'.<br>5. Die Oktettstrings KD.e und KD.i MÜSSEN an den Secure Messaging Layer übergeben werden (siehe CosT_a2e). <b>[<=]</b>

REQ(ids=G2_N085.056.d)<b>G2_N085.056.d - (N085.056)d K_COS, Option_Kryptobox</b>
PAR Schritt d: Wenn das Kommando mit dem Trailer NoError antwortet, genau dann MUSS setSecurityStatus( affectedObject_PuK ) ausgeführt werden. <b>[<=]</b>

REQ(ids=G2_N085.056.e)<b>G2_N085.056.e - (N085.056)e K_COS, Option_Kryptobox</b>
PAR Schritt e: Die Antwortdaten MÜSSEN leer sein: responseData = ''. <b>[<=]</b>

REQ(ids=A_16557)<b>A_16557 - (N085.060) K_COS</b>
PAR Wenn dies der erste Schritt des Authentisierungsprotokolls für eine asynchrone, symmetrische Kartenadministration ist, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N085.060.a.1)<b>G2_N085.060.a.1 - (N085.060)a.1 K_COS</b>
PAR Schritt a.1: Wenn channelContext.keyReferenceList.externalAuthenticate leer ist, genau dann MUSS das Kommando mit dem Trailer NoKeyReference terminieren. <b>[<=]</b>

REQ(ids=A_16558)<b>A_16558 - (N085.060)a.2 K_COS</b>
PAR Schritt a.2: Wenn channelContext.keyReferenceList.externalAuthenticate nicht leer ist, dann wird<br>affectedObject = SearchKey(<br>    channelContext.currentFolder,<br>    keyReferenceList externalAuthenticate.keyReference,<br>    keyReferenceList.externalAuthenticate.algID<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. <b>[<=]</b>

REQ(ids=G2_N085.060.a.2.i)<b>G2_N085.060.a.2.i - (N085.060)a.2.i K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N085.060.a.2.ii)<b>G2_N085.060.a.2.ii - (N085.060)a.2.ii K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N085.060.b)<b>G2_N085.060.b - (N085.060)b K_COS</b>
PAR Schritt b: Es gilt: responseData = '7C – 04 – ( 81 – 02 – I2OS( affectedObject.numberScenario ))'. <b>[<=]</b>

REQ(ids=A_16559)<b>A_16559 - (N085.062) K_COS</b>
PAR Wenn dies der zweite Schritt des Authentisierungsprotokolls für eine asynchrone, symmetrische Kartenadministration ist, dann MUSS das in (N085.060) ausgewählten Objekte affectedObject in den folgenden Schritten verwendet werden: <b>[<=]</b>

REQ(ids=G2_N085.062.a)<b>G2_N085.062.a - (N085.062)a K_COS</b>
PAR Schritt a: Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=A_16560)<b>A_16560 - (N085.062)b K_COS</b>
PAR Schritt b: cmdData MUSS wie folgt aufgeteilt werden:<br>1. cmdData == M   ||   MAC.<br>2. OctetLength( MAC ) == 8. <b>[<=]</b>

REQ(ids=A_16561)<b>A_16561 - (N085.062)c K_COS</b>
PAR Schritt c: out = VerifyCMAC_IsoPadding( affectedObject.macKey, MAC, M ) <b>[<=]</b>

REQ(ids=G2_N085.062.d)<b>G2_N085.062.d - (N085.062)d K_COS</b>
PAR Schritt d: Falls out den Wert INVALID besitzt, dann MUSS das Kommando mit dem Trailer AuthenticationFailure terminieren. <b>[<=]</b>

REQ(ids=A_16562)<b>A_16562 - (N085.062)e K_COS</b>
PAR Schritt e: Die Nachricht M MUSS wie folgt aufgeteilt werden:<br>1. M  == NumberPrecondition   ||   NumberScenario   ||   C.<br>2. OctetLength( NumberPrecondition ) == 2.<br>3. OctetLength( NumberScenario ) == 2.<br>4. OctetLength( C ) == 64. <b>[<=]</b>

REQ(ids=G2_N085.062.f.1)<b>G2_N085.062.f.1 - (N085.062)f.1 K_COS</b>
PAR Schritt f.1: Falls affectedObject.numberScenario kleiner als OS2I( NumberPrecondition ) ist, genau dann MUSS das Kommando mit dem Trailer NumberPreconditionWrong terminieren. <b>[<=]</b>

REQ(ids=G2_N085.062.f.2)<b>G2_N085.062.f.2 - (N085.062)f.2 K_COS</b>
PAR Schritt f.2: Falls affectedObject.numberScenario größer gleich OS2I( NumberScenario ) ist, genau dann MUSS das Kommando mit dem Trailer NumberScenarioWrong terminieren. <b>[<=]</b>

REQ(ids=G2_N085.062.g)<b>G2_N085.062.g - (N085.062)g K_COS</b>
PAR Schritt g: affectedObject.numberScenario MUSS transaktionsgesichert auf den Wert OS2I( NumberScenario ) gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N085.062.h)<b>G2_N085.062.h - (N085.062)h K_COS</b>
PAR Schritt h: Es gilt:<br>1. KD.e = AES_CBC_DEC( affectedObject.encKey, 0, C ).<br>2. KD.i = '00…00' = I2OS(0, OctetLength(KD.e)).<br>3. Die Oktettstrings KD.e und KD.i MÜSSEN an den Secure Messaging Layer übergeben werden (siehe CosT_a2e). <b>[<=]</b>

REQ(ids=G2_N085.062.i)<b>G2_N085.062.i - (N085.062)i K_COS</b>
PAR Schritt i: Wenn das Kommando mit dem Trailer NoError antwortet, genau dann MUSS setSecurityStatus( affectedObject ) ausgeführt werden. <b>[<=]</b>

REQ(ids=G2_N085.062.j)<b>G2_N085.062.j - (N085.062)j K_COS</b>
PAR Schritt j: Die Antwortdaten MÜSSEN leer sein: responseData = ''. <b>[<=]</b>

REQ(ids=A_16563)<b>A_16563 - (N085.064) K_COS, Option_kontaktlose_Schnittstelle</b>
PAR PACE Authentisierungsprotokoll für eine Endnutzerkarte: Falls in channelContext.keyReferenceList.internalAuthenticate.algID ein Algorithmus aus der in (N102.440)a genannten Menge eingetragen ist, dann MUSS folgendes ausgeführt werden: <b>[<=]</b>

REQ(ids=A_16564)<b>A_16564 - (N085.064)a K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Falls dies der erste Schritt des Authentisierungsprotokolls, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=A_16565)<b>A_16565 - (N085.064)a.1 K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Schlüsselsuche, es wird<br>affectedObject = SearchKey(<br>    channelContext.currentFolder,<br>    channelContext.keyReferenceList.internalAuthenticate.keyReference,<br>    channelContext.keyReferenceList.internalAuthenticate.algID<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. <b>[<=]</b>

REQ(ids=G2_N085.064.a.1.i)<b>G2_N085.064.a.1.i - (N085.064)a.1.i K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N085.064.a.1.ii)<b>G2_N085.064.a.1.ii - (N085.064)a.1.ii K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Wenn die Schlüsselsuche den Fehler notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N085.064.a.2-6)<b>G2_N085.064.a.2-6 - (N085.064)a.2 K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=A_16566)<b>A_16566 - (N085.064)a.3 K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Das Attribut affectedObject.can (siehe (N017.028)) wird in einen Oktettstring gewandelt (vergleiche [BSI-TR-03110-3#D.2.1.4]): Die Ziffernfolge can besteht aus den Ziffern z<sub>1</sub>, …, z<sub>n</sub> und MUSS in einen Oktettstring CAN = 'o<sub>1</sub>, …, o<sub>n</sub>' umgewandelt werden, indem jede Ziffer z<sub>i</sub> in ein Oktett o<sub>i</sub> transformiert wird mit<br>i.   z<sub>i</sub> = 0 => o<sub>i</sub> = '30',<br>ii.  z<sub>i</sub> = 1 => o<sub>i</sub> = '31',<br>iii. z<sub>i</sub> = 2 => o<sub>i</sub> = '32',<br>…<br>ix. z<sub>i</sub> = 9 => o<sub>i</sub> = '39', <b>[<=]</b>

REQ(ids=A_16567)<b>A_16567 - (N085.064)a.4-6 K_COS, Option_kontaktlose_Schnittstelle</b>
PAR 4. s    = RAND( 16 ),<br>5. z    = AES_ENC( KDF(CAN, 3, channelContext.keyReferenceList.internalAuthenticate.algID), s ),<br>6. responseData = '7C – 12 – (80 – 10 – z)'. <b>[<=]</b>

REQ(ids=A_16568)<b>A_16568 - (N085.064)b K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Falls dies der zweite Schritt des Authentisierungsprotokolls ist, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=A_16569)<b>A_16569 - (N085.064)b.1 K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Es MUSS eine Zuordnung von channelContext.keyReferenceList.internalAuthenticate.algID zu dP durchgeführt werden (diese Zuordnung gilt auch für die übrigen Schritte des Protokolls): <b>[<=]</b>

REQ(ids=G2_N085.064.b.1.i)<b>G2_N085.064.b.1.i - (N085.064)b.1.i K_COS, Option_kontaktlose_Schnittstelle</b>
PAR id-PACE-ECDH-GM-AES-CBC-CMAC-128   =>   dP = brainpoolP256r1 <b>[<=]</b>

REQ(ids=G2_N085.064.b.1.ii)<b>G2_N085.064.b.1.ii - (N085.064)b.1.ii K_COS, Option_kontaktlose_Schnittstelle</b>
PAR id-PACE-ECDH-GM-AES-CBC-CMAC-192   =>   dP = brainpoolP384r1 <b>[<=]</b>

REQ(ids=G2_N085.064.b.1.iii)<b>G2_N085.064.b.1.iii - (N085.064)b.1.iii K_COS, Option_kontaktlose_Schnittstelle</b>
PAR id-PACE-ECDH-GM-AES-CBC-CMAC-256   =>   dP = brainpoolP512r1 <b>[<=]</b>

REQ(ids=G2_N085.064.b.2)<b>G2_N085.064.b.2 - (N085.064)b.2 K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Aus dem Wertfeld value<sub>81</sub> des DO81 im Kommandodatenfeld wird ein Punkt extrahiert:<br>~PK1<sub>PCD</sub> = OS2P(value<sub>81</sub>, dP), <b>[<=]</b>

REQ(ids=G2_N085.064.b.3-6)<b>G2_N085.064.b.3-6 - (N085.064)b.3-6 K_COS, Option_kontaktlose_Schnittstelle</b>
PAR b.3: Es wird ein ephemeres Schlüsselpaar generiert:<br>      i.  ~SK1<sub>PICC</sub> = zufällige Zahl aus dem Intervall [1, dP.n – 1],<br>      ii. ~PK1<sub>PICC</sub> = ~SK1<sub>PICC</sub> * dP.G,<br>b.4: Berechne den ephemeren Basispunkt ~G mit s aus Schritt 1:<br>       ~G = s * dP.G  + ECKApoint( ~SK1<sub>PICC</sub> , ~PK1<sub>PCD</sub>, dP ),<br>b.5: Berechne ephemere Domainparameter ~D aus dP und ~G:<br>       ~D = (dP.p, dP.a, dP.b, ~G, dP.n, dP.h, dP.L, dP.t, dP.OID),<br>b.6: responseData MUSS ein DER codieretes DO7C wie folgt enthalten:<br>      responseData = '7C – L<sub>7C</sub> – (82 – L<sub>82</sub> – P2OS(~PK1<sub>PICC</sub>, dP.t / 8 ))' <b>[<=]</b>

PAR Hinweis CosH_4f9: In einer früheren Dokumentenversion war der zweite Summand in (N085.064)b.4 definiert als Produkt aus ~SK1<sub>PICC</sub> und ~PK1<sub>PCD</sub>. Dies ist nicht konform zu [BSI-TR-03110-3#A.3.4.1]. Deshalb wurde (N085.064)b.4 konform zu [BSI-TR-03110-3#A.3.4.1] korrigiert. Für die normativ zu unterstützenden elliptischen Kurven aus (N002.500) hat diese Änderung keine Auswirkungen, da für alle diese Kurven gilt: Cofaktor h = 1.
REQ(ids=G2_N085.064.c)<b>G2_N085.064.c - (N085.064)c K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Falls dies der dritte Schritt des Authentisierungsprotokolls ist, dann MÜSSEN folgende Schritte ausgeführt werden:

ORDERED-LIST->
LITEM->PAR Aus dem Wertfeld value<sub>83</sub> des DO83 im Kommandodatenfeld wird ein Punkt extrahiert:<br>~PK2<sub>PCD</sub> = OS2P(value<sub>83</sub>, ~D),LITEM->PAR Es wird ein weiteres ephemeres Schlüsselpaar generiert:<br>i.  ~SK2<sub>PICC</sub> = zufällige Zahl aus dem Intervall [1, ~D.n – 1],<br>ii. ~PK2<sub>PICC</sub> = ~SK2<sub>PICC</sub> * ~D.G,LITEM->PAR responseData MUSS ein DER codieretes DO7C wie folgt enthalten:    <br>responseData = '7C – L<sub>7C</sub> – (84 – L<sub>84</sub> – P2OS(~PK2<sub>PICC</sub> ,  ~D.t / 8 ))'
PAR <b>[<=]</b>

REQ(ids=A_16570)<b>A_16570 - (N085.064)d K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Falls dies der vierte Schritt des Authentisierungsprotokolls ist, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N085.064.d.1-5)<b>G2_N085.064.d.1-5 - (N085.064)d.1-5 K_COS, Option_kontaktlose_Schnittstelle</b>

ORDERED-LIST->
LITEM->PAR Berechne gemeinsames Geheimnis zur Ableitung von Sessionkeys:<br>i.  KD.i  = K<sub>AB</sub> = ECKAvalue(~SK2<sub>PICC</sub>,  ~PK2<sub>PCD</sub>, ~D ),<br>ii. KD.e = I2OS(0, OctetLength(KD.i)) = '00…00',LITEM->PAR Die algID aus channelContext.keyReferenceList.internalAuthenticate bestimmt, wie der Schlüssel k<sub>MAC</sub> berechnet wird: k<sub>MAC</sub> = KDF(KD.i, 2, algID ),LITEM->PAR Für den Zusammenhang zwischen algID aus externalAuthenticate oder internalAuthenticate in channelContext.keyReferenceList und OID gilt hier algID = OID.LITEM->PAR Berechne den DER codierten Oktettstring M<sub>PCD</sub> gemäß:    <br>M<sub>PCD</sub> = '7F49 – L<sub>7F4</sub><sub>9</sub> – [(06 – 0A – OID) || (86 – L<sub>86</sub> – P2OS(~PK2<sub>PICC</sub>, ~D ))]',LITEM->PAR Berechne den DER codierten Oktettstring M<sub>PICC</sub> gemäß:    <br>M<sub>PICC</sub> = '7F49 – L<sub>7F49</sub> – [(06 – 0A – OID) || (86 – L<sub>86</sub> – P2OS(~PK2<sub>PCD</sub>, ~D ))]',
PAR <b>[<=]</b>

REQ(ids=A_16571)<b>A_16571 - (N085.064)d.6 K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Der MAC aus der Kommandonachricht MUSS überprüft werden:<br>result = VerifyCMAC_NoPadding( k<sub>MAC</sub>, T<sub>PCD</sub>, M<sub>PCD</sub> ) <b>[<=]</b>

REQ(ids=G2_N085.064.d.6.i)<b>G2_N085.064.d.6.i - (N085.064)d.6.i K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Wenn result den Wert INVALID besitzt, dann MUSS<br>A. clearSecurityStatusKey( affectedObject ) ausgeführt werden und<br>B. das Kommando mit dem Trailer AuthenticationFailure terminieren. <b>[<=]</b>

REQ(ids=G2_N085.064.d.6.ii)<b>G2_N085.064.d.6.ii - (N085.064)d.6.ii K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Wenn result den Wert VALID besitzt, dann<br>A. MUSS der MAC für die Antwortnachricht wie folgt berechnet werden:<br>   T<sub>PICC</sub> = CalculateCMAC_NoPadding( k<sub>MAC</sub>, M<sub>PICC</sub> ), und<br>B. MUSS setSecurityStatus( affectedObject ) ausgeführt werden und<br>C. MÜSSEN die Oktettstrings KD.e und KD.i an den Secure Messaging Layer übergeben werden (siehe CosT_a2e), und<br>D. MUSS das Datenfeld der Antwortnachricht wie folgt berechnet werden:<br>   responseData = '7C 0A (86 08 T<sub>PICC</sub>)'. <b>[<=]</b>

REQ(ids=A_16572)<b>A_16572 - (N085.066) K_COS, Option_PACE_PCD</b>
PAR PACE Authentisierungsprotokoll für ein Sicherheitsmodul: Falls in channelContext.keyReferenceList.internalAuthenticate.algID ein Algorithmus aus der in (N102.440)b genannten Menge eingetragen ist, dann MUSS folgendes ausgeführt werden: <b>[<=]</b>

REQ(ids=A_16573)<b>A_16573 - (N085.066)a K_COS, Option_PACE_PCD</b>
PAR Falls dies der erste Schritt des Authentisierungsprotokolls, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=A_16574)<b>A_16574 - (N085.066)a.1 K_COS, Option_PACE_PCD</b>
PAR Schlüsselsuche, es wird<br>affectedObject = SearchKey(<br>    channelContext.currentFolder,<br>    channelContext.keyReferenceList.internalAuthenticate.keyReference,<br>    channelContext.keyReferenceList.internalAuthenticate.algID<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. <b>[<=]</b>

REQ(ids=G2_N085.066.a.1.i)<b>G2_N085.066.a.1.i - (N085.066)a.1.i K_COS, Option_PACE_PCD</b>
PAR Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N085.066.a.1.ii)<b>G2_N085.066.a.1.ii - (N085.066)a.1.ii K_COS, Option_PACE_PCD</b>
PAR Wenn die Schlüsselsuche den Fehler notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N085.066.a.2)<b>G2_N085.066.a.2 - (N085.066)a.2 K_COS, Option_PACE_PCD</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N085.066.a.3-5)<b>G2_N085.066.a.3-5 - (N085.066)a.3-5 K_COS, Option_PACE_PCD</b>
PAR 3. Es MUSS eine Zuordnung von channelContext.keyReferenceList.internalAuthenticate.algID zu dP durchgeführt werden (diese Zuordnung gilt auch für die übrigen Schritte des Protokolls):<br>      i.   id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-128   =>   dP = brainpoolP256r1<br>      ii.  id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-192   =>   dP = brainpoolP384r1<br>      iii. id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-256   =>   dP = brainpoolP512r1<br>4. Es wird ein ephemeres Schlüsselpaar generiert:<br>      i.  ~SK1<sub>PCD</sub> = zufällige Zahl aus dem Intervall [1, dP.n – 1],<br>      ii. ~PK1<sub>PCD</sub> = ~SK1<sub>PCD</sub> * dP.G,<br>5. responseData MUSS ein DER codieretes DO7C wie folgt enthalten:    <br>    responseData = '7C – L<sub>7C</sub> – (81 – L<sub>81</sub> – P2OS(~PK1<sub>PCD</sub>, dP.t / 8 ))' <b>[<=]</b>

REQ(ids=G2_N085.066.b)<b>G2_N085.066.b - (N085.066)b K_COS, Option_PACE_PCD</b>
PAR Falls dies der zweite Schritt des Authentisierungsprotokolls ist, dann MÜSSEN folgende Schritte ausgeführt werden:<br>1. Aus dem Datenfeld der Kommandonachricht werden z und CAN extrahiert.<br>2. s    = OS2I( AES_DEC( KDF(CAN, 3, channelContext.keyReferenceList.internalAuthenticate.algID), z ) ),<br>3. responseData = '' (leerer Oktettstring). <b>[<=]</b>

REQ(ids=A_16575)<b>A_16575 - (N085.066)c K_COS, Option_PACE_PCD</b>
PAR Falls dies der dritte Schritt des Authentisierungsprotokolls ist, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N085.066.c.1)<b>G2_N085.066.c.1 - (N085.066)c.1 K_COS, Option_PACE_PCD</b>
PAR Aus dem Wertfeld value<sub>82</sub> des DO82 im Kommandodatenfeld wird ein Punkt extrahiert:<br>~PK1<sub>PICC</sub> = OS2P(value<sub>82</sub>, dP), <b>[<=]</b>

REQ(ids=G2_N085.066.c.2-5)<b>G2_N085.066.c.2-5 - (N085.066)c.2-5 K_COS, Option_PACE_PCD</b>
PAR c.2: Berechne den ephemeren Basispunkt ~G mit s aus Schritt 2:<br>      ~G = s * dP.G   +  ECKApoint( ~SK1<sub>PCD</sub> , ~PK1<sub>PICC</sub> , dP),<br>c.3: Berechne ephemere Domainparameter ~D aus dP und ~G:<br>     ~D = (dP.p, dP.a, dP.b, ~G, dP.n, dP.h, dP.L, dP.t, dP.OID),<br>c.4: Es wird ein weiteres ephemeres Schlüsselpaar generiert:<br>      i.  ~SK2<sub>PCD</sub> = zufällige Zahl aus dem Intervall [1, ~D.n – 1],<br>      ii. ~PK2<sub>PCD</sub> = ~SK2<sub>PCD</sub> * ~D.G,<br>c.5: responseData MUSS ein DER codieretes DO7C wie folgt enthalten:    <br>       responseData = '7C – L<sub>7C</sub> – (83 – L<sub>83</sub> - P2OS(~PK2<sub>PCD</sub>, ~D.t / 8 ))' <b>[<=]</b>

PAR Hinweis CosH_5a4: In einer früheren Dokumentenversion war der zweite Summand in (N085.066)c.2 definiert als Produkt aus ~SK1<sub>PCD</sub> und ~PK1<sub>PICC</sub>. Dies ist nicht konform zu [BSI-TR-03110-3#A.3.4.1]. Deshalb wurde (N085.066)c.2 konform zu [BSI-TR-03110-3#A.3.4.1] korrigiert. Für die normativ zu unterstützenden elliptischen Kurven aus (N002.500) hat diese Änderung keine Auswirkungen, da für alle diese Kurven gilt: Cofaktor h = 1.
REQ(ids=A_16576)<b>A_16576 - (N085.066)d K_COS, Option_PACE_PCD</b>
PAR Falls dies der vierte Schritt des Authentisierungsprotokolls, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N085.066.d.1)<b>G2_N085.066.d.1 - (N085.066)d.1 K_COS, Option_PACE_PCD</b>
PAR Aus dem Wertfeld value<sub>84</sub> des DO84 im Kommandodatenfeld wird ein Punkt extrahiert:<br>~PK2<sub>PICC</sub> = OS2P(value<sub>84</sub>, ~D), <b>[<=]</b>

REQ(ids=G2_N085.066.d.2-7)<b>G2_N085.066.d.2-7 - (N085.066)d.2-7 K_COS, Option_PACE_PCD</b>
PAR d.2: Berechne gemeinsames Geheimnis zur Ableitung von Sessionkeys:<br>      i.  KD.i  = K<sub>AB</sub> = ECKAvalue(~SK2<sub>PCD</sub>, ~PK2<sub>PICC</sub>, ~D ),<br>      ii. KD.e = I2OS(0, OctetLength(KD.i)) = '00…00',<br>d.3: Die algID aus channelContext.keyReferenceList.internalAuthenticate bestimmt, wie der Schlüssel k<sub>MAC</sub> berechnet wird: k<sub>MAC</sub> = KDF(KD.i, 2, algID ),<br>d.4: Für den Zusammenhang zwischen algID aus externalAuthenticate oder internalAuthenticate in channelContext.keyReferenceList und OID gilt hier:<br>      i.   algID = id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-128   =>   OID = id-PACE-ECDH-GM-AES-CBC-CMAC-128<br>      ii.  algID = id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-192   =>   OID = id-PACE-ECDH-GM-AES-CBC-CMAC-192<br>      iii. algID = id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-256   =>   OID = id-PACE-ECDH-GM-AES-CBC-CMAC-256<br>d.5: Berechne den Oktettstring M<sub>PCD</sub> identisch zu (N085.064)d.4 und den zugehörigen MAC:<br>     T<sub>PCD</sub> = CalculateCMAC_NoPadding( k<sub>MAC</sub>, M<sub>PCD</sub> ).<br>d.6: Berechne den Oktettstring M<sub>PICC</sub> identisch zu (N085.064)d.5.<br>d.7: Setze responseData = '7C – 0A – (85 – 08 – T<sub>PCD</sub>)' <b>[<=]</b>

REQ(ids=A_16577)<b>A_16577 - (N085.066)e K_COS, Option_PACE_PCD</b>
PAR Falls dies der fünfte Schritt des Authentisierungsprotokolls ist, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=A_16578)<b>A_16578 - (N085.066)e.1 K_COS, Option_PACE_PCD</b>
PAR Der MAC aus der Kommandonachricht MUSS überprüft werden:<br>result = VerifyCMAC_NoPadding( k<sub>MAC</sub>, T<sub>PICC</sub>, M<sub>PICC</sub> ) <b>[<=]</b>

REQ(ids=G2_N085.066.e.1.i)<b>G2_N085.066.e.1.i - (N085.066)e.1.i K_COS, Option_PACE_PCD</b>
PAR Wenn result den Wert INVALID besitzt, dann MUSS<br>A. clearSecurityStatusKey( affectedObject ) ausgeführt werden und<br>B. das Kommando mit dem Trailer AuthenticationFailure terminieren. <b>[<=]</b>

REQ(ids=G2_N085.066.e.1.ii)<b>G2_N085.066.e.1.ii - (N085.066)e.1.ii K_COS, Option_PACE_PCD</b>
PAR Wenn result den Wert VALID besitzt, dann<br>A. MUSS setSecurityStatus( affectedObject ) ausgeführt werden und<br>B. MÜSSEN die Oktettstrings KD.e und KD.i an den Secure Messaging Layer übergeben werden (siehe CosT_a2e), und<br>C. MUSS gelten responseData = '' (leerer Oktettstring). <b>[<=]</b>

REQ(ids=A_16579)<b>A_16579 - (N085.068)a K_COS</b>
PAR Wenn dies der erste Schritt des Authentisierungsprotokolls für eine asynchrone, asymmetrische Kartenadministration ist, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N085.068.a.1)<b>G2_N085.068.a.1 - (N085.068)a.1 K_COS</b>
PAR Schlüsselsuche nach einem privaten Schlüsselobjekt, es wird<br>affectedObject_PrK = SearchKey(<br>    channelContext.currentFolder,<br>    channelContext.keyReferenceList.internalAuthenticate.keyReference,<br>    channelContext.keyReferenceList.internalAuthenticate.algID<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. Wenn die Schlüsselsuche den Fehler<br>i.  keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer PrKNotFound terminieren.<br>ii. notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N085.068.a.2)<b>G2_N085.068.a.2 - (N085.068)a.2 K_COS</b>
PAR Schlüsselsuche nach einem öffentlichen Schlüsselobjekt, es wird<br>affectedObject_PuK = SearchKey(<br>    channelContext.currentFolder,<br>    keyRef,<br>    channelContext.keyReferenceList.internalAuthenticate.algID<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. Wenn die Schlüsselsuche den Fehler<br>i.  keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren.<br>ii. notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N085.068.a.3)<b>G2_N085.068.a.3 - (N085.068)a.3 K_COS</b>
PAR Wenn affectedObject_PuK.expirationDate kleiner als pointInTime ist (siehe (N019.900)j), dann MUSS das Kommando mit dem Trailer KeyExpired terminieren. <b>[<=]</b>

REQ(ids=G2_N085.068.a.4)<b>G2_N085.068.a.4 - (N085.068)a.4 K_COS</b>
PAR Wenn affectedObject_PrK.domainParameter verschieden ist von affectedObject_PuK.domainParameter, dann MUSS das Kommando mit dem Trailer ParameterMismatch terminieren. <b>[<=]</b>

REQ(ids=G2_N085.068.a.5)<b>G2_N085.068.a.5 - (N085.068)a.5 K_COS</b>
PAR Es gilt:  responseData = '7C – 04 – (81 – 02 – I2OS( affectedObject_PrK.numberScenario ))'. <b>[<=]</b>

REQ(ids=A_16580)<b>A_16580 - (N085.068)b K_COS</b>
PAR Wenn dies der zweite Schritt des Authentisierungsprotokolls für eine asynchrone, asymmetrische Kartenadministration ist, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N085.068.b.1)<b>G2_N085.068.b.1 - (N085.068)b.1 K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject_PrK, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=A_16581)<b>A_16581 - (N085.068)b.2 K_COS</b>
PAR cmdData MUSS wie folgt aufgeteilt werden:<br>i.   cmdData == M   ||   SIG.<br>ii.  In Abhängigkeit von den affectecObject_PrK.domainParameter gilt:<br>     A. brainpoolP256r1: OctetLength(SIG) ==   64, hash = SHA_256( M )<br>     B. brainpoolP384r1: OctetLength(SIG) ==   96, hash = SHA_384( M )<br>     C. brainpoolP512r1: OctetLength(SIG) == 128, hash = SHA_512( M )<br>iii. SIG == R   ||   S<br>iv. OctetLength( R ) == OctetLength( S ). <b>[<=]</b>

REQ(ids=G2_N085.068.b.2-3)<b>G2_N085.068.b.2-3 - (N085.068)b.3 K_COS</b>
PAR Falls ELC_VER_SIG( affectedObject_PuK, R, S, hash ) den Wert False besitzt, MUSS das Kommando mit dem Trailer AuthenticationFailure terminieren. <b>[<=]</b>

REQ(ids=A_16582)<b>A_16582 - (N085.068)b.4 K_COS</b>
PAR Die Nachricht M MUSS wie folgt aufgeteilt werden:<br>i.   M == NumberPrecondition   ||   NumberScenario   ||   cipher.<br>ii.  OctetLength( NumberPrecondition ) ==  2.<br>iii. OctetLength( NumberScenario )       ==  2. <b>[<=]</b>

REQ(ids=G2_N085.068.b.4-5.i)<b>G2_N085.068.b.4-5.i - (N085.068)b.5.i K_COS</b>
PAR Wenn affectedObject_PrK.numberScenario kleiner als OS2I( NumberPrecondition ) ist, genau dann MUSS das Kommando mit dem Trailer NumberPreconditionWrong terminieren. <b>[<=]</b>

REQ(ids=G2_N085.068.b.4-5.ii)<b>G2_N085.068.b.4-5.ii - (N085.068)b.5.ii K_COS</b>
PAR Wenn affectedObject_PrK.numberScenario größer gleich OS2I( NumberScenario ) ist, genau dann MUSS das Kommando mit dem Trailer NumberScenarioWrong terminieren. <b>[<=]</b>

REQ(ids=G2_N085.068.b.6)<b>G2_N085.068.b.6 - (N085.068)b.6 K_COS</b>
PAR affectedObject_PrK.numberScenario MUSS transaktionsgesichert auf den Wert OS2I( NumberScenario ) gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N085.068.b.7)<b>G2_N085.068.b.7 - (N085.068)b.7 K_COS</b>
PAR Es gilt (Hinweis CosH_310: cipher ist hier identisch zu (N090.300)c, (N091.700)d und (N094.400)c definiert):<br>i.    cipher MUSS ein DER codiertes DOA6 sein.<br>ii.   cipher      = 'A6 – L<sub>A6</sub> – ( oidDO   ||   keyDO   ||   cipherDO   ||   macDO )'.<br>iii.  oidDO      = '06 – L<sub>06</sub> – oid '.<br>iv.  keyDO      = '7F49 – L<sub>7F49</sub> – ( 86 – L<sub>86</sub> – PO<sub>A</sub> )'.<br>v.   cipherDO = '86 – L<sub>86</sub> – ( 02   ||   C )'.<br>vi.  macDO    = '8E – L<sub>8E</sub> –T '.<br>vii.  Falls oid verschieden ist zur OID, die gemäß (N008.600)d zu affectedObject_PrK.privateElcKey.domainParameter gehört, dann MUSS das Kommando mit dem Trailer ParameterMismatch terminieren. Diese Domainparameter werden im Folgenden mit dP bezeichnet.<br>viii. KD.e = ELC_DEC(PO<sub>A</sub>, affectedObject_PrK.privateElcKey, C, T).<br>ix.  KD.i = '00…00' = I2OS(0, OctetLength(KD.e)).<br>x.   Die Oktettstrings KD.e und KD.i MÜSSEN an den Secure Messaging Layer übergeben werden (siehe CosT_a2e). <b>[<=]</b>

REQ(ids=G2_N085.068.b.8)<b>G2_N085.068.b.8 - (N085.068)b.8 K_COS</b>
PAR Falls das Kommando mit dem Trailer NoError antwortet, genau dann MUSS setSecurityStatus( affectedObject_PuK ) ausgeführt werden. <b>[<=]</b>

REQ(ids=G2_N085.068.b.9)<b>G2_N085.068.b.9 - (N085.068)b.9 K_COS</b>
PAR Die Antwortdaten MÜSSEN leer sein: responseData = ''. <b>[<=]</b>

PAR Hinweis CosH_6bc: Wegen (N008.600)d und CosT_a91 ist L<sub>06</sub> in (N085.068)b.7.iii stets 9 und damit oidDO stets 11 Oktett lang.
PAR Hinweis CosH_361: In Abhängigkeit von den Domainparametern von affectedObject_PrK, (N000.300)a und (N008.600)b gilt für L<sub>86</sub> in (N085.068)b.7.iv:<br>a. brainpoolP256r1: L<sub>86</sub> =   65   =>   keyDO ist   70 Oktett lang.<br>b. brainpoolP384r1: L<sub>86</sub> =   97   =>   keyDO ist 102 Oktett lang.<br>c. brainpoolP512r1: L<sub>86</sub> = 129   =>   keyDO ist 136 Oktett lang.
PAR Hinweis CosH_61b: Wegen (N085.040) und (N004.800)e ist L<sub>86</sub> in (N085.068)b.7.v gleich 1 + 64 + 16 = 81 und damit cipherDO 83 Oktett lang.
PAR Hinweis CosH_8sd: Wegen (N002.810)h ist L<sub>8E</sub> in (N085.068)b.7.vi gleich 8 und damit macDO 10 Oktett lang.
REQ(ids=G2_N085.070)<b>G2_N085.070 - (N085.070) K_COS</b>
PAR Als Datenfeld der Antwortnachricht MUSS der (möglicherweise leere) Oktettstring responseData verwendet werden. <b>[<=]</b>

REQ(ids=G2_N085.072)<b>G2_N085.072 - (N085.072) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16583)<b>A_16583 - (N085.074)a K_TST</b>
PAR Die Priorität der Trailer in CosT_b4e MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N085.074.b)<b>G2_N085.074.b - (N085.074)b K_COS</b>
PAR Jeder Trailer in CosT_b4e MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR Hinweis CosH_a4e: Im Rahmen dieser Spezifikation sind Authentisierungssequenzen nicht unterbrechbar (siehe (N104.600)).
PAR Hinweis CosH_0cc: Bei der Schlüsselsuche in (N085.052)c wird nach einem öffentlichen Schlüsselobjekt gesucht. Trotzdem wird algID aus keyReferenceList.internalAuthenticate entnommen, damit sichergestellt ist, dass öffentliches wie privates Schlüsselobjekt denselben Algorithmus verwenden. Aus der übrigen Spezifikation ergibt sich, dass dieser Algorithmus Element der Menge<br>{ elcSessionkey4SM, elcSessionkey4TC } ist.
PAR -HEADING(ids=14.7.3)14.7.3 CosK_e80 GET SECURITY STATUS KEY
PAR Hinweis CosH_364: Dieses Kommando ist in der Normenreihe ISO/IEC 7816 nicht enthalten. Es ließe sich kombinieren mit dem Kommando EXTERNAL AUTHENTICATE.
PAR Hinweis CosH_149: Bei der Spezifikation der Kommando-APDU wurde das MSE-Set-Kommando zugrunde gelegt.
PAR Hinweis CosH_3ab: Motivation für das Kommando: Ausgehend von der Annahme, dass ein bestimmtes Kommando mit dem Trailer SecurityStatusNotSatisfied terminiert, ist für die steuernde Software gelegentlich nicht offensichtlich, was zu tun ist, um Zugriff zu erhalten. Selbst bei Kenntnis der Zugriffsregel des Objektes lässt sich lediglich beurteilen, ob Secure Messaging Vorgaben eingehalten wurden. Falls eine PIN-Verifikation erforderlich ist, so lässt sich der zugehörige Sicherheitszustand mittels GET PIN STATUS erfragen. Falls aber mehrere Sicherheitszustände von Schlüsseln ins Spiel kommen, dann hat die steuernde Software nur zwei Möglichkeiten: Entweder "Try and error", was schlecht für die Performanz ist, oder sie baut die COS spezifische Zustandsmaschine für den Sicherheitsstatus von Schlüsseln nach (und hofft, dass interner und externer Zustand synchron bleiben).
PAR Das Kommando GET SECURITY STATUS KEY wird verwendet, um den Sicherheitszustand von Schlüsselobjekten zu erfragen. Welcher Sicherheitszustand ausgelesen wird, bestimmt eine Referenz, die als Parameter in den Kommandodaten enthalten ist.
PAR -HEADING(ids=14.7.3.1)14.7.3.1 CosK_e7b Use Case Auslesen Sicherheitsstatus symmetrischer Schlüssels, Option_DES
PAR Die folgenden Anforderungen sind absichtlich leer: (N085.100), (N085.200), (N085.300), (N085.400).
PAR In dieser Variante enthält die APDU des GET SECURITY STATUS KEY Kommandos einen Parameter:
REQ(ids=A_16508)<b>A_16508 - (N085.100) K_externeWelt {K_Karte}, Option_DES</b>
PAR Der Parameter cmdData enthält eine Schlüsselreferenz. Wert und Codierung MÜSSEN gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=A_16509)<b>A_16509 - (N085.200) K_externeWelt {K_Karte}, Option_DES</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosK_0f6 verwendet werden.
PAR (ids=Tabelle-248,-CosT_0f6)Tabelle 248, CosT_0f6: GET SECURITY STATUS KEY, symmetrischer Schlüssel

TABLE(rows=6,cols=64+86+445)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '80' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4] wird hier "proprietary" angezeigt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '82' TD(2,2/1/1)->PAR Instruction Byte (derselbe Wert wie bei EXTERNAL AUTHENTICATE)
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '80' TD(3,2/1/1)->PAR Auslesen Sicherheitszustand
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR –
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '83 01 || cmdData '
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.3.2)14.7.3.2 CosK_3dd Use Case Auslesen Sicherheitsstatus einer Rolle, Option_RSA_CVC
PAR In dieser Variante enthält die APDU des GET SECURITY STATUS KEY Kommandos einen Parameter:
REQ(ids=A_16510)<b>A_16510 - (N085.300) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Der Parameter cmdData enthält eine Rollenkennung. Wert und Codierung MÜSSEN gemäß CosK_ec2 und (N005.700) gewählt werden. <b>[<=]</b>

REQ(ids=A_16511)<b>A_16511 - (N085.400) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosK_0b6 verwendet werden.
PAR (ids=Tabelle-249,-CosT_0b6)Tabelle 249, CosT_0b6: GET SECURITY STATUS KEY, Rollenkennung

TABLE(rows=6,cols=64+86+445)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '80' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4] wird hier "proprietary" angezeigt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '82' TD(2,2/1/1)->PAR Instruction Byte (derselbe Wert wie bei EXTERNAL AUTHENTICATE)
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '80' TD(3,2/1/1)->PAR Auslesen Sicherheitszustand
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR –
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '5F4C - 07 - cmdData '
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.3.3)14.7.3.3 CosK_11e Use Case Auslesen Sicherheitsstatus einer Bitliste
PAR In dieser Variante enthält die APDU des GET SECURITY STATUS KEY Kommandos zwei Parameter:
REQ(ids=A_16512)<b>A_16512 - (N085.440) K_externeWelt {K_Karte}</b>
PAR Der Parameter oid MUSS eine OID aus der Menge {oid_cvc_fl_ti, oid_cvc_fl_cms} enthalten. <b>[<=]</b>

REQ(ids=A_16513)<b>A_16513 - (N085.442) K_externeWelt {K_Karte}</b>
PAR Der Parameter cmdData MUSS eine sieben Oktett lange Flagliste enthalten. Die beiden höchstwertigen Bit in cmdData MÜSSEN den Wert 0 besitzen. Für die Werte übrigen Bit gibt es keine Beschränkung. <b>[<=]</b>

REQ(ids=A_16514)<b>A_16514 - (N085.444) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosK_3cf verwendet werden.
PAR (ids=Tabelle-250,-CosT_3cf)Tabelle 250, CosT_3cf: GET SECURITY STATUS KEY, bitSecurityList

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '80' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4] wird hier "proprietary" angezeigt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '82' TD(2,2/1/1)->PAR Instruction Byte (derselbe Wert wie bei EXTERNAL AUTHENTICATE)
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '80' TD(3,2/1/1)->PAR Auslesen Sicherheitszustand
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR –
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '7F4C – 13 – (06 – 08 – oid || 53 – 07 – cmdData )'
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.3.4)14.7.3.4 Antwort der Karte auf Auslesen Sicherheitsstatus eines Schlüssels
PAR (ids=Tabelle-251,-CosT_380)Tabelle 251, CosT_380: GET SECURITY STATUS KEY Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 CF' TD(1,1/1/1)->PAR NoAuthentication TD(1,2/1/1)->PAR Authentisierungsstatus ist nicht gesetzt
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Authentisierungsstatus ist gesetzt
PAR (ids=Tabelle-252,-CosT_599)Tabelle 252, CosT_599: GET SECURITY STATUS KEY Antwort-APDU im Fehlerfall

TABLE(rows=3,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '69 82' TD(1,1/1/1)->PAR SecurityStatusNotSatisfied TD(1,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(2,0/1/1)->PAR '6A 88' TD(2,1/1/1)->PAR KeyNotFound TD(2,2/1/1)->PAR Adressiertes Schlüsselobjekt wurde nicht gefunden
PAR Hinweis CosH_000: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16515)<b>A_16515 - (N085.500) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando GET SECURITY STATUS KEY verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.7.3.5)14.7.3.5 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N085.600.a)<b>G2_N085.600.a - (N085.600)a K_COS</b>
PAR Das COS MUSS die GET SECURITY STATUS KEY-Varianten aus<br>1. Dieser Punkt ist absichtlich leer. (N085.200) (nur Option_DES)<br>2. Dieser Punkt ist absichtlich leer. (N085.400) (nur Option_RSA_CVC)<br>3. (N085.444)<br>unterstützen. <b>[<=]</b>

REQ(ids=A_16516)<b>A_16516 - (N085.600)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere GET SECURITY STATUS KEY-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

PAR (N085.700) ist absichtlich leer.<br>(N085.800) ist absichltich leer.
REQ(ids=A_16517)<b>A_16517 - (N085.700) K_COS, Option_DES</b>
PAR Wemm cmdData die Referenz eines symmetrischen Schlüssels gemäß (N085.200) ist, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N085.700.a)<b>G2_N085.700.a - (N085.700)a K_COS</b>
PAR Schritt 1: Es wird affectedObject = SearchSecretKey(<br>    channelContext.currentFolder,<br>    cmdData,<br>    Wildcard     <br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren.<br>Hinweis CosH_54b: Der Fehler notSupported ist wegen der Wildcard-Suche nicht möglich. <b>[<=]</b>

REQ(ids=G2_N085.700.b)<b>G2_N085.700.b - (N085.700)b K_COS</b>
PAR Schritt 2:Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N085.700.c)<b>G2_N085.700.c - (N085.700)c K_COS</b>
PAR Schritt 3: Wenn affectedObject in globalSecurityList (siehe (N029.900)e) oder in dfSpecificSecurityList (siehe (N029.900)f) enthalten ist, dann MUSS als Trailer NoError verwendet werden. <b>[<=]</b>

REQ(ids=G2_N085.800)<b>G2_N085.800 - (N085.800) K_COS, Option_RSA_CVC</b>
PAR Falls cmdData eine Rolle gemäß (N085.400) ist und diese Rolle in globalSecurityList (siehe (N029.900)e) oder in dfSpecificSecurityList (siehe (N029.900)f) enthalten ist, dann MUSS als Trailer NoError verwendet werden. <b>[<=]</b>

REQ(ids=G2_N085.900)<b>G2_N085.900 - (N085.900) K_COS</b>
PAR Wenn cmdData ein CHAT enthält und es gibt mindestens ein Element in bitSecurityList (siehe (N029.900)h), in welchem dieselbe OID und mindestens dieselben Bits gesetzt sind wie in flagList (siehe auch CosH_1ea), dann MUSS als Trailer NoError verwendet werden. <b>[<=]</b>

REQ(ids=G2_N086.000)<b>G2_N086.000 - (N086.000) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoAuthentication gewählt werden. <b>[<=]</b>

REQ(ids=A_16518)<b>A_16518 - (N086.100)a K_TST</b>
PAR Die Priorität der Trailer in CosK_599 MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N086.100.b)<b>G2_N086.100.b - (N086.100)b K_COS</b>
PAR Jeder Trailer in CosK_599 MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

REQ(ids=G2_N086.100.c)<b>G2_N086.100.c - (N086.100)c K_COS</b>
PAR NoError MUSS eine höhere Priorität als NoAuthentication haben. <b>[<=]</b>

PAR -HEADING(ids=14.7.4)14.7.4 CosK_6fe INTERNAL AUTHENTICATE
PAR Das Kommando INTERNAL AUTHENTICATE berechnet Authentisierungsdaten zu einem Token mittels eines symmetrischen oder privaten Schlüssels. Der Schlüssel wird vor der Authentisierungsoperation ausgewählt. Dies geschieht vor dem Senden dieses INTERNAL AUTHENTICATE-Kommandos durch ein MSE-Set-Kommando (siehe (N100.400) und (N100.900)). Das Token ist als Parameter in der Kommandonachricht enthalten.
PAR -HEADING(ids=14.7.4.1)14.7.4.1 CosK_f9b Use Case internes Authentisieren
PAR In dieser Variante enthält die APDU des INTERNAL AUTHENTICATE-Kommandos zwei Parameter:
REQ(ids=A_16584)<b>A_16584 - (N086.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter token enthält die zu authentisierenden Daten. Der Parameter token ist ein Oktettstring mit beliebigem Inhalt. Die Länge von token MUSS abhängig von der mittels (N100.400) oder (N100.800) ausgewählten algId gewählt werden. <b>[<=]</b>

REQ(ids=A_16585)<b>A_16585 - (N086.200)a K_externeWelt {K_Karte}</b>
PAR Wenn algId gleich elcRoleAuthentication ist, dann MUSS token gleich 24 Oktett lang sein. <b>[<=]</b>

REQ(ids=A_16586)<b>A_16586 - (N086.200)b K_externeWelt {K_Karte}</b>
PAR Wenn algId gleich rsaClientAuthentication ist, dann DARF token NICHT länger als 64 Oktette sein. <b>[<=]</b>

PAR (N086.200)c ist absichtlich leer.<br>(N086.200)d ist absichtlich leer.
REQ(ids=N086.200.c)<b>N086.200.c - (N086.200)c K_externeWelt {K_Karte} Option_RSA_CVC</b>
PAR Wenn algId gleich rsaRoleAuthentication ist, dann MUSS token gleich 16 Oktette lang sein. <b>[<=]</b>

REQ(ids=N086.200.d)<b>N086.200.d - (N086.200)d K_externeWelt {K_Karte} Option_DES</b>
PAR Wenn algId gleich rsaSessionkey4SM ist, dann MUSS token gemäß (N106.700) gewählt werden. <b>[<=]</b>

REQ(ids=A_16587)<b>A_16587 - (N086.200)e K_externeWelt {K_Karte}</b>
PAR Wenn algId gleich signPKCS1_V1_5 ist, dann MUSS die Anzahl Oktette in token kleiner als 0,4 OctetLength( n ) sein, mit n als Modulus des ausgewählten Authentisierungsschlüssels. <b>[<=]</b>

REQ(ids=A_16588)<b>A_16588 - (N086.200)f K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Wenn algId gleich aesSessionkey4TC ist, dann MUSS token gleich 24 Oktett lang sein. <b>[<=]</b>

PAR (N086.200)g ist absichtlich leer.<br>(N086.200)h ist absichtlich leer.
REQ(ids=A_16589)<b>A_16589 - (N086.200)g K_externeWelt {K_Karte}, Option_Kryptobox, Option_DES</b>
PAR Wenn algId gleich desSessionkey4TC ist, dann MUSS token gleich 16 Oktett lang sein. <b>[<=]</b>

REQ(ids=A_16590)<b>A_16590 - (N086.200)h K_externeWelt {K_Karte}, Option_Kryptobox, Option_DES</b>
PAR Wenn algId gleich rsaSessionkey4TC ist, dann MUSS token gleich 16 Oktett lang sein. <b>[<=]</b>

PAR (N086.202) Diese Anforderung ist absichtlich leer.
REQ(ids=A_16591)<b>A_16591 - (N086.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS  so aus der Menge {WildCardShort, WildCardExtended} gewählt werden, dass der komplette Oktettstring response in der Antwortnachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_16592)<b>A_16592 - (N086.400) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 oder eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_1d2 verwendet werden.
PAR (ids=Tabelle-253,-CosT_1d2)Tabelle 253, CosT_1d2: INTERNAL AUTHENTICATE

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '88' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR Information zum Algorithmus bereits in der Karte vorhanden
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR Schlüsselreferenz bereits in der Karte vorhanden
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR token
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.7.4.2)14.7.4.2 Antwort der Karte auf internes Authentisieren
PAR (ids=Tabelle-254,-CosT_710)Tabelle 254, CosT_710: INTERNAL AUTHENTICATE Antwort-APDU im Erfolgsfall

TABLE(rows=4,cols=63+183+345)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)->PAR response TD(1,2/1/1)->PAR Authentisierende Daten
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '90 00' TD(3,1/1/1)->PAR NoError TD(3,2/1/1)->PAR Erfolgreiche Authentisierungsoperation
PAR (ids=Tabelle-255,-CosT_235)Tabelle 255, CosT_235: INTERNAL AUTHENTICATE Antwort-APDU im Fehlerfall

TABLE(rows=9,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '64 00' TD(1,1/1/1)->PAR KeyInvalid TD(1,2/1/1)->PAR Schlüsseldaten fehlen
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '69 85' TD(3,1/1/1)->PAR NoKeyReference TD(3,2/1/1)->PAR Kein Authentisierungsschlüssel ausgewählt
TR-> TD(4,0/1/1)->PAR '69 85' TD(4,1/1/1)->PAR NoPukReference TD(4,2/1/1)->PAR Kein Verschlüsselungsschlüssel ausgewählt
TR-> TD(5,0/1/1)->PAR `6A 80' TD(5,1/1/1)->PAR WrongToken TD(5,2/1/1)->PAR fehlerhaftes Token
TR-> TD(6,0/1/1)->PAR '6A 81' TD(6,1/1/1)->PAR UnsupportedFunction TD(6,2/1/1)->PAR Schlüssel unterstützt den angegeben Algorithmus nicht
TR-> TD(7,0/1/1)->PAR '6A 88' TD(7,1/1/1)->PAR KeyNotFound TD(7,2/1/1)->PAR Authentisierungsschlüssel nicht gefunden
TR-> TD(8,0/1/1)->PAR '6A 88' TD(8,1/1/1)->PAR PukNotFound TD(8,2/1/1)->PAR Verschlüsselungsschlüssel nicht gefunden
PAR Hinweis CosH_0aa: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16593)<b>A_16593 - (N086.500) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando INTERNAL AUTHENTICATE verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.7.4.3)14.7.4.3 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N086.600.a)<b>G2_N086.600.a - (N086.600)a K_COS</b>
PAR Das COS MUSS die INTERNAL AUTHENTICATE-Variante aus (N086.400) unterstützen. <b>[<=]</b>

REQ(ids=A_16594)<b>A_16594 - (N086.600)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere INTERNAL AUTHENTICATE-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N086.700.a)<b>G2_N086.700.a - (N086.700)a K_COS</b>
PAR Wenn channelContext.keyReferenceList.internalAuthenticate leer ist, genau dann MUSS das Kommando mit dem Trailer NoKeyReference terminieren. <b>[<=]</b>

REQ(ids=A_16595)<b>A_16595 - (N086.700)b K_COS</b>
PAR Wenn channelContext.keyReferenceList.internalAuthenticate nicht leer ist, dann wird<br>affectedObject = SearchKey(<br>    currentFolder,<br>    keyReferenceList.internalAuthenticate.keyReference,<br>    keyReferenceList.internalAuthenticate.algID<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. <b>[<=]</b>

REQ(ids=G2_N086.700.b.1)<b>G2_N086.700.b.1 - (N086.700)b.1 K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N086.700.b.2)<b>G2_N086.700.b.2 - (N086.700)b.2 K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N086.800)<b>G2_N086.800 - (N086.800) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N086.810)<b>G2_N086.810 - (N086.810) K_COS</b>
PAR Wenn affectedObject.keyAvailable den Wert False besitzt, genau dann MUSS das Kommando mit dem Trailer KeyInvalid terminieren. <b>[<=]</b>

REQ(ids=G2_N086.820)<b>G2_N086.820 - (N086.820) K_COS</b>
PAR Wenn channelContext.keyReferenceList.internalAuthenticate.algID einen Wert aus der Menge {aesSessionkey4TC, desSessionkey4TC, elcRoleAuthentication, rsaRoleAuthentication, rsaSessionkey4SM, rsaSessionkey4TC} besitzt und die acht LSByte von token identisch sind zu iccsn8 (siehe (N019.900)c), genau dann MUSS das Kommando mit dem Trailer WrongToken terminieren. <b>[<=]</b>

REQ(ids=A_16596)<b>A_16596 - (N086.900) K_COS</b>
PAR Die Antwort response MUSS wie folgt in Abhängigkeit von algID = channelContext.keyReferenceList.internalAuthenticate.algID berechnet werden: <b>[<=]</b>

REQ(ids=G2_N086.900.a)<b>G2_N086.900.a - (N086.900)a K_COS</b>
PAR Falls algID den Wert elcRoleAuthentication besitzt, dann gilt mit PrK = affectedObject.privateKey:<br>response = ELC_SIG( PrK, I2OS(OS2I(token || elcRoleAuthentication), PrK.domainParameter.t /8)). <b>[<=]</b>

REQ(ids=G2_N086.900.b)<b>G2_N086.900.b - (N086.900)b K_COS</b>
PAR Falls algID den Wert rsaClientAuthentication besitzt, dann gilt    <br>response = RSASSA_PSS_SIGN( PrK, token ). <b>[<=]</b>

PAR (N086.900)c ist absichtlich leer.<br>(N086.900)d ist absichtlich leer.
REQ(ids=A_16597)<b>A_16597 - (N086.900)c K_COS, Option_RSA_CVC</b>
PAR Falls algID den Wert , rsaRoleAuthentication besitzt, dann MÜSSEN mit der Definition PrK = affectedObject.privateKey folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N086.900.c.1)<b>G2_N086.900.c.1 - (N086.900)c.1 K_COS, Option_RSA_CVC</b>
PAR Schritt c.1: PRND    = RAND(OctetLength( PrK.n ) – 34 ) <b>[<=]</b>

REQ(ids=G2_N086.900.c.2)<b>G2_N086.900.c.2 - (N086.900)c.2 K_COS, Option_RSA_CVC</b>
PAR Schritt c.2: M         = PRND   ||   token <b>[<=]</b>

REQ(ids=G2_N086.900.c.3)<b>G2_N086.900.c.3 - (N086.900)c.3 K_COS, Option_RSA_CVC</b>
PAR Schritt c.3: ( response, M2 ) = RSA_ISO9796_2_DS1_SIGN( PrK, M )    <br>Hinweis CosH_c2d: Die Länge von PRND ist so gewählt, dass M2 = token ist. Darum ist es nicht notwendig, M2 in die Antwortnachricht einzustellen. <b>[<=]</b>

REQ(ids=A_16598)<b>A_16598 - (N086.900)d K_COS, Option_DES</b>
PAR Falls algID den Wert rsaSessionkey4SM besitzt, dann MÜSSEN mit der Definition PrK = affectedObject.privateKey folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N086.900.d.1)<b>G2_N086.900.d.1 - (N086.900)d.1 K_COS, Option_DES</b>
PAR Schritt d.1: KD.i        = RAND( 64 ).<br>Der Oktettstring KD.i MUSS an den Secure Messaging Layer übergeben werden (siehe CosT_a2e). <b>[<=]</b>

REQ(ids=G2_N086.900.d.2)<b>G2_N086.900.d.2 - (N086.900)d.2 K_COS, Option_DES</b>
PAR Schritt d.2: PRND        = RAND(OctetLength( PrK.n ) – 34 – OctetLength(KD.i) ) <b>[<=]</b>

REQ(ids=G2_N086.900.d.3)<b>G2_N086.900.d.3 - (N086.900)d.3 K_COS, Option_DES</b>
PAR Schritt d.3: M             = PRND   ||   KD.i   ||   token <b>[<=]</b>

REQ(ids=G2_N086.900.d.4)<b>G2_N086.900.d.4 - (N086.900)d.4 K_COS, Option_DES</b>
PAR Schritt d.4: ( sig, M2 )     = RSA_ISO9796_2_DS1_SIGN( PrK, M )    <br>Hinweis CosH_c73: Die Länge von PRND ist so gewählt, dass M2 = token ist. Darum ist es nicht notwendig, M2 in die Antwortnachricht einzustellen. <b>[<=]</b>

REQ(ids=G2_N086.900.d.5.i)<b>G2_N086.900.d.5.i - (N086.900)d.5.i K_COS, Option_DES</b>
PAR Schritt d.5.i: Wenn channelContext.keyReferenceList.externalAuthenticate leer ist, genau dann MUSS das Kommando mit dem Trailer NoPukReference terminieren. <b>[<=]</b>

REQ(ids=A_16599)<b>A_16599 - (N086.900)d.5.ii K_COS, Option_DES</b>
PAR Schritt d.5.ii: Wenn channelContext.keyReferenceList.externalAuthenticate nicht leer, dann wird<br>tmpObject = SearchKey(<br>    currentFolder,<br>    keyReferenceList.externalAuthenticate.keyReference,<br>    keyReferenceList.internalAuthenticate.algID<br>) gesetzt. Gemäß CosT_995 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. Wenn die Schlüsselsuche den Fehler<br>A. keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer PukNotFound terminieren.<br>B. notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N086.900.d.6)<b>G2_N086.900.d.6 - (N086.900)d.6 K_COS, Option_DES</b>
PAR Schritt d.6: response = sig<sup>PuK.e</sup> mod PuK.n, mit PuK = tmpObject.publicKey. <b>[<=]</b>

REQ(ids=G2_N086.900.e)<b>G2_N086.900.e - (N086.900)e K_COS</b>
PAR Falls algID den Wert signPKCS1_V1_5 besitzt, dann gilt:    <br>response = RSASSA_PKCS1_V1_5_SIGN( PrK, token ) <b>[<=]</b>

REQ(ids=A_16600)<b>A_16600 - (N086.902)a K_COS, Option_Kryptobox</b>
PAR Falls channelContext.keyReferenceList.internalAuthenticate.algID den Wert aesSessionkey4TC besitzt, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N086.902.a.1)<b>G2_N086.902.a.1 - (N086.902)a.1 K_COS, Option_Kryptobox</b>
PAR Schritt a.1: Setze       RND.int     = RAND( 16 ) <b>[<=]</b>

REQ(ids=G2_N086.902.a.2)<b>G2_N086.902.a.2 - (N086.902)a.2 K_COS, Option_Kryptobox</b>
PAR Schritt a.2: Setze       ICCSN8.int     = iccsn8 (siehe (N019.900)c) <b>[<=]</b>

REQ(ids=G2_N086.902.a.3)<b>G2_N086.902.a.3 - (N086.902)a.3 K_COS, Option_Kryptobox</b>
PAR Schritt a.3: Setze       KD.i         = RAND( 64 ) <b>[<=]</b>

REQ(ids=G2_N086.902.a.4)<b>G2_N086.902.a.4 - (N086.902)a.4 K_COS, Option_Kryptobox</b>
PAR Schritt a.4: Setze   S = RND.int  ||  ICCSN8.int  ||  token  ||  KD.i <b>[<=]</b>

REQ(ids=G2_N086.902.a.5)<b>G2_N086.902.a.5 - (N086.902)a.5 K_COS, Option_Kryptobox</b>
PAR Schritt a.5: Setze C1 = AES_CBC_ENC( affectedObject.encKey, 0, S ) <b>[<=]</b>

REQ(ids=G2_N086.902.a.6)<b>G2_N086.902.a.6 - (N086.902)a.6 K_COS, Option_Kryptobox</b>
PAR Schritt a.6: Setze MAC1 = CalculateCMAC_IsoPadding( affectedObject.macKey, C1 ) <b>[<=]</b>

REQ(ids=G2_N086.902.a.7)<b>G2_N086.902.a.7 - (N086.902)a.7 K_COS, Option_Kryptobox</b>
PAR Schritt a.7: Setze response = C1   ||   MAC1 <b>[<=]</b>

REQ(ids=G2_N086.902.a.8)<b>G2_N086.902.a.8 - (N086.902)a.8 K_COS, Option_Kryptobox</b>
PAR Schritt a.8: RND.int MUSS als RND.ICC gespeichert werden (siehe (N029.900)b). <b>[<=]</b>

REQ(ids=G2_N086.902.a.9)<b>G2_N086.902.a.9 - (N086.902)a.9 K_COS, Option_Kryptobox</b>
PAR Schritt a.9: KD.i MUSS an den Secure Messaging Layer übergeben werden (siehe CosT_a2e). <b>[<=]</b>

PAR (N086.902)b ist absichtlich leer.<br>(N086.902)c ist absichtlich leer.
REQ(ids=A_16601)<b>A_16601 - (N086.902)b K_COS, Option_DES</b>
PAR Falls channelContext.keyReferenceList.internalAuthenticate.algID den Wert desSessionkey4TC besitzt, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N086.902.b.1)<b>G2_N086.902.b.1 - (N086.902)b.1 K_COS, Option_DES</b>
PAR Schritt b.1: Setze       RND.int     = RAND( 8 ). <b>[<=]</b>

REQ(ids=G2_N086.902.b.2)<b>G2_N086.902.b.2 - (N086.902)b.2 K_COS, Option_DES</b>
PAR Schritt b.2: Setze       ICCSN8.int     = iccsn8 (siehe (N019.900)c) <b>[<=]</b>

REQ(ids=G2_N086.902.b.3)<b>G2_N086.902.b.3 - (N086.902)b.3 K_COS, Option_DES</b>
PAR Schritt b.3: Setze       KD.i         = RAND( 64 ). <b>[<=]</b>

REQ(ids=G2_N086.902.b.4)<b>G2_N086.902.b.4 - (N086.902)b.4 K_COS, Option_DES</b>
PAR Schritt b.4: Setze   S = RND.int  ||  ICCSN8.int  ||  token  ||  KD.i <b>[<=]</b>

REQ(ids=G2_N086.902.b.5)<b>G2_N086.902.b.5 - (N086.902)b.5 K_COS, Option_DES</b>
PAR Schritt b.5: Setze C1 = 3TDES_CBC_ENC( affectedObject.encKey, 0, S ) <b>[<=]</b>

REQ(ids=G2_N086.902.b.6)<b>G2_N086.902.b.6 - (N086.902)b.6 K_COS, Option_DES</b>
PAR Schritt b.6: Setze MAC1 = CALCULATE_Retail_MAC( affectedObject.macKey, C1 ) <b>[<=]</b>

REQ(ids=G2_N086.902.b.7)<b>G2_N086.902.b.7 - (N086.902)b.7 K_COS, Option_DES</b>
PAR Schritt b.7: Setze response = C1   ||   MAC1 <b>[<=]</b>

REQ(ids=G2_N086.902.b.8)<b>G2_N086.902.b.8 - (N086.902)b.8 K_COS, Option_DES</b>
PAR Schritt b.8: RND.int MUSS als RND.ICC gespeichert werden (siehe (N029.900)b). <b>[<=]</b>

REQ(ids=G2_N086.902.b.9)<b>G2_N086.902.b.9 - (N086.902)b.9 K_COS, Option_DES</b>
PAR Schritt b.9: KD.i MUSS an den Secure Messaging Layer übergeben werden (siehe CosT_a2e). <b>[<=]</b>

REQ(ids=G2_N086.902.c)<b>G2_N086.902.c - (N086.902)c K_COS, Option_DES</b>
PAR Falls channelContext.keyReferenceList.internalAuthenticate.algID den Wert rsaSessionkey4TC besitzt, dann MUSS im Rahmen der Kommandobearbeitung identisch zu rsaSessionkey4SM verfahren werden. <b>[<=]</b>

REQ(ids=G2_N087.000)<b>G2_N087.000 - (N087.000) K_COS</b>
PAR Als Datenfeld der Antwortnachricht MUSS response verwendet werden. <b>[<=]</b>

REQ(ids=G2_N087.100)<b>G2_N087.100 - (N087.100) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16602)<b>A_16602 - (N087.200)a K_TST</b>
PAR Die Priorität der Trailer in CosT_235 MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N087.200.b)<b>G2_N087.200.b - (N087.200)b K_COS</b>
PAR Jeder Trailer in CosT_235 MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR Hinweis CosH_9a7: Bei der Schlüsselsuche in (N086.900)d.5.ii wird nach einem öffentlichen Schlüsselobjekt gesucht. Trotzdem wird algID aus keyReferenceList.internalAuthenticate entnommen, damit sicher gestellt ist, dass auch das öffentliche Schlüsselobjekt den hier zum Tragen kommenden Algorithmus unterstützt. Aus der übrigen Spezifikation ergibt sich, dass dieser Algorithmus Element von {rsaSessionkey4SM, rsaSessionkey4TC} ist.
PAR -HEADING(ids=14.8)14.8 CosK_00c Kryptographische Operationen
PAR Hinweis CosH_b01: In einer früheren Version trug dieses Kapitel die Überschrift "Kryptoboxkommandos". Es wurde umbenannt in "Krypto Operationen", weil es zu Verwechselungen mit der Option_Kryptobox kam.
PAR Dieses Unterkapitel behandelt Funktionalitäten, die in [ISO/IEC 7816-8] mit dem Kommando PERFORM SECURITY OPERATION verknüpft und alle über den INS Code '2A' erreichbar sind. Die folgende Tabelle gibt einen informativen Überblick über die hier behandelten Funktionalitäten. Einzelheiten finden sich in den nachfolgenden Kapiteln.
PAR (ids=Tabelle-256,-CosT_c98)Tabelle 256, CosT_c98: Tabelle aller PERFORM SECURITY OPERATION Kommando Header

TABLE(rows=12,cols=48+43+47+44+284+63)->
TR-> TH(0,0/1/1)->PAR CLA TH(0,1/1/1)->PAR INS TH(0,2/1/1)->PAR P1 TH(0,3/1/1)->PAR P2 TH(0,4/1/1)->PAR Kommando TH(0,5/1/1)->PAR Referenz
TR-> TD(1,0/11/1)->PAR '00' TD(1,1/11/1)->PAR '2A' TD(1,2/1/1)->PAR '8E' TD(1,3/1/1)->PAR '80' TD(1,4/1/1)->PAR PSO Compute Cryptographic Checksum TD(1,5/1/1)->PAR CosK_2f2
TR-> TD(2,2/1/1)->PAR '9E' TD(2,3/1/1)->PAR '9A' TD(2,4/1/1)->PAR PSO Compute Digital Signature, ohne "recovery" TD(2,5/1/1)->PAR CosK_582
TR-> TD(3,2/1/1)->PAR '9E' TD(3,3/1/1)->PAR 'AC' TD(3,4/1/1)->PAR PSO Compute Digital Signature, mit "recovery" TD(3,5/1/1)->PAR CosK_f37
TR-> TD(4,2/1/1)->PAR '80' TD(4,3/1/1)->PAR '86' TD(4,4/1/1)->PAR PSO Decipher TD(4,5/1/1)->PAR CosK_a85
TR-> TD(5,2/1/1)->PAR '86' TD(5,3/1/1)->PAR '80' TD(5,4/1/1)->PAR PSO Encipher TD(5,5/1/1)->PAR CosK_f48
TR-> TD(6,2/1/1)->PAR '90' TD(6,3/1/1)->PAR 'XX' TD(6,4/1/1)->PAR PSO Hash, siehe [ISO/IEC 7816-8] TD(6,5/1/1)->PAR -
TR-> TD(7,2/1/1)->PAR '86' TD(7,3/1/1)->PAR 'B8' TD(7,4/1/1)->PAR PSO Transcipher mittels RSA TD(7,5/1/1)->PAR CosK_94a
TR-> TD(8,2/1/1)->PAR '86' TD(8,3/1/1)->PAR 'B8' TD(8,4/1/1)->PAR PSO Transcipher mittels ELC TD(8,5/1/1)->PAR CosK_e8f
TR-> TD(9,2/1/1)->PAR '00' TD(9,3/1/1)->PAR 'AE' TD(9,4/1/1)->PAR PSO Verify Certificate TD(9,5/1/1)->PAR CosK_ca7
TR-> TD(10,2/1/1)->PAR '00' TD(10,3/1/1)->PAR 'A2' TD(10,4/1/1)->PAR PSO Verify Cryptographic Checksum TD(10,5/1/1)->PAR CosK_dbc
TR-> TD(11,2/1/1)->PAR '00' TD(11,3/1/1)->PAR 'A8' TD(11,4/1/1)->PAR PSO Verify Digital Signature TD(11,5/1/1)->PAR CosK_3e9
PAR -HEADING(ids=14.8.1)14.8.1 CosK_2f2 PSO Compute Cryptographic Checksum
PAR Das Kommando PSO Compute Cryptographic Checksum berechnet zu gegebenen Daten eine kryptographische Checksumme mittels eines symmetrischen Schlüssels. Der symmetrische Schlüssel wird im Rahmen einer gegenseitigen Authentisierung (siehe CosK_b47, CosK_580, CosK_2da oder CosK_2ed) ausgehandelt. Die durch eine Checksumme zu schützenden Daten sind als Parameter in der Kommandonachricht enthalten.
PAR -HEADING(ids=14.8.1.1)14.8.1.1 CosK_7d0 Use Case Berechnen einer kryptographischen Checksumme
PAR Diese Variante gilt für Algorithmen aus der folgenden Menge: {aesSessionkey, desSessionkey (Option_DES)}.
PAR In dieser Variante enthält die APDU des PSO Compute Cryptographic Checksum Kommandos drei Parameter:
REQ(ids=A_16603)<b>A_16603 - (N087.220)a K_externeWelt {K_Karte}, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Der Parameter flagSSCmacIncrement MUSS wie folgt gewählt werden: <b>[<=]</b>

PAR (N087.220)a.1 ist absichtlich leer.
REQ(ids=N07.220.a.1)<b>N07.220.a.1 - (N087.220)a.1 K_externeWelt {K_Karte}, (Option_Kryptobox oder Option_PACE_PCD) und Option_DES</b>
PAR Wenn es sich um Sessionkeys für den Algorithmus desSessionkey handelt, dann ist flagSSCmacIncrement ein leerer Oktettstring. <b>[<=]</b>

REQ(ids=A_16604)<b>A_16604 - (N087.220)a.2 K_externeWelt {K_Karte}, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn es sich um Sessionkeys für den Algorithmus aesSessionkey handelt und SSCmac<br>i.  zu inkrementieren ist, dann ist flagSSCmacIncrement = '01'.<br>ii. unverändert zu verwenden ist, dann ist flagSSCmacIncrement = '00'. <b>[<=]</b>

REQ(ids=A_16605)<b>A_16605 - (N087.220)b K_externeWelt {K_Karte}, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Der Parameter data enthält die zu schützenden Daten. Der Parameter data ist ein Oktettstring mit beliebigem Inhalt. Die Länge von data MUSS aus dem in (N026.900) definierten Bereich gewählt werden. <b>[<=]</b>

REQ(ids=A_16606)<b>A_16606 - (N087.220)c K_externeWelt {K_Karte}, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus der Menge {WildCardShort, WildCardExtended} gewählt werden. <b>[<=]</b>

REQ(ids=A_16607)<b>A_16607 - (N087.228) K_externeWelt {K_Karte}, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 oder eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_861 verwendet werden.
PAR (ids=Tabelle-257,-CosT_861)Tabelle 257, CosT_861: PSO Compute Cryptographic Checksum, Berechnen eines MAC

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '8E' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier kryptographische Checksumme
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '80' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier Klartext
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR flagSSCmacIncrement   ||   data
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.1.2)14.8.1.2 Antwort der Karte auf Berechnen einer kryptographischen Checksumme
PAR (ids=Tabelle-258,-CosT_7e7)Tabelle 258, CosT_7e7: PSO Compute Cryptographic Checksum Antwort-APDU im Erfolgsfall

TABLE(rows=4,cols=63+183+345)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)->PAR mac TD(1,2/1/1)->PAR kryptographische Checksumme
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '90 00' TD(3,1/1/1)->PAR NoError TD(3,2/1/1)->PAR erfolgreiche Berechnung eines MAC
PAR (ids=Tabelle-259,-CosT_532)Tabelle 259, CosT_532: PSO Compute Cryptographic Checksum Antwort-APDU im Fehlerfall

TABLE(rows=5,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '69 82' TD(1,1/1/1)->PAR SecurityStatusNotSatisfied TD(1,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(2,0/1/1)->PAR '69 85' TD(2,1/1/1)->PAR NoKeyReference TD(2,2/1/1)->PAR kein Schlüssel für MAC Berechnung ausgewählt
TR-> TD(3,0/1/1)->PAR '6A 81' TD(3,1/1/1)->PAR UnsupportedFunction TD(3,2/1/1)->PAR Schlüssel unterstützt den angegeben Algorithmus nicht
TR-> TD(4,0/1/1)->PAR '6A 88' TD(4,1/1/1)->PAR KeyNotFound TD(4,2/1/1)->PAR kein Schlüssel für MAC Berechnung vorhanden
PAR Hinweis CosH_7cb: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16608)<b>A_16608 - (N087.232) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando PSO Compute Cryptographic Checksum verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.8.1.3)14.8.1.3 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N087.236.a)<b>G2_N087.236.a - (N087.236)a K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Das COS MUSS die PSO Compute Cryptographic Checksum Variante aus (N087.228) unterstützen. <b>[<=]</b>

REQ(ids=A_16609)<b>A_16609 - (N087.236)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere PSO Compute Cryptographic Checksum-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N087.240.a)<b>G2_N087.240.a - (N087.240)a K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn channelContext.keyReferenceList.macCalculation leer ist, genau dann MUSS das Kommando mit dem Trailer NoKeyReference terminieren. <b>[<=]</b>

REQ(ids=A_16610)<b>A_16610 - (N087.240)b K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn channelContext.keyReferenceList.macCalculation nicht leer ist, dann wird<br>affectedObject = SearchKey(<br>    currentFolder,<br>    keyReferenceList.macCalculation.keyReference,<br>    keyReferenceList.macCalculation.algID<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. <b>[<=]</b>

REQ(ids=G2_N087.240.b.1)<b>G2_N087.240.b.1 - (N087.240)b.1 K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N087.240.b.2)<b>G2_N087.240.b.2 - (N087.240)b.2 K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn die Schlüsselsuche den Fehler notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N087.244)<b>G2_N087.244 - (N087.244) K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

PAR Mit den Attributen SSCmac und Kmac aus dem Attribut SessionkeyContext gilt:
REQ(ids=G2_N087.248.a)<b>G2_N087.248.a - (N087.248)a K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn keyReferenceList.macCalculation.algID den Wert aesSessionkey besitzt, MUSS gelten:<br>1. Wenn flagSSCmacIncrement = '01' ist,<br>   dann wird SSCmac inkrementiert:  SSCmac = SSCmac + 1,<br>    sonst bleibt SSCmac unverändert.<br>2. mac = CalculateCMAC_IsoPadding(Kmac, I2OS(SSCmac, 16)  ||  data ). <b>[<=]</b>

PAR (N087.248)b ist absichtlich leer.
REQ(ids=G2_N087.248.b)<b>G2_N087.248.b - (N087.248)b K_COS, (Option_Kryptobox oder Option_PACE_PCD) und Option_DES</b>
PAR Wenn keyReferenceList.macCalculation.algID den Wert desSessionkey besitzt, MUSS gelten:<br>1. SSCmac = SSCmac + 1.<br>2. mac       = CALCULATE_Retail_MAC(Kmac, I2OS(SSCmac,   8)  ||  data ). <b>[<=]</b>

REQ(ids=G2_N087.252)<b>G2_N087.252 - (N087.252) K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Als Datenfeld der Antwortnachricht MUSS mac verwendet werden. <b>[<=]</b>

REQ(ids=G2_N087.256)<b>G2_N087.256 - (N087.256) K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16611)<b>A_16611 - (N087.260)a K_TST, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Die Priorität der Trailer in CosT_532 MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N087.260.b)<b>G2_N087.260.b - (N087.260)b K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Jeder Trailer in CosT_532 MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.8.2)14.8.2 CosK_e61 PSO Compute Digital Signature
PAR Das Kommando PSO Compute Digital Signature signiert Daten mittels eines privaten Schlüssels. Der private Schlüssel und der zu verwendende Algorithmus werden vor der Signieroperation ausgewählt. Dies geschieht vor dem Senden dieses PSO Compute Digital Signature-Kommandos durch ein MSE-Set-Kommando (siehe (N102.900)). Die zu signierenden Daten sind als Parameter in der Kommandonachricht enthalten.
PAR -HEADING(ids=14.8.2.1)14.8.2.1 CosK_582 Use Case Signieren des Datenfeldes, ohne "message recovery"
PAR Diese Variante gilt für folgende Algorithmen (siehe (N017.600) und (N018.300)): {rsaClientAuthentication, signECDSA, signPKCS1_V1_5, signPSS}.
PAR In dieser Variante enthält die APDU des PSO Compute Digital Signature-Kommandos zwei Parameter:
REQ(ids=A_16612)<b>A_16612 - (N087.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter dataToBeSigned enthält die zu signierenden Daten. Der Parameter dataToBeSigned ist ein Oktettstring mit beliebigem Inhalt. Die Länge von dataToBeSigned MUSS in Abhängigkeit von der mittels (N102.800) ausgewählten algId gewählt werden. <b>[<=]</b>

REQ(ids=A_16613)<b>A_16613 - (N087.300)a K_externeWelt {K_Karte}</b>
PAR Wenn algId gleich rsaClientAuthentication ist, dann MUSS die Länge von dataToBeSigned kleiner gleich 64 Oktette sein. <b>[<=]</b>

REQ(ids=A_16614)<b>A_16614 - (N087.300)b K_externeWelt {K_Karte}</b>
PAR Wenn algId gleich signECDSA ist, dann MUSS die Länge von dataToBeSigned gleich dem Parameter domainParameter.t des Signierschlüssels sein. <b>[<=]</b>

REQ(ids=A_16615)<b>A_16615 - (N087.300)c K_externeWelt {K_Karte}</b>
PAR Wenn algId gleich signPKCS1_V1_5 ist, dann MUSS die Länge von dataToBeSigned kleiner als 0,4 OctetLength( n ) sein, mit n als Modulus des ausgewählten Signaturschlüssels. <b>[<=]</b>

REQ(ids=A_16616)<b>A_16616 - (N087.300)d K_externeWelt {K_Karte}</b>
PAR Wenn algId gleichsignPSS ist, dann MUSS die Länge von dataToBeSigned kleiner gleich 64 Oktette sein. <b>[<=]</b>

REQ(ids=A_16617)<b>A_16617 - (N087.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS so aus der Menge {WildCardShort, WildCardExtended} gewählt werden, dass der komplette Oktettstring signature in der Antwortnachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_16618)<b>A_16618 - (N087.500) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 oder eine Case 4E Kommanod-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_c48 verwendet werden.
PAR (ids=Tabelle-260,-CosT_c48)Tabelle 260, CosT_c48: PSO Compute Digital Signature, Signieren ohne "message recovery"

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '9E' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier digitale Signature
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '9A' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier "zu signierende Daten"
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR dataToBeSigned
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.2.2)14.8.2.2 CosK_f37 Use Case Signieren des Datenfeldes, mit "message recovery"
PAR Diese Variante gilt für folgenden Algorithmus (siehe (N018.300)): {sign9796_2_DS2}.
PAR In dieser Variante enthält die APDU des PSO Compute Digital Signature-Kommandos drei Parameter:
REQ(ids=A_16619)<b>A_16619 - (N087.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter M1 enthält den "recoverable part" der zu signierenden Nachricht. Der Parameter M1 ist ein Oktettstring mit beliebigem Inhalt. Die Bitlänge von M1 DARF die Kapazität des Schemas gemäß [ISO/IEC 9796-2#9.2.4] NICHT überschreiten. <b>[<=]</b>

PAR Hinweis CosH_7cb: Die Kapazität eines RSA-Schlüssels (siehe (N002.100)) beträgt für die Moduluslänge<br>a. 2048 bit: c = k – L<sub>h</sub> – L<sub>s</sub> – 8t – 2 = (2048 – 256 – 256 – 8*1 – 2) bit = 1526 bit.<br>b. 3072 bit: c = k – L<sub>h</sub> – L<sub>s</sub> – 8t – 2 = (3072 – 256 – 256 – 8*1 – 2) bit = 2550 bit.
REQ(ids=A_16620)<b>A_16620 - (N087.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter hashM2 enthält den Hash-Wert des "non recoverable part" der zu signierenden Nachricht. Der Parameter hashM2 ist ein Oktettstring mit beliebigem Inhalt, dessen Länge kleiner gleich 64 sein MUSS. <b>[<=]</b>

REQ(ids=A_16621)<b>A_16621 - (N087.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS so aus der Menge {WildCardShort, WildCardExtended} gewählt werden, dass der komplette Oktettstring signature in der Antwortnachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_16622)<b>A_16622 - (N087.900) K_externeWelt {K_Karte}</b>
PAR Die Parameter M1 und hashM2 MÜSSEN im Datenfeld der Kommandonachricht enthalten sein. Die Codierung wird in (N088.600)b spezifiziert. Die Anzahl der Oktette in signInput9796_2_DS2 wird durch (N087.600) und (N087.700) beschränkt. <b>[<=]</b>

REQ(ids=A_16623)<b>A_16623 - (N088.000) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 oder eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_f84 verwendet werden.
PAR (ids=Tabelle-261,-CosT_f84)Tabelle 261, CosT_f84: PSO Compute Digital Signature, Signieren "message recovery"

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '9E' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier digitale Signature
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'AC' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier zu signierende Daten als DE
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR signInput9796_2_DS2, DER codiertes Datenfeld
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.2.3)14.8.2.3 Antwort der Karte auf Signieren von Daten
PAR (ids=Tabelle-262,-CosT_562)Tabelle 262, CosT_562: PSO Compute Digital Signature Antwort-APDU im Erfolgsfall

TABLE(rows=4,cols=63+183+345)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)->PAR signature TD(1,2/1/1)->PAR Signatur
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '90 00' TD(3,1/1/1)->PAR NoError TD(3,2/1/1)->PAR Erfolgreiche Signaturoperation
PAR (ids=Tabelle-263,-CosT_7c1)Tabelle 263, CosT_7c1: PSO Compute Digital Signature Antwort-APDU im Fehlerfall

TABLE(rows=6,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '64 00' TD(1,1/1/1)->PAR KeyInvalid TD(1,2/1/1)->PAR Schlüsseldaten fehlen
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '69 85' TD(3,1/1/1)->PAR NoKeyReference TD(3,2/1/1)->PAR Kein Signierschlüssel ausgewählt
TR-> TD(4,0/1/1)->PAR '6A 81' TD(4,1/1/1)->PAR UnsupportedFunction TD(4,2/1/1)->PAR Schlüssel unterstützt den geforderten Algorithmus nicht
TR-> TD(5,0/1/1)->PAR '6A 88' TD(5,1/1/1)->PAR KeyNotFound TD(5,2/1/1)->PAR Schlüssel nicht gefunden
PAR Hinweis CosH_926: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16624)<b>A_16624 - (N088.100) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando PSO Compute Digital Signature verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.8.2.4)14.8.2.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N088.200.a)<b>G2_N088.200.a - (N088.200)a K_COS</b>
PAR Das COS MUSS die PSO Compute Digital Signature-Varianten aus (N087.500) und (N088.000) unterstützen. <b>[<=]</b>

REQ(ids=A_16625)<b>A_16625 - (N088.200)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere PSO Compute Digital Signature-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N088.300.a)<b>G2_N088.300.a - (N088.300)a K_COS</b>
PAR Wenn channelContext.keyReferenceList.signatureCreation leer ist, genau dann MUSS das Kommando mit dem Trailer NoKeyReference terminieren. <b>[<=]</b>

REQ(ids=A_16626)<b>A_16626 - (N088.300)b K_COS</b>
PAR Wenn channelContext.keyReferenceList.signatureCreation nicht leer ist, dann wird<br>affectedObject = SearchKey(<br>    currentFolder,<br>    keyReferenceList.signatureCreation.keyReference,<br>    keyReferenceList.signatureCreation.algID<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. <b>[<=]</b>

REQ(ids=G2_N088.300.b.1)<b>G2_N088.300.b.1 - (N088.300)b.1 K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N088.300.b.2)<b>G2_N088.300.b.2 - (N088.300)b.2 K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N088.400)<b>G2_N088.400 - (N088.400) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N088.500)<b>G2_N088.500 - (N088.500) K_COS</b>
PAR Wenn affectedObject.keyAvailable den Wert False besitzt, genau dann MUSS das Kommando mit dem Trailer KeyInvalid terminieren. <b>[<=]</b>

PAR Die Signatur signature wird in Abhängigkeit der gewählten algID berechnet.
REQ(ids=G2_N088.600.a)<b>G2_N088.600.a - (N088.600)a K_COS</b>
PAR Wenn keyReferenceList.signatureCreation.algID den Wert rsaClientAuthentication oder signPSS besitzt, dann gilt:<br>signature = RSASSA_PSS_SIGN( affectedObject.privateRsaKey, dataToBeSigned ). <b>[<=]</b>

REQ(ids=G2_N088.600.b)<b>G2_N088.600.b - (N088.600)b K_COS</b>
PAR Wenn keyReferenceList.signatureCreation.algID den Wert sign9796_2_DS2 besitzt, dann gilt:<br>1.  signInput9796_2_DS2 == plainDO   ||   hashDO.<br>2. plainDO  == '80 – L<sub>80</sub> – M1'.<br>3. hashDO   == '90 – L<sub>90</sub> – hashM2'.<br>4. signature  = RSA_ISO9796_2_DS2_SIGN( affectedObject.privateRsaKey, M1, hashM2 ). <b>[<=]</b>

REQ(ids=G2_N088.600.c)<b>G2_N088.600.c - (N088.600)c K_COS</b>
PAR Wenn keyReferenceList.signatureCreation.algID den Wert signECDSA besitzt, dann gilt:<br>1. ( R, S )     = ELC_SIG( affectedObject.privateElcKey, dataToBeSigned ).<br>2. signature   = R   ||   S. <b>[<=]</b>

REQ(ids=G2_N088.600.d)<b>G2_N088.600.d - (N088.600)d K_COS</b>
PAR Wenn keyReferenceList.signatureCreation.algID den Wert signPKCS1_V1_5 besitzt, dann gilt:<br>signature = RSASSA_PKCS1_V1_5_SIGN( affectedObject.privateRsaKey, dataToBeSigned ). <b>[<=]</b>

REQ(ids=G2_N088.700)<b>G2_N088.700 - (N088.700) K_COS</b>
PAR Als Datenfeld der Antwortnachricht MUSS signature verwendet werden. <b>[<=]</b>

REQ(ids=G2_N088.800)<b>G2_N088.800 - (N088.800) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16627)<b>A_16627 - (N088.900)a K_TST</b>
PAR Die Priorität der Trailer in CosT_7c1 MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N088.900.b)<b>G2_N088.900.b - (N088.900)b K_COS</b>
PAR Jeder Trailer in CosT_7c1 MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.8.3)14.8.3 CosK_a85 PSO Decipher
PAR Das Kommando PSO Decipher entschlüsselt Daten, die als Parameter in der Kommandonachricht enthalten sind. Für den Entschlüsselungsschlüssel und den zu verwendenden Algorithmus gibt es mehrere Optionen

LIST->
LITEM->PAR Wird ein symmetrischer Schlüssel verwendet, so wird dieser im Rahmen einer gegenseitigen Authentisierung (siehe CosK_b47, CosK_580, CosK_2da oder CosK_2ed) ausgehandelt und zusammen mit einem Algorithmus implizit ausgewählt.LITEM->PAR Wird ein asymmetrischer Schlüssel verwendet, der persistent in der Smartcard gespeichert ist, so wird dieser Schlüssel und der zu verwendende Algorithmus vor dem Senden dieses PSO Decipher-Kommandos durch ein explizites MSE-Set-Kommando ausgewählt (siehe (N103.800)).
PAR -HEADING(ids=14.8.3.1)14.8.3.1 CosK_db6 Use Case Entschlüsseln mittels RSA
PAR Diese Variante gilt für Algorithmen (siehe (N017.900)a.1) aus folgender Menge: {rsaDecipherPKCS1_V1_5, rsaDecipherOaep}.
PAR In dieser Variante enthält die APDU des PSO Decipher-Kommandos zwei Parameter:
REQ(ids=A_16628)<b>A_16628 - (N089.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter C enthält die zu entschlüsselnden Daten. Der Parameter C ist ein Oktettstring mit beliebigem Inhalt. Die Anzahl Oktette in C MUSS identisch sein zu OctetLength( n ) mit n als Modulus des Schlüssels, der zum Entschlüsseln verwendet wird. <b>[<=]</b>

REQ(ids=A_16629)<b>A_16629 - (N089.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardExtended sein. <b>[<=]</b>

REQ(ids=A_16630)<b>A_16630 - (N089.200) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_643 verwendet werden.
PAR (ids=Tabelle-264,-CosT_643)Tabelle 264, CosT_643: PSO Decipher, Entschlüsseln mittels RSA

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '80' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier Klartext
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '86' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier Chiffrat
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '00' || C, dies bedeutet: PaddingIndicator || Cryptogram
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '0000' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.3.2)14.8.3.2 CosK_491 Use Case Entschlüsseln mittels ELC
PAR Diese Variante gilt für Algorithmen (siehe (N017.900)a.2) aus folgender Menge: {elcSharedSecretCalculation}.
PAR In dieser Variante enthält die APDU des PSO Decipher-Kommandos vier Parameter:
REQ(ids=A_16631)<b>A_16631 - (N089.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter PO<sub>A</sub> enthält einen Punkt auf einer elliptischen Kurve. Dieser Punkt wurde vom Sender der Nachricht gewählt. Der Parameter PO<sub>A</sub> ist ein Oktettstring, dessen Inhalt so gewählt werden SOLL, dass bei der Decodierung kein Fehler auftritt (siehe (N004.800)a). <b>[<=]</b>

REQ(ids=A_16632)<b>A_16632 - (N089.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter C enthält die zu entschlüsselnden Daten. Der Parameter C MUSS ein Oktettstring mit beliebigem Inhalt sein. <b>[<=]</b>

REQ(ids=A_16633)<b>A_16633 - (N089.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter T enthält einen MAC, der die Integrität von C schützt. Der Parameter T ist ein Oktettstring, dessen Länge und Inhalt so gewählt werden SOLL, dass bei der MAC-Prüfung kein Fehler auftritt. <b>[<=]</b>

REQ(ids=A_16634)<b>A_16634 - (N089.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus der Menge {WildCardShort, WildCardExtended} gewählt werden. <b>[<=]</b>

REQ(ids=A_16635)<b>A_16635 - (N089.700) K_externeWelt {K_Karte}</b>
PAR Die Parameter PO<sub>A</sub>, C und T MÜSSEN im Datenfeld der Kommandonachricht enthalten sein. Die Codierung MUSS den Vorgaben in (N090.300)c entsprechen. <b>[<=]</b>

REQ(ids=A_16636)<b>A_16636 - (N089.800) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 oder eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_767 verwendet werden.
PAR (ids=Tabelle-265,-CosT_767)Tabelle 265, CosT_767: PSO Decipher, Entschlüsseln mittels elliptischer Kurven

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '80' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier Klartext
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '86' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier Chiffrat
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR cipher, DER codiertes Datenfeld
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR Hinweis CosH_e00(129) Möglicherweise wird P2 in einer späteren Dokumentenversion geändert.
PAR -HEADING(ids=14.8.3.3)14.8.3.3 CosK_73a Use Case Entschlüsseln mittels symmetrischer Schlüssel
PAR Diese Variante gilt für Algorithmen aus der folgenden Menge: {aesSessionkey, desSessionkey (Option_DES)}.
PAR In dieser Variante enthält die APDU des PSO Decipher-Kommandos zwei Parameter:
REQ(ids=A_16637)<b>A_16637 - (N089.840) K_externeWelt {K_Karte}, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Der Parameter C enthält die zu entschlüsselnden Daten. Der Parameter C ist ein Oktettstring mit beliebigem Inhalt. Die Anzahl Oktette in C MUSS ein ganzzahliges Vielfaches der Blocklänge des verwendeten Kryptoalgorithmus sein. <b>[<=]</b>

REQ(ids=A_16638)<b>A_16638 - (N089.843) K_externeWelt {K_ Karte}, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus der Menge {WildCardShort, WildCardExtended} gewählt werden. <b>[<=]</b>

REQ(ids=A_16639)<b>A_16639 - (N089.845) K_externeWelt {K_ Karte}, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 oder eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_0f8 verwendet werden.
PAR (ids=Tabelle-266,-CosT_0f8)Tabelle 266, CosT_0f8: PSO Decipher, Entschlüsseln mittels symmetrischem Schlüssel

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '80' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier Klartext
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '86' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier Chiffrat
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '01' || C, dies bedeutet: Paddingindikator || Kryptogramm
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.3.4)14.8.3.4 Antwort der Karte auf Entschlüsseln von Daten
PAR (ids=Tabelle-267,-CosT_add)Tabelle 267, CosT_add: PSO Decipher Antwort-APDU im Erfolgsfall

TABLE(rows=4,cols=63+183+345)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)->PAR plain TD(1,2/1/1)->PAR Klartext
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '90 00' TD(3,1/1/1)->PAR NoError TD(3,2/1/1)->PAR Erfolgreiche Entschlüsselungsoperation
PAR (ids=Tabelle-268,-CosT_dbf)Tabelle 268, CosT_dbf: PSO Decipher Antwort-APDU im Fehlerfall

TABLE(rows=7,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '64 00' TD(1,1/1/1)->PAR KeyInvalid TD(1,2/1/1)->PAR Schlüsseldaten fehlen
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '69 85' TD(3,1/1/1)->PAR NoKeyReference TD(3,2/1/1)->PAR Kein Schlüssel für Entschlüsselung ausgewählt
TR-> TD(4,0/1/1)->PAR '6A 80' TD(4,1/1/1)->PAR WrongCiphertext TD(4,2/1/1)->PAR Fehler beim Entschlüsseln des Chiffrats
TR-> TD(5,0/1/1)->PAR '6A 81' TD(5,1/1/1)->PAR UnsupportedFunction TD(5,2/1/1)->PAR Schlüssel unterstützt den angegeben Algorithmus nicht
TR-> TD(6,0/1/1)->PAR '6A 88' TD(6,1/1/1)->PAR KeyNotFound TD(6,2/1/1)->PAR Schlüssel nicht gefunden
PAR Hinweis CosH_d87: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16640)<b>A_16640 - (N089.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando PSO Decipher verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.8.3.5)14.8.3.5 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N090.000.a)<b>G2_N090.000.a - (N090.000)a K_COS</b>
PAR Das COS MUSS die PSO Decipher-Varianten aus (N089.200) und (N089.800) unterstützen. <b>[<=]</b>

REQ(ids=G2_N090.000.b)<b>G2_N090.000.b - (N090.000)b K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Das COS MUSS die PSO Decipher-Variante aus (N089.845) unterstützen. <b>[<=]</b>

REQ(ids=A_16641)<b>A_16641 - (N090.000)c K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere PSO Decipher-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N090.100.a)<b>G2_N090.100.a - (N090.100)a K_COS</b>
PAR Wenn channelContext.keyReferenceList.dataDecipher leer ist, genau dann MUSS das Kommando mit dem Trailer NoKeyReference terminieren. <b>[<=]</b>

REQ(ids=A_16642)<b>A_16642 - (N090.100)b K_COS</b>
PAR Wenn channelContext.keyReferenceList.dataDecipher nicht leer ist, dann wird<br>affectedObject = SearchKey(<br>    currentFolder,<br>    keyReferenceList.dataDecipher.keyReference,<br>    keyReferenceList.dataDecipher.algID<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. <b>[<=]</b>

REQ(ids=G2_N090.100.b.1)<b>G2_N090.100.b.1 - (N090.100)b.1 K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N090.100.b.2)<b>G2_N090.100.b.2 - (N090.100)b.2 K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N090.200)<b>G2_N090.200 - (N090.200) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N090.210)<b>G2_N090.210 - (N090.210) K_COS</b>
PAR Wenn affectedObject.keyAvailable den Wert False besitzt, genau dann MUSS das Kommando mit dem Trailer KeyInvalid terminieren. <b>[<=]</b>

PAR Die Klartextnachricht plain wird wie folgt berechnet:
PAR (N090.300) a Diese Anforderung ist absichtlich leer.
REQ(ids=G2_N090.300.a)<b>G2_N090.300.a - (N090.300)a K_COS</b>
PAR Wenn channelContext.keyReferenceList.dataDecipher.algID den Wert rsaDecipherPKCS1_V1_5 besitzt, dann gilt:<br>plain = RSAES_PKCS1_V1_5_DECRYPT( affectedObject.privateRsaKey, C ) <b>[<=]</b>

REQ(ids=G2_N090.300.b)<b>G2_N090.300.b - (N090.300)b K_COS</b>
PAR Wenn channelContext.keyReferenceList.dataDecipher.algID den Wert rsaDecipherOaep besitzt, dann gilt    <br> plain = RSAES_OAEP_DECRYPT( affectedObject.privateRsaKey, C ) <b>[<=]</b>

REQ(ids=G2_N090.300.c)<b>G2_N090.300.c - (N090.300)c K_COS</b>
PAR Wenn channelContext.keyReferenceList.dataDecipher.algID den Wert elcSharedSecretCalculation besitzt, dann gilt<br>(Hinweis CosH_7de: cipher ist hier identisch zu (N085.068)b.7, (N091.700)d und (N094.400)c definiert):<br>1. cipher     == 'A6 – L<sub>A6</sub> – ( oidDO   ||   keyDO   ||   cipherDO   ||   macDO ).<br>2. oidDO    == '06 – L<sub>06</sub> – oid '.<br>3. keyDO     == '7F49 – L<sub>7F49</sub> – ( 86 – L<sub>86</sub> – PO<sub>A</sub> )'.<br>4. cipherDO  == '86 – L<sub>86</sub> – ( 02   ||   C )'.<br>5. macDO     == '8E – L<sub>8E</sub> – T '.<br>6. Wenn oid verschieden ist zur OID, die gemäß (N008.600)d zu affectedObject.privateElcKey.domainParameter gehört, dann MUSS das Kommando mit dem Trailer WrongCiphertext terminieren. Diese Domainparameter werden im Folgenden mit dP bezeichnet.<br>7. plain = ELC_DEC( OS2P( PO<sub>A</sub>, dP ), affectedObject.privateElcKey, C, T ). <b>[<=]</b>

REQ(ids=G2_N090.302.a)<b>G2_N090.302.a - (N090.302)a K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn channelContext.keyReferenceList.dataDecipher.algID den Wert aesSessionkey besitzt, dann gilt mit den Attributen SSCmac und Kenc aus dem Attribut SessionkeyContext:<br>1. Schritt 1: SSCenc = OS2I(AES_ENC( K<sub>enc</sub>, I2OS( SSCmac, 16))).<br>2. Schritt 2: P         = AES_CBC_DEC( Kenc, SSCenc, C ).<br>3. Schritt 3: plain    = TruncateIso( P, 16 ).<br>4. Wenn die Funktion TruncateIso mit dem Fehler paddingError terminiert, dann<br>    i.  MUSS das Kommando mit dem Trailer WrongCiphertext terminieren und<br>    ii. die Sessionkeys MÜSSEN mittels clearSessionkeys( ) gelöscht werden. <b>[<=]</b>

PAR (N090.302)b ist absichtlich leer.
REQ(ids=G2_N090.302.b)<b>G2_N090.302.b - (N090.302)b K_COS, Option_DES und (Option_Kryptobox oder Option_PACE_PCD)</b>
PAR Falls channelContext.keyReferenceList.dataDecipher.algID den Wert desSessionkey besitzt, dann gilt mit den Attributen SSCenc und Kenc aus dem Attribut SessionkeyContext:<br>1. Schritt 1: SSCenc = SSCenc + 1.<br>2. Schritt 2: P         = 3TDES_CBC_DEC( Kenc, SSCenc, C ).<br>3. Schritt 3: plain    = TruncateIso( P, 8 ).<br>4. Falls die Funktion TruncateIso mit dem Fehler paddingError terminiert, dann<br>   i.  MUSS das Kommando mit dem Trailer WrongCiphertext terminieren und<br>   ii. die Sessionkeys MÜSSEN mittels clearSessionkeys( ) gelöscht werden. <b>[<=]</b>

REQ(ids=G2_N090.400)<b>G2_N090.400 - (N090.400) K_COS</b>
PAR Wenn die Entschlüsselung gemäß (N090.300) oder (N090.302) mit dem Fehler "ERROR" terminiert, genau dann MUSS das Kommando mit dem Trailer WrongCiphertext terminieren. <b>[<=]</b>

REQ(ids=G2_N090.500)<b>G2_N090.500 - (N090.500) K_COS</b>
PAR Als Datenfeld der Antwortnachricht MUSS plain verwendet werden. <b>[<=]</b>

REQ(ids=G2_N090.600)<b>G2_N090.600 - (N090.600) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16643)<b>A_16643 - (N090.700)a K_TST</b>
PAR Die Priorität der Trailer in CosT_dbf MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N090.700.b)<b>G2_N090.700.b - (N090.700)b K_COS</b>
PAR Jeder Trailer in CosT_dbf MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.8.4)14.8.4 CosK_f48 PSO Encipher
PAR Das Kommando PSO Encipher verschlüsselt Daten, die als Parameter in der Kommandonachricht enthalten sind. Für den Verschlüsselungsschlüssel und den zu verwendenden Verschlüsselungsalgorithmus gibt es mehrere Optionen:

LIST->
LITEM->PAR Wird ein symmetrischer Schlüssel verwendet, so wird dieser im Rahmen einer gegenseitigen Authentisierung (siehe CosK_b47, CosK_580, CosK_2da oder CosK_2ed) ausgehandelt und zusammen mit einem Verschlüsselungsalgorithmus implizit ausgewählt.LITEM->PAR Wird ein asymmetrischer Schlüssel verwendet, der persistent in der Smartcard gespeichert ist, so wird dieser Schlüssel und der zu verwendende Algorithmus vor dem Senden dieses PSO Encipher-Kommandos durch ein explizites MSE-Set-Kommando ausgewählt (siehe (N103.850)).LITEM->PAR Wird ein asymmetrischer Schlüssel verwendet, der als Parameter in der Kommandonachricht enthalten ist, so ist auch der zu verwendende Algorithmus als Parameter in der Kommandonachricht enthalten.
PAR -HEADING(ids=14.8.4.1)14.8.4.1 CosK_b57 Use Case Verschlüsseln von Daten mittels übergebenem RSA-Schlüssel
PAR In dieser Variante wird der Schlüssel als Parameter in der Kommandonachricht übergeben. Folgende Algorithmen sind zulässig: {rsaEncipherOaep, rsaEncipherPKCS1_V1_5}.
PAR Hinweis CosH_672: Gemäß den Festlegungen in (N091.650) und (N091.700) ist dieser Use Case nur dann ausführbar, wenn channelContext.keyReferenceList.dataEncipher leer ist.
PAR In dieser Variante enthält die APDU des PSO Encipher-Kommandos vier Parameter:
REQ(ids=A_16644)<b>A_16644 - (N090.780) K_externeWelt {K_Karte}</b>
PAR Der Parameter algID enthält Informationen zum Algorithmus, der für die Verschlüsselung verwendet wird. Der Parameter algID MUSS aus der Menge {rsaEncipherOaep, rsaEncipherPKCS1_V1_5} gewählt werden. <b>[<=]</b>

REQ(ids=A_16645)<b>A_16645 - (N090.782) K_externeWelt {K_Karte}</b>
PAR Der Parameter PuK enthält den öffentlichen Schlüssel des Empfängers gemäß CosK_933. Der Parameter PuK ist ein Oktettstring, dessen Inhalt so gewählt werden MUSS, dass bei der Decodierung kein Fehler auftritt (siehe (N091.700)b.3, c.3). <b>[<=]</b>

PAR Der Parameter M enthält die zu verschlüsselnden Daten. Der Parameter M ist ein Oktettstring mit beliebigem Inhalt. Die maximal mögliche Länge von M ist abhängig von der gemäß (N090.780) übergebenen algId und der Länge des Modulus n.
REQ(ids=A_16646)<b>A_16646 - (N090.784)a K_externeWelt {K_Karte}</b>
PAR Wenn algId gleich rsaEncipherOaep ist, dann MUSS OctetLength( M ) kleiner gleich OctetLength( n ) – 66 sein. <b>[<=]</b>

PAR (N090.784)b Diese Anforderung ist absichtlich leer.
REQ(ids=A_16647)<b>A_16647 - (N090.784)b K_externeWelt {K_Karte}</b>
PAR Wenn algId gleich rsaEncipherPKCS1_V1_5 ist, dann MUSS OctetLength( M ) kleiner gleich OctetLength( n ) – 11 sein. <b>[<=]</b>

REQ(ids=A_16648)<b>A_16648 - (N090.786) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardExtended sein. <b>[<=]</b>

REQ(ids=A_16649)<b>A_16649 - (N090.788) K_externeWelt {K_Karte}</b>
PAR Die Parameter PuK, algID und M MÜSSEN im Datenfeld der Kommandonachricht enthalten sein. Die Codierung wird in (N091.700)b, c spezifiziert. <b>[<=]</b>

REQ(ids=A_16650)<b>A_16650 - (N090.790) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_da1 verwendet werden.
PAR (ids=Tabelle-269,-CosT_da1)Tabelle 269, CosT_da1: PSO Encipher, Verschlüsseln mittels übergebenem RSA-Schlüssel

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '86' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier Chiffrat
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '80' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier Klartext
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR plainDO, DER codiertes Datenfeld
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '0000' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.4.2)14.8.4.2 CosK_40e Use Case Verschlüsseln von Daten mittels übergebenem ELC-Schlüssel
PAR In dieser Variante wird der Schlüssel als Parameter in der Kommandonachricht übergeben. Folgende Algorithmen sind zulässig: {elcSharedSecretCalculation}.
PAR Hinweis CosH_cb0: Gemäß den Festlegungen in (N091.650) und (N091.700) ist dieser Use Case nur dann ausführbar, wenn channelContext.keyReferenceList.dataEncipher leer ist.
PAR In dieser Variante enthält die APDU des PSO Encipher-Kommandos fünf Parameter:
REQ(ids=A_16651)<b>A_16651 - (N090.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter algID enthält Informationen zum Algorithmus, der für die Verschlüsselung verwendet wird. Der Parameter algID MUSS aus der Menge {elcSharedSecretCalculation} gewählt werden. <b>[<=]</b>

REQ(ids=A_16652)<b>A_16652 - (N090.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter oid enthält einen Objektidentifier, der die zu verwendende elliptische Kurve referenziert. Der Parameter oid MUSS aus der in CosT_a91 genannten Menge gewählt werden und eine elliptische Kurve aus der Menge in (N002.500) referenzieren. <b>[<=]</b>

REQ(ids=A_16653)<b>A_16653 - (N091.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter PO<sub>B</sub> enthält einen Punkt auf einer elliptischen Kurve. Dieser Punkt repräsentiert den öffentlichen Schlüssel des Empfängers. Der Parameter PO<sub>B</sub> ist ein Oktettstring, dessen Inhalt so gewählt werden MUSS, dass bei der Decodierung kein Fehler auftritt (siehe (N004.500)a). <b>[<=]</b>

REQ(ids=A_16654)<b>A_16654 - (N091.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter M enthält die zu verschlüsselnden Daten. Der Parameter M ist ein Oktettstring mit beliebigem Inhalt. Die Länge von M MUSS so gewählt werden, dass für die Kommandonachricht die Vorgaben aus (N026.900) eingehalten werden und die Antwortnachricht nicht länger ist als limitRspSecureMessaging. <b>[<=]</b>

REQ(ids=A_16655)<b>A_16655 - (N091.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS so aus der Menge {WildCardShort, WildCardExtended} gewählt werden, dass der komplette Oktettstring cipher in der Antwortnachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_16656)<b>A_16656 - (N091.300) K_externeWelt {K_Karte}</b>
PAR Die Parameter algID, oid, PO<sub>B</sub> und M MÜSSEN im Datenfeld der Kommandonachricht enthalten sein. Die Codierung wird in (N091.700)d spezifiziert. <b>[<=]</b>

REQ(ids=A_16657)<b>A_16657 - (N091.400) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 oder eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_b10 verwendet werden.
PAR (ids=Tabelle-270,-CosT_b10)Tabelle 270, CosT_b10: PSO Encipher, Verschlüsseln mittels übergebenem ELC-Schlüssel

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '86' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier Chiffrat
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '80' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier Klartext
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR plainDO
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.4.3)14.8.4.3 CosK_1d3 Use Case Verschlüsseln mittels gespeichertem RSA-Schlüssel
PAR In dieser Variante wird ein in der Smartcard gespeicherter Schlüssel verwendet. Folgende Algorithmen sind zulässig: {rsaEncipherOaep, rsaEncipherPKCS1_V1_5}.
PAR Hinweis CosH_ed7: Gemäß den Festlegungen in (N091.650) und (N091.700) ist dieser Use Case nur dann ausführbar, wenn channelContext.keyReferenceList.dataEncipher Daten enthält.
PAR In dieser Variante enthält die APDU des PSO Encipher-Kommandos zwei Parameter:
PAR Der Parameter M enthält die zu verschlüsselnden Daten. Der Parameter M ist ein Oktettstring mit beliebigem Inhalt. Die maximal mögliche Länge von M ist abhängig von der mittels (N103.845) ausgewählten algId und der Länge des Modulus n.
REQ(ids=A_16658)<b>A_16658 - (N091.420)a K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Falls algId gleich rsaEncipherOaep ist, dann MUSS OctetLength( M ) kleiner gleich OctetLength( n ) – 66 sein. <b>[<=]</b>

PAR (N091.420)b Diese Anforderung ist absichtlich leer.
REQ(ids=A_16659)<b>A_16659 - (N091.420)b K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Falls algId gleich rsaEncipherPKCS1_V1_5 ist, dann MUSS OctetLength( M ) kleiner gleich OctetLength( n ) – 11 sein. <b>[<=]</b>

REQ(ids=A_16660)<b>A_16660 - (N091.422) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardExtended sein. <b>[<=]</b>

REQ(ids=A_16661)<b>A_16661 - (N091.424) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Es MUSS eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_c3c verwendet werden.
PAR (ids=Tabelle-271,-CosT_c3c)Tabelle 271, CosT_c3c: PSO Encipher, Verschlüsseln mittels gespeichertem RSA-Schlüssel

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '86' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier Chiffrat
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '80' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier Klartext
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR M
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '0000' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.4.4)14.8.4.4 CosK_ba3 Use Case Verschlüsseln mittels gespeichertem ELC-Schlüssel
PAR In dieser Variante wird ein in der Smartcard gespeicherter Schlüssel verwendet. Folgende Algorithmen sind zulässig: {elcSharedSecretCalculation}.
PAR Hinweis CosH_179: Gemäß den Festlegungen in (N091.650) und (N091.700) ist dieser Use Case nur dann ausführbar, wenn channelContext.keyReferenceList.dataEncipher Daten enthält.
PAR In dieser Variante enthält die APDU des PSO Encipher-Kommandos zwei Parameter:
REQ(ids=A_16662)<b>A_16662 - (N091.430) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Der Parameter M enthält die zu verschlüsselnden Daten. Der Parameter M ist ein Oktettstring mit beliebigem Inhalt. Die Länge von M MUSS so gewählt werden, dass für die Kommandonachricht die Vorgaben aus (N026.900) eingehalten werden und die Antwortnachricht nicht länger ist als limitRspSecureMessaging. <b>[<=]</b>

REQ(ids=A_16663)<b>A_16663 - (N091.432) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS so aus der Menge {WildCardShort, WildCardExtended} gewählt werden, dass der komplette Oktettstring cipher in der Antwortnachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_16664)<b>A_16664 - (N091.434) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 oder eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_94d verwendet werden.
PAR (ids=Tabelle-272,-CosT_94d)Tabelle 272, CosT_94d: PSO Encipher, Verschlüsseln mittels gespeichertem ELC-Schlüssel

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '86' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier Chiffrat
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '80' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier Klartext
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR M
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.4.5)14.8.4.5 CosK_ed9 Use Case Verschlüsseln mittels symmetrischem Schlüssel
PAR In dieser Variante wird ein in der Smartcard gespeicherter Schlüssel verwendet. Folgende Algorithmen sind zulässig: {aesSessionkey, desSessionkey (Option_DES)}.
PAR Hinweis CosH_666: Gemäß den Festlegungen in (N091.650) und (N091.700) ist dieser Use Case nur dann ausführbar, wenn channelContext.keyReferenceList.dataEncipher Daten enthält.
PAR In dieser Variante enthält die APDU des PSO Encipher-Kommandos zwei Parameter:
REQ(ids=A_16665)<b>A_16665 - (N091.440) K_externeWelt {K_Karte}, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Der Parameter M enthält die zu verschlüsselnden Daten. Der Parameter M ist ein Oktettstring mit beliebigem Inhalt. Die Länge von M MUSS so gewählt werden, dass für die Kommandonachricht die Vorgaben aus (N026.900) eingehalten werden und die Antwortnachricht nicht länger ist als limitRspSecureMessaging. <b>[<=]</b>

REQ(ids=A_16666)<b>A_16666 - (N091.443) K_externeWelt {K_Karte}, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS so aus der Menge {WildCardShort, WildCardExtended} gewählt werden, dass der komplette Oktettstring cipher in der Antwortnachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_16667)<b>A_16667 - (N091.446) K_externeWelt {K_Karte}, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 oder eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_acb verwendet werden.
PAR (ids=Tabelle-273,-CosT_acb)Tabelle 273, CosT_acb: PSO Encipher, Verschlüsseln mittels symmetrischem Schlüssel

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '86' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier Chiffrat
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '80' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier Klartext
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR M
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.4.6)14.8.4.6 Antwort der Karte auf Verschlüsseln von Daten
PAR (ids=Tabelle-274,-CosT_6f0)Tabelle 274, CosT_6f0: PSO Encipher Antwort-APDU im Erfolgsfall

TABLE(rows=4,cols=63+183+345)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)->PAR cipher TD(1,2/1/1)->PAR Chiffrat
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '90 00' TD(3,1/1/1)->PAR NoError TD(3,2/1/1)->PAR Erfolgreiche Verschlüsselungsoperation
PAR (ids=Tabelle-275,-CosT_6c0)Tabelle 275, CosT_6c0: PSO Encipher Antwort-APDU im Fehlerfall

TABLE(rows=5,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '64 00' TD(1,1/1/1)->PAR EncipherError TD(1,2/1/1)->PAR Verschlüsselung fehlgeschlagen
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '6A 81' TD(3,1/1/1)->PAR UnsupportedFunction TD(3,2/1/1)->PAR Schlüssel unterstützt den angegeben Algorithmus nicht
TR-> TD(4,0/1/1)->PAR '6A 88' TD(4,1/1/1)->PAR KeyNotFound TD(4,2/1/1)->PAR Schlüssel nicht gefunden
PAR Hinweis CosH_37b: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16668)<b>A_16668 - (N091.500) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando PSO Encipher verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.8.4.7)14.8.4.7 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N091.600.a)<b>G2_N091.600.a - (N091.600)a K_COS</b>
PAR Das COS MUSS die PSO Encipher-Variante aus (N090.790) und (N091.400) unterstützen. <b>[<=]</b>

REQ(ids=G2_N091.600.b)<b>G2_N091.600.b - (N091.600)b K_COS, Option_Kryptobox</b>
PAR Das COS MUSS die PSO Encipher-Variante aus (N091.424) und (N091.434) unterstützen. <b>[<=]</b>

REQ(ids=G2_N091.600.c)<b>G2_N091.600.c - (N091.600)c K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Das COS MUSS die PSO Encipher-Variante aus (N091.446) unterstützen. <b>[<=]</b>

REQ(ids=A_16669)<b>A_16669 - (N091.600)d K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere PSO Encipher-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16670)<b>A_16670 - (N091.650) K_COS</b>
PAR Wenn channelContext.keyReferenceList.dataEncipher nicht leer ist, genau dann MUSS das Kommando auf folgende Art mit einem in der Smartcard gespeicherten Schlüssel arbeiten: <b>[<=]</b>

REQ(ids=A_16671)<b>A_16671 - (N091.650)a K_COS</b>
PAR Es wird<br>affectedObject = SearchKey(<br>    currentFolder,<br>    keyReferenceList.dataEncipher.keyReference,<br>    keyReferenceList.dataEncipher.algID<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. <b>[<=]</b>

REQ(ids=A_16672)<b>A_16672 - (N091.650)a.1 K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=A_16673)<b>A_16673 - (N091.650)a.2 K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N091.650.b)<b>G2_N091.650.b - (N091.650)b K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=A_17538)<b>A_17538 - (N091.650)c K_COS</b>
PAR Das Chiffrat cipher MUSS wie folgt berechnet werden: <b>[<=]</b>

REQ(ids=G2_N091.650.c.1)<b>G2_N091.650.c.1 - (N091.650)c.1 K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn channelContext.keyReferenceList.dataEncipher.algID den Wert aesSessionkey besitzt, dann gilt mit den Attributen SSCmac und Kenc aus dem Attribut SessionkeyContext:<br>0. Schritt 0: SSCmac = SSCmac + 1.<br>1. Schritt 1: SSCenc  = OS2I(AES_ENC ( Kenc, I2OS( SSCmac, 16))).<br>2. Schritt 2: P          = PaddingIso( M, 16 ).<br>3. Schritt 3: C          = AES_CBC_ENC( Kenc, SSCenc, P ).<br>4. Schritt 4: cipher    = '01' || C. <b>[<=]</b>

PAR (N091.650)c.2 ist absichtlich leer.
REQ(ids=G2_N091.650.c.2)<b>G2_N091.650.c.2 - (N091.650)c.2 K_COS, Option_DES und (Option_Kryptobox oder Option_PACE_PCD)</b>
PAR Falls channelContext.keyReferenceList.dataEncipher.algID den Wert desSessionkey besitzt, dann gilt mit den Attributen SSCenc und Kenc aus dem Attribut SessionkeyContext:<br>1. Schritt 1: SSCenc = SSCenc + 1.<br>2. Schritt 2: P         = PaddingIso( M, 8 ).<br>3. Schritt 3: C        = 3TDES_CBC_ENC( Kenc, SSCenc, P ).<br>4. Schritt 4: cipher  = '01' || C. <b>[<=]</b>

REQ(ids=G2_N091.650.c.3)<b>G2_N091.650.c.3 - (N091.650)c.3 K_COS</b>
PAR Falls channelContext.keyReferenceList.dataEncipher.algID den Wert elcSharedSecretCalculation besitzt, dann MUSS gelten:<br>i. ( PO<sub>A</sub>, C, T ) = ELC_ENC( M, affectedObject.publicElcKey.P, affectedObject.domainParameter ).     <br>Wenn diese Funktion mit dem Fehler "ERROR" terminiert, genau dann MUSS das Kommando mit dem Trailer EncipherError terminieren. Andernfalls wird ein DER-TLV codierter Oktettstring cipher wie folgt konstruiert:<br>Hinweis CosH_412: cipher ist hier identisch zu (N090.300)c und (N094.400)c definiert.<br>ii.  Setze   oidDO     = '06 – L<sub>06</sub> – affectedObject.domainParameter.OID'.<br>iii. Setze   keyDO    = '7F49 – L<sub>7F49</sub> – ( 86 – L<sub>86</sub> – PO<sub>A</sub> )'.<br>iv. Setze   cipherDO = '86 – L<sub>86</sub> – ( 02   ||   C )'.<br>v.  Setze   macDO   = '8E – L<sub>8E</sub> – T '.<br>vi. Setze   cipher     = 'A6 – L<sub>A6</sub> – ( oidDO   ||   keyDO   ||   cipherDO   ||   macDO )'. <b>[<=]</b>

REQ(ids=G2_N091.650.c.4)<b>G2_N091.650.c.4 - (N091.650)c.4 K_COS</b>
PAR Falls channelContext.keyReferenceList.dataEncipher.algID den Wert rsaEncipherOaep besitzt, dann gilt:    <br>i.  Schritt 1: C        = RSAES_OAEP_ENCRYPT( affectedObject.publicKey, M )    <br>ii. Schritt 2: cipher = '85' || C. <b>[<=]</b>

PAR (N091.650)c.5 Diese Anforderung ist absichtlich leer.
REQ(ids=G2_N091.650.c.5)<b>G2_N091.650.c.5 - (N091.650)c.5 K_COS</b>
PAR Falls channelContext.keyReferenceList.dataEncipher.algID den Wert rsaEncipherPKCS1_V1_5 besitzt, dann gilt:    <br>i.  Schritt 1: C        = RSAES_PKCS1_V1_5_ENCRYPT( affectedObject.publicKey, M ).<br>ii. Schritt 2: cipher = '81' || C. <b>[<=]</b>

REQ(ids=A_16674)<b>A_16674 - (N091.700) K_COS</b>
PAR Wenn channelContext.keyReferenceList.dataEncipher leer ist, genau dann MUSS das Kommando auf folgende Art mit einem Schlüssel in den Kommanddaten arbeiten: Das Chiffrat cipher MUSS wie folgt berechnet werden: <b>[<=]</b>

REQ(ids=G2_N091.700.a)<b>G2_N091.700.a - (N091.700)a K_COS</b>
PAR Suche in plainDO nach einem DO mit Tag = '80' und der Länge eins. Es gilt algID_enc = Wertfeld dieses DO. <b>[<=]</b>

PAR (N091.700)b Diese Anforderung ist absichtlich leer.
REQ(ids=A_16675)<b>A_16675 - (N091.700)b K_COS</b>
PAR Wenn algID_enc den Wert rsaEncipherPKCS1_V1_5 besitzt, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N091.700.b.1)<b>G2_N091.700.b.1 - (N091.700)b.1 K_COS</b>
PAR Schritt b.1: plainDO == 'A0 – L<sub>A0</sub> – ( algDO   ||   keyDO   ||   mDO ). <b>[<=]</b>

REQ(ids=G2_N091.700.b.2)<b>G2_N091.700.b.2 - (N091.700)b.2 K_COS</b>
PAR Schritt b.2: algDO   == '80 – 01 – algID_enc '. <b>[<=]</b>

REQ(ids=G2_N091.700.b.3)<b>G2_N091.700.b.3 - (N091.700)b.3 K_COS</b>
PAR Schritt b.3: keyDO  == '7F49 – L<sub>7F49</sub> – [(81 – L<sub>81</sub> – PuK.n )   ||   (82 – L<sub>82</sub> – PuK.e )]'. <b>[<=]</b>

REQ(ids=G2_N091.700.b.4)<b>G2_N091.700.b.4 - (N091.700)b.4 K_COS</b>
PAR Schritt b.4: mDO    == '80 – L<sub>80</sub> – M '. <b>[<=]</b>

REQ(ids=G2_N091.700.b.5)<b>G2_N091.700.b.5 - (N091.700)b.5 K_COS</b>
PAR Schritt b.5: cipher   = '00' || RSAES_PKCS1_V1_5_ENCRYPT( PuK, M ). <b>[<=]</b>

REQ(ids=A_16676)<b>A_16676 - (N091.700)c K_COS</b>
PAR Falls algID_enc den Wert rsaEncipherOaep besitzt, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N091.700.c.1)<b>G2_N091.700.c.1 - (N091.700)c.1 K_COS</b>
PAR Schritt c.1: plainDO == 'A0 – L<sub>A0</sub> – ( algDO   ||   keyDO   ||   mDO ). <b>[<=]</b>

REQ(ids=G2_N091.700.c.2)<b>G2_N091.700.c.2 - (N091.700)c.2 K_COS</b>
PAR Schritt c.2: algDO   == '80 – 01 – algID_enc '. <b>[<=]</b>

REQ(ids=G2_N091.700.c.3)<b>G2_N091.700.c.3 - (N091.700)c.3 K_COS</b>
PAR Schritt c.3: keyDO  == '7F49 – L<sub>7F49</sub> – [(81 – L<sub>81</sub> – PuK.n )   ||   (82 – L<sub>82</sub> – PuK.e )]'. <b>[<=]</b>

REQ(ids=G2_N091.700.c.4)<b>G2_N091.700.c.4 - (N091.700)c.4 K_COS</b>
PAR Schritt c.4: mDO    == '80 – L<sub>80</sub> – M '. <b>[<=]</b>

REQ(ids=G2_N091.700.c.5)<b>G2_N091.700.c.5 - (N091.700)c.5 K_COS</b>
PAR Schritt c.5: cipher   = '00' || RSAES_OAEP_ENCRYPT( PuK, M ). <b>[<=]</b>

REQ(ids=A_16677)<b>A_16677 - (N091.700)d K_COS</b>
PAR Falls algID_enc den Wert elcSharedSecretCalculation besitzt, dann MÜSSEN folgende Schritte ausgeführt werden:<br>Hinweis CosH_737: cipher ist hier identisch zu (N085.068)b.7, (N090.300)c und (N094.400)c definiert. <b>[<=]</b>

REQ(ids=G2_N091.700.d.1)<b>G2_N091.700.d.1 - (N091.700)d.1 K_COS</b>
PAR Schritt d.1: plainDO == 'A0 – L<sub>A0</sub> – ( algDO   ||   oidDO   ||   keyDO   ||   mDO ). <b>[<=]</b>

REQ(ids=G2_N091.700.d.2)<b>G2_N091.700.d.2 - (N091.700)d.2 K_COS</b>
PAR Schritt d.2: algDO   == '80 01   algID_enc '. <b>[<=]</b>

REQ(ids=G2_N091.700.d.3)<b>G2_N091.700.d.3 - (N091.700)d.3 K_COS</b>
PAR Schritt d.3:oidDO    == '06 – L<sub>06</sub> – oid '. <b>[<=]</b>

REQ(ids=G2_N091.700.d.4)<b>G2_N091.700.d.4 - (N091.700)d.4 K_COS</b>
PAR Schritt d.4: keyDO    == '7F49 – L<sub>7F49</sub> – ( 86 – L<sub>86</sub> – PO<sub>B</sub> )'. <b>[<=]</b>

REQ(ids=G2_N091.700.d.5)<b>G2_N091.700.d.5 - (N091.700)d.5 K_COS</b>
PAR Schritt d.5: mDO    == '80 – L<sub>80</sub> – M '. <b>[<=]</b>

REQ(ids=G2_N091.700.d.6)<b>G2_N091.700.d.6 - (N091.700)d.6 K_COS</b>
PAR Schritt d.6: Die oid aus der Kommandonachricht wird gemäß CosT_a91 in Domainparameter übersetzt, die im Folgenden mit dP bezeichnet werden. <b>[<=]</b>

REQ(ids=G2_N091.700.d.7)<b>G2_N091.700.d.7 - (N091.700)d.7 K_COS</b>
PAR Schritt d.7: ( PO<sub>A</sub>, C, T ) = ELC_ENC( M, PO<sub>B</sub>, dP ).<br>Wenn diese Funktion mit dem Fehler "ERROR" terminiert, genau dann MUSS das Kommando mit dem Trailer EncipherError terminieren. Andernfalls wird ein DER-TLV codierter Oktettstring cipher wie folgt konstruiert: <b>[<=]</b>

REQ(ids=G2_N091.700.d.8)<b>G2_N091.700.d.8 - (N091.700)d.8 K_COS</b>
PAR Schritt d.8: Setze      keyDO     = '7F49 – L<sub>7F49</sub> – ( 86 – L<sub>86</sub> – PO<sub>A</sub> )'. <b>[<=]</b>

REQ(ids=G2_N091.700.d.9)<b>G2_N091.700.d.9 - (N091.700)d.9 K_COS</b>
PAR Schritt d.9: Setze      cipherDO  = '86 – L<sub>86</sub> – ( 02   ||   C )'. <b>[<=]</b>

REQ(ids=G2_N091.700.d.10)<b>G2_N091.700.d.10 - (N091.700)d.10 K_COS</b>
PAR Schritt d.10: Setze      macDO   = '8E – L<sub>8E</sub> – T '. <b>[<=]</b>

REQ(ids=G2_N091.700.d.11)<b>G2_N091.700.d.11 - (N091.700)d.11 K_COS</b>
PAR Schritt d.11: Setze      cipher    = 'A6 – L<sub>A6</sub> – ( oidDO   ||   keyDO   ||   cipherDO   ||   macDO ). <b>[<=]</b>

PAR (N091.800) Diese Anforderung ist absichtlich leer.
REQ(ids=G2_N091.900)<b>G2_N091.900 - (N091.900) K_COS</b>
PAR Als Datenfeld der Antwortnachricht MUSS cipher verwendet werden. <b>[<=]</b>

REQ(ids=G2_N092.000)<b>G2_N092.000 - (N092.000) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16678)<b>A_16678 - (N092.100)a K_TST</b>
PAR Die Priorität der Trailer in CosT_6c0 MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N092.100.b)<b>G2_N092.100.b - (N092.100)b K_COS</b>
PAR Jeder Trailer in CosT_6c0 MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.8.5)14.8.5 PSO Hash
REQ(ids=A_16679)<b>A_16679 - (N092.200) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das PSH Hash-Kommando gemäß [ISO/IEC 7816-8] würde<br>a. unterstützt oder<br>b. abgelehnt. <b>[<=]</b>

PAR -HEADING(ids=14.8.6)14.8.6 CosK_53f PSO Transcipher
PAR Das Kommando PSO Transcipher kombiniert die Kommandos PSO Decipher und PSO Encipher, ohne dass die Klartextdaten die Karte verlassen. Es werden also Daten mittels eines privaten Schlüssels entschlüsselt und sofort wieder mittels eines öffentlichen Schlüssels verschlüsselt. Der private Schlüssel und der zu verwendende Algorithmus werden vor der Entschlüsselungsoperation ausgewählt. Dies geschieht vor dem Senden dieses PSO Transcipher-Kommandos durch ein MSE-Set-Kommando (siehe (N103.800)). Die umzuschlüsselnden Daten und der öffentliche Schlüssel des Empfängers sind als Parameter in der Kommandonachricht enthalten.
PAR -HEADING(ids=14.8.6.1)14.8.6.1 CosK_94a Use Case Umschlüsseln von Daten mittels RSA-Schlüssel
PAR In dieser Variante wird ein Chiffrat mittels eines privaten RSA-Schlüssels entschlüsselt und anschließend mit einem öffentlichen RSA-Schlüssels verschlüsselt.
PAR In dieser Variante enthält die APDU des PSO Transcipher-Kommandos vier Parameter:
REQ(ids=A_16680)<b>A_16680 - (N092.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter C<sub>in</sub> enthält die umzuschlüsselnden Daten. Der Parameter C<sub>in</sub> ist ein Oktettstring mit beliebigem Inhalt. <b>[<=]</b>

REQ(ids=A_16681)<b>A_16681 - (N092.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter PuK enthält den öffentlichen Schlüssel des Empfängers gemäß CosK_933. Der Parameter PuK ist ein Oktettstring, dessen Inhalt so gewählt werden MUSS, dass bei der Decodierung kein Fehler auftritt (siehe (N094.400)b.3). <b>[<=]</b>

REQ(ids=A_16682)<b>A_16682 - (N092.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter algID_enc enthält den Algorithmus, der zur Verschlüsselung eingesetzt wird. Es MUSS ein Wert aus der Menge {rsaEncipherPKCS1_V1_5, rsaEncipherOaep} verwendet werden. <b>[<=]</b>

REQ(ids=A_16683)<b>A_16683 - (N092.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardExtended sein. <b>[<=]</b>

REQ(ids=A_16684)<b>A_16684 - (N092.700) K_externeWelt {K_Karte}</b>
PAR Die Parameter C<sub>in</sub>, PuK und algID_enc MÜSSEN im Datenfeld der Kommandonachricht enthalten sein. Die Codierung wird in (N094.100), (N094.200) und (N094.400) spezifiziert. <b>[<=]</b>

REQ(ids=A_16685)<b>A_16685 - (N092.800) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_f40 verwendet werden.
PAR (ids=Tabelle-276,-CosT_f40)Tabelle 276, CosT_f40: PSO Transcipher, Umschlüsseln mittels RSA-Schlüssel

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '86' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier Chiffrat
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'B8' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier CRT für Verschlüsselung
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR cipherIN, DER codiertes Datenfeld
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '0000' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.6.2)14.8.6.2 CosK_a07 Use Case Umschlüsseln von Daten von RSA-Schlüssel nach ELC-Schlüssel
PAR In dieser Variante wird ein Chiffrat mittels eines privaten RSA-Schlüssels entschlüsselt und anschließend mit einem öffentlichen ELC-Schlüssel verschlüsselt.
PAR In dieser Variante enthält die APDU des PSO Transcipher-Kommandos fünf Parameter:
REQ(ids=A_16686)<b>A_16686 - (N092.820) K_externeWelt {K_Karte}</b>
PAR Der Parameter C<sub>in</sub> MUSS die umzuschlüsselnden Daten enthalten. Der Parameter C<sub>in</sub> ist ein Oktettstring mit beliebigem Inhalt. <b>[<=]</b>

REQ(ids=A_16687)<b>A_16687 - (N092.821) K_externeWelt {K_Karte}</b>
PAR Der Parameter oid<sub>out</sub> enthält einen Objektidentifier, der die zu verwendende elliptische Kurve für die Verschlüsselung referenziert. Der Parameter oid<sub>out</sub> MUSS aus der in CosT_a91 genannten Menge gewählt werden und eine elliptische Kurve aus der Menge in (N002.500) referenzieren. <b>[<=]</b>

REQ(ids=A_16688)<b>A_16688 - (N092.822) K_externeWelt {K_Karte}</b>
PAR Der Parameter PO<sub>B</sub> enthält einen Punkt auf einer elliptischen Kurve. Dieser Punkt repräsentiert den öffentlichen Schlüssel des Empfängers. Der Parameter PO<sub>B</sub> ist ein Oktettstring, dessen Inhalt so gewählt werden SOLL, dass bei der Decodierung kein Fehler auftritt (siehe (N004.500)a). <b>[<=]</b>

REQ(ids=A_16689)<b>A_16689 - (N092.824) K_externeWelt {K_Karte}</b>
PAR Der Parameter algID_enc enthält den Algorithmus, der zur Verschlüsselung eingesetzt wird. Es MUSS ein Wert aus der Menge {elcSharedSecretCalculation} verwendet werden. <b>[<=]</b>

REQ(ids=A_16690)<b>A_16690 - (N092.826) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardExtended sein. <b>[<=]</b>

REQ(ids=A_16691)<b>A_16691 - (N092.828) K_externeWelt {K_Karte}</b>
PAR Die Parameter C<sub>in</sub>, oid<sub>out</sub>, PO<sub>B</sub> und algID_enc MÜSSEN im Datenfeld der Kommandonachricht enthalten sein. Die Codierung wird in (N094.100), (N094.200) und (N094.400) spezifiziert. <b>[<=]</b>

REQ(ids=A_16692)<b>A_16692 - (N092.830) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_632 verwendet werden.
PAR (ids=Tabelle-277,-CosT_632)Tabelle 277, CosT_632: PSO Transcipher, Umschlüsseln von RSA nach ELC

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '86' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier Chiffrat
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'B8' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier CRT für Verschlüsselung
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR cipherIN
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '0000' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.6.3)14.8.6.3 CosK_e8f Use Case Umschlüsseln von Daten mittels ELC
PAR In dieser Variante wird ein Chiffrat mittels eines privaten ELC-Schlüssels entschlüsselt und anschließend mit einem öffentlichen ELC-Schlüssel verschlüsselt.
PAR In dieser Variante enthält die APDU des PSO Transcipher-Kommandos acht Parameter:
REQ(ids=A_16693)<b>A_16693 - (N092.900) K_externeWelt {K_Karte}</b>
PAR Der Parameter PO<sub>A</sub> enthält einen Punkt auf einer elliptischen Kurve. Dieser Punkt wurde vom Sender der Nachricht gewählt. Der Parameter PO<sub>A</sub> ist ein Oktettstring, dessen Inhalt so gewählt werden SOLL, dass bei der Decodierung kein Fehler auftritt (siehe (N004.800)a). <b>[<=]</b>

REQ(ids=A_16694)<b>A_16694 - (N092.902) K_externeWelt {K_Karte}</b>
PAR Der Parameter oid<sub>in</sub> enthält einen Objektidentifier, der die zu verwendende elliptische Kurve für die Entschlüsselung referenziert. Der Parameter oid<sub>in</sub> MUSS aus der in CosT_a91 genannten Menge gewählt werden und eine elliptische Kurve aus der Menge in (N002.500) referenzieren. <b>[<=]</b>

REQ(ids=A_16695)<b>A_16695 - (N093.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter C<sub>in</sub> MUSS die umzuschlüsselnden Daten enthalten. Der Parameter C<sub>in</sub> ist ein Oktettstring mit beliebigem Inhalt. <b>[<=]</b>

REQ(ids=A_16696)<b>A_16696 - (N093.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter T<sub>in</sub> enthält einen MAC, der die Integrität von C<sub>in</sub> schützt. Der Parameter T<sub>in</sub> ist ein Oktettstring, dessen Länge und Inhalt so gewählt werden SOLL, dass bei der MAC-Prüfung kein Fehler auftritt. <b>[<=]</b>

REQ(ids=A_16697)<b>A_16697 - (N093.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter PO<sub>B</sub> enthält einen Punkt auf einer elliptischen Kurve. Dieser Punkt repräsentiert den öffentlichen Schlüssel des Empfängers. Der Parameter PO<sub>B</sub> ist ein Oktettstring, dessen Inhalt so gewählt werden SOLL, dass bei der Decodierung kein Fehler auftritt (siehe (N004.800)a). <b>[<=]</b>

REQ(ids=A_16698)<b>A_16698 - (N093.202) K_externeWelt {K_Karte}</b>
PAR Der Parameter oid<sub>out</sub> enthält einen Objektidentifier, der die zu verwendende elliptische Kurve für die Verschlüsselung referenziert. Der Parameter oid<sub>out</sub> MUSS aus der in CosT_a91 genannten Menge gewählt werden und eine elliptische Kurve aus der Menge in (N002.500) referenzieren. <b>[<=]</b>

REQ(ids=A_16699)<b>A_16699 - (N093.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter algID_enc enthält den Algorithmus, der zur Verschlüsselung eingesetzt wird. Es MUSS ein Wert aus der Menge {elcSharedSecretCalculation} verwendet werden. <b>[<=]</b>

REQ(ids=A_16700)<b>A_16700 - (N093.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS so aus der Menge {WildCardShort, WildCardExtended} gewählt werden, dass der komplette Oktettstring cipherOUT in der Antwortnachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_16701)<b>A_16701 - (N093.500) K_externeWelt {K_Karte}</b>
PAR Die Parameter PO<sub>A</sub>, oid<sub>in</sub>, C<sub>in</sub>, T<sub>in</sub>, PO<sub>B</sub>, oid<sub>out</sub> und algID_enc MÜSSEN im Datenfeld der Kommandonachricht enthalten sein. Die Codierung wird in (N094.100), (N094.200) und (N094.400) spezifiziert. <b>[<=]</b>

REQ(ids=A_16702)<b>A_16702 - (N093.600) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 oder eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_c68 verwendet werden.
PAR (ids=Tabelle-278,-CosT_c68)Tabelle 278, CosT_c68: PSO Transcipher, Umschlüsseln mittels ELC-Schlüssel

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '86' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier Chiffrat
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'B8' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier CRT für Verschlüsselung
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR cipherIN
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR length TD(6,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.6.4)14.8.6.4 CosK_b38 Use Case Umschlüsseln von Daten von ELC-Schlüssel nach RSA-Schlüssel
PAR In dieser Variante wird ein Chiffrat mittels eines privaten ELC-Schlüssels entschlüsselt und anschließend mit einem öffentlichen RSA-Schlüssel verschlüsselt.
PAR In dieser Variante enthält die APDU des PSO Transcipher-Kommandos sieben Parameter:
REQ(ids=A_16703)<b>A_16703 - (N093.620) K_externeWelt {K_Karte}</b>
PAR Der Parameter PO<sub>A</sub> enthält einen Punkt auf einer elliptischen Kurve. Dieser Punkt wurde vom Sender der Nachricht gewählt. Der Parameter PO<sub>A</sub> ist ein Oktettstring, dessen Inhalt so gewählt werden SOLL, dass bei der Decodierung kein Fehler auftritt (siehe (N004.800)a). <b>[<=]</b>

REQ(ids=A_16704)<b>A_16704 - (N093.621) K_externeWelt {K_Karte}</b>
PAR Der Parameter oid<sub>in</sub> enthält einen Objektidentifier, der die zu verwendende elliptische Kurve für die Entschlüsselung referenziert. Der Parameter oid<sub>in</sub> MUSS aus der in CosT_a91 genannten Menge gewählt werden und eine elliptische Kurve aus der Menge in (N002.500) referenzieren. <b>[<=]</b>

REQ(ids=A_16705)<b>A_16705 - (N093.622) K_externeWelt {K_Karte}</b>
PAR Der Parameter C<sub>in</sub> MUSS die umzuschlüsselnden Daten enthalten. Der Parameter C<sub>in</sub> ist ein Oktettstring mit beliebigem Inhalt. <b>[<=]</b>

REQ(ids=A_16706)<b>A_16706 - (N093.624) K_externeWelt {K_Karte}</b>
PAR Der Parameter T<sub>in</sub> enthält einen MAC, der die Integrität von C schützt. Der Parameter T<sub>i</sub><sub>n</sub> ist ein Oktettstring, dessen Länge und Inhalt so gewählt werden SOLL, dass bei der MAC-Prüfung kein Fehler auftritt. <b>[<=]</b>

REQ(ids=A_16707)<b>A_16707 - (N093.626) K_externeWelt {K_Karte}</b>
PAR Der Parameter PuK enthält den öffentlichen Schlüssel des Empfängers gemäß CosK_933. Der Parameter PuK ist ein Oktettstring, dessen Inhalt so gewählt werden MUSS, dass bei der Decodierung kein Fehler auftritt (siehe (N094.400)b.3). <b>[<=]</b>

REQ(ids=A_16708)<b>A_16708 - (N093.628) K_externeWelt {K_Karte}</b>
PAR Der Parameter algID_enc enthält den Algorithmus, der zur Verschlüsselung eingesetzt wird. Es MUSS ein Wert aus der Menge {rsaEncipherPKCS1_V1_5, rsaEncipherOaep} verwendet werden. <b>[<=]</b>

REQ(ids=A_16709)<b>A_16709 - (N093.630) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardExtended sein. <b>[<=]</b>

REQ(ids=A_16710)<b>A_16710 - (N093.632) K_externeWelt {K_Karte}</b>
PAR Die Parameter PO<sub>A</sub>, oid<sub>n</sub>, C<sub>in</sub>, T<sub>n</sub>, PuK und algID_enc MÜSSEN im Datenfeld der Kommandonachricht enthalten sein. Die Codierung wird in (N094.100), (N094.200) und (N094.400) spezifiziert. <b>[<=]</b>

REQ(ids=A_16711)<b>A_16711 - (N093.634) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4E Kommando-APDU gemäß CosK_265 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_8eb verwendet werden.
PAR (ids=Tabelle-279,-CosT_8eb)Tabelle 279, CosT_8eb: PSO Transcipher, Umschlüsseln von ELC nach RSA

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '86' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier Chiffrat
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'B8' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier CRT für Verschlüsselung
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR cipherIN
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '0000' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.6.5)14.8.6.5 Antwort der Karte auf Umschlüsseln von Daten
PAR (ids=Tabelle-280,-CosT_dba)Tabelle 280, CosT_dba: PSO Transcipher Antwort-APDU im Erfolgsfall

TABLE(rows=4,cols=63+183+345)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)->PAR cipherOUT TD(1,2/1/1)->PAR Chiffrat
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '90 00' TD(3,1/1/1)->PAR NoError TD(3,2/1/1)->PAR Erfolgreiche Umschlüsselungsoperation
PAR (ids=Tabelle-281,-CosT_2dd)Tabelle 281, CosT_2dd: PSO Transcipher Antwort-APDU im Fehlerfall

TABLE(rows=8,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '64 00' TD(1,1/1/1)->PAR KeyInvalid TD(1,2/1/1)->PAR Schlüsseldaten fehlen
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '69 85' TD(3,1/1/1)->PAR NoKeyReference TD(3,2/1/1)->PAR Kein Schlüssel zur Entschlüsselung ausgewählt
TR-> TD(4,0/1/1)->PAR '6A 80' TD(4,1/1/1)->PAR WrongCiphertext TD(4,2/1/1)->PAR Fehler beim Entschlüsseln des Chiffrats
TR-> TD(5,0/1/1)->PAR '6A 81' TD(5,1/1/1)->PAR UnsupportedFunction TD(5,2/1/1)->PAR Schlüssel unterstützt den geforderten Algorithmus nicht
TR-> TD(6,0/1/1)->PAR '6A 84' TD(6,1/1/1)->PAR MessageTooLong TD(6,2/1/1)->PAR Klartext zu lang für Verschlüsselung
TR-> TD(7,0/1/1)->PAR '6A 88' TD(7,1/1/1)->PAR KeyNotFound TD(7,2/1/1)->PAR Schlüssel für Entschlüsselung nicht gefunden
PAR Hinweis CosH_619: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16712)<b>A_16712 - (N093.700) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando PSO Transcipher verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.8.6.6)14.8.6.6 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N093.800.a)<b>G2_N093.800.a - (N093.800)a K_COS</b>
PAR Das COS MUSS die PSO Transcipher-Variante aus (N092.800), (N092.830), (N093.600) und (N093.634) unterstützen. <b>[<=]</b>

REQ(ids=A_16713)<b>A_16713 - (N093.800)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere PSO Transcipher-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N093.900.a)<b>G2_N093.900.a - (N093.900)a K_COS</b>
PAR Wenn channelContext.keyReferenceList.dataDecipher leer ist, genau dann MUSS das Kommando mit dem Trailer NoKeyReference terminieren. <b>[<=]</b>

REQ(ids=A_16714)<b>A_16714 - (N093.900)b K_COS</b>
PAR Wenn channelContext.keyReferenceList.dataDecipher nicht leer ist, dann wird<br>affectedObject = SearchKey(<br>    currentFolder,<br>    keyReferenceList.dataDecipher.keyReference,<br>    keyReferenceList.dataDecipher.algID<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. <b>[<=]</b>

REQ(ids=G2_N093.900.b.1)<b>G2_N093.900.b.1 - (N093.900)b.1 K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N093.900.b.2)<b>G2_N093.900.b.2 - (N093.900)b.2 K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N094.000)<b>G2_N094.000 - (N094.000) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N094.010)<b>G2_N094.010 - (N094.010) K_COS</b>
PAR Wenn affectedObject.keyAvailable den Wert False besitzt, genau dann MUSS das Kommando mit dem Trailer KeyInvalid terminieren. <b>[<=]</b>

REQ(ids=A_16715)<b>A_16715 - (N094.100) K_COS</b>
PAR Die Kommandodaten MÜSSEN wie folgt aufgeteilt werden:<br>a. cipherIN  == cipher   ||   plainDO.<br>b. cipher    MUSS ein DO mit Tag = 'A6' sein.<br>c. plainDO MUSS ein DO mit Tag = 'A0' sein. <b>[<=]</b>

REQ(ids=A_16716)<b>A_16716 - (N094.200) K_COS</b>
PAR Der Klartext M MUSS in Abhängigkeit von algID = channelContext.keyReferenceList.dataDecipher.algID wie folgt berechnet werden <b>[<=]</b>

PAR (N094.200)a Diese Anforderung ist absichtlich leer.
REQ(ids=G2_N094.200.a)<b>G2_N094.200.a - (N094.200)a K_COS</b>
PAR Falls algID den Wert rsaDecipherPKCS1_V1_5 besitzt, dann gilt:<br>1. cipher         = 'A6 – L<sub>A6 </sub>– ( cipherDO<sub>in</sub> )'.<br>2. cipherDO<sub>in</sub>  = '86 – L<sub>86 </sub>– ( 00   ||   C<sub>in</sub> )'.<br>3. M               = RSAES_PKCS1_V1_5_DECRYPT( affectedObject.privateRsaKey, C<sub>in</sub> ).   <br>Wenn diese Funktion mit dem Fehler "ERROR" terminiert, genau dann MUSS das Kommando mit dem Trailer WrongCiphertext terminieren. <b>[<=]</b>

REQ(ids=G2_N094.200.b)<b>G2_N094.200.b - (N094.200)b K_COS</b>
PAR Wenn algID den Wert rsaDecipherOaep besitzt, dann gilt:<br>1. cipher         == 'A6 – L<sub>A6 </sub>– ( cipherDO<sub>in</sub> )'.<br>2. cipherDO<sub>in</sub>  == '86 – L<sub>86 </sub>– ( 00   ||   C<sub>in</sub> )'.<br>3. M               = RSAES_OAEP_DECRYPT( affectedObject.privateRsaKey, C<sub>in</sub> ).    <br>Wenn diese Funktion mit dem Fehler "ERROR" terminiert, genau dann MUSS das Kommando mit dem Trailer WrongCiphertext terminieren. <b>[<=]</b>

REQ(ids=G2_N094.200.c)<b>G2_N094.200.c - (N094.200)c K_COS</b>
PAR Falls algID den Wert elcSharedSecretCalculation besitzt, dann gilt (Hinweis CosH_62d: cipher ist hier identisch zu (N090.300)c und (N091.700)d definiert):<br>1. cipher        == 'A6 – L<sub>A6</sub> – ( oidDO<sub>in</sub>   ||   keyDO<sub>A</sub>   ||   cipherDO<sub>in</sub>   ||   macDO<sub>in</sub> )'.<br>2. oidDO<sub>in</sub>     == '06 – L<sub>06 </sub>– oid<sub>in</sub> '.<br>3. keyDO<sub>A</sub>      == '7F49 – L<sub>7F49</sub> – ( 86 – L<sub>86</sub> – PO<sub>A</sub> )'.<br>4. cipherDO<sub>in</sub> == '86 – L<sub>86 </sub>– ( 02   ||   C<sub>in</sub> )'.<br>5. macDO<sub>in</sub>    == '8E – L<sub>8E</sub> – T<sub>in</sub>'.<br>6. Falls oid<sub>in</sub> verschieden ist zur OID, die gemäß (N008.600)d zu affectedObject.privateElcKey.domainParameter gehört, dann MUSS das Kommando mit dem Trailer WrongCiphertext terminieren.<br>7. M              = ELC_DEC( PO<sub>A</sub>, affectedObject.privateElcKey, C<sub>in</sub>, T<sub>in</sub> ).    <br>Wenn diese Funktion mit dem Fehler "ERROR" terminiert, genau dann MUSS das Kommando mit dem Trailer WrongCiphertext terminieren. <b>[<=]</b>

REQ(ids=G2_N094.300)<b>G2_N094.300 - (N094.300) K_COS</b>
PAR Suche in plainDO nach einem DO mit Tag = '80' dieses DO MUSS die Länge eins haben. Es gilt algID_enc = Wertfeld des DO mit Tag = '80'. <b>[<=]</b>

REQ(ids=A_16717)<b>A_16717 - (N094.400) K_COS</b>
PAR Das Chiffrat cipherOUT MUSS wie folgt aus M berechnet werden: <b>[<=]</b>

PAR (N094.400)a Diese Anforderung ist absichtlich leer.
REQ(ids=G2_N094.400.a)<b>G2_N094.400.a - (N094.400)a K_COS</b>
PAR Falls algID_enc den Wert rsaEncipherPKCS1_V1_5 besitzt, dann gilt:<br>1. plainDO     = 'A0 – L<sub>A0 </sub>– ( algDO   ||   keyDO ).<br>2. algDO       = '80 01   ||   algID_enc'.<br>3. keyDO       = '7F49 – L<sub>7F49</sub> – [( 81 – L<sub>81</sub> – PuK.n )   ||   ( 82 – L<sub>82</sub> – PuK.e )]'.<br>4. cipherOUT = '00' || RSAES_PKCS1_V1_5_ENCRYPT( PuK, M ).    <br>Wenn diese Funktion mit dem Fehler "ERROR" terminiert, dann MUSS das Kommando mit dem Trailer MessageTooLong terminieren. <b>[<=]</b>

REQ(ids=G2_N094.400.b)<b>G2_N094.400.b - (N094.400)b K_COS</b>
PAR Falls algID_enc den Wert rsaEncipherOaep besitzt, dann gilt:<br>1. plainDO    == 'A0 – L<sub>A0 </sub>– ( algDO   ||   keyDO ).<br>2. algDO       == '80 – 01 – algID_enc'.<br>3. keyDO       == '7F49 – L<sub>7F49</sub> – [( 81 – L<sub>81</sub> – PuK.n )   ||   ( 82 – L<sub>82</sub> – PuK.e )]'.<br>4. cipherOUT = '00' || RSAES_OAEP_ENCRYPT( PuK, M ).     <br>Wenn diese Funktion mit dem Fehler "ERROR" terminiert, dann MUSS das Kommando mit dem Trailer MessageTooLong terminieren. <b>[<=]</b>

REQ(ids=G2_N094.400.c)<b>G2_N094.400.c - (N094.400)c K_COS</b>
PAR Falls algID_enc den Wert elcSharedSecretCalculation besitzt, dann gilt (Hinweis CosH_624: cipherOUT ist hier identisch zu (N085.068)b.7, (N090.300)c und (N091.700)d definiert):<br>1. plainDO    == 'A0 – L<sub>A0</sub> – ( algDO   ||   oidDO<sub>out</sub>   ||   keyDO<sub>B</sub> ).<br>2. algDO      == '80 – 01 – algID_enc'.<br>3. oidDO<sub>out</sub>   == '06 – L<sub>06 </sub>– oid<sub>out</sub> '.<br>4. keyDO<sub>B</sub>    == '7F49 – L<sub>7F49 </sub>– ( 86 – L<sub>86</sub> – PO<sub>B</sub> )'.<br>5. Die oid<sub>out</sub> aus der Kommandonachricht wird gemäß CosT_a91 in Domainparameter übersetzt, die im Folgenden mit dP bezeichnet werden.<br>6. ( PO<sub>out</sub>, C<sub>out</sub>, T<sub>out</sub> ) = ELC_ENC( M, PO<sub>B</sub>, dP ).<br>Wenn diese Funktion mit dem Fehler "ERROR" terminiert, genau dann MUSS das Kommando mit dem Trailer WrongCiphertext terminieren. Andernfalls wird ein DER-TLV codierter Oktettstring cipherOUT wie folgt konstruiert:<br>7.  Setze  keyDO<sub>out</sub>     = '7F49 – L<sub>7F49 </sub>– ( 86 – L<sub>86 </sub>– PO<sub>out</sub> )'.<br>8.  Setze  cipherDO<sub>out</sub> = '86 – L<sub>86 </sub>– ( 02   ||   C<sub>out</sub> )'.<br>9.  Setze  macDO<sub>out</sub>   = '8E – L<sub>8E</sub> – T<sub>out</sub>'.<br>10. Setze cipherOUT   = 'A6 – L<sub>A6 </sub>– ( oidDO<sub>out</sub>   ||   keyDO<sub>out</sub>   ||   cipherDO<sub>out</sub>   ||   macDO<sub>out</sub> ). <b>[<=]</b>

REQ(ids=G2_N094.500)<b>G2_N094.500 - (N094.500) K_COS</b>
PAR Als Datenfeld der Antwortnachricht MUSS cipherOUT verwendet werden. <b>[<=]</b>

REQ(ids=G2_N094.600)<b>G2_N094.600 - (N094.600) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16718)<b>A_16718 - (N094.700)a K_TST</b>
PAR Die Priorität der Trailer in CosT_2dd MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N094.700.b)<b>G2_N094.700.b - (N094.700)b K_COS</b>
PAR Jeder Trailer in CosT_2dd MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.8.7)14.8.7 CosK_ca7 PSO Verify Certificate
PAR Das Kommando PSO Verify Certificate überprüft die Signatur eines Zertifikates mittels eines öffentlichen Schlüssels. Der öffentliche Schlüssel wird vor der Verifikationsoperation ausgewählt. Dies geschieht vor dem Senden dieses PSO Verify Certificate-Kommandos durch ein MSE-Set-Kommando (siehe (N103.300)). Das Zertifikat ist als Parameter in der Kommandonachricht enthalten. Falls die Signatur des Zertifikates als gültig betrachtet wird, dann werden gewisse Attribute des im Zertifikat enthaltenen Schlüsselobjektes zur späteren Verwendung gespeichert.
PAR -HEADING(ids=14.8.7.1)14.8.7.1 CosK_4ab Use Case Importieren RSA-Schlüssels mittels Zertifikat, Option_RSA_CVC
PAR Die folgenden Anforderungen sind absichtlich leer: (N094.800), (N094.810), (N094.820), (N094.900), (N095.000), (N095.100).
PAR In dieser Variante enthält die APDU des PSO Verify Certificate-Kommandos zwei Parameter:
REQ(ids=A_16719)<b>A_16719 - (N094.800) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Der Parameter certificateContent MUSS Attributsinformationen für das Schlüsselobjekt enthalten. <b>[<=]</b>

REQ(ids=G2_N094.810)<b>G2_N094.810 - (N094.810) K_Anwendungsspezifikation {K_Karte}, Option_RSA_CVC</b>
PAR Die Anwendungsspezifikation einer Karte MUSS eine vollständige Liste aller CHA-Werte enthalten, die von dieser Karte zu unterstützen ist. <b>[<=]</b>

REQ(ids=A_16720)<b>A_16720 - (N094.820) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Der in certificateContent enthaltene Wert für CHA MUSS aus Element der Anwendungsspezifikation genannten Menge sein (siehe (N094.810)). <b>[<=]</b>

REQ(ids=A_16721)<b>A_16721 - (N094.900) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Der Parameter signature MUSS die von einer CA erstellte Signatur über die Attributsinformationen enthalten. <b>[<=]</b>

REQ(ids=A_16722)<b>A_16722 - (N095.000) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Die Parameter certificateContent und signature MÜSSEN im Datenfeld der Kommandonachricht enthalten sein. Die Codierung wird in (N095.900)a spezifiziert. <b>[<=]</b>

REQ(ids=A_16723)<b>A_16723 - (N095.100) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Es MUSS eine Case 3E Kommando-APDU gemäß CosK_afd über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_eb9 verwendet werden.
PAR Tabelle 282, CosT_eb9: PSO Verify Certificate für RSA-Schlüssel

TABLE(rows=6,cols=64+86+445)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR Keine Antwortdaten
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'AE' TD(4,2/1/1)->PAR Kommandodaten mit Template, dessen Wertfelder zertifiziert sind
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR certificate
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.7.2)14.8.7.2 CosK_e13 Use Case Importieren ELC-Schlüssels mittels Zertifikat
PAR In dieser Variante enthält die APDU des PSO Verify Certificate-Kommandos zwei Parameter:
REQ(ids=A_16724)<b>A_16724 - (N095.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter certificateContent MUSS alle Attribute für das Schlüsselobjekt enthalten. <b>[<=]</b>

REQ(ids=A_16725)<b>A_16725 - (N095.300) K_externeWelt {K_Karte}</b>
PAR Der Parameter signature MUSS die von einer CA erstellte Signatur über die Attribute enthalten. <b>[<=]</b>

REQ(ids=A_16726)<b>A_16726 - (N095.400) K_externeWelt {K_Karte}</b>
PAR Die Parameter certificateContent und signature MÜSSEN im Datenfeld der Kommandonachricht enthalten sein. Die Codierung wird in (N095.900)b spezifiziert. <b>[<=]</b>

REQ(ids=G2_N095.410)<b>G2_N095.410 - (N095.410) K_COS</b>
PAR Der öffentliche Punkt P im Parameter certificateContent liegt gemäß [gemSpec_PKI] auf einer der Kurven brainpoolP256r1, brainpoolP384r1 oder brainpoolP512r1. Die Signature im Parameter signature ist gemäß [gemSpec_PKI] mit einem öffentlichen Schlüssel prüfbar, der auf einer der Kurven brainpoolP256r1, brainpoolP384r1 oder brainpoolP512r1 liegt. In einem CV-Zertifikat für elliptische Kurven ist eine Kurve für certificateContent zu kombinieren mit einer Kurve für signature. Für die zu unterstützenden Kombinationen durch das COS MÜSSEN die in CosT_952 genannten Schlüsselwörter gelten.
PAR (ids=Tabelle-283,-CosT_952)Tabelle 283, CosT_952: Kombination von Kurvenparametern in CV-Zertifikaten

TABLE(rows=5,cols=152+103+103+103+45)->
TR-> TH(0,0/1/1)->PAR                certificateContent<br>signature TH(0,1/1/1)->PAR brainpoolP256r1 TH(0,2/1/1)->PAR brainpoolP384r1 TH(0,3/1/1)->PAR brainpoolP512r1 TH(0,4/1/1)->PAR andere
TR-> TD(1,0/1/1)->PAR brainpoolP256r1 TD(1,1/1/1)->PAR MUSS TD(1,2/1/1)->PAR MUSS TD(1,3/1/1)->PAR MUSS TD(1,4/1/1)->PAR KANN
TR-> TD(2,0/1/1)->PAR brainpoolP384r1 TD(2,1/1/1)->PAR MUSS TD(2,2/1/1)->PAR MUSS TD(2,3/1/1)->PAR MUSS TD(2,4/1/1)->PAR KANN
TR-> TD(3,0/1/1)->PAR brainpoolP512r1 TD(3,1/1/1)->PAR MUSS TD(3,2/1/1)->PAR MUSS TD(3,3/1/1)->PAR MUSS TD(3,4/1/1)->PAR KANN
TR-> TD(4,0/1/1)->PAR andere TD(4,1/1/1)->PAR KANN TD(4,2/1/1)->PAR KANN TD(4,3/1/1)->PAR KANN TD(4,4/1/1)->PAR KANN
PAR <b>[<=]</b>

REQ(ids=A_16727)<b>A_16727 - (N095.500) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 oder eine Case 3E Kommando-APDU gemäß CosK_afd über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_8a7 verwendet werden.
PAR (ids=Tabelle-284,-CosT_8a7)Tabelle 284, CosT_8a7: PSO Verify Certificate für ELC-Schlüssel

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR Keine Antwortdaten
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'BE' TD(4,2/1/1)->PAR Kommandodaten mit zertifiziertem Template
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR certificate
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.7.3)14.8.7.3 Antwort den Importieren eines CV-Zertifikates
PAR (ids=Tabelle-285,-CosT_b8a)Tabelle 285, CosT_b8a: PSO Verify Certificate Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '63 Cx' TD(1,1/1/1)->PAR UpdateRetryWarning TD(1,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiche Zertifikatsprüfung
PAR (ids=Tabelle-286,-CosT_527)Tabelle 286, CosT_527: PSO Verify Certificate Antwort-APDU im Fehlerfall

TABLE(rows=8,cols=80+172+492)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '65 81' TD(1,1/1/1)->PAR MemoryFailure TD(1,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(2,0/1/1)->PAR '69 82' TD(2,1/1/1)->PAR SecurityStatusNotSatisfied TD(2,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(3,0/1/1)->PAR '69 83' TD(3,1/1/1)->PAR KeyExpired TD(3,2/1/1)->PAR Gültigkeitszeitraum des<br>a. Signaturprüfschlüssels ist abgelaufen<br>b. Zertifikates ist abgelaufen
TR-> TD(4,0/1/1)->PAR '69 85' TD(4,1/1/1)->PAR NoKeyReference TD(4,2/1/1)->PAR Kein Signaturprüfschlüssel ausgewählt
TR-> TD(5,0/1/1)->PAR '6A 80' TD(5,1/1/1)->PAR VerificationError TD(5,2/1/1)->PAR Prüfung des Zertifikates fehlgeschlagen
TR-> TD(6,0/1/1)->PAR '6A 88' TD(6,1/1/1)->PAR InconsistentKeyReference TD(6,2/1/1)->PAR Signaturprüfschlüssel hat eine andere Referenz als CAR des Zertifikates
TR-> TD(7,0/1/1)->PAR '6A 88' TD(7,1/1/1)->PAR KeyNotFound TD(7,2/1/1)->PAR Signaturprüfschlüssel nicht gefunden
PAR Hinweis CosH_7c5: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16728)<b>A_16728 - (N095.600) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando PSO Verify Certificate verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.8.7.4)14.8.7.4 Kommandoabarbeitung innerhalb der Karte
PAR (N095.700)a.1 ist absichlich leer.
REQ(ids=G2_N095.700.a)<b>G2_N095.700.a - (N095.700)a.1 K_COS, Option_RSA_CVC</b>
PAR Das COS MUSS die PSO Verify Certificate-Variante aus (N095.100) unterstützen. <b>[<=]</b>

REQ(ids=A_16729)<b>A_16729 - (N095.700)a.2 K_COS</b>
PAR Das COS MUSS die PSO Verify Certificate-Variante aus (N095.500) unterstützen. <b>[<=]</b>

REQ(ids=A_16730)<b>A_16730 - (N095.700)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere PSO Verify Certificate-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N095.800.a)<b>G2_N095.800.a - (N095.800)a K_COS</b>
PAR Wenn channelContext.keyReferenceList.verifyCertificate leer ist, genau dann MUSS das Kommando mit dem Trailer NoKeyReference terminieren. <b>[<=]</b>

REQ(ids=G2_N095.800.b)<b>G2_N095.800.b - (N095.800)b K_COS</b>
PAR Wenn channelContext.keyReferenceList.verifyCertificate nicht leer ist, dann wird<br>affectedObject = SearchKey(<br>    currentFolder,<br>    keyReferenceList.verifyCertificate.keyReference,<br>    verifyCertificate<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. <b>[<=]</b>

REQ(ids=G2_N095.810)<b>G2_N095.810 - (N095.810) K_COS</b>
PAR Wenn affectedObject ein Attribut expirationDate besitzt und affectedObject.CHAT.flagList nicht die Rolle Root-CA-Schlüssel anzeigt (d.h. Bits b0 b1 sind ungleich 11<sub>2</sub>) und affectedObject.expirationDate kleiner als pointInTime ist (siehe (N019.900)j), dann MUSS das Kommando mit dem Trailer KeyExpired terminieren. <b>[<=]</b>

REQ(ids=G2_N095.820)<b>G2_N095.820 - (N095.820) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

PAR Je nach Typ des selektierten Signaturprüfschlüssel werden die Schlüsselinformationen wie folgt extrahiert:
PAR (N095.900)a ist absichtlich leer.
REQ(ids=A_16731)<b>A_16731 - (N095.900)a K_COS, Option_RSA_CVC</b>
PAR Falls affectedObject.publicKey vom Typ publicRsaKey ist, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N095.900.a.1)<b>G2_N095.900.a.1 - (N095.900)a.1 K_COS, Option_RSA_CVC</b>
PAR certificate = '5F37 – L<sub>5F37 </sub>– signature   ||   5F38 – L<sub>5F38</sub> – certificateContent '. <b>[<=]</b>

REQ(ids=G2_N095.900.a.2)<b>G2_N095.900.a.2 - (N095.900)a.2 K_COS, Option_RSA_CVC</b>
PAR ( out, M ) = RSA_ISO9796_2_DS1_VERIFY( affectedObject.publicRsaKey, signature, certificateContent  ).   <br>Falls diese Operation mit einem Fehler abbricht, oder out gleich False ist, dann MUSS das Kommando mit dem Trailer VerificationError terminieren. <b>[<=]</b>

REQ(ids=G2_N095.900.a.3)<b>G2_N095.900.a.3 - (N095.900)a.3 K_COS, Option_RSA_CVC</b>
PAR Die Schlüsselattribute werden gemäß CosK_e9b aus der Nachricht M extrahiert und ein öffentliches Schlüsselobjekt pukObj gebildet. <b>[<=]</b>

REQ(ids=A_16732)<b>A_16732 - (N095.900)a.4 K_COS, Option_RSA_CVC</b>
PAR Falls CPI gleich '21' ist, dann MUSS pukObj ein öffentliches Signaturprüfobjekt sein (siehe CosK_9bb), dessen Attribute mit den Definitionen aus CosK_0d2 wie folgt zu setzen sind: <b>[<=]</b>

REQ(ids=G2_N095.900.a.4.i)<b>G2_N095.900.a.4.i - (N095.900)a.4.i K_COS, Option_RSA_CVC</b>
PAR pukObj.oid = OID. <b>[<=]</b>

REQ(ids=G2_N095.900.a.4.ii)<b>G2_N095.900.a.4.ii - (N095.900)a.4.ii K_COS, Option_RSA_CVC</b>
PAR pukObj.publicKey.n = Modulus. <b>[<=]</b>

REQ(ids=G2_N095.900.a.4.iii)<b>G2_N095.900.a.4.iii - (N095.900)a.4.iii K_COS, Option_RSA_CVC</b>
PAR pukObj.publicKey.e = öffentlicherExponent. <b>[<=]</b>

REQ(ids=G2_N095.900.a.4.iv)<b>G2_N095.900.a.4.iv - (N095.900)a.4.iv K_COS, Option_RSA_CVC</b>
PAR pukObj.keyIdentifier = CHR. <b>[<=]</b>

REQ(ids=G2_N095.900.a.4.v)<b>G2_N095.900.a.4.v - (N095.900)a.4.v K_COS, Option_RSA_CVC</b>
PAR pukObj.lifeCycleStatus = "Operational state (active)" <b>[<=]</b>

REQ(ids=G2_N095.900.a.4.vi)<b>G2_N095.900.a.4.vi - (N095.900)a.4.vi K_COS, Option_RSA_CVC</b>
PAR pukObj.accessRules = affectedObject. accessRulesPublicSignatureVerificationObject. <b>[<=]</b>

REQ(ids=G2_N095.900.a.4.vii)<b>G2_N095.900.a.4.vii - (N095.900)a.4.vii K_COS, Option_RSA_CVC</b>
PAR pukObj.accessRulesPublicSignatureVerificationObject = affectedObject.accessRulesPublicSignatureVerificationObject. <b>[<=]</b>

REQ(ids=G2_N095.900.a.4.viii)<b>G2_N095.900.a.4.viii - (N095.900)a.4.viii K_COS, Option_RSA_CVC</b>
PAR pukObj.accessRulesPublicAuthenticationObject = affectedObject.accessRulesPublicAuthenticationObject. <b>[<=]</b>

REQ(ids=A_16733)<b>A_16733 - (N095.900)a.5 K_COS, Option_RSA_CVC</b>
PAR Falls CPI gleich '22' ist, dann MUSS pukObj ein öffentliches Authentisierungsobjekt sein (siehe CosK_17c), dessen Attribute mit den Definitionen aus CosK_bc0 wie folgt zu setzen sind: <b>[<=]</b>

REQ(ids=G2_N095.900.a.5.i)<b>G2_N095.900.a.5.i - (N095.900)a.5.i K_COS, Option_RSA_CVC</b>
PAR pukObj.CHA = CHA. <b>[<=]</b>

REQ(ids=G2_N095.900.a.5.ii)<b>G2_N095.900.a.5.ii - (N095.900)a.5.ii K_COS, Option_RSA_CVC</b>
PAR pukObj.oid = OID. <b>[<=]</b>

REQ(ids=G2_N095.900.a.5.iii)<b>G2_N095.900.a.5.iii - (N095.900)a.5.iii K_COS, Option_RSA_CVC</b>
PAR pukObj.publicKey.n = Modulus. <b>[<=]</b>

REQ(ids=G2_N095.900.a.5.iv)<b>G2_N095.900.a.5.iv - (N095.900)a.5.iv K_COS, Option_RSA_CVC</b>
PAR pukObj.publicKey.e = öffentlicherExponent. <b>[<=]</b>

REQ(ids=G2_N095.900.a.5.v)<b>G2_N095.900.a.5.v - (N095.900)a.5.v K_COS, Option_RSA_CVC</b>
PAR pukObj.keyIdentifier = CHR. <b>[<=]</b>

REQ(ids=G2_N095.900.a.5.vi)<b>G2_N095.900.a.5.vi - (N095.900)a.5.vi K_COS, Option_RSA_CVC</b>
PAR pukObj.lifeCycleStatus = "Operational state (active)" <b>[<=]</b>

REQ(ids=G2_N095.900.a.5.vii)<b>G2_N095.900.a.5.vii - (N095.900)a.5.vii K_COS, Option_RSA_CVC</b>
PAR pukObj.accessRules = affectedObject.accessRulesPublicAuthenticationObject. <b>[<=]</b>

REQ(ids=A_16751)<b>A_16751 - (N095.900)b K_COS</b>
PAR Wenn affectedObject.publicKey vom Typ publicElcKey ist, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N095.900.b.1.i)<b>G2_N095.900.b.1.i - (N095.900)b.1.i K_COS</b>
PAR Das COS MUSS den Wert CPI = '70' = 112 unterstützen. <b>[<=]</b>

REQ(ids=A_16752)<b>A_16752 - (N095.900)b.1.ii K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere CPI-Werte würden<br>A. unterstützt oder<br>B. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N095.900.b.2)<b>G2_N095.900.b.2 - (N095.900)b.2 K_COS</b>
PAR certificate == '7F4E – L<sub>7F4E</sub> – certificateContent   ||   5F37 – L<sub>5F37 </sub>– signature '. <b>[<=]</b>

REQ(ids=G2_N095.900.b.3)<b>G2_N095.900.b.3 - (N095.900)b.3 K_COS</b>
PAR Falls affectedObject.publicElcKey.domainParameter.L gleich<br>i.   32 ist, dann gilt:     hash = SHA_256('7F4E – L<sub>7F4E</sub> – certificateContent ').<br>ii.  48 ist, dann gilt:     hash = SHA_384('7F4E – L<sub>7F4E</sub> – certificateContent ').<br>iii. 64 ist, dann gilt:     hash = SHA_512('7F4E – L<sub>7F4E </sub>– certificateContent '). <b>[<=]</b>

REQ(ids=G2_N095.900.b.4)<b>G2_N095.900.b.4 - (N095.900)b.4 K_COS</b>
PAR signature wird wie folgt in R und S aufgeteilt:    <br>signature == R   ||   S,   mit OctetLength( R ) == OctetLength( S ). <b>[<=]</b>

REQ(ids=G2_N095.900.b.5)<b>G2_N095.900.b.5 - (N095.900)b.5 K_COS</b>
PAR out = ELC_VER_SIG( affectedObject.publicElcKey, R, S, hash ).   <br>Wenn diese Operation mit einem Fehler abbricht, oder out gleich False ist, dann MUSS das Kommando mit dem Trailer VerificationError terminieren. <b>[<=]</b>

REQ(ids=G2_N095.900.b.6)<b>G2_N095.900.b.6 - (N095.900)b.6 K_COS</b>
PAR Falls die OID im CHAT aus certificateContent verschieden ist von der aus affectedObject.publickey.accessRights, dann MUSS das Kommando mit dem Trailer VerificationError terminieren. <b>[<=]</b>

REQ(ids=A_16734)<b>A_16734 - (N095.900)b.7</b>
PAR Das COS MUSS das Wertfeld von CED als vorzeichenlose ganze Zahl interpretieren, gemäß ced = OS2I( Wertfeld_von_CED ). <b>[<=]</b>

REQ(ids=A_16735)<b>A_16735 - (N095.900)b.8</b>
PAR Das COS MUSS das Wertfeld von CXD als vorzeichenlose ganze Zahl interpretieren, gemäß cxd = OS2I( Wertfeld_von_CXD ). <b>[<=]</b>

REQ(ids=G2_N095.900.b.9)<b>G2_N095.900.b.9 - (N095.900)b.9 K_COS</b>
PAR Falls CED aus certificateContent größer ist als CXD aus certificateContent, dann MUSS das Kommando mit dem Trailer VerificationError terminieren. <b>[<=]</b>

REQ(ids=G2_N095.900.b.10)<b>G2_N095.900.b.10 - (N095.900)b.10 K_COS</b>
PAR Das COS MUSS den Wert effectiveFlagList wie folgt bilden:    <br>effectiveFlagList = affectedObject.CHAT.flagList   AND   (flagList aus certificateContent ). <b>[<=]</b>

REQ(ids=G2_N095.900.b.11.i)<b>G2_N095.900.b.11.i - (N095.900)b.11.i K_COS</b>
PAR Wenn effectiveFlagList die Rolle Root-CA-Schlüssel anzeigt (d.h. Bits b0 b1 sind gleich 11<sub>2</sub>), dann DARF ein Import NICHT daran scheitern, dass CXD aus certificateContent größer ist als affectedObject.expirationDate. <b>[<=]</b>

REQ(ids=G2_N095.900.b.11.ii)<b>G2_N095.900.b.11.ii - (N095.900)b.11.ii K_COS</b>
PAR Wenn effectiveFlagList  nicht die Rolle Root-CA-Schlüssel anzeigt (d.h. Bits b0 b1 sind ungleich 11<sub>2</sub>) und CXD aus certificateContent größer ist als affectedObject.expirationDate, dann MUSS das Kommando mit dem Trailer VerificationError terminieren. <b>[<=]</b>

REQ(ids=G2_N095.900.b.12.i)<b>G2_N095.900.b.12.i - (N095.900)b.12.i K_COS</b>
PAR Wenn effectiveFlagList die Rolle Root-CA-Schlüssel anzeigt (d.h. Bits b0 b1 sind gleich 11<sub>2</sub>), dann DARF ein Import NICHT daran scheitern, dass CXD aus certificateContent kleiner als pointInTime ist (siehe (N019.900)j). <b>[<=]</b>

REQ(ids=G2_N095.900.b.12.ii)<b>G2_N095.900.b.12.ii - (N095.900)b.12.ii K_COS</b>
PAR Wenn effectiveFlagList nicht die Rolle Root-CA-Schlüssel anzeigt (d.h. Bits b0 b1 sind ungleich 11<sub>2</sub>) und CXD aus certificateContent kleiner als pointInTime ist (siehe (N019.900)j), dann MUSS das Kommando mit dem Trailer KeyExpired terminieren. <b>[<=]</b>

REQ(ids=G2_N095.900.b.13)<b>G2_N095.900.b.13 - (N095.900)b.13 K_COS</b>
PAR Wenn CED aus certificateContent größer als pointInTime ist (siehe (N019.900)j), dann MUSS pointInTime mit Transaktionsschutz auf den Wert CED gesetzt werden. <b>[<=]</b>

REQ(ids=A_16753)<b>A_16753 - (N095.900)b.14 K_COS</b>
PAR Die Schlüsselattribute MÜSSEN gemäß [gemSpec_PKI] aus certificateContent extrahiert und ein öffentliches Schlüsselobjekt pukObj gebildet werden. <b>[<=]</b>

REQ(ids=G2_N095.900.b.15.i)<b>G2_N095.900.b.15.i - (N095.900)b.15.i K_COS</b>
PAR Wenn das höchstwertige Bit von effectiveFlagList gesetzt ist, dann MUSS pukObj ein öffentliches Signaturprüfobjekt sein (siehe CosK_9bb). <b>[<=]</b>

REQ(ids=G2_N095.900.b.15.ii)<b>G2_N095.900.b.15.ii - (N095.900)b.15.ii K_COS</b>
PAR Wenn das höchstwertige Bit von effectiveFlagList nicht gesetzt ist, dann MUSS pukObj ein öffentliches Authentisierungsobjekt sein (siehe CosK_17c). <b>[<=]</b>

REQ(ids=A_16754)<b>A_16754 - (N095.900)b.16 K_COS</b>
PAR Die Attribute von pukObj MÜSSEN mit den Definitionen aus [gemSpec_PKI] wie folgt gesetzt werden: <b>[<=]</b>

REQ(ids=G2_N095.900.b.16.i.A)<b>G2_N095.900.b.16.i.A - (N095.900)b.16.i.A K_COS</b>
PAR Wenn das Wertfeld von DO'86' eine Länge von '41' =   65 hat,<br>dann gilt PuK.domainParameter = brainpoolP256r1. <b>[<=]</b>

REQ(ids=G2_N095.900.b.16.i.B)<b>G2_N095.900.b.16.i.B - (N095.900)b.16.i.B K_COS</b>
PAR Wenn das Wertfeld von DO'86' eine Länge von '61' =   97 hat,<br>dann gilt PuK.domainParameter = brainpoolP384r1. <b>[<=]</b>

REQ(ids=G2_N095.900.b.16.i.C)<b>G2_N095.900.b.16.i.C - (N095.900)b.16.i.C K_COS</b>
PAR Wenn das Wertfeld von DO'86' eine Länge von '81 '= 129 hat,<br>dann gilt PuK.domainParameter = brainpoolP512r1. <b>[<=]</b>

REQ(ids=G2_N095.900.b.16.ii)<b>G2_N095.900.b.16.ii - (N095.900)b.16.ii K_COS</b>
PAR PuK.P = OS2P( Wertfeld von DO'86', PuK.domainParameter ). <b>[<=]</b>

REQ(ids=G2_N095.900.b.16.iii)<b>G2_N095.900.b.16.iii - (N095.900)b.16.iii K_COS</b>
PAR pukObj.keyIdentifier = CHR gemäß [gemSpec_PKI#6.7.2.4]. <b>[<=]</b>

REQ(ids=G2_N095.900.b.16.iv)<b>G2_N095.900.b.16.iv - (N095.900)b.16.iv K_COS</b>
PAR pukObj.lifeCycleStatus = "Operational state (active)". <b>[<=]</b>

REQ(ids=A_16755)<b>A_16755 - (N095.900)b.16.v K_COS</b>
PAR pukObj.publicElcKey = PuK. <b>[<=]</b>

REQ(ids=G2_N095.900.b.16.vi)<b>G2_N095.900.b.16.vi - (N095.900)b.16.vi K_COS</b>
PAR pukObj.oid = OID<sub>PuK</sub>.    Hinweis CosH_00b: Anhand von pukObj.oid ist erkennbar, ob pukObj ein Signaturprüfobjekt oder ein Authentisierungsobjekt ist. <b>[<=]</b>

REQ(ids=A_16756)<b>A_16756 - (N095.900)b.16.vii K_COS</b>
PAR Wenn pukObj ein öffentliches Signaturprüfobjekt ist, dann MUSS gelten: <b>[<=]</b>

REQ(ids=G2_N095.900.b.16.vii.A)<b>G2_N095.900.b.16.vii.A - (N095.900)b.16.vii.A K_COS</b>
PAR pukObj.accessRules = affectedObject.accessRulesPublicSignatureVerificationObject. <b>[<=]</b>

REQ(ids=G2_N095.900.b.16.vii.B)<b>G2_N095.900.b.16.vii.B - (N095.900)b.16.vii.B K_COS</b>
PAR pukObj.accessRulesPublicSignatureVerificationObject = affectedObject.accessRulesPublicSignatureVerificationObject. <b>[<=]</b>

REQ(ids=G2_N095.900.b.16.vii.C)<b>G2_N095.900.b.16.vii.C - (N095.900)b.16.vii.C K_COS</b>
PAR pukObj.accessRulesPublicAuthenticationObject = affectedObject.accessRulesPublicAuthenticationObject. <b>[<=]</b>

REQ(ids=A_16757)<b>A_16757 - (N95.900)b.16.viii K_COS</b>
PAR Wenn pukObj ein öffentliches Authentisierungsobjekt ist, dann MUSS gelten:<br>pukObj.accessRules = affectedObject.accessRulesPublicAuthenticationObject. <b>[<=]</b>

REQ(ids=G2_N095.900.b.16.ix)<b>G2_N095.900.b.16.ix - (N095.900)b.16.ix K_COS</b>
PAR pukObj.CHAT.OID<sub>flags</sub> = affectedObject.CHAT.OID<sub>flags</sub>. <b>[<=]</b>

REQ(ids=G2_N095.900.b.16.x)<b>G2_N095.900.b.16.x - (N095.900)b.16.x K_COS</b>
PAR pukObj.CHAT.flagList = effectiveFlagList. <b>[<=]</b>

REQ(ids=G2_N095.900.b.16.xi)<b>G2_N095.900.b.16.xi - (N095.900)b.16.xi K_COS</b>
PAR pukObj.expirationDate = Wertfeld des Datenobjektes CXD. <b>[<=]</b>

REQ(ids=G2_N095.900.c)<b>G2_N095.900.c - (N095.900)c K_COS</b>
PAR Wenn affectedObject.keyIdentifier ungleich CAR aus dem imporiterten Zertifikat ist, genau dann MUSS das Kommando mit dem Trailer InconsistentKeyReference terminieren. <b>[<=]</b>

REQ(ids=A_16747)<b>A_16747 - (N095.900)d K_COS</b>
PAR Das Objekt pukObj MUSS wie folgt gespeichert werden: <b>[<=]</b>

REQ(ids=G2_N095.900.d.1)<b>G2_N095.900.d.1 - (N095.900)d.1 K_COS</b>
PAR persistent = StoreInCache("Ordner dem affectedObject zugeordnet ist", pukObj ). <b>[<=]</b>

REQ(ids=A_16748)<b>A_16748 - (N096.000) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_16749)<b>A_16749 - (N096.100) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N096.200)<b>G2_N096.200 - (N096.200) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16750)<b>A_16750 - (N096.300) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>a. Die Priorität der Trailer in CosT_527 ist herstellerspezifisch.<br>b. Jeder Trailer in CosT_527 MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>c. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.8.8)14.8.8 CosK_dbc PSO Verify Cryptographic Checksum
PAR Das Kommando PSO Verify Cryptographic Checksum überprüft mittels eines symmetrischen Schlüssels, ob eine gegebene kryptographische Checksumme zu gegebenen Daten passt. Der symmetrische Schlüssel wird im Rahmen einer gegenseitigen Authentisierung (siehe CosK_b47, CosK_580, CosK_2da und CosK_2ed) ausgehandelt. Checksumme und geschützte Daten sind als Parameter in der Kommandonachricht enthalten.
PAR -HEADING(ids=14.8.8.1)14.8.8.1 CosK_637 Use Case Prüfen einer kryptographischen Checksumme
PAR Diese Variante gilt für Algorithmen aus der folgenden Menge: {aesSessionkey, desSessionkey (Option_DES)}.
PAR In dieser Variante enthält die APDU des PSO Verify Cryptographic Checksum-Kommandos zwei Parameter:
REQ(ids=A_16758)<b>A_16758 - (N096.340) K_externeWelt {K_Karte}, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Der Parameter data MUSS die geschützten Daten enthalten. Der Parameter data ist ein Oktettstring mit beliebigem Inhalt. <b>[<=]</b>

REQ(ids=A_16759)<b>A_16759 - (N096.342) K_externeWelt {K_Karte}, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Der Parameter mac enthält eine kryptographische Checksumme. Der Parameter mac ist ein Oktettstring mit beliebigem Inhalt, dessen Länge acht Oktette betragen MUSS. <b>[<=]</b>

PAR Hinweis CosH_103: Falls mac eine andere Länge als acht Oktett besitzt, dann schlägt gemäß (N002.700)e und (N002.810)h der Vergleich in (N002.900)b bzw. (N003.010)b oder (N003.020)b stets fehl.
REQ(ids=A_16760)<b>A_16760 - (N096.344) K_externeWelt {K_Karte}, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Die Parameter data und mac MÜSSEN im Datenfeld der Kommandonachricht enthalten sein. Die Codierung wird in (N096.366)a spezifiziert. <b>[<=]</b>

REQ(ids=A_16761)<b>A_16761 - (N096.346) K_externeWelt {K_Karte}, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 oder eine Case 3E Kommando-APDU gemäß CosK_afd über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_674 verwendet werden.
PAR (ids=Tabelle-287,-CosT_674)Tabelle 287, CosT_674: PSO Verify Cryptographic Checksum, Prüfen MAC

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR Beschreibung der Antwortdaten, hier keine Antwortdaten
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'A2' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, hier Input Template für MAC
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR inputTemplate, DER codiertes Datenfeld
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.8.2)14.8.8.2 Antwort der Karte auf Prüfen einer kryptographischen Checksumme
PAR (ids=Tabelle-288,-CosT_5e2)Tabelle 288, CosT_5e2: PSO Verify Cryptographic Checksum Antwort-APDU im Erfolgsfall

TABLE(rows=2,cols=63+183+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '90 00' TD(1,1/1/1)->PAR NoError TD(1,2/1/1)->PAR erfolgreiche Verifizierung eines MAC
PAR (ids=Tabelle-289,-CosT_804)Tabelle 289, CosT_804: PSO Verify Cryptographic Checksum Antwort-APDU im Fehlerfall

TABLE(rows=6,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '69 82' TD(1,1/1/1)->PAR SecurityStatusNotSatisfied TD(1,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(2,0/1/1)->PAR '69 85' TD(2,1/1/1)->PAR NoKeyReference TD(2,2/1/1)->PAR kein Schlüssel für MAC-Berechnung ausgewählt
TR-> TD(3,0/1/1)->PAR '6A 80' TD(3,1/1/1)->PAR VerificationError TD(3,2/1/1)->PAR MAC-Prüfung fehlgeschlagen
TR-> TD(4,0/1/1)->PAR '6A 81' TD(4,1/1/1)->PAR UnsupportedFunction TD(4,2/1/1)->PAR Schlüssel unterstützt den angegeben Algorithmus nicht
TR-> TD(5,0/1/1)->PAR '6A 88' TD(5,1/1/1)->PAR KeyNotFound TD(5,2/1/1)->PAR kein Schlüssel für MAC-Berechnung vorhanden
PAR Hinweis CosH_6a5: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16762)<b>A_16762 - (N096.350) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando PSO Verify Cryptographic verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.8.8.3)14.8.8.3 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N096.360.a)<b>G2_N096.360.a - (N096.360)a K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Das COS MUSS die PSO Verify Cryptographic Checksum-Variante aus (N096.346) unterstützen. <b>[<=]</b>

REQ(ids=A_16763)<b>A_16763 - (N096.360)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere PSO Verify Cryptographic Checksum-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N096.362.a)<b>G2_N096.362.a - (N096.362)a K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn channelContext.keyReferenceList.macCalculation leer ist, genau dann MUSS das Kommando mit dem Trailer NoKeyReference terminieren. <b>[<=]</b>

REQ(ids=A_16764)<b>A_16764 - (N096.362)b K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn channelContext.keyReferenceList.macCalculation nicht leer ist, dann wird<br>affectedObject = SearchKey(<br>    currentFolder,<br>    keyReferenceList.macCalculation.keyReference,<br>    keyReferenceList.macCalculation.algID<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. <b>[<=]</b>

REQ(ids=G2_N096.362.b.1)<b>G2_N096.362.b.1 - (N096.362)b.1 K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N096.362.b.2)<b>G2_N096.362.b.2 - (N096.362).b.2 K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn die Schlüsselsuche den Fehler notSupported meldet, genau dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N096.364)<b>G2_N096.364 - (N096.364) K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=A_16765)<b>A_16765 - (N096.366)a K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Es gilt: inputTemplate == '80 – L<sub>80</sub> – data   ||   8E – L<sub>8E </sub>– mac '. <b>[<=]</b>

PAR Mit den Attributen SSCmac und Kmac aus dem Attribut SessionkeyContext sowie algID = keyReferenceList.macCalculation.algID gilt:
REQ(ids=G2_N096.368.a)<b>G2_N096.368.a - (N096.368)a K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Falls algID den Wert aesSessionkey besitzt, gilt:<br>1. SSCmac = SSCmac + 1.<br>2. result     = VerifyCMAC_IsoPadding( Kmac, mac, I2OS( SSCmac, 16) || data ). <b>[<=]</b>

PAR (N096.368)b ist absichtlich leer.
REQ(ids=G2_N096.368.b)<b>G2_N096.368.b - (N096.368)b K_COS, (Option_Kryptobox oder Option_PACE_PCD) und Option_DES</b>
PAR Falls algID den Wert desSessionkey besitzt, gilt:<br>1. SSCmac = SSCmac + 1.<br>2. result     = VERIFY_Retail_MAC( Kmac, mac, I2OS( SSCmac, 8) || data ). <b>[<=]</b>

REQ(ids=G2_N096.370.a)<b>G2_N096.370.a - (N096.370.)a K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn result den Wert INVALID besitzt, dann<br>1. MUSS als Trailer VerificationError verwendet werden und<br>2. die Sessionkeys MÜSSEN mittels clearSessionkeys( ) gelöscht werden. <b>[<=]</b>

REQ(ids=G2_N096.370.b)<b>G2_N096.370.b - (N096.370)b K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Wenn result den Wert VALID besitzt, genau dann MUSS als Trailer NoError verwendet werden. <b>[<=]</b>

REQ(ids=A_16766)<b>A_16766 - (N096.372)a K_TST</b>
PAR Die Priorität der Trailer in CosT_804 MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N096.372.b)<b>G2_N096.372.b - (N096.372.b K_COS, Option_Kryptobox oder Option_PACE_PCD</b>
PAR Jeder Trailer in CosT_804 MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.8.9)14.8.9 CosK_3e9 PSO Verify Digital Signature
PAR Das Kommando PSO Verify Digital Signature überprüft eine Signatur mittels eines öffentlichen Schlüssels. Sowohl die Signatur, als auch der öffentliche Schlüssel und der zur Prüfung zu verwendende Algorithmus sind als Parameter in der Kommanodnachricht enthalten.
PAR -HEADING(ids=14.8.9.1)14.8.9.1 CosK_4db Use Case Prüfen einer ELC-Signatur
PAR Diese Variante prüft Signaturen, die mittels signECDSA erstellt wurden. Als Domainparameter sind alle Kurven zulässig, die vom COS unterstützt werden (siehe (N002.500)).
PAR In dieser Variante enthält die APDU des PSO Verify Digital Signature vier Parameter:
REQ(ids=A_16767)<b>A_16767 - (N096.380) K_externeWelt {K_Karte}</b>
PAR Der Parameter oid enthält einen Objektidentifier, der die zu verwendende elliptische Kurve referenziert. Der Parameter oid MUSS aus der in CosT_a91 genannten Menge gewählt werden und eine elliptische Kurve aus der Menge in (N002.500) referenzieren. <b>[<=]</b>

REQ(ids=A_16768)<b>A_16768 - (N096.381) K_externeWelt {K_Karte}</b>
PAR Der Parameter PO<sub>B</sub> enthält einen Punkt auf einer elliptischen Kurve. Dieser Punkt repräsentiert den öffentlichen Schlüssel des Signierenden. Der Parameter PO<sub>B</sub> ist ein Oktettstring, dessen Inhalt so gewählt werden SOLL, dass bei der Decodierung kein Fehler auftritt (siehe (N096.396)a und (N000.300)(N004.500)a). <b>[<=]</b>

REQ(ids=A_16769)<b>A_16769 - (N096.382) K_externeWelt {K_Karte}</b>
PAR Der Parameter hash enthält den im Rahmen der Signaturerstellung erzeugten Hashwert. Der Parameter hash ist ein Oktettstring mit beliebigem Inhalt. Für den Zusammenhang zwischen oid und der Länge von hash MUSS gelten:<br>a. ansix9p256r1        =>   OctetLength( hash ) gleich 32.<br>b. ansix9p384r1        =>   OctetLength( hash ) gleich 48.<br>c. brainpoolP256r1    =>   OctetLength( hash ) gleich 32.<br>d. brainpoolP384r1    =>   OctetLength( hash ) gleich 48.<br>e. brainpoolP512r1    =>   OctetLength( hash ) gleich 64. <b>[<=]</b>

REQ(ids=A_16770)<b>A_16770 - (N096.383) K_externeWelt {K_Karte}</b>
PAR Der Parameter signature enthält die zu prüfende Signatur. Der Parameter signature ist ein Oktettstring mit beliebigem Inhalt. Für den Zusammenhang zwischen oid und der Länge von signature MUSS gelten:<br>a. ansix9p256r1        =>   OctetLength( signature ) gleich   64.<br>b. ansix9p384r1        =>   OctetLength( signature ) gleich   96.<br>c. brainpoolP256r1    =>   OctetLength( signature ) gleich   64.<br>d. brainpoolP384r1    =>   OctetLength( signature ) gleich   96.<br>e. brainpoolP512r1    =>   OctetLength( signature ) gleich 128. <b>[<=]</b>

REQ(ids=A_16771)<b>A_16771 - (N096.386) K_externeWelt {K_Karte}</b>
PAR Die Parameter oid, PO<sub>B</sub>, hash und signature MÜSSEN im Datenfeld der Kommandonachricht enthalten sein. Die Codierung wird in (N096.394) spezifiziert. <b>[<=]</b>

REQ(ids=A_16772)<b>A_16772 - (N096.388) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_f4d verwendet werden.
PAR (ids=Tabelle-290,-CosT_f4d)Tabelle 290, CosT_f4d: PSO Verify Digital Signature mittels übergebenem ELC-Schlüssel

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '2A' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR Keine Antwortdaten
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'A8' TD(4,2/1/1)->PAR Beschreibung der Kommandodaten, Template einer digitalen Signatur
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR signatureTemplate, DER codiertes Datenfeld
PAR <b>[<=]</b>

PAR -HEADING(ids=14.8.9.2)14.8.9.2 Antwort der Karte auf Prüfen einer digitalen Signatur
PAR (ids=Tabelle-291,-CosT_c29)Tabelle 291, CosT_c29: PSO Verify Digital Signature Antwort-APDU im Erfolgsfall

TABLE(rows=2,cols=63+183+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '90 00' TD(1,1/1/1)->PAR NoError TD(1,2/1/1)->PAR erfolgreiche Verifizierung einer Signatur
PAR (ids=Tabelle-292,-CosT_3f2)Tabelle 292, CosT_3f2: PSO Verify Digital Signature Antwort-APDU im Fehlerfall

TABLE(rows=2,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '6A 80' TD(1,1/1/1)->PAR VerificationError TD(1,2/1/1)->PAR Signaturprüfung fehlgeschlagen
PAR Hinweis CosH_67f: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16773)<b>A_16773 - (N096.390) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando PSO Verify Digital Signature verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.8.9.3)14.8.9.3 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N096.392.a)<b>G2_N096.392.a - (N096.392)a K_COS</b>
PAR Das COS MUSS die PSO Verify Digital Signature-Variante aus (N096.388) unterstützen. <b>[<=]</b>

REQ(ids=A_16774)<b>A_16774 - (N096.392)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere PSO Verify Digital Signature-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16775)<b>A_16775 - (N096.394) K_COS</b>
PAR Mit den Festlegungen aus [ISO/IEC 7816-8#Table 6] MUSS gelten:<br>a. signatureTemplate == '(06 – L<sub>06 </sub>– oid ) || (90 – L<sub>90</sub> – hash ) || (9C – L<sub>9C </sub>– publicKey ) || (9E – L<sub>9E</sub> – signature )'.<br>b. publicKey            == '7F49 – L<sub>7F49</sub> – (86 – L<sub>86 </sub>– PO<sub>B</sub> )'.<br>c. signature wird wie folgt auf R und S aufgeteilt:<br>    1. signature == R   ||   S.<br>    2. OctetLength( R ) == OctetLength( S ).<br>d. Die oid wird gemäß CosT_a91 in Domainparameter übersetzt, die im Folgenden mit dP bezeichnet werden. <b>[<=]</b>

REQ(ids=G2_N096.396.a)<b>G2_N096.396.a - (N096.396)a K_COS</b>
PAR Falls ELC_VER_SIG( OS2P( PO<sub>B</sub>, dP), R, S, hash ) den Wert False besitzt, genau dann MUSS als Trailer VerificationError verwendet werden. <b>[<=]</b>

REQ(ids=G2_N096.396.b)<b>G2_N096.396.b - (N096.396)b K_COS</b>
PAR Falls ELC_VER_SIG( OS2P( PO<sub>B</sub>, dP), R, S, hash ) den Wert True besitzt, genau dann MUSS als Trailer NoError verwendet werden. <b>[<=]</b>

REQ(ids=A_16776)<b>A_16776 - (N096.398)a K_TST</b>
PAR Die Priorität der Trailer in CosT_3f2 MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N096.398.b)<b>G2_N096.398.b - (N096.398)b K_COS</b>
PAR Jeder Trailer in CosT_3f2 MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.9)14.9 Verschiedenes
PAR -HEADING(ids=14.9.1)14.9.1 CosK_1e9 ENVELOPE
REQ(ids=A_16777)<b>A_16777 - (N096.400) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das ENVELOPE-Kommando gemäß [ISO/IEC 7816-4] würde<br>a. unterstützt oder<br>b. abgelehnt. <b>[<=]</b>

PAR -HEADING(ids=14.9.2)14.9.2 CosK_6b0 FINGERPRINT
PAR Das Kommando FINGERPRINT dient der Überprüfung der Integrität und Authentizität des COS. Dazu wird im Kommando ein Präfix übergeben. Über das Präfix und das COS wird ein Fingerprint berechnet. Stimmen berechneter Fingerprint und der Fingerprint eines authentischen COS überein, so ist die Authentizität des COS nachgewiesen.
PAR Hinweis CosH_2f6: Typischerweise werden für Tests im Rahmen einer funktionalen Zulassung und im Rahmen einer Sicherheitsevaluierung verschiedene Images erzeugt. Zudem werden typischerweise im Rahmen einer Fehlerbeseitigung Patches entwickelt. Mit Hilfe dieses Kommandos lässt sich der Nachweis führen, dass in sämtlichen Images, die für ein Zulassungsverfahren relevant sind, derselbe Softwarestand (im Allgemeinen ROM Code plus Patches) zu Grunde liegt.
PAR -HEADING(ids=14.9.2.1)14.9.2.1 CosK_d38 Use Case Berechnen eines COS-Fingerprints
PAR In dieser Variante enthält die APDU des FINGERPRINT-Kommandos zwei Parameter:
REQ(ids=A_16778)<b>A_16778 - (N096.450) K_externeWelt {K_Karte}</b>
PAR Der Parameter prefix enthält den Präfix. Der Parameter prefix ist ein Oktettstring mit beliebigem Inhalt. Die Länge von prefix MUSS 128 Oktett betragen. <b>[<=]</b>

REQ(ids=A_16779)<b>A_16779 - (N096.452) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS WildCardShort sein. <b>[<=]</b>

REQ(ids=A_16780)<b>A_16780 - (N096.454) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 4S Kommando-APDU gemäß CosK_876 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 4 Kommando-APDU MÜSSEN die Angaben aus CosT_b85 verwendet werden.
PAR (ids=Tabelle-293,-CosT_b85)Tabelle 293, CosT_b85: FINGERPRINT über das COS

TABLE(rows=7,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '80' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4] wird hier "proprietary" angezeigt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'FA' TD(2,2/1/1)->PAR Instruction Byte
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR -
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR –
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR prefix
TR-> TD(6,0/1/1)->PAR Le TD(6,1/1/1)->PAR '00' TD(6,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.2.2)14.9.2.2 Antwort der Karte auf Berechnen eines COS-Fingerprints
PAR (ids=Tabelle-294,-CosT_bee)Tabelle 294, CosT_bee: FINGERPRINT Antwort-APDU im Erfolgsfall

TABLE(rows=3,cols=63+183+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)->PAR fingerprint TD(1,2/1/1)->PAR Fingerprint des COS zum gegebenen Präfix
TR-> TD(2,0/1/1)->PAR '90 00' TD(2,1/1/1)->PAR NoError TD(2,2/1/1)->PAR Erfolgreiche Fingerprintberechnung
PAR (ids=Tabelle-295,-CosT_105)Tabelle 295, CosT_105: FINGERPRINT Antwort-APDU im Fehlerfall

TABLE(rows=2,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '69 82' TD(1,1/1/1)->PAR SecurityStatusNotSatisfied TD(1,2/1/1)->PAR Zugriffsregel nicht erfüllt
PAR Hinweis CosH_252: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16781)<b>A_16781 - (N096.469) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando FINGERPRINT verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.9.2.3)14.9.2.3 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N096.470.a)<b>G2_N096.470.a - (N096.470)a K_COS</b>
PAR Das COS MUSS die FINGERPRINT-Variante aus (N096.454) unterstützen. <b>[<=]</b>

REQ(ids=A_16782)<b>A_16782 - (N096.470)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere FINGERPRINT-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N096.472)<b>G2_N096.472 - (N096.472) K_COS</b>
PAR Als affectedObject MUSS currentFolder verwendet werden. <b>[<=]</b>

REQ(ids=G2_N096.474)<b>G2_N096.474 - (N096.474) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N096.476)<b>G2_N096.476 - (N096.476) K_COS</b>
PAR Berechnung des Repräsentanten M des COS:<br>a. Das COS MUSS einen Oktettstring M konstruieren, der sämtliche Bestandteile des COS beinhaltet.<br>b. Die Funktion, die das COS auf M abbildet ist herstellerspezifisch und<br>    1. MUSS zeitinvariant sein,<br>    2. MUSS reproduzierbar sein und<br>    3. DARF NICHT abhängig sein von Veränderungen am Objektsystem, die mit Kommandos möglich sind, die im Rahmen dieser Spezifikation möglich und gemäß Objektsystemspezifikation erlaubt sind. <b>[<=]</b>

REQ(ids=G2_N096.478)<b>G2_N096.478 - (N096.478) K_COS</b>
PAR Basierend auf dem Parameter prefix aus den Kommandodaten und M MUSS das Datenfeld fingerprint der Antwortnachricht mit einem der folgenden Verfahren berechnet werden:<br>a. fingerprint = SHA_256( prefix || M ) gesetzt werden.<br>b. fingerprint = SHA_384( prefix || M ) gesetzt werden.<br>c. fingerprint = SHA_512( prefix || M ) gesetzt werden.<br>d. fingerprint = CalculateCMAC_IsoPadding( key, prefix || M ) gesetzt werden,<br>    wobei key ein herstellerspezifischer Schlüssel ist. <b>[<=]</b>

REQ(ids=G2_N096.480)<b>G2_N096.480 - (N096.480) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=G2_N096.482)<b>G2_N096.482 - (N096.482) K_COS</b>
PAR Das Datenfeld der Antwortnachricht MUSS fingerprint sein. <b>[<=]</b>

PAR -HEADING(ids=14.9.3)14.9.3 CosK_d2f GENERATE ASYMMETRIC KEY PAIR
PAR Das Kommando GENERATE ASYMMETRIC KEY PAIR (GAKP) dient dem Erzeugen von asymmetrischen Schlüsselpaaren und dem Auslesen eines dabei erzeugten öffentlichen Schlüssels. Es ist möglich das betroffen Schlüsselobjekt zuvor auszuwählen. Dies geschieht durch ein MSE-Set-Kommando (siehe (N102.900)). Zusätzlich ist es möglich, den zu generierenden Schlüssel im Kommando zu referenzieren.
PAR -HEADING(ids=14.9.3.1)14.9.3.1 CosK_fbb Use Case Generieren, ohne Überschreiben, ohne Referenz, ohne Ausgabe
PAR In dieser Variante wird das betroffene Schlüsselobjekt durch ein MSE-Set-Kommando ausgewählt und mit Schlüsseldaten befüllt, falls diese fehlen. Falls bereits Schlüsseldaten vorhanden sind, bleiben diese erhalten. Die APDU des GAKP-Kommandos enthält hier einen Parameter:
REQ(ids=A_16783)<b>A_16783 - (N096.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = '84' gewählt werden. <b>[<=]</b>

REQ(ids=A_16784)<b>A_16784 - (N096.600) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_d52 verwendet werden.
PAR (ids=Tabelle-296,-CosT_d52)Tabelle 296, CosT_d52: GAKP, ohne Überschreiben, ohne Referenz, ohne Ausgabe

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '46' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '84' TD(3,2/1/1)->PAR operationMode = Schlüsselgenerierung, falls kein Schlüssel vorhanden
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR betroffenes Objekt via channelContext.keyReferenceList
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.3.2)14.9.3.2 CosK_f65 Use Case Generieren, ohne Überschreiben, mit Referenz, ohne Ausgabe
PAR In dieser Variante wird das betroffene Schlüsselobjekt durch den Parameter P2 ausgewählt und mit Schlüsseldaten befüllt, falls diese fehlen. Falls bereits Schlüsseldaten vorhanden sind, bleiben diese erhalten. Die APDU des GAKP-Kommandos enthält hier zwei Parameter:
REQ(ids=A_16785)<b>A_16785 - (N096.640) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = '84' gewählt werden. <b>[<=]</b>

REQ(ids=A_16786)<b>A_16786 - (N096.642) K_externeWelt {K_Karte}</b>
PAR Der Parameter keyReference referenziert das von der Aktion betroffene Schlüsselobjekt und MUSS gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=A_16787)<b>A_16787 - (N096.644) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_39e verwendet werden.
PAR (ids=Tabelle-297,-CosT_39e)Tabelle 297, CosT_39e: GAKP, ohne Überschreiben, mit Schlüsselreferenz, ohne Ausgabe

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '46' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '84' TD(3,2/1/1)->PAR operationMode = Schlüsselgenerierung, falls kein Schlüssel vorhanden
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR keyReference bestimmt betroffenes Schlüsselobjekt
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.3.3)14.9.3.3 CosK_aeb Use Case Generieren, ggf. Überschreiben, ohne Referenz, ohne Ausgabe
PAR In dieser Variante wird das betroffene Schlüsselobjekt durch ein MSE-Set-Kommando ausgewählt und mit Schlüsseldaten befüllt. Falls bereits Schlüsseldaten vorhanden sind, dann werden diese überschrieben. Die APDU des GAKP-Kommandos enthält hier einen Parameter:
REQ(ids=A_16788)<b>A_16788 - (N096.650) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = 'C4' gewählt werden. <b>[<=]</b>

REQ(ids=A_16789)<b>A_16789 - (N096.652) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_8ee verwendet werden.
PAR (ids=Tabelle-298,-CosT_8ee)Tabelle 298, CosT_8ee: GAKP, ggf. Überschreiben, ohne Referenz, ohne Ausgabe

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '46' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'C4' TD(3,2/1/1)->PAR operationMode = Schlüsselgenerierung, ggf. Überschreiben
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR betroffenes Objekt via channelContext.keyReferenceList
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.3.4)14.9.3.4 CosK_3f4 Use Case Generieren, ggf. Überschreiben, mit Referenz, ohne Ausgabe
PAR In dieser Variante wird das betroffene Schlüsselobjekt durch den Parameter P2 ausgewählt und mit Schlüsseldaten befüllt. Falls bereits Schlüsseldaten vorhanden sind, dann werden diese überschrieben. Die APDU des GAKP-Kommandos enthält hier zwei Parameter:
REQ(ids=A_16790)<b>A_16790 - (N096.660) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = 'C4' gewählt werden. <b>[<=]</b>

REQ(ids=A_16791)<b>A_16791 - (N096.662) K_externeWelt {K_Karte}</b>
PAR Der Parameter keyReference referenziert das von der Aktion betroffene Schlüsselobjekt und MUSS gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=A_16792)<b>A_16792 - (N096.664) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_e3e verwendet werden.
PAR (ids=Tabelle-299,-CosT_e3e)Tabelle 299, CosT_e3e: GAKP, ggf. Überschreiben, mit Schlüsselreferenz, ohne Ausgabe

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '46' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'C4' TD(3,2/1/1)->PAR operationMode = Schlüsselgenerierung, ggf. Überschreiben
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR keyReference bestimmt betroffenes Schlüsselobjekt
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.3.5)14.9.3.5 CosK_d72 Use Case Auslesen vorhandener Schlüssel, ohne Referenz
PAR In dieser Variante wird das betroffene Schlüsselobjekt durch ein MSE-Set-Kommando ausgewählt. Die dort vorhandenen Schlüsseldaten werden ausgelesen. Die APDU des GAKP-Kommandos enthält hier zwei Parameter:
REQ(ids=A_16793)<b>A_16793 - (N096.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = '81' gewählt werden. <b>[<=]</b>

REQ(ids=A_16794)<b>A_16794 - (N096.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS so aus der Menge {WildCardShort, WildCardExtended} gewählt werden, dass der komplette Oktettstring publicKeyDO (siehe (N098.200){a, b}) in der Antwortnachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_16795)<b>A_16795 - (N096.900) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d oder eine Case 2E Kommando-APDU gemäß CosK_f88 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_36f verwendet werden.
PAR (ids=Tabelle-300, CosT_36f)Tabelle 300, CosT_36f: GAKP, Auslesen vorhandener Schlüssel ohne Schlüsselreferenz

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '46' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '81' TD(3,2/1/1)->PAR operationMode = Auslesen eines öffentlichen Schlüssels
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR betroffenes Objekt via channelContext.keyReferenceList
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR length TD(5,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.3.6)14.9.3.6 CosK_c5c Use Case Auslesen vorhandener Schlüssel, mit Referenz
PAR In dieser Variante wird das betroffene Schlüsselobjekt durch den Parameter P2 ausgewählt. Die dort vorhandenen Schlüsseldaten werden ausgelesen. Die APDU des GAKP-Kommandos enthält hier drei Parameter:
REQ(ids=A_16796)<b>A_16796 - (N096.940) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = '81' gewählt werden. <b>[<=]</b>

REQ(ids=A_16797)<b>A_16797 - (N096.942) K_externeWelt {K_Karte}</b>
PAR Der Parameter keyReference referenziert das von der Aktion betroffene Schlüsselobjekt und MUSS gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=A_16798)<b>A_16798 - (N096.944) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS so aus der Menge {WildCardShort, WildCardExtended} gewählt werden, dass der komplette Oktettstring publicKeyDO (siehe (N098.200){a, b}) in der Antwortnachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_16799)<b>A_16799 - (N096.946) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d oder eine Case 2E Kommando-APDU gemäß CosK_f88 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando–APDU MÜSSEN die Angaben aus CosT_f6d verwendet werden.
PAR (ids=Tabelle-301,-CosT_f6d)Tabelle 301, CosT_f6d: GAKP, Auslesen vorhandener Schlüssel mit Schlüsselreferenz

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '46' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '81' TD(3,2/1/1)->PAR operationMode = Auslesen eines öffentlichen Schlüssels
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR keyReference bestimmt betroffenes Schlüsselobjekt
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR length TD(5,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.3.7)14.9.3.7 CosK_540 Use Case Generieren, ohne Überschreiben, ohne Referenz, mit Ausgabe
PAR In dieser Variante wird das betroffene Schlüsselobjekt durch ein MSE-Set-Kommando ausgewählt, mit Schlüsseldaten befüllt und die der erzeugte öffentliche Schlüssel wird exportiert. Falls bereits Schlüsseldaten vorhanden sind, bleiben diese erhalten. Die APDU des GAKP-Kommandos enthält hier zwei Parameter:
REQ(ids=A_16800)<b>A_16800 - (N097.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = '80' gewählt werden. <b>[<=]</b>

REQ(ids=A_16801)<b>A_16801 - (N097.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS so aus der Menge {WildCardShort, WildCardExtended} gewählt werden, dass der komplette Oktettstring publicKeyDO (siehe (N098.200){a, b}) in der Antwortnachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_16802)<b>A_16802 - (N097.200) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d oder eine Case 2E Kommando-APDU gemäß CosK_f88 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_fb7 verwendet werden.
PAR (ids=Tabelle-302,-CosT_fb7)Tabelle 302, CosT_fb7: GAKP, ohne Überschreiben, ohne Schlüsselreferenz, mit Ausgabe

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '46' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '80' TD(3,2/1/1)->PAR operationMode = Schlüsselgenerierung falls nicht vorhanden, Ausgabe
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR betroffenes Objekt via channelContext.keyReferenceList
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR length TD(5,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.3.8)14.9.3.8 CosK_900 Use Case Generieren, ohne Überschreiben, mit Referenz, mit Ausgabe
PAR In dieser Variante wird das betroffene Schlüsselobjekt durch den Parameter P2 ausgewählt, mit Schlüsseldaten befüllt und der öffentliche Teil des erzeugten Schlüsselpaares wird exportiert. Falls bereits Schlüsseldaten vorhanden sind, bleiben diese erhalten. Die APDU des GAKP-Kommandos enthält hier drei Parameter:
PAR In dieser Variante enthält die APDU des GAKP-Kommandos drei Parameter:
REQ(ids=A_16803)<b>A_16803 - (N097.240) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = '80' gewählt werden. <b>[<=]</b>

REQ(ids=A_16804)<b>A_16804 - (N097.242) K_externeWelt {K_Karte}</b>
PAR Der Parameter keyReference referenziert das von der Aktion betroffene Schlüsselobjekt und MUSS gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=A_16805)<b>A_16805 - (N097.244) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS so aus der Menge {WildCardShort, WildCardExtended} gewählt werden, dass der komplette Oktettstring publicKeyDO (siehe (N098.200){a, b}) in der Antwortnachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_16806)<b>A_16806 - (N097.246) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d oder eine Case 2E Kommando-APDU gemäß CosK_f88 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_c33 verwendet werden.
PAR (ids=Tabelle-303,-CosT_c33)Tabelle 303, CosT_c33: GAKP, ohne Überschreiben, mit Schlüsselreferenz, mit Ausgabe

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '46' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '80' TD(3,2/1/1)->PAR operationMode = Schlüsselgenerierung falls nicht vorhanden, Ausgabe
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR keyReference bestimmt betroffenes Schlüsselobjekt
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR length TD(5,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.3.9)14.9.3.9 CosK_8f4 Use Case Generieren, ggf. Überschreiben, ohne Referenz, mit Ausgabe
PAR In dieser Variante wird das betroffene Schlüsselobjekt durch ein MSE-Set-Kommando ausgewählt und mit Schlüsseldaten befüllt. Falls bereits Schlüsseldaten vorhanden sind, dann werden diese überschrieben. Der erzeugte öffentliche Schlüssel wird exportiert. Die APDU des GAKP-Kommandos enthält hier zwei Parameter:
REQ(ids=A_16807)<b>A_16807 - (N097.250) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = 'C0' gewählt werden. <b>[<=]</b>

REQ(ids=A_16808)<b>A_16808 - (N097.252) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS so aus der Menge {WildCardShort, WildCardExtended} gewählt werden, dass der komplette Oktettstring publicKeyDO (siehe (N098.200){a, b}) in der Antwortnachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_16809)<b>A_16809 - (N097.254) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d oder eine Case 2E Kommando-APDU gemäß CosK_f88 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_5d8 verwendet werden.
PAR (ids=Tabelle-304,-CosT_5d8)Tabelle 304, CosT_5d8: GAKP, ggf. Überschreiben, ohne Schlüsselreferenz, mit Ausgabe

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '46' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'C0' TD(3,2/1/1)->PAR operationMode = Schlüsselgenerierung, ggf. Überschreiben, Ausgabe
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR betroffenes Objekt via channelContext.keyReferenceList
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR length TD(5,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.3.10)14.9.3.10 CosK_c05 Use Case Generieren, ggf. Überschreiben, mit Referenz, mit Ausgabe
PAR In dieser Variante wird das betroffene Schlüsselobjekt durch den Parameter P2 ausgewählt und mit Schlüsseldaten befüllt. Falls bereits Schlüsseldaten vorhanden sind, dann werden diese überschrieben. Der erzeugte öffentliche Schlüssel wird exportiert. Die APDU des GAKP-Kommandos enthält hier drei Parameter:
REQ(ids=A_16810)<b>A_16810 - (N097.260) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = 'C0' gewählt werden. <b>[<=]</b>

REQ(ids=A_16811)<b>A_16811 - (N097.262) K_externeWelt {K_Karte}</b>
PAR Der Parameter keyReference referenziert das von der Aktion betroffene Schlüsselobjekt und MUSS gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=A_16812)<b>A_16812 - (N097.264) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS so aus der Menge {WildCardShort, WildCardExtended} gewählt werden, dass der komplette Oktettstring publicKeyDO (siehe (N098.200){a, b}) in der Antwortnachricht enthalten ist. <b>[<=]</b>

REQ(ids=A_16813)<b>A_16813 - (N097.266) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d oder eine Case 2E Kommando-APDU gemäß CosK_f88 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_cd2 verwendet werden.
PAR (ids=Tabelle-305,-CosT_cd2)Tabelle 305, CosT_cd2: GAKP, ggf. Überschreiben, mit Schlüsselreferenz, mit Ausgabe

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '46' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'C0' TD(3,2/1/1)->PAR operationMode = Schlüsselgenerierung, ggf. Überschreiben, Ausgabe
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR keyReference bestimmt betroffenes Schlüsselobjekt
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR length TD(5,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.3.11)14.9.3.11 Zusammenfassung der GENERATE ASYMMETRIC KEY PAIR-Kommando-Varianten
PAR Wegen der Vielzahl an Varianten für dieses Kommando werden hier alle auf einen Blick dargestellt. Es sei darauf hingewiesen, dass nicht alle Kombinationen der folgenden Tabelle in den vorangegangenen Kapiteln enthalten sind. Welche der möglichen Kombinationen zu unterstützen sind wird in (N097.400) festgelegt.
PAR (ids=Tabelle-306,-CosT_246)Tabelle 306, CosT_246: GENERATE ASYMMETRIC KEY PAIR, Kommandoparameter im Überblick

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '46' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '81'<br>'80'<br>'84'<br>'C0'<br>'C4' TD(3,2/1/1)->PAR keine Schlüsselgenerierung, nur Ausgabe<br>Schlüsselgenerierung, falls kein Schlüssel vorhanden und Ausgabe<br>Schlüsselgenerierung, falls kein Schlüssel vorhanden, keine Ausgabe<br>Schlüsselgenerierung, ggf. Überschreiben und Ausgabe<br>Schlüsselgenerierung, ggf. Überschreiben, keine Ausgabe
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00'<br>sonst TD(4,2/1/1)->PAR betroffenes Objekt via channelContext.keyReferenceList<br>keyReference bestimmt betroffenes Schlüsselobjekt
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR length TD(5,2/1/1)->PAR Bit b3 von P1 == 0: Anzahl der erwarteten Oktette in den Antwortdaten<br>Bit b3 von P1 == 1: abwesend
PAR -HEADING(ids=14.9.3.12)14.9.3.12 Antwort der Karte auf Generieren oder Auslesen eines asym. Schlüssels
PAR (ids=Tabelle-307,-CosT_a45)Tabelle 307, CosT_a45: GENERATE ASYMMETRIC KEY PAIR Antwort-APDU im Erfolgsfall

TABLE(rows=5,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)->PAR publicKeyDO TD(1,2/1/1)->PAR Abwesend oder öffentlicher Schlüssel
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '63 Cx' TD(3,1/1/1)->PAR UpdateRetryWarning TD(3,2/1/1)->PAR Wie NoError, aber Schreibschwierigkeiten
TR-> TD(4,0/1/1)->PAR '90 00' TD(4,1/1/1)->PAR NoError TD(4,2/1/1)->PAR Erfolgreiche Operation
PAR (ids=Tabelle-308,-CosT_6d3)Tabelle 308, CosT_6d3: GENERATE ASYMMETRIC KEY PAIR Antwort-APDU im Fehlerfall

TABLE(rows=6,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '64 00' TD(1,1/1/1)->PAR KeyInvalid TD(1,2/1/1)->PAR Auszulesende Schlüsseldaten fehlen
TR-> TD(2,0/1/1)->PAR '65 81' TD(2,1/1/1)->PAR MemoryFailure TD(2,2/1/1)->PAR Schreibvorgang nicht erfolgreich
TR-> TD(3,0/1/1)->PAR '69 82' TD(3,1/1/1)->PAR SecurityStatusNotSatisfied TD(3,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(4,0/1/1)->PAR '69 85' TD(4,1/1/1)->PAR KeyAlreadyPresent TD(4,2/1/1)->PAR Schlüsseldaten bereits gesetzt, Generierung unmöglich
TR-> TD(5,0/1/1)->PAR '6A 88' TD(5,1/1/1)->PAR KeyNotFound TD(5,2/1/1)->PAR Referenziertes Schlüsselobjekt wurde nicht gefunden
PAR Hinweis CosH_c72: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16814)<b>A_16814 - (N097.300) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando GENERATE ASYMMETRIC KEY PAIR verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.9.3.13)14.9.3.13 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N097.400.a)<b>G2_N097.400.a - G2_097.400.a</b>
PAR TODO gematik-Testabteilung, siehe Kommentar.<br>AFO-ID aus ReqPro: AFO1819 <b>[<=]</b>

REQ(ids=A_16815)<b>A_16815 - (N097.400)a.1 K_COS</b>
PAR Das COS MUSS für private ELC-Schlüssel die GENERATE ASYMMETRIC KEY PAIR-Varianten aus (N096.600), (N096.644), (N096.652), (N096.664), (N096.900), (N096.946), (N097.200), (N097.246), (N097.254) und (N097.226) unterstützen. <b>[<=]</b>

REQ(ids=A_16816)<b>A_16816 - (N097.400)a.2 K_COS</b>
PAR Das COS MUSS für private RSA-Schlüssel die GENERATE ASYMMETRIC KEY PAIR-Varianten aus (N096.900) und (N096.946) unterstützen. <b>[<=]</b>

REQ(ids=A_16817)<b>A_16817 - (N097.400)a.3 K_COS, Option_RSA_KeyGeneration</b>
PAR Das COS MUSS für private RSA-Schlüssel die GENERATE ASYMMETRIC KEY PAIR-Varianten aus (N096.600), (N096.644), (N096.652), (N096.664), (N097.200), (N097.246), (N097.254) und (N097.226) unterstützen. <b>[<=]</b>

REQ(ids=A_16818)<b>A_16818 - (N097.400)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere GENERATE ASYMMETRIC KEY PAIR-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

PAR Das vom Kommando betroffene Schlüsselobjekt wird wie folgt bestimmt:
REQ(ids=A_16819)<b>A_16819 - (N097.500)a K_COS</b>
PAR Wenn der Parameter P2 gleich '00' ist, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=A_16820)<b>A_16820 - (N097.500)a.1 K_TST</b>
PAR Wenn das Attribute channelContext.keyReferenceList.signatureCreation leer, dann DARD die funktionale Eignung einem Prüfling NICHT mit der Begründung verwehrt werden das COS beantworte dieses Kommandos mit einem beliebigen Trailer oder arbeite mit einem beliebigen anderen privaten Schlüsselobjekt. <b>[<=]</b>

REQ(ids=G2_N097.500.a.2)<b>G2_N097.500.a.2 - (N097.500)a.2 K_COS</b>
PAR Wenn das Attribute channelContext.keyReferenceList.signatureCreation nicht leer ist, gilt:<br>keyReference = keyReferenceList.signatureCreation.keyReference. <b>[<=]</b>

REQ(ids=G2_N097.500.b)<b>G2_N097.500.b - (N097.500)b K_COS</b>
PAR Falls der Parameter P2 ungleich '00' ist, MUSS keyReference = P2 gelten. <b>[<=]</b>

REQ(ids=G2_N097.500.c)<b>G2_N097.500.c - (N097.500)c K_COS</b>
PAR Es wird<br>affectedObject = SearchSecretKey(<br>    currentFolder,<br>    keyReference,<br>    Wildcard<br>) gesetzt. Gemäß CosT_a08 und (N104.300) ist es möglich, dass die Schlüsselsuche nicht erfolgreich ist. Falls die Schlüsselsuche den Fehler keyNotFound meldet, genau dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren.<br>Hinweis CosH_1b7: Der Fehler notSupported ist wegen der Wildcard-Suche hier nicht möglich. <b>[<=]</b>

REQ(ids=G2_N097.600)<b>G2_N097.600 - (N097.600) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=G2_N097.650)<b>G2_N097.650 - (N097.650) K_COS</b>
PAR Wenn operationMode Element der Menge {'80', '84'} ist und das Attribute keyAvailable den Wert True hat, genau dann MUSS das Kommando mit dem Trailer KeyAlreadyPresent terminieren. <b>[<=]</b>

REQ(ids=G2_N097.700)<b>G2_N097.700 - (N097.700) K_COS</b>
PAR Wenn operationMode Element der Menge {'80', '84', 'C0', 'C4'} ist, dann MÜSSEN folgende Schritte ausgeführt werden:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Es MUSS ein Schlüsselpaar ( PrK, PuK ) erzeugt werden, dessen Eigenschaften zu den Attributen von affectedObject und zu (N002.100) bzw. (N002.500) passen.LITEM->PAR Anschließend MUSS das Attribute keyAvailable mit Transaktionsschutz auf den Wert True geändert werden.
PAR <b>[<=]</b>

REQ(ids=G2_N097.800)<b>G2_N097.800 - (N097.800) K_COS</b>
PAR Wenn operationMode Element der Menge {'81'} ist und das Attribute keyAvailable den Wert False hat, genau dann MUSS das Kommando mit dem Trailer KeyInvalid terminieren. <b>[<=]</b>

REQ(ids=A_16821)<b>A_16821 - (N097.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er verwende bei der Bearbeitung dieses Kommandos den Trailer UpdateRetryWarning, weil ein Schreibvorgang nicht beim ersten Versuch erfolgreich verlief. <b>[<=]</b>

REQ(ids=A_16822)<b>A_16822 - (N098.000) K_COS</b>
PAR Wenn ein Schreibvorgang nicht erfolgreich verlief, genau dann MUSS<br>a. entweder als Trailer MemoryFailure verwendet werden, oder<br>b. die Kommandobearbeitung gemäß (N031.940) stoppen. <b>[<=]</b>

REQ(ids=G2_N098.100)<b>G2_N098.100 - (N098.100) K_COS</b>
PAR Falls nicht anderweitig spezifiziert, MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

PAR Das DER-TLV codierte Datenobjekt publicKeyDO wird wie folgt berechnet:
REQ(ids=G2_N098.200.a)<b>G2_N098.200.a - (N098.200)a K_COS</b>
PAR Falls PuK ein RSA-Schlüssel ist, dann gilt:<br>1. Setze L<sub>82</sub> größer gleich OctetLength( PuK.e ), aber kleiner als 128.<br>2. Setze n = I2OS( PuK.n, OctetLength( PuK.n ) ).<br>3. Setze e = I2OS( PuK.e, L<sub>82</sub> ).<br>4. publicKeyDO = '7F49 – L<sub>7F49</sub> – [(81 – L<sub>81 </sub>– n )   ||   (82 – L<sub>82</sub> – e )]'. <b>[<=]</b>

REQ(ids=G2_N098.200.b)<b>G2_N098.200.b - (N098.200)b K_COS</b>
PAR Falls PuK ein ELC-Schlüssel ist mit dem öffentlichen Punkt P und den Domainparametern dP, dann gilt publicKeyDO = '7F49 – L<sub>7F49 </sub>– (86 – L<sub>86 </sub>– P2OS( P , dP.L) )'. <b>[<=]</b>

REQ(ids=G2_N098.300.a)<b>G2_N098.300.a - (N098.300)a K_COS</b>
PAR Wenn operationMode einen Wert aus der Menge {'80', '81', 'C0'} hat, dann MUSS das Datenfeld der Antwortnachricht publicKeyDO enthalten. <b>[<=]</b>

REQ(ids=G2_N098.300.b)<b>G2_N098.300.b - (N098.300)b K_COS</b>
PAR Wenn operationMode nicht einen Wert aus der Menge {'80', '81', 'C0'} hat, dann MUSS das Datenfeld der Antwortnachricht fehlen. <b>[<=]</b>

REQ(ids=A_16823)<b>A_16823 - (N098.400) K_COS</b>
PAR Für die Priorität der Trailer gilt:<br>a. Die Priorität der Trailer in CosT_6d3 ist herstellerspezifisch.<br>b. Jeder Trailer in CosT_6d3 MUSS eine höhere Priorität als UpdateRetryWarning haben.<br>c. UpdateRetryWarning MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.9.4)14.9.4 CosK_8c2 GET CHALLENGE
PAR Das Kommando GET CHALLENGE erzeugt eine Zufallszahl. Diese steht kartenintern mindestens bei der Ausführung des nächsten Kommandos zur Verfügung. Typischerweise beinhaltet dieses nächste Kommando die Authentisierung einer externen Komponente.
PAR -HEADING(ids=14.9.4.1)14.9.4.1 CosK_77f Use Case Erzeugen einer Zufallszahl für DES oder RSA Authentisierung
PAR (N098.500) ist absichtlich leer.<br>(N098.600) ist absichtlich leer.
PAR In dieser Variante enthält die APDU des GET CHALLENGE-Kommandos einen Parameter:
REQ(ids=A_16824)<b>A_16824 - (N098.500) K_externeWelt {K_Karte}; Option_DES oder Option_RSA_CVC</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich 8 sein. <b>[<=]</b>

REQ(ids=N098.600)<b>N098.600 - (N098.600) K_externeWelt {K_Karte}, Option_DES oder Option_RSA_CVC</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_31c verwendet werden.
PAR (ids=Tabelle-309,-CosT_31c)Tabelle 309, CosT_31c: GET CHALLENGE für DES oder RSA Authentisierung

TABLE(rows=6,cols=64+86+445)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '84' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR –
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR –
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR '08' TD(5,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten, hier acht
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.4.2)14.9.4.2 CosK_5e1 Use Case Erzeugen einer Zufallszahl für AES oder ELC Authentisierung
PAR In dieser Variante enthält die APDU des GET CHALLENGE-Kommandos einen Parameter:
REQ(ids=A_16825)<b>A_16825 - (N098.620) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich 16 sein. <b>[<=]</b>

REQ(ids=A_16826)<b>A_16826 - (N098.625) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_b6b verwendet werden.
PAR (ids=Tabelle-310,-CosT_b6b)Tabelle 310, CosT_b6b: GET CHALLENGE für AES oder ELC Authentisierung

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '84' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR –
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR –
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR '10' TD(5,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten, hier 16
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.4.3)14.9.4.3 Antwort der Karte auf Erzeugen einer Zufallszahl
PAR (ids=Tabelle-311,-CosT_652)Tabelle 311, CosT_652: GET CHALLENGE Antwort-APDU im Erfolgsfall

TABLE(rows=4,cols=63+183+345)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)->PAR rspData TD(1,2/1/1)->PAR Zufallszahl
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '90 00' TD(3,1/1/1)->PAR NoError TD(3,2/1/1)->PAR Erfolgreiche Erzeugung einer Zufallszahl
PAR (ids=Tabelle-312,-CosT_d95)Tabelle 312, CosT_d95: GET CHALLENGE Antwort-APDU im Fehlerfall

TABLE(rows=2,cols=63+183+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR – TD(1,1/1/1)->PAR – TD(1,2/1/1)->PAR Derzeit keine Fehlerfälle spezifiziert
PAR Hinweis CosH_144: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16827)<b>A_16827 - (N098.700) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando GET CHALLENGE verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.9.4.4)14.9.4.4 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N098.800.a)<b>G2_N098.800.a - (N098.800)a</b>
PAR TODO gematik-Testabteilung, siehe Kommentar.<br>AFO-ID aus ReqPro: AFO1831 <b>[<=]</b>

PAR (N098.800)a.1 ist absichtlich leer.
REQ(ids=A_16828)<b>A_16828 - (N098.800)a.1 K_COS, Option_DES oder Option_RSA_CVC</b>
PAR Das COS MUSS die GET CHALLENGE-Variante aus (N098.600) unterstützen. <b>[<=]</b>

REQ(ids=A_16829)<b>A_16829 - (N098.800)a.2 K_COS</b>
PAR Das COS MUSS die GET CHALLENGE-Variante aus (N098.625) unterstützen. <b>[<=]</b>

REQ(ids=A_16830)<b>A_16830 - (N098.800)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere GET CHALLENGE-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16831)<b>A_16831 - (N098.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden im Rahmen der Bearbeitung des GET CHALLENGE-Kommandos<br>a. würden Zugriffsregeln ausgewertet oder<br>b. würde als Zugriffsbedingung eines GET CHALLENGE-Kommandos stets ALWAYS verwendet. <b>[<=]</b>

REQ(ids=G2_N099.000)<b>G2_N099.000 - (N099.000) K_COS</b>
PAR Es MUSS rspData = RAND( Ne ) gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N099.100)<b>G2_N099.100 - (N099.100) K_COS</b>
PAR Als Trailer MUSS NoError gewählt werden. <b>[<=]</b>

REQ(ids=G2_N099.200)<b>G2_N099.200 - (N099.200) K_COS</b>
PAR Das Datenfeld der Antwortnachricht MUSS rspData sein. <b>[<=]</b>

REQ(ids=G2_N099.300)<b>G2_N099.300 - (N099.300) K_COS</b>
PAR Das Datenfeld der Antwortnachricht rspData MUSS zwecks Verwendung in nachfolgenden Kommandos in RND.ICC (siehe (N029.900)b) gespeichert werden. <b>[<=]</b>

PAR -HEADING(ids=14.9.5)14.9.5 CosK_5d7 GET RANDOM
PAR Das Kommando GET RANDOM erzeugt eine Zufallszahl. Im Unterschied zu GET CHALLENGE steht diese Zufallszahl nach Abschluss des Kommandos kartenintern nicht für weitere Aktionen zur Verfügung. Dafür erfüllt die mittels GET RANDOM erzeugte Zufallszahl höhere Sicherheitsanforderungen (siehe (N099.356)b). Zudem sind auch andere Längen als 16 Oktette möglich.
PAR -HEADING(ids=14.9.5.1)14.9.5.1 CosK_91c Use Case Erzeugen kryptographisch sicherer Zufallszahl
PAR In dieser Variante enthält die APDU des GET RANDOM-Kommandos einen Parameter:
REQ(ids=A_16832)<b>A_16832 - (N099.320) K_externeWelt {K_Karte}</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS aus der Menge {1, 2, …, 255, WildCardShort} gewählt werden. <b>[<=]</b>

REQ(ids=A_16833)<b>A_16833 - (N099.322) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_222 verwendet werden.
PAR (ids=Tabelle-313,-CosT_222)Tabelle 313, CosT_222: GET RANDOM

TABLE(rows=6,cols=63+84+444)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '80' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4] wird hier "proprietary" angezeigt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '84' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4] (identisch zu GET CHALLENGE)
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/1/1)->PAR –
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00' TD(4,2/1/1)->PAR –
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR length TD(5,2/1/1)->PAR Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.5.2)14.9.5.2 Antwort der Karte Erzeugen kryptographisch sichere Zufallszahl
PAR (ids=Tabelle-314,-CosT_086)Tabelle 314, CosT_086: GET RANDOM Antwort-APDU im Erfolgsfall

TABLE(rows=4,cols=63+183+345)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)->PAR random TD(1,2/1/1)->PAR Zufallszahl
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '90 00' TD(3,1/1/1)->PAR NoError TD(3,2/1/1)->PAR erfolgreiche Erzeugung einer Zufallszahl
PAR (ids=Tabelle-315,-CosT_211)Tabelle 315, CosT_211: GET RANDOM Antwort-APDU im Fehlerfall

TABLE(rows=2,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '69 82' TD(1,1/1/1)->PAR SecurityStatusNotSatisfied TD(1,2/1/1)->PAR Zugriffsregel nicht erfüllt
PAR Hinweis CosH_fc0: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16834)<b>A_16834 - (N099.340) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando GET RANDOM verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.9.5.3)14.9.5.3 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N099.344.a)<b>G2_N099.344.a - (N099.344)a K_COS</b>
PAR Das COS MUSS die GET RANDOM-Variante aus (N099.322) unterstützen. Option_logische_Kanäle <b>[<=]</b>

REQ(ids=A_16835)<b>A_16835 - (N099.344)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere GET RANDOM-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=G2_N099.348)<b>G2_N099.348 - (N099.348) K_COS</b>
PAR Als affectedObject MUSS currentFolder verwendet werden. <b>[<=]</b>

REQ(ids=G2_N099.352)<b>G2_N099.352 - (N099.352) K_COS</b>
PAR Wenn AccessRuleEvaluation( affectedObject, CLA, INS, P1, P2 ) den Wert False zurückliefert, genau dann MUSS das Kommando mit dem Trailer SecurityStatusNotSatisfied terminieren. <b>[<=]</b>

REQ(ids=A_16836)<b>A_16836 - (N099.356)a K_COS</b>
PAR Es MUSS random = RAND( Ne ) gesetzt werden. <b>[<=]</b>

REQ(ids=A_18226)<b>A_18226 - (N099.356)b K_PP-COS</b>
PAR Die Güte der Zufallszahl in random MUSS im zugehörigen Schutzprofil festgelegt werden.mindestens [BSI-TR-03116-1#3.5] PTG.3 oder K4-DRNG oder DRG.3 entsprechen. <b>[<=]</b>

REQ(ids=G2_N099.360)<b>G2_N099.360 - (N099.360) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=G2_N099.364)<b>G2_N099.364 - (N099.364) K_COS</b>
PAR Das Datenfeld der Antwortnachricht MUSS random sein. <b>[<=]</b>

PAR -HEADING(ids=14.9.6)14.9.6 CosK_dfe GET RESPONSE
REQ(ids=A_16837)<b>A_16837 - (N099.400) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das GET RESPONSE-Kommando gemäß [ISO/IEC 7816-4] würde<br>a. unterstützt oder<br>b. abgelehnt. <b>[<=]</b>

PAR -HEADING(ids=14.9.7)14.9.7 CosK_ed1 LIST PUBLIC KEY
PAR Das Kommando LIST PUBLIC KEY liefert eine Liste der in einer Karte gespeicherten öffentlichen Schlüsselobjekte. Die Ausführung dieses Kommandos ist an keine Vorbedingung geknüpft. Insbesondere ist die Ausführung dieses Kommandos unabhängig vom konkreten Wert von currentFolder.
PAR -HEADING(ids=14.9.7.1)14.9.7.1 CosK_5fb Use Case Auslesen der Liste öffentlicher Schlüsselobjekte
PAR In dieser Variante enthält die Liste alle Arten von öffentlichen Schlüsselobjekten.
REQ(ids=G2_N099.450)<b>G2_N099.450 - (N099.450) K_externeWelt {K_Karte}</b>
PAR Die APDU des LIST PUBLIC KEY-Kommandos enthält zwei Parameter.

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Parameter intendedAction ziegt an, dass in die Liste alle Arten von öffentlichen Schlüsselobjekten aufzunehmen sind. Der Wert von intendedAction MUSS 256 = '0100' sein.LITEM->PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS gleich WildCardExtended sein.
PAR <b>[<=]</b>

REQ(ids=G2_N099.452)<b>G2_N099.452 - (N099.452) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 2E-Kommando-APDU gemäß CosK_f88 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2E-Kommando-APDU MÜSSEN die Angaben aus CosT_662 verwendet werden.
PAR (ids=Tabelle-316,-CosT_662)Tabelle 316, CosT_662: LIST PUBLIC KEY mit allen Arten öffentlicher Schlüsselobjekte

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '80' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4] wird hier "proprietary" angezeigt
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR 'CA' TD(2,2/1/1)->PAR Instruction Byte von GET DATA gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/2/1)->PAR '0100' TD(3,2/2/1)->PAR intendedAction, gemäß [ISO/IEC 7816-4] proprietärer Wert für GET DATA, hier: Alle Arten von öffentlichen Schlüsselobjekten
TR-> TD(4,0/1/1)->PAR P2
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR '0000' TD(5,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.7.2)14.9.7.2 Antwort der Karte auf Auslesen einer Schlüsselliste
PAR (ids=Tabelle-317,-CosT_53a)Tabelle 317, CosT_53a: LIST PUBLIC KEY Antwort-APDU im Erfolgsfall

TABLE(rows=5,cols=63+184+345)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR 'xx…xx' TD(1,1/1/1)->PAR keyReferenceList TD(1,2/1/1)->PAR Liste mit Referenzen öffentlicher Schlüsselobjekte
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '62 00' TD(3,1/1/1)->PAR DataTruncated TD(3,2/1/1)->PAR Antwortdaten unvollständig
TR-> TD(4,0/1/1)->PAR '90 00' TD(4,1/1/1)->PAR NoError TD(4,2/1/1)->PAR Erfolgreiche Leseoperation
PAR (ids=Tabelle-318,-CosT_985)Tabelle 318, CosT_985: LIST PUBLIC KEY Antwort-APDU im Fehlerfall

TABLE(rows=2,cols=63+183+345)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR - TD(1,1/1/1)->PAR - TD(1,2/1/1)->PAR derzeit ist kein Fehlerfall spezifiziert
PAR Hinweis CosH_04e: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16838)<b>A_16838 - (N099.458) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando LIST PUBLIC KEY verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.9.7.3)14.9.7.3 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N099.460.a)<b>G2_N099.460.a - (N099.460)a K_COS</b>
PAR Das COS MUSS die LIST PUBLIC KEY-Variante aus (N099.452) unterstützen. <b>[<=]</b>

REQ(ids=A_16839)<b>A_16839 - (N099.460)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere LIST PUBLIC KEY-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16840)<b>A_16840 - (N099.461) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden im Rahmen der Bearbeitung des LIST PUBLIC KEY-Kommandos<br>a. würden Zugriffsregeln ausgewertet oder<br>b. würde als Zugriffsbedingung eines LIST PUBLIC KEY-Kommandos stets ALWAYS verwendet. <b>[<=]</b>

REQ(ids=G2_N099.462)<b>G2_N099.462 - G2_N099.462</b>
PAR TODO gematik-Testabteilung, siehe Kommentar.<br>AFO-ID aus ReqPro: AFO7510 <b>[<=]</b>

REQ(ids=A_16841)<b>A_16841 - (N099.462) K_COS</b>
PAR Das Datenfeld keyReferenceList der Antwortnachricht MUSS durch Ausführen der folgenden Schritte berechnet werden: <b>[<=]</b>

REQ(ids=A_16842)<b>A_16842 - (N099.462)a K_COS</b>
PAR Wenn keine Referenz auf ein öffentliches Schlüsselobjekt zurückgemeldet wird, dann MUSS keyReferenceList = '' leer sein. <b>[<=]</b>

REQ(ids=A_16843)<b>A_16843 - (N099.462)b K_COS</b>
PAR Für jedes öffentliche Schlüsselobjekt in persistentPublicKeyList MUSS ein Eintrag in keyReferenceList erfolgen. <b>[<=]</b>

REQ(ids=A_16844)<b>A_16844 - (N099.462)c K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden für ein öffentliches Schlüsselobjekt in volatileCache würde ein Eintrag in keyReferenceList<br>1. erfolgen oder<br>2. unterbleiben. <b>[<=]</b>

REQ(ids=A_16845)<b>A_16845 - (N099.462)d K_COS</b>
PAR Jeder Eintrag in keyReferenceList MUSS ein DER-TLV-Datenobjekt puKReference sein. <b>[<=]</b>

REQ(ids=A_16846)<b>A_16846 - (N099.462)e K_COS</b>
PAR Alle pukReference Datenobjekte MÜSSEN konkateniert werden. <b>[<=]</b>

REQ(ids=A_16847)<b>A_16847 - (N099.462)f K_COS</b>
PAR Jedes Datenobjekt pukReference MUSS wie folgt aufgebaut sein:

ORDERED-LIST->
LITEM->PAR Als Tag MUSS 'E0' verwendet werden.LITEM->PAR Das erste Datenobjekt im DO'E0' MUSS ein Application Identifier DO'4F' sein und die Applikation angeben, in dessen Unterstruktur das öffentliche Schlüsselobjekt gespeichert ist.LITEM->PAR Wenn das öffentliche Schlüsselobjekt
ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR der im DO'4F' referenzierten Applikation zugeordnet ist, dann DARF DO'E0' KEIN DO'51' enthalten.LITEM->PAR einem Unterordner der im DO'4F'referenzierten Applikation zugeordnet ist, dann MUSS das DO'E0' an zweiter Stelle ein File Reference DO'51' enthalten.
ORDERED-LIST->
LITEM->PAR Das Wertfeld des DO'51' MUSS einen Pfad von der Applikation zu dem DF enthalten, welches das öffentliche Schlüsselobjekt enthält.LITEM->PAR Die Länge des Werfeldes von DO'51' MUSS gerade sein.LITEM->PAR Die ersten beiden Oktette in DO'51' MÜSSEN den File Identifier eines DF enthalten, welches im Attribut children der Applikation enthalten ist.LITEM->PAR Als nächstes MUSS DO'E0' ein CRT enthalten, dessen Tag gleich
ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR 'A4' ist, falls es sich um ein öffentliches Authentisierungsobjekt handelt.LITEM->PAR 'B6' ist, falls es sich um ein öffentliches Signaturprüfobjekt handelt.LITEM->PAR 'B8' ist, falls es sich um ein öffentliches Verschlüsselungsobjekt handelt.LITEM->PAR Das CRT MUSS ein DO'83' mit dem Attribut keyIdentifier des öffentlichen Schlüsselobjektes enthalten.LITEM->PAR Wenn es für ein öffentliches Schlüsselobjekt mehr als eine Möglichkeit gibt pukReference zu codieren, dann MUSS das COS aus der Menge der möglichen Werte genau einen auswählen.
PAR <b>[<=]</b>

REQ(ids=G2_N099.463)<b>G2_N099.463 - (N099.463) K_COS</b>
PAR Das COS MUSS für keyReferenceList eine Mindestlänge von limitRspSecureMessaging unterstützen. Falls keyReferenceList länger ist als vom COS unterstüzt, dann

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR MÜSSEN so viele beliebige Einträge wie nötig aus keyReferenceList entfernt werden, damit die vom COS unterstützte Länge eingehalten wird.LITEM->PAR MUSS als Trailer DataTruncated verwendet werden.
PAR <b>[<=]</b>

REQ(ids=G2_N099.464.a)<b>G2_N099.464.a - (N099.464)a K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=G2_N099.464.b)<b>G2_N099.464.b - (N099.464)b K_COS</b>
PAR Für die Priorität der Trailer gilt: DataTruncated MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

REQ(ids=A_16848)<b>A_16848 - (N099.466) K_TST</b>
PAR Es ist unzulässig mehr Einträge aus keyReferenceList zu entfernen, als nötig. Im Rahmen funktionaler Zulassungstests MUSS eine Abweichung zur Testerwartungshaltung ausgewiesen werden, falls von allen möglichen Codierungen von pukReference aller in keyReferenceList fehlender Schlüssel die längste dieser Codierungen zu keyReferenceList hinzugefügbar ist, ohne dadurch limitRspSecureMessaging zu überschreiten. <b>[<=]</b>

PAR -HEADING(ids=14.9.8)14.9.8 CosK_02b MANAGE CHANNEL
PAR Das Kommando MANAGE CHANNEL dient dem Öffnen und Schließen von logischen Kanälen mit einer von null verschiedenen Kanalnummer sowie dem Rücksetzen eines beliebigen logischen Kanals. Ob ein Kanal geöffnet, welcher Kanal geschlossen oder zurückgesetzt wird, bestimmen Parameter, die diesem MANAGE CHANNEL-Kommando beigefügt sind.
PAR Es ist möglich, dass ein zusätzlich zum Basiskanal 0 geöffneter logischer Kanal Einfluss auf die Ausführung eines Kommandos hat, wenn dieses Kommando auf Objekte zugreift, welche in anderen logischen Kanälen aktiv sind. Zwecks Vermeidung von Seiteneffekten gilt folgende Anforderung, die von der Kommando-APDU schickenden Einheit einzuhalten ist:
REQ(ids=A_16853)<b>A_16853 - (N099.500) K_externeWelt {K_Karte}</b>
PAR Das Kommando DELETE DARF NICHT an das COS gesendet werden, wenn außer dem Basiskanal noch weitere logische Kanäle geöffnet sind. <b>[<=]</b>

PAR -HEADING(ids=14.9.8.1)14.9.8.1 CosK_1ce Use Case Öffnen eines logischen Kanals
PAR In dieser Variante enthält die APDU des MANAGE CHANNEL-Kommandos zwei Parameter:
REQ(ids=A_16854)<b>A_16854 - (N099.504) K_externeWelt {K_Karte}, Option_logische_Kanäle</b>
PAR Der Parameter intendedAction zeigt an, dass ein logischer Kanal zu öffnen ist, wobei die Kanalnummer vom COS bestimmt wird. Der Wert von intendedAction MUSS 0 = '0000' sein. <b>[<=]</b>

REQ(ids=A_16855)<b>A_16855 - (N099.506) K_externeWelt {K_Karte}, Option_logische_Kanäle</b>
PAR Der Parameter length bestimmt die Länge der erwarteten Antwortdaten. Der Wert von length MUSS 1 = '01' sein. <b>[<=]</b>

REQ(ids=A_16856)<b>A_16856 - (N099.508) K_externeWelt {K_Karte}, Option_logische_Kanäle</b>
PAR Es MUSS eine Case 2S Kommando-APDU gemäß CosK_80d über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 2 Kommando-APDU MÜSSEN die Angaben aus CosT_42a verwendet werden.
PAR (ids=Tabelle-319,-CosT_42a)Tabelle 319, CosT_42a: MANAGE CHANNEL zum Öffnen eines logischen Kanals

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '70' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '00' TD(3,2/2/1)->PAR intendedAction, hier Öffnen eines Kanals,<br>Kanalnummer wird vom COS bestimmt.
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00'
TR-> TD(5,0/1/1)->PAR Le TD(5,1/1/1)->PAR '01' TD(5,2/1/1)->PAR length, Anzahl der erwarteten Oktette in den Antwortdaten
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.8.2)14.9.8.2 CosK_8c7 Use Case Schließen eines logischen Kanals
PAR In dieser Variante enthält die APDU des MANAGE CHANNEL-Kommandos zwei Parameter:
REQ(ids=A_16857)<b>A_16857 - (N099.510) K_externeWelt {K_Karte}, Option_logische_Kanäle</b>
PAR Der Parameter logicalChannelNumber MUSS die Nummer eines geöffneten Kanals enthalten, der zu schließen ist. Der Wert von logicalChannelNumber MUSS von null verschieden sein und MUSS gemäß [ISO/IEC 7816-4#5.4.1] ins CLA-Byte der APDU eingestellt werden, die an der Schnittstelle "Interface I/O" sichtbar ist. <b>[<=]</b>

REQ(ids=A_16858)<b>A_16858 - (N099.512) K_externeWelt {K_Karte}, Option_logische_Kanäle</b>
PAR Der Parameter intendedAction zeigt an, dass ein logischer Kanal zu schließen ist, wobei die Kanalnummer im CLA-Byte übertragen wird. Der Wert von intendedAction MUSS 32.768 = '8000' sein. <b>[<=]</b>

REQ(ids=A_16859)<b>A_16859 - (N099.514) K_externeWelt {K_Karte}, Option_logische_Kanäle</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interface I/O" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_5ca verwendet werden.
PAR (ids=Tabelle-320,-CosT_5ca)Tabelle 320, CosT_5ca: MANAGE CHANNEL zum Schließen eines logischen Kanals

TABLE(rows=5,cols=42+51+651)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR 'XX' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4] mit einer von 0 verschiedenen Kanalnummer
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '70' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '80' TD(3,2/2/1)->PAR intendedAction, hier Schließen eines Kanals,<br>betroffener Kanal wird im CLA-Byte angezeigt.
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00'
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.8.3)14.9.8.3 CosK_184 Use Case Zurücksetzen eines logischen Kanals
PAR In dieser Variante enthält die APDU des MANAGE CHANNEL-Kommandos zwei Parameter:
REQ(ids=A_16860)<b>A_16860 - (N099.520) K_externeWelt {K_Karte}</b>
PAR Der Parameter logicalChannelNumber MUSS die Nummer eines geöffneten Kanals enthalten, der zurückzusetzen ist. Der Wert von logicalChannelNumber MUSS gemäß [ISO/IEC 7816-4#5.4.1] ins CLA-Byte der APDU eingestellt werden, die an der Schnittstelle "Interface I/O" sichtbar ist. <b>[<=]</b>

REQ(ids=A_16861)<b>A_16861 - (N099.522) K_externeWelt {K_Karte}</b>
PAR Der Parameter intendedAction zeigt an, dass ein logischer Kanal zurückzusetzen ist, wobei die Kanalnummer im CLA-Byte übertragen wird. Der Wert von intendedAction MUSS 16.384 = '4000' sein. <b>[<=]</b>

REQ(ids=A_16862)<b>A_16862 - (N099.524) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interface I/O" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_442 verwendet werden.
PAR (ids=Tabelle-321,-CosT_442)Tabelle 321, CosT_442: MANAGE CHANNEL zum Zurücksetzen eines logischen Kanals

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR 'XX' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '70' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '40' TD(3,2/2/1)->PAR intendedAction, hier Zurücksetzen eines Kanals,<br>betroffener Kanal wird im CLA-Byte angezeigt.
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '00'
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.8.4)14.9.8.4 CosK_0ab Use Case logischer Reset der Applikationsebene
PAR In dieser Variante enthält die APDU des MANAGE CHANNEL-Kommandos einen Parameter:
REQ(ids=A_16863)<b>A_16863 - (N099.530) K_externeWelt {K_Karte}, Option_logische_Kanäle</b>
PAR Der Parameter intendedAction zeigt an, dass der Basiskanal zurückzusetzen ist und alle anderen logischen Kanäle zu schließen sind. Der Wert von intendedAction MUSS 16.385 = '4001' sein. <b>[<=]</b>

REQ(ids=A_16864)<b>A_16864 - (N099.532) K_externeWelt {K_Karte}, Option_logische_Kanäle</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interface I/O" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_901 verwendet werden.
PAR (ids=Tabelle-322,-CosT_901)Tabelle 322, CosT_901: MANAGE CHANNEL zum logischen Reset der Applikationsebene

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '70' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '40' TD(3,2/2/1)->PAR intendedAction, hier logischer Reset der Applikationsebene, d.h. Basiskanal zurücksetzen und alle anderen logischen Kanäle schließen.
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR '01'
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.8.5)14.9.8.5 Antwort der Karte auf Kanalmanagementoperationen
PAR (ids=Tabelle-323,-CosT_558)Tabelle 323, CosT_558: MANAGE CHANNEL Antwort-APDU im Erfolgsfall

TABLE(rows=4,cols=120+87+537)->
TR-> TH(0,0/1/1)->PAR Daten TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR Kanalnummer TD(1,1/1/1)->PAR 'XX' TD(1,2/1/1)->PAR Nummer des soeben geöffneten Kanals
TR-> TD(2,0/1/1)->PAR Trailer TD(2,1/1/1)->PAR Inhalt TD(2,2/1/1)->PAR Beschreibung
TR-> TD(3,0/1/1)->PAR '90 00' TD(3,1/1/1)->PAR NoError TD(3,2/1/1)->PAR erfolgreiche Operation
PAR (ids=Tabelle-324,-CosT_ea3)Tabelle 324, CosT_ea3: MANAGE CHANNEL Antwort-APDU im Fehlerfall

TABLE(rows=2,cols=63+184+344)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '69 81' TD(1,1/1/1)->PAR NoMoreChannelsAvailable TD(1,2/1/1)->PAR kein weiterer logischen Kanäle verfügbar
PAR Hinweis CosH_205: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes in CosA_e09 entdeckt wurden.
REQ(ids=A_16865)<b>A_16865 - (N099.540) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando MANAGE CHANNEL verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.9.8.6)14.9.8.6 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N099.542.a)<b>G2_N099.542.a - (N099.542)a K_COS</b>
PAR Das COS MUSS die MANAGE CHANNEL-Variante aus (N099.524) unterstützen. <b>[<=]</b>

REQ(ids=G2_N099.542.b)<b>G2_N099.542.b - (N099.542)b K_COS, Option_logische_Kanäle</b>
PAR Das COS MUSS die MANAGE CHANNEL-Varianten aus (N099.508), (N099.514) und (N099.532) unterstützen. <b>[<=]</b>

REQ(ids=A_16866)<b>A_16866 - (N099.542)c K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere MANAGE CHANNEL-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16867)<b>A_16867 - (N099.545) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden im Rahmen der Bearbeitung des MANAGE CHANNEL-Kommandos<br>a. würden Zugriffsregeln ausgewertet oder<br>b. würde als Zugriffsbedingung eines MANAGE CHANNEL-Kommandos stets ALWAYS verwendet. <b>[<=]</b>

REQ(ids=G2_N099.548.a.1)<b>G2_N099.548.a.1 - (N099.548)a.1 K_COS</b>
PAR Wenn intendedAction das Öffnen eines logischen Kanals (indendedAction = P1P2 = '0000') anzeigt und bereits alle verfügbaren logischen Kanäle geöffnet sind, dann MUSS das Kommando mit dem Trailer NoMoreChannelsAvailable terminieren, <b>[<=]</b>

REQ(ids=G2_N099.548.a.2)<b>G2_N099.548.a.2 - (N099.548)a.2 K_COS</b>
PAR Wenn intendedAction das Öffnen eines logischen Kanals (indendedAction = P1P2 = '0000') anzeigt und noch nicht alle verfügbaren logischen Kanäle geöffnet sind, dann MUSS das COS<br>i.   eine derzeit nicht verwendete Kanalnummer newChannelNumber aus dem Intervall [1, 19] allokieren und<br>ii.  einen weiteren logischen Kanal öffnen und<br>iiii. diesem die allokierte Nummer newChannelNumber zuweisen und<br>iv.  dessen Kanalkontext entsprechend (N030.100) initialisieren. <b>[<=]</b>

REQ(ids=G2_N099.548.a.3)<b>G2_N099.548.a.3 - (N099.548)a.3 K_COS</b>
PAR Wenn intendedAction das Öffnen eines logischen Kanals (indendedAction = P1P2 = '0000') anzeigt, dann MUSS als Datenfeld der Antwortnachricht I2OS( newChannelNumber, 1) verwendet werden. <b>[<=]</b>

REQ(ids=G2_N099.548.b)<b>G2_N099.548.b - (N099.548)b K_COS</b>
PAR Wenn intendedAction das Schließen eines logischen Kanals (indendedAction = P1P2 = '8000') anzeigt,<br>1. dann MUSS der entsprechende logische Kanal geschlossen werden und<br>2. die freiwerdende Kanalnummer MUSS für zukünftige Allokationen verfügbar sein und<br>3. das Datenfeld der Antwortnachricht MUSS leer sein. <b>[<=]</b>

REQ(ids=G2_N099.548.c)<b>G2_N099.548.c - (N099.548)c K_COS</b>
PAR Wenn intendedAction das Zurücksetzen eines logischen Kanals (indendedAction = P1P2 = '4000') anzeigt,<br>1. dann MUSS der channelContext des entsprechenden logischen Kanals auf den in (N030.100) definierten Wert gesetzt werden,<br>2. und das Datenfeld der Antwortnachricht MUSS leer sein. <b>[<=]</b>

REQ(ids=G2_N099.548.d)<b>G2_N099.548.d - (N099.548)d K_COS</b>
PAR Wenn intendedAction das logische Resetten (indendedAction = P1P2 = '4001') anzeigt<br>1. dann MÜSSEN bis auf den Basiskanal alle anderen offenen logischen Kanäle geschlossen werden und<br>2. die freiwerdenden Kanalnummern MÜSSEN für zukünftige Allokationen verfügbar sein, und<br>3. der channelContext des Basiskanals auf den in (N030.100) definierten Wert gesetzt werden, und<br>4. das Datenfeld der Antwortnachricht MUSS leer sein. <b>[<=]</b>

REQ(ids=G2_N099.551)<b>G2_N099.551 - (N099.551) K_COS</b>
PAR Wenn nicht anderweitig spezifiziert, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16868)<b>A_16868 - (N099.554)a K_TST</b>
PAR Die Priorität der Trailer in CosT_ea3 MUSS herstellerspezifisch sein. <b>[<=]</b>

REQ(ids=G2_N099.554.b)<b>G2_N099.554.b - (N099.554)b K_COS</b>
PAR Jeder Trailer in CosT_ea3 MUSS eine höhere Priorität als NoError haben. <b>[<=]</b>

PAR -HEADING(ids=14.9.9)14.9.9 CosK_146 MANAGE SECURITY ENVIRONMENT
PAR Das Kommando MANAGE SECURITY ENVIRONMENT (MSE) verändert im currentFolder die Attribute seIdentifier und Elemente von keyReferenceList. Welche Aktion durchzuführen ist, welches Attribut oder Listenelement betroffen ist und auf welchen Wert sie zu ändern sind, wird durch Parameter bestimmt, die in der Kommandonachricht enthalten sind.
REQ(ids=A_16869)<b>A_16869 - (N099.600) K_externeWelt {K_Karte}</b>
PAR Falls ein symmetrisches Authentisierungsobjekt oder ein symmetrisches Kartenverbindunsobjekt oder ein privates Schlüsselobjekt referenziert wird, dann besteht der Parameter keyReference aus den zwei Teilen location und identifier. Der Teil location zeigt an, ob ein globaler oder DF-spezifischer Schlüssel von der Aktion betroffen ist. Als Wert für location MUSS ein Element der Menge {'00', '80'} verwendet werden. Dabei gilt:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Wert location = '00' MUSS verwendet werden, wenn ein globaler Schlüssel betroffen ist.LITEM->PAR Der Wert location = '80' MUSS verwendet werden, wenn ein DF-spezifischer Schlüssel betroffen ist.LITEM->PAR Der Parameter identifier bestimmt das betroffene Schlüsselobjekt. Der Wert von identifier MUSS konform zu (N016.400), (N017.020) oder (N017.100) gewählt werden.LITEM->PAR Der Parameter keyReference MUSS in einem Oktett mit folgendem Wert codiert werden:<br>keyReference = location + identifier.
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.9.1)14.9.9.1 CosK_082 Use Case Ändern des SE-Identifiers
PAR In dieser Variante enthält die APDU des MSE-Kommandos zwei Parameter:
REQ(ids=A_16870)<b>A_16870 - (N099.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = 'F3' gewählt werden. <b>[<=]</b>

REQ(ids=A_16871)<b>A_16871 - (N099.800) K_externeWelt {K_Karte}</b>
PAR Der Parameter seNo MUSS gemäß (N007.900) gewählt werden. <b>[<=]</b>

REQ(ids=A_16872)<b>A_16872 - (N099.900) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 1 Kommando-APDU gemäß CosK_f7e über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 1 Kommando-APDU MÜSSEN die Angaben aus CosT_6fc verwendet werden.
PAR (ids=Tabelle-325,-CosT_6fc)Tabelle 325, CosT_6fc: MSE, Restore Variante

TABLE(rows=5,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '22' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'F3' TD(3,2/1/1)->PAR operationMode = Auswahl eines SE–Identifiers
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'XX' TD(4,2/1/1)->PAR seNo = Wert des auszuwählenden SE–Identifiers
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.9.2)14.9.9.2 CosK_b6c Use Case Schlüsselauswahl zur internen, symmetrischen Authentisierung
PAR In dieser Variante enthält die APDU des MSE-Kommandos vier Parameter:
REQ(ids=A_16873)<b>A_16873 - (N100.000) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = '41' gewählt werden. <b>[<=]</b>

REQ(ids=A_16874)<b>A_16874 - (N100.100) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Der Parameter crtTag bestimmt das Listenelement in keyReferenceList, welches zu ändern ist. Für diesen Use Case MUSS crtTag = 'A4' gewählt werden. <b>[<=]</b>

REQ(ids=A_16875)<b>A_16875 - (N100.200) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Der Parameter keyRef enthält den neuen Wert für das Element keyReference im Listenelement internalAuthenticate. Wert und Codierung MÜSSEN gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=G2_N100.300.a)<b>G2_N100.300.a - (N100.300)a K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Der Parameter algId enthält den neuen Wert für das Element algorithmIdentifier im Listenelement internalAuthenticate. Wert und Codierung MÜSSEN gemäß CosT_7a2 gewählt werden, wobei ein Wert aus der Menge {    <br>    aesSessionkey4TC,    <br>     desSessionkey4TC (Option_DES),<br>} verwendet werden MUSS. <b>[<=]</b>

REQ(ids=A_16876)<b>A_16876 - (N100.300)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere Werte für algId würden<br>1. akzeptiert oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16877)<b>A_16877 - (N100.400) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_1b4 verwendet werden.
PAR (ids=Tabelle-326,-CosT_1b4)Tabelle 326, CosT_1b4: MSE, Selektion symmetrischer INTERNAL AUTHENTICATE-Schlüssel

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '22' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '41' TD(3,2/2/1)->PAR operationMode = Setzen eines "internen" Schlüssels<br>crtTag = betroffenes Listenelement ist internalAuthenticate
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'A4'
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '83 – 01 – keyRef   ||   80 – 01 – algId '
PAR <b>[<=]</b>

PAR Hinweis (149) L<sub>83</sub> ist ein Oktett mit dem Wert I2OS( OctetLength(keyRef), 1).
PAR -HEADING(ids=14.9.9.3)14.9.9.3 CosK_428 Use Case Schlüsselauswahl zur internen, asymmetrischen Authentisierung
PAR In dieser Variante enthält die APDU des MSE-Kommandos vier Parameter:
REQ(ids=A_16878)<b>A_16878 - (N100.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = '41' gewählt werden. <b>[<=]</b>

REQ(ids=A_16879)<b>A_16879 - (N100.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter crtTag bestimmt das Listenelement in keyReferenceList, welches zu ändern ist.<br>Für diesen Use Case MUSS crtTag = 'A4' gewählt werden. <b>[<=]</b>

REQ(ids=A_16880)<b>A_16880 - (N100.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter keyRef enthält den neuen Wert für das Element keyReference im Listenelement internalAuthenticate. Wert und Codierung MÜSSEN gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=G2_N100.800.a)<b>G2_N100.800.a - (N100.800)a K_externeWelt {K_Karte}</b>
PAR Der Parameter algId enthält den neuen Wert für das Element algorithmIdentifier im Listenelement internalAuthenticate. Wert und Codierung MÜSSEN gemäß CosT_7a2 oder CosT_c40 gewählt werden, wobei ein Wert aus der Menge {  <br>    elcAsynchronAdmin,    <br>    elcRoleAuthentication,    <br>    elcSessionkey4SM,     <br>    elcSessionkey4TC,     <br>    rsaClientAuthentication,    <br>    rsaRoleAuthentication    (Option_RSA_CVC),    <br>    rsaSessionkey4SM       (Option_DES),    <br>    rsaSessionkey4TC        (Option_Kryptobox und Option_DES),    <br>    signPKCS1_V1_5    <br>} verwendet werden MUSS. <b>[<=]</b>

REQ(ids=A_16881)<b>A_16881 - (N100.800)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere Werte für algId würden<br>1. akzeptiert oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16882)<b>A_16882 - (N100.900) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_84e verwendet werden.
PAR (ids=Tabelle-327,-CosT_84e)Tabelle 327, CosT_84e: MSE, Selektion privater INTERNAL AUTHENTICATE-Schlüssel

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '22' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '41' TD(3,2/2/1)->PAR operationMode = Setzen eines "internen" Schlüssels<br>crtTag = betroffenes Listenelement ist internalAuthenticate
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'A4'
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '84 – 01 – keyRef   ||   80 – 01 – algId '
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.9.4)14.9.9.4 CosK_915 Use Case Schlüsselauswahl zur externen, symmetrischen Authentisierung
PAR In dieser Variante enthält die APDU des MSE-Kommandos vier Parameter:
REQ(ids=A_16885)<b>A_16885 - (N101.000) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = '81' gewählt werden. <b>[<=]</b>

REQ(ids=A_16886)<b>A_16886 - (N101.100) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Der Parameter crtTag bestimmt das Listenelement in keyReferenceList, welches zu ändern ist.<br>Für diesen Use Case MUSS crtTag = 'A4' gewählt werden. <b>[<=]</b>

REQ(ids=A_16887)<b>A_16887 - (N101.200) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Der Parameter keyRef enthält den neuen Wert für das Element keyReference im Listenelement externalAuthenticate. Wert und Codierung MÜSSEN gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=G2_N101.300.a)<b>G2_N101.300.a - (N101.300)a K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Der Parameter algId enthält den neuen Wert für das Element algorithmIdentifier im Listenelement externalAuthenticate. Wert und Codierung MÜSSEN gemäß CosT_7a2 gewählt werden, wobei ein Wert aus der Menge {    <br>    aesSessionkey4TC,    <br>    desSessionkey4TC    (Option_DES),    <br>} verwendet werden MUSS. <b>[<=]</b>

REQ(ids=A_16888)<b>A_16888 - (N101.300)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere Werte für algId würden<br>1. akzeptiert oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16889)<b>A_16889 - (N101.400) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_a68 verwendet werden.
PAR (ids=Tabelle-328,-CosT_a68)Tabelle 328, CosT_a68: MSE, Selektion symmetrischer EXTERNAL AUTHENTICATE-Schlüssel

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '22' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '81' TD(3,2/2/1)->PAR operationMode = Setzen eines "externen" Schlüssels<br>crtTag = betroffenes Listenelement ist externalAuthenticate
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'A4'
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '83 – 01 – keyRef   ||   80 – 01 – algId '
PAR <b>[<=]</b>

PAR Hinweis (150) L<sub>83</sub> ist ein Oktett mit dem Wert I2OS( OctetLength(keyRef), 1).
PAR -HEADING(ids=14.9.9.5)14.9.9.5 CosK_8d4 Use Case Schlüsselauswahl zur externen, asymmetrischen Authentisierung
PAR In dieser Variante enthält die APDU des MSE-Kommandos vier Parameter:
REQ(ids=A_16890)<b>A_16890 - (N101.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = '81' gewählt werden. <b>[<=]</b>

REQ(ids=A_16891)<b>A_16891 - (N101.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter crtTag bestimmt das Listenelement in keyReferenceList, welches zu ändern ist.<br>Für diesen Use Case MUSS crtTag = 'A4' gewählt werden. <b>[<=]</b>

REQ(ids=A_16892)<b>A_16892 - (N101.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter keyRef enthält den neuen Wert für das Element keyReference im Listenelement externalAuthenticate. Wert und Codierung MÜSSEN gemäß (N019.500) gewählt werden. <b>[<=]</b>

REQ(ids=G2_N101.800.a)<b>G2_N101.800.a - (N101.800)a K_externeWelt {K_Karte}</b>
PAR Der Parameter algId enthält den neuen Wert für das Element algorithmIdentifier im Listenelement externalAuthenticate. Wert und Codierung MÜSSEN gemäß CosT_7a2 gewählt werden, wobei ein Wert aus der Menge {    <br>    elcRoleCheck,    <br>    rsaRoleCheck             (Option_RSA_CVC),    <br>    rsaSessionkey4SM     (Option_DES),    <br>    rsaSessionkey4TC      (OptionKryptobox und Option_DES)    <br>} verwendet werden MUSS.    <br>Hinweis CosH_665: Die Schlüsselselektion für die Algorithmen elcSessionkey4SM und elcSessionkey4TC erfolgt im GENERAL AUTHENTICATE-Kommando, siehe (N085.012). <b>[<=]</b>

REQ(ids=A_16893)<b>A_16893 - (N101.800)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere Werte für algId würden<br>1. akzeptiert oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16894)<b>A_16894 - (N101.900) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_b61 verwendet werden.
PAR (ids=Tabelle-329,-CosT_b61)Tabelle 329, CosT_b61: MSE, Selektion öffentlicher EXTERNAL AUTHENTICATE-Schlüssel

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '22' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '81' TD(3,2/2/1)->PAR operationMode = Setzen eines öffentlichen Schlüssels<br>crtTag = betroffenes Listenelement ist externalAuthenticate
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'A4'
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '83 – 0C – keyRef   ||   80 – 01 – algId '
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.9.6)14.9.9.6 CosK_5c6 Use Case Schlüsselauswahl zur symmetrischen, gegenseitigen Authentisierung
PAR In dieser Variante enthält die APDU des MSE-Kommandos vier Parameter:
REQ(ids=A_16905)<b>A_16905 - (N102.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = '81' gewählt werden. <b>[<=]</b>

REQ(ids=A_16906)<b>A_16906 - (N102.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter crtTag bestimmt das Listenelement in keyReferenceList, welches zu ändern ist.<br>Für diesen Use Case MUSS crtTag = 'A4' gewählt werden. <b>[<=]</b>

REQ(ids=A_16907)<b>A_16907 - (N102.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter keyRef enthält den neuen Wert für das Element keyReference im Listenelement externalAuthenticate. Wert und Codierung MÜSSEN gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=G2_N102.300.a)<b>G2_N102.300.a - (N102.300)a K_externeWelt {K_Karte}</b>
PAR Der Parameter algId enthält den neuen Wert für das Element algorithmIdentifier im Listenelement externalAuthenticate. Wert und Codierung MÜSSEN gemäß CosT_7a2 gewählt werden, wobei ein Wert aus der Menge {    <br>    aesSessionkey4SM    <br>    desSessionkey4SM    (Option_DES)    <br>} verwendet werden MUSS. <b>[<=]</b>

REQ(ids=A_16908)<b>A_16908 - (N102.300)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere Werte für algId würden<br>1. akzeptiert oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16909)<b>A_16909 - (N102.400) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_4f0 verwendet werden.
PAR (ids=Tabelle-330,-CosT_4f0)Tabelle 330, CosT_4f0: MSE, Selektion symmetrischer MUTUAL AUTHENTICATE-Schlüssel

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '22' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '81' TD(3,2/2/1)->PAR operationMode = Setzen eines symmetrischen Schlüssels<br>crtTag = betroffenes Listenelement ist externalAuthenticate
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'A4'
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '83 – 01 – keyRef   ||   80 – 01 – algId '
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.9.7)14.9.9.7 CosK_86a Use Case Schlüsselauswahl zur sym. Kartenverbindung ohne Kurvenangabe
PAR In dieser Variante wird ein symmetrisches Kartenverbindungsobjekt gemäß [BSI-TR-03110-3#B.14.1] ausgewählt ohne Referenzierung einer elliptischen Kurve. Anschließend ist es möglich eine Authentisierung mit dem PACE Authentisierungsprotokoll gemäß CosK_580 durchzuführen. In dieser Variante enthält das MSE-Kommando zwei Parameter:
REQ(ids=A_16910)<b>A_16910 - (N102.440) K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR Der Parameter OID bestimmt, welche PACE Variante vom COS verwendet wird und enthält den neuen Wert für das Element algortihmIdentifier in den Listenelementen externalAuthenticate und internalAuthenticate. Wert und Codierung MÜSSEN gemäß CosT_a91 gewählt werden. <b>[<=]</b>

REQ(ids=A_16911)<b>A_16911 - (N102.440)a K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle</b>
PAR Für OID MUSS ein Wert aus der Menge {<br>1. id-PACE-ECDH-GM-AES-CBC-CMAC-128,<br>2. id-PACE-ECDH-GM-AES-CBC-CMAC-192,<br>3. id-PACE-ECDH-GM-AES-CBC-CMAC-256,<br>} verwendet werden (siehe CosK_580). <b>[<=]</b>

REQ(ids=A_16912)<b>A_16912 - (N102.440)b K_externeWelt {K_Karte}, Option_PACE_PCD</b>
PAR Für OID MUSS ein Wert aus der Menge {<br>1. id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-128,<br>2. id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-192,<br>3. id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-256,<br>} verwendet werden (siehe CosK_580). <b>[<=]</b>

REQ(ids=A_16913)<b>A_16913 - (N102.444) K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR Der Parameter keyRef enthält den neuen Wert für das Element keyReference in den Listenelementen externalAuthenticate und internalAuthenticate. Wert und Codierung MÜSSEN gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=A_16914)<b>A_16914 - (N102.448) K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_a40 verwendet werden.
PAR (ids=Tabelle-331,-CosT_a40)Tabelle 331, CosT_a40: MSE, Selektion symmetrisches Kartenverbindungsobjekt ohne Kurvenangabe

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '22' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'C1' TD(3,2/2/1)->PAR operationMode = Setzen eines geheimen Schlüsselobjektes<br>crtTag = betr. Listenelemente: externalAuthenticate, internalAuthenticate
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'A4'
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '80 – I2OS(OctetLength( OID ), 1) – OID   ||   83 – 01 – keyRef '
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.9.8)14.9.9.8 CosK_2ee Use Case Schlüsselauswahl zur sym. Kartenverbindung mit Kurvenangabe
PAR In dieser Variante wird ein symmetrisches Kartenverbindungsobjekt gemäß [BSI-TR-03110-3#B.14.1] ausgewählt mit Referenzierung einer elliptischen Kurve. Anschließend ist es möglich eine Authentisierung mit dem PACE-Authentisierungsprotokoll gemäß CosK_580 durchzuführen. In dieser Variante enthält das MSE-Kommando drei Parameter:
REQ(ids=A_16915)<b>A_16915 - (N102.450) K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR Der Parameter OID hat dieselbe Bedeutung und Codierung wie in (N102.440). <b>[<=]</b>

REQ(ids=A_16916)<b>A_16916 - (N102.452) K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR Der Parameter keyRef hat dieselbe Bedeutung und Codierung wie in (N102.444). <b>[<=]</b>

REQ(ids=A_16917)<b>A_16917 - (N102.454) K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR Der Parameter idDomainParameter enthält einen Identifier für Domainparameter der zu verwendenden elliptischen Kurve mit der in CosT_3ce gezeigten Zuordnung gemäß [BSI-TR-03110-3#A.2.1.1], wobei idDomainparameter passend zum Attribut algorithmIdentifier des referenzierten symmetrischen Kartenverbindungsobjektes gewählt werden MUSS:
PAR (ids=Tabelle-332,-CosT_3ce)Tabelle 332, CosT_3ce: Zuordnung von idDomainParameter zu Domainparameter

TABLE(rows=4,cols=55+133+556)->
TR-> TH(0,0/1/1)->PAR ID TH(0,1/1/1)->PAR Domainparameter TH(0,2/1/1)->PAR algorithmIdentifier im sym. Kartenverbindungsobjekt
TR-> TD(1,0/1/1)->PAR 13 = '0D' TD(1,1/1/1)->PAR brainpoolP256r1 TD(1,2/1/1)->PAR id-PACE-ECDH-GM-AES-CBC-CMAC-128             oder    <br>id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-128
TR-> TD(2,0/1/1)->PAR 16 = '10' TD(2,1/1/1)->PAR brainpoolP384r1 TD(2,2/1/1)->PAR id-PACE-ECDH-GM-AES-CBC-CMAC-192             oder    <br>id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-192
TR-> TD(3,0/1/1)->PAR 17 = '11' TD(3,1/1/1)->PAR brainpoolP512r1 TD(3,2/1/1)->PAR id-PACE-ECDH-GM-AES-CBC-CMAC-256             oder    <br>id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-256
PAR <b>[<=]</b>

REQ(ids=A_16918)<b>A_16918 - (N102.458) K_externeWelt {K_Karte}, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR Es MUSS eine Case 3S-Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3-Kommando-APDU MÜSSEN die Angaben aus CosT_100 verwendet werden.
PAR (ids=Tabelle-333,-CosT_100)Tabelle 333, CosT_100: MSE, Selektion symmetrisches Kartenverbindungsobjekt

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '22' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR 'C1' TD(3,2/2/1)->PAR operationMode = Setzen eines geheimen Schlüsselobjektes<br>crtTag = betr. Listenelemente: externalAuthenticate, internalAuthenticate
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'A4'
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '80 – I2OS(OctetLength( OID ), 1) – OID   ||<br>83 – 01 – keyRef  ||<br>84 – 01 – idDomainparameter '
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.9.9)14.9.9.9 CosK_e04 Use Case Schlüsselauswahl für Signierschlüssel
PAR Dieser Use Case wird verwendet, um einen Signierschlüssel zu selektieren. Anschließend ist es möglich diesen Schlüssel zu erzeugen oder seinen öffentlichen Teil auszulesen (siehe (N096.600), (N096.652), (N096.900), (N097.200) und (N097.254)) oder mit diesem Schlüssel Signaturen zu erzeugen (siehe (N087.500) und (N088.000)). In dieser Variante enthält die APDU des MSE-Kommandos vier Parameter:
REQ(ids=A_16919)<b>A_16919 - (N102.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = '41' gewählt werden. <b>[<=]</b>

REQ(ids=A_16920)<b>A_16920 - (N102.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter crtTag bestimmt das Listenelement in keyReferenceList, welches zu ändern ist.<br>Für diesen Use Case MUSS crtTag = 'B6' gewählt werden. <b>[<=]</b>

REQ(ids=A_16921)<b>A_16921 - (N102.700) K_externeWelt {K_Karte}</b>
PAR Der Parameter keyRef enthält den neuen Wert für das Element keyReference im Listenelement signatureCreation. Wert und Codierung MÜSSEN gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=G2_N102.800.a)<b>G2_N102.800.a - (N102.800)a K_externeWelt {K_Karte}</b>
PAR Der Parameter algId enthält den neuen Wert für das Element algorithmIdentifier im Listenelement signatureCreation. Wert und Codierung MÜSSEN gemäß CosT_7a2 oder CosT_c40 gewählt werden, wobei ein Wert aus der Menge {    <br>    rsaClientAuthentication,    <br>    sign9796_2_DS2,    <br>    signECDSA,    <br>    signPKCS1_V1_5,    <br>    signPSS    <br>} verwendet werden MUSS. <b>[<=]</b>

REQ(ids=A_16922)<b>A_16922 - (N102.800)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere Werte für algId würden<br>1. akzeptiert oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16923)<b>A_16923 - (N102.900) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_d68 verwendet werden.
PAR (ids=Tabelle-334,-CosT_d68)Tabelle 334, CosT_d68: MSE, Selektion privater Signaturschlüssel

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '22' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '41' TD(3,2/2/1)->PAR operationMode = Setzen eines privaten Schlüssels<br>crtTag = betroffenes Listenelement ist signatureCreation
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'B6'
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '84 – 01 – keyRef   ||   80 – 01 – algId '
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.9.10)14.9.9.10 CosK_7fb Use Case Schlüsselauswahl zum Prüfen von CV–Zertifikaten
PAR In dieser Variante enthält die APDU des MSE-Kommandos drei Parameter:
REQ(ids=A_16924)<b>A_16924 - (N103.000) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = '81' gewählt werden. <b>[<=]</b>

REQ(ids=A_16925)<b>A_16925 - (N103.100) K_externeWelt {K_Karte}</b>
PAR Der Parameter crtTag bestimmt das Listenelement in keyReferenceList, welches zu ändern ist.<br>Für diesen Use Case MUSS crtTag = 'B6' gewählt werden. <b>[<=]</b>

REQ(ids=A_16926)<b>A_16926 - (N103.200) K_externeWelt {K_Karte}</b>
PAR Der Parameter keyRef enthält den neuen Wert für das Element keyReference im Listenelement verifyCertificate. Wert und Codierung MÜSSEN gemäß (N019.100) gewählt werden. <b>[<=]</b>

REQ(ids=A_16927)<b>A_16927 - (N103.300) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_25a verwendet werden.
PAR (ids=Tabelle-335,-CosT_25a)Tabelle 335, CosT_25a: MSE, Selektion öffentlicher Zertifikatsprüfschlüssel

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '22' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '81' TD(3,2/2/1)->PAR operationMode = Setzen eines öffentlichen Schlüssels<br>crtTag = betroffenes Listenelement ist verifyCertificate
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'B6'
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '83 – 08 – keyRef '
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.9.11)14.9.9.11 CosK_378 Use Case Schlüsselauswahl zur Datenent- oder Datenumschlüsselung
PAR In dieser Variante enthält die APDU des MSE-Kommandos vier Parameter:
REQ(ids=A_16928)<b>A_16928 - (N103.400) K_externeWelt {K_Karte}</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = '41' gewählt werden. <b>[<=]</b>

REQ(ids=A_16929)<b>A_16929 - (N103.500) K_externeWelt {K_Karte}</b>
PAR Der Parameter crtTag bestimmt das Listenelement in keyReferenceList, welches zu ändern ist.<br>Für diesen Use Case MUSS crtTag = 'B8' gewählt werden. <b>[<=]</b>

REQ(ids=A_16930)<b>A_16930 - (N103.600) K_externeWelt {K_Karte}</b>
PAR Der Parameter keyRef enthält den neuen Wert für das Element keyReference im Listenelement dataDecipher. Wert und Codierung MÜSSEN gemäß (N099.600) gewählt werden. <b>[<=]</b>

REQ(ids=G2_N103.700.a)<b>G2_N103.700.a - (N103.700)a K_externeWelt {K_Karte}</b>
PAR Der Parameter algId enthält den neuen Wert für das Element algorithmIdentifier im Listenelement dataDecipher. Wert und Codierung MÜSSEN gemäß CosT_605 gewählt werden, wobei ein Wert aus der Menge {    <br>    elcSharedSecretCalculation,    <br>    rsaDecipherPKCS1_V1_5,    <br>    rsaDecipherOaep    <br>} verwendet werden MUSS. <b>[<=]</b>

REQ(ids=A_16931)<b>A_16931 - (N103.700)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere Werte für algId würden<br>1. akzeptiert oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16932)<b>A_16932 - (N103.800) K_externeWelt {K_Karte}</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_9df verwendet werden.
PAR (ids=Tabelle-336,-CosT_9df)Tabelle 336, CosT_9df: MSE, Schlüsselselektion zur Ent- und Umschlüsselung

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '22' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '41' TD(3,2/2/1)->PAR operationMode = Setzen eines privaten Schlüssels<br>crtTag = betroffenes Listenelement ist dataDecipher
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'B8'
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '84 – 01 – keyRef   ||   80 – 01 – algId '
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.9.12)14.9.9.12 CosK_043 Use Case Schlüsselauswahl für Verschlüsselung
PAR Dieser Use Case wird verwendet um einen Verschlüsselungsschlüssel zu selektieren. Anschließend ist es möglich diesen Schlüssel zum Verschlüsseln von Daten einzusetzen (siehe Kapitel (N091.424) und (N091.434)). In dieser Variante enthält die APDU des MSE-Kommandos vier Parameter:
REQ(ids=A_16933)<b>A_16933 - (N103.830) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Der Parameter operationMode bestimmt die durchzuführende Aktion. Für diesen Use Case MUSS operationMode = '81' gewählt werden. <b>[<=]</b>

REQ(ids=A_16934)<b>A_16934 - (N103.835) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Der Parameter crtTag bestimmt das Listenelement in keyReferenceList, welches zu ändern ist.<br>Für diesen Use Case MUSS crtTag = 'B8' gewählt werden. <b>[<=]</b>

REQ(ids=A_16935)<b>A_16935 - (N103.840) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Der Parameter keyRef enthält den neuen Wert für das Element keyReference im Listenelement dataEncipher. Wert und Codierung MÜSSEN gemäß (N019.822) gewählt werden. <b>[<=]</b>

REQ(ids=G2_N103.845.a)<b>G2_N103.845.a - (N103.845)a K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Der Parameter algId enthält den neuen Wert für das Element algorithmIdentifier im Listenelement dataEncipher. Wert und Codierung MÜSSEN gemäß CosT_605 gewählt werden, wobei ein Wert aus der Menge {    <br>    elcSharedSecretCalculation,    <br>    rsaEncipherOaep,    <br>    rsaEncipherPKCS1_V1_5    <br>} verwendet werden MUSS. <b>[<=]</b>

REQ(ids=A_16936)<b>A_16936 - (N103.845)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere Werte für algId würden<br>1. akzeptiert oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16937)<b>A_16937 - (N103.850) K_externeWelt {K_Karte}, Option_Kryptobox</b>
PAR Es MUSS eine Case 3S Kommando-APDU gemäß CosK_d83 über die Schnittstelle "Interpreter" in CosA_e09 geschickt werden. Für die Konstruktion dieser Case 3 Kommando-APDU MÜSSEN die Angaben aus CosT_d68 verwendet werden.
PAR (ids=Tabelle-337,-CosT_d68)Tabelle 337, CosT_d68: MSE, Selektion Verschlüsselungsschlüssel

TABLE(rows=6,cols=63+86+443)->
TR-> TH(0,0/1/1)-> TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR CLA TD(1,1/1/1)->PAR '00' TD(1,2/1/1)->PAR CLA-Byte gemäß [ISO/IEC 7816-4]
TR-> TD(2,0/1/1)->PAR INS TD(2,1/1/1)->PAR '22' TD(2,2/1/1)->PAR Instruction Byte gemäß [ISO/IEC 7816-4]
TR-> TD(3,0/1/1)->PAR P1 TD(3,1/1/1)->PAR '81' TD(3,2/2/1)->PAR operationMode = Setzen eines öffentlichen Schlüssels<br>crtTag = betroffenes Listenelement ist dataEncipher
TR-> TD(4,0/1/1)->PAR P2 TD(4,1/1/1)->PAR 'B8'
TR-> TD(5,0/1/1)->PAR Data TD(5,1/1/1)->PAR 'XX…XX' TD(5,2/1/1)->PAR '83 – 0C – keyRef   ||   80 – 01 – algId '
PAR <b>[<=]</b>

PAR -HEADING(ids=14.9.9.13)14.9.9.13 Antwort der Karte auf Management des Security Environments
PAR (ids=Tabelle-338,-CosT_33b)Tabelle 338, CosT_33b: MSE Antwort-APDU im Erfolgsfall

TABLE(rows=2,cols=63+169+359)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '90 00' TD(1,1/1/1)->PAR NoError TD(1,2/1/1)->PAR Erfolgreiche Übernahme der Kommandodatenparameter
PAR (ids=Tabelle-339,-CosT_03c)Tabelle 339, CosT_03c: MSE Antwort-APDU im Fehlerfall

TABLE(rows=3,cols=63+170+359)->
TR-> TH(0,0/1/1)->PAR Trailer TH(0,1/1/1)->PAR Inhalt TH(0,2/1/1)->PAR Beschreibung
TR-> TD(1,0/1/1)->PAR '6A 81' TD(1,1/1/1)->PAR UnsupportedFunction TD(1,2/1/1)->PAR Schlüssel unterstützt den angegebenen Algorithmus nicht
TR-> TD(2,0/1/1)->PAR '6A 88' TD(2,1/1/1)->PAR KeyNotFound TD(2,2/1/1)->PAR Zu selektierendes Schlüsselobjekt wurde nicht gefunden
PAR Hinweis CosH_4b8: Diese Tabelle enthält keine Fehler, die in den Komponenten I/O, ChannelSwitch und SecMes aus CosA_e09 entdeckt wurden.
REQ(ids=A_16938)<b>A_16938 - (N103.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden das Kommando MANAGE SECURITY ENVIRONMENT verwende zusätzliche Trailer. <b>[<=]</b>

PAR -HEADING(ids=14.9.9.14)14.9.9.14 Kommandoabarbeitung innerhalb der Karte
REQ(ids=G2_N104.000.a)<b>G2_N104.000.a - (N104.000)a K_COS</b>
PAR Das COS MUSS die MANAGE SECURITY ENVIRONMENT-Varianten aus (N99.900), (N100.900), (N101.900), (N102.400), (N102.900), (N103.300) und (N103.800) unterstützen. <b>[<=]</b>

REQ(ids=G2_N104.000.b)<b>G2_N104.000.b - (N104.000)b K_COS, Option_Kryptobox</b>
PAR Das COS MUSS die MANAGE SECURITY ENVIRONMENT-Varianten aus (N100.400), (N101.400) und (N103.850) unterstützen. <b>[<=]</b>

REQ(ids=G2_N104.000.c)<b>G2_N104.000.c - (N104.000)c K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Das COS MUSS die MANAGE SECURITY ENVIRONMENT-Varianten aus (N102.448) und (N102.458) unterstützen. <b>[<=]</b>

REQ(ids=G2_N104.000.d)<b>G2_N104.000.d - (N104.000)d K_COS, Option_PACE_PCD</b>
PAR Das COS MUSS die MANAGE SECURITY ENVIRONMENT-Variante aus (N102.448) und (N102.458) unterstützen. <b>[<=]</b>

REQ(ids=A_16939)<b>A_16939 - (N104.000)e K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden weitere MANAGE SECURITY ENVIRONMENT-Varianten würden<br>1. unterstützt oder<br>2. abgelehnt. <b>[<=]</b>

REQ(ids=A_16940)<b>A_16940 - (N104.100) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden im Rahmen der Bearbeitung des MANAGE SECURITY ENVIRONMENT-Kommandos<br>a. würden Zugriffsregeln ausgewertet oder<br>b. würde als Zugriffsbedingung eines MANAGE SECURITY ENVIRONMENT-Kommandos stets ALWAYS verwendet. <b>[<=]</b>

REQ(ids=A_16946)<b>A_16946 - (N104.200) K_COS</b>
PAR Wenn der Parameter operationMode in P1 den Wert 'F3' besitzt, dann MÜSSEN folgende Schritte ausgeführt werden: <b>[<=]</b>

REQ(ids=G2_N104.200.a)<b>G2_N104.200.a - (N104.200)a K_COS</b>
PAR Das COS MUSS in currentFolder das Attribut seIdentifier (siehe (N030.000)a) auf den Wert des Parameters seNo setzen. <b>[<=]</b>

REQ(ids=G2_N104.200.b)<b>G2_N104.200.b - (N104.200)b K_COS</b>
PAR Das COS MUSS jedes Listenelement in keyReferenceList (siehe (N029.900)c), welches auf ein Schlüsselobjekt in currentFolder zeigt, auf den Wert "leer" setzen. <b>[<=]</b>

REQ(ids=G2_N104.200.c)<b>G2_N104.200.c - (N104.200)c K_COS</b>
PAR Das COS MUSS jedes Element in globalPasswordList (siehe (N029.900)i) und in dfSpecificPasswordList (siehe (N029.900)j) mittels clearPasswordStatus(…) aus den genannten Listen entfernt werden, wenn es currentFolder zugeordnet ist. <b>[<=]</b>

REQ(ids=G2_N104.200.d)<b>G2_N104.200.d - (N104.200)d K_COS</b>
PAR Das COS MUSS den Wert von currentEF unverändert lassen. <b>[<=]</b>

REQ(ids=G2_N104.200.e)<b>G2_N104.200.e - (N104.200)e K_COS</b>
PAR Das COS MUSS clearSecurityStatusFolder( currentFolder ) ausgeführen. <b>[<=]</b>

REQ(ids=G2_N104.200.f)<b>G2_N104.200.f - (N104.200)f K_COS</b>
PAR Das COS DARF Attribute, die übergeordneten Ordnern zugeordnet sind, NICHT ändern. <b>[<=]</b>

REQ(ids=A_16947)<b>A_16947 - (N104.300) K_COS</b>
PAR Wenn der Parameter operationMode in P1 einen Wert aus der Menge {'41', '81', 'C1'} besitzt dann MUSS das COS je nach Länge der Schlüsselreferenz keyRef folgende Operationen ausgeführen: <b>[<=]</b>

REQ(ids=G2_N104.300.a.1)<b>G2_N104.300.a.1 - (N104.300)a.1 K_COS</b>
PAR Wenn keyRef ein Oktett lang ist, dann SOLL mittels SearchKey( channelContext.currentFolder, keyRef, algId ) nach dem Schlüssel gesucht werden. Falls diese Funktion<br>i.   den Fehler keyNotFound meldet, dann MUSS dass Kommando mit dem Trailer KeyNotFound terminieren.<br>ii.  den Fehler notSupported meldet, dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren.<br>iii. keinen Fehler meldet dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16948)<b>A_16948 - (N104.300)a.2 K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden für den Fall einer ein Oktett langen Schlüsselreferenz keyRef unterbliebe eine Schlüsselsuche und es werde als Trailer NoError verwendet. <b>[<=]</b>

REQ(ids=A_16949)<b>A_16949 - (N104.300)b K_COS</b>
PAR Wenn keyRef acht Oktett lang ist (öffentliches Signaturprüfobjekt), dann MUSS mittels<br>SearchKey( channelContext.currentFolder, keyRef, verifyCertificate) nach dem Schlüssel gesucht werden. <b>[<=]</b>

REQ(ids=G2_N104.300.b.1)<b>G2_N104.300.b.1 - (N104.300)b.1 K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler keyNotFound meldet, dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N104.300.b.2)<b>G2_N104.300.b.2 - (N104.300)b.2 K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler notSupported meldet, dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N104.300.b.3)<b>G2_N104.300.b.3 - (N104.300)b.3 K_COS</b>
PAR Wenn die Schlüsselsuche keinen Fehler meldet, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=A_16950)<b>A_16950 - (N104.300)c K_COS</b>
PAR Wenn keyRef zwölf Oktett lang ist (öffentliches Authentisierungsobjekt, öffentliches Verschlüsselungsobjekt), dann MUSS mittels SearchKey( channelContext.currentFolder, keyRef, algId ) nach dem Schlüssel gesucht werden. <b>[<=]</b>

REQ(ids=G2_N104.300.c.1)<b>G2_N104.300.c.1 - (N104.300)c.1 K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler keyNotFound meldet, dann MUSS das Kommando mit dem Trailer KeyNotFound terminieren. <b>[<=]</b>

REQ(ids=G2_N104.300.c.2)<b>G2_N104.300.c.2 - (N104.300)c.2 K_COS</b>
PAR Wenn die Schlüsselsuche den Fehler notSupported meldet, dann MUSS das Kommando mit dem Trailer UnsupportedFunction terminieren. <b>[<=]</b>

REQ(ids=G2_N104.300.c.3)<b>G2_N104.300.c.3 - (N104.300)c.3 K_COS</b>
PAR Wenn die Schlüsselsuche keinen Fehler meldet, dann MUSS als Trailer NoError gewählt werden. <b>[<=]</b>

REQ(ids=G2_N104.320.a)<b>G2_N104.320.a - (N104.320.)a K_COS</b>
PAR Wenn als Trailer NoError verwendet wird, dann MÜSSEN in channelContext.keyReferenceList die durch die Parameter operationMode und crtTag gekennzeichneten Listenelemente mit den Parametern aus dem Datenfeld der Kommandonachricht gefüllt werden. <b>[<=]</b>

REQ(ids=G2_N104.320.b)<b>G2_N104.320.b - (N104.320)b K_COS</b>
PAR Wenn als Trailer nicht NoError verwendet wird, dann DARF channelContext.keyReferenceList NICHT verändert werden. <b>[<=]</b>

PAR (N104.400) Dieser Punkt ist absichtlich leer.
PAR (N104.500) Dieser Punkt ist absichtlich leer.
PAR -HEADING(ids=15)15 CosK_8e4 Authentisierungsprotokolle (normativ)
PAR Dieses Kapitel beschreibt, wie eine schlüsselbasierte Authentisierung zwischen einer externen Entität und dem COS abläuft. Die externe Entität wird als Gegenstelle bezeichnet. Aus Symmetriegründen und der leichteren Referenzierbarkeit innerhalb dieses Dokumentes wird eine sprachliche Darstellung gewählt, welche die Gegenstelle als Smartcard mit einem Funktionsumfang beschreibt, der dem Funktionsumfang dieses Dokumentes analog ist. Diese Darstellungsform beschränkt nicht die Allgemeingültigkeit, weil hier lediglich die Schnittstelle zwischen Gegenstelle und COS betrachtet wird, und für die Gegenstelle aus Sicht dieses Dokumentes auch eine beliebige andere Komponente mit entsprechender Funktionalität möglich ist.

PAR Abbildung 3, CosA_559: Kommunikationsmodell Gegenstelle, Steuersoftware und COS
PAR In diesem Kapitel wird folgendes Kommunikationsmodell verwendet:

LIST->
LITEM->PAR Eine Komponente COS besitze die in diesem Dokument spezifizierten Schnittstelleneigenschaften.LITEM->PAR Eine Komponente Gegenstelle besitze zur Komponente COS analoge Eigenschaften.LITEM->PAR Eine Komponente Steuersoftware besitze eine Ablauflogik. Zudem kommuniziert die Steuersoftware mit der Gegenstelle über den Kommunikationskanal Channel_a und mit dem COS über den Kommunikationskanal Channel_b. Diese beiden Kanäle entsprechen der physikalischen Schnittstelle in CosA_e09.
PAR Jedem, der in diesem Kapitel behandelten Authentisierungsverfahren, ist ein eigenes Unterkapitel gewidmet. Im Allgemeinen besteht die Authentisierung aus einer Sequenz von einem oder mehreren Kommandos, die über die Kommunikationskanäle Channel_a und Channel_b gesendet werden. Für alle Authentisierungsprotokolle gilt:
REQ(ids=A_15905)<b>A_15905 - (N104.600) K_externeWelt {K_Karte}</b>
PAR Wenn die Sequenz eines Authentisierungsprotokolls aus mehr als einem Kommando-Antwort-Paar besteht (siehe CosK_ado), so DARF diese Sequenz an der Schnittstelle "Channel_b" (siehe CosA_559) NICHT durch Kommandos unterbrochen werden, welche nicht zu dieser Sequenz gehören. <b>[<=]</b>

REQ(ids=A_15906)<b>A_15906 - (N104.700) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden bei Nichteinhaltung der Anforderung (N104.600) würde das COS<br>a. das unterbrechende Kommando akzeptieren, oder<br>b. das unterbrechende Kommando ablehnen, oder<br>c. ein Fortsetzen der unterbrochenen Sequenz akzeptieren, oder<br>d. ein Fortsetzen der unterbrochenen Sequenz ablehnen. <b>[<=]</b>

REQ(ids=A_15907)<b>A_15907 - (N104.800) K_COS</b>
PAR Es MUSS möglich sein, dass jede, der hier genannten Sequenzen, ungeschützt (ohne Secure Messaging) übertragen wird. Falls auch die geschützte Übertragung der Sequenz zu unterstützen ist, so ist dies im entsprechenden Unterkapitel vermerkt. <b>[<=]</b>

REQ(ids=A_15908)<b>A_15908 - (N104.850) K_externeWelt {K_Karte}</b>
PAR Wenn das erste Kommando dieser Sequenz<br>a. geschützt übertragen wird, dann MÜSSEN auch alle anderen Kommandos dieser Sequenz geschützt übertragen werden.<br>b. ungeschützt übertragen wird, dann MÜSSEN auch alle anderen Kommandos dieser Sequenz ungeschützt übertragen werden. <b>[<=]</b>

REQ(ids=A_15909)<b>A_15909 - (N104.900) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden die externe Welt sende eine Authentisierungssequenz mit Secure Messaging geschützt, obwolh dies nicht normativ gefordert ist und das COS würde dies<br>a. akzeptieren oder<br>b. ablehnen. <b>[<=]</b>

PAR -HEADING(ids=15.1)15.1 CosK_9bd Externe Authentisierung
PAR Dieses Unterkapitel behandelt die Authentisierung einer "Gegenstelle" gegenüber dem COS.

PAR Abbildung 4, CosA_336: Sequenzdiagramm zur externen Authentisierung
PAR Hinweis CosH_fce: Die Bedeutung der Bezeichnungen in CosA_336 ergibt sich aus dem jeweiligen Kontext der Kommandos gemäß CosK_3a7.
PAR -HEADING(ids=15.1.1)15.1.1 Externe Authentisierung mittels symmetrischer Schlüssel
PAR In einer früheren Dokumentenversion wurde in diesem Unterkapitel die einseitige symmetrische Authentisierung ohne Vereinbarung von Sessionkeys behandelt. Weil diese Art der Authentisierung nicht mehr zum normativen Umfang gehört, sind alle Anforderungen dieses Unterkapitels leer.
PAR (N105.000), (N105.100), (N105.200), (N105.300), (N105.400), (N105.500) Diese Anforderungen sind absichtlich leer.
PAR -HEADING(ids=15.1.2)15.1.2 CosK_9b6 RSA, asymmetrische Rollenauthentisierung, Option_RSA_CVC
PAR Für den Fall, dass eine externe Entität ihre Authentizität mittels eines RSA-Schlüsselpaares nachweisen will und dabei keine Sessionkeys ausgehandelt werden, ist folgende Sequenz zu wählen (vergleiche CosA_336):
REQ(ids=G2_N105.300)<b>G2_N105.300 - (N105.300) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Das erste Kommando der Sequenz MUSS GET CHALLENGE gemäß CosK_77f sein und über Channel_b geschickt werden. <b>[<=]</b>

REQ(ids=G2_N105.400)<b>G2_N105.400 - (N105.400) K_externeWelt {K_Karte}, Option_RSA_CVC</b>
PAR Das zweite Kommando über Channel_b ist das letzte dieser Sequenz und MUSS ein EXTERNAL AUTHENTICATE gemäß CosK_021 mit algId gleich rsaRoleCheck sein. <b>[<=]</b>

REQ(ids=G2_N105.500)<b>G2_N105.500 - (N105.500) K_COS, Option_RSA_CVC</b>
PAR Das COS MUSS die (mit Secure Messaging) geschützte Übertragung der Kommandos dieser Sequenz, welche über Channel_b gesendet werden, unterstützen. <b>[<=]</b>

PAR -HEADING(ids=15.1.3)15.1.3 CosK_101 ELC, asymmetrische Berechtigungsnachweis
PAR Für den Fall, dass eine externe Entität ihre Authentizität mittels eines ELC-Schlüsselpaares nachweisen will und dabei keine Sessionkeys ausgehandelt werden, ist folgende Sequenz zu wählen (vergleiche CosA_336):
REQ(ids=G2_N105.600)<b>G2_N105.600 - (N105.600) K_externeWelt {K_Karte}</b>
PAR Das erste Kommando der Sequenz MUSS GET CHALLENGE gemäß (N098.625) sein und über Channel_b geschickt werden. <b>[<=]</b>

REQ(ids=G2_N105.700)<b>G2_N105.700 - (N105.700) K_externeWelt {K_Karte}</b>
PAR Das zweite Kommando über Channel_b ist das letzte dieser Sequenz und MUSS ein EXTERNAL AUTHENTICATE gemäß (N083.500) mit algId aus der Menge {elcRoleCheck} sein. <b>[<=]</b>

REQ(ids=G2_N105.800)<b>G2_N105.800 - (N105.800) K_COS</b>
PAR Das COS MUSS die (mit Secure Messaging) geschützte Übertragung der Kommandos dieser Sequenz, welche über Channel_b gesendet werden, unterstützen. <b>[<=]</b>

PAR -HEADING(ids=15.2)15.2 CosK_0df Interne Authentisierung
PAR Für den Fall, dass eine externe Entität die Authentizität einer Smartcard mittels eines Schlüssels überprüfen will und dabei keine Sessionkeys ausgehandelt werden, ist folgende Sequenz zu wählen (vergleiche CosA_e0a):
REQ(ids=G2_N105.900)<b>G2_N105.900 - (N105.900) K_externeWelt {K_Karte}</b>
PAR Das erste Kommando über Channel_b ist das letzte dieser Sequenz für Channel_b und MUSS ein INTERNAL AUTHENTICATE gemäß (N086.400) mit einer algId aus folgender Menge sein: {    <br>    elcRoleAuthentication,<br>    rsaClientAuthentication,<br>    rsaRoleAuthentication (Option_RSA_CVC),<br>    signPKCS1_V1_5<br>}. <b>[<=]</b>

REQ(ids=G2_N106.000)<b>G2_N106.000 - (N106.000) K_COS</b>
PAR Das COS MUSS die (mit Secure Messaging) geschützte Übertragung der Kommandos dieser Sequenz, welche über Channel_b gesendet werden, unterstützen. <b>[<=]</b>


PAR Abbildung 5, CosA_e0a: Sequenzdiagramm zur internen Authentisierung
PAR Hinweis CosH_946: Die Bedeutung der Bezeichnungen in CosA_e0a ergibt sich aus dem jeweiligen Kontext der Kommandos gemäß CosK_3a7.
PAR -HEADING(ids=15.3)15.3 Card-2-Card-Authentisierung ohne Sessionkey-Aushandlung
PAR Die Card-2-Card-Authentisierung ohne Sessionkey Aushandlung ist eine spezielle Variante der in CosK_9bd und CosK_0df behandelten Verfahren, wobei die Gegenstelle definitiv ebenfalls eine Smartcard ist.
PAR Falls eine einseitige Authentisierung (nur eine der beiden Komponenten Gegenstelle oder COS authentisiert sich) beabsichtigt ist, wird je nach Richtung der Authentisierung entweder ein Algorithmus aus CosK_9bd oder aus CosK_0df gewählt.
PAR Falls eine gegenseitige Authentisierung (beide Komponenten, also sowohl Gegenstelle als auch COS, authentisieren sich) beabsichtigt ist, wird sowohl ein Algorithmus aus CosK_9db als auch ein Algorithmus aus CosK_0df gewählt. Typischerweise legen Zugriffsregeln der beteiligten Schlüssel fest, welche Komponente sich zuerst zu authentisieren hat.
PAR -HEADING(ids=15.4)15.4 Aushandlung von Sessionkey
PAR Dieses Unterkapitel behandelt die gegenseitige Authentisierung zweier Entitäten, wobei gleichzeitig Sessionkeys ausgehandelt werden.
PAR -HEADING(ids=15.4.1)15.4.1 CosK_b47 Sessionkeys mittels symmetrischer Authentisierungsobjekte
PAR Für den Fall, dass eine gegenseitige Authentisierung mittels symmetrischer Schlüssel durchzuführen ist und dabei Sessionkeys ausgehandelt werden, ist folgende Sequenz zu wählen (vergleiche CosA_a81):
REQ(ids=G2_N106.100)<b>G2_N106.100 - (N106.100) K_externeWelt {K_Karte}</b>
PAR Das erste Kommando der Sequenz MUSS GET CHALLENGE gemäß (N098.625) sein und über Channel_b zum COSb geschickt werden. Die dabei vom COSb erzeugte Zufallszahl wird mit R1 bezeichnet. <b>[<=]</b>

REQ(ids=G2_N106.200)<b>G2_N106.200 - (N106.200) K_externeWelt {K_Karte}</b>
PAR Das zweite Kommando der Sequenz MUSS über Channel_a zum COSa gesendet werden und MUSS ein INTERNAL AUTHENTICATE gemäß (N086.400) mit algId gleich symSessionkey4TC sein. Dabei MUSS cmdData ein token (siehe (N086.902)a.4) mit R1 und iccsn8 des COSb gemäß (N084.410)a.6.ii enthalten. Die Antwortdaten des COSa werden mit rspData.2 bezeichnet. <b>[<=]</b>

REQ(ids=G2_N106.300)<b>G2_N106.300 - (N106.300) K_externeWelt {K_Karte}</b>
PAR Das dritte Kommando der Sequenz MUSS über Channel_b zum COSb gesendet werden. Es MUSS ein MUTUAL AUTHENTICATE gemäß (N083.800) mit algId gleich symSessionkey4SM sein. Als Kommandodaten MUSS rspData.2 verwendet werden. Die Antwortdaten des COSb werden mit rspData.3 bezeichnet. <b>[<=]</b>

REQ(ids=G2_N106.400)<b>G2_N106.400 - (N106.400) K_externeWelt {K_Karte}</b>
PAR Das vierte Kommando ist das letzte dieser Sequenz und MUSS über Channel_a zum COSa gesendet werden. Es MUSS ein EXTERNAL AUTHENTICATE gemäß (N083.500) mit algId gleich symSessionkey4TC sein. Als Kommandodaten MUSS rspData.3 verwendet werden. <b>[<=]</b>

REQ(ids=A_15910)<b>A_15910 - (N106.500) K_TST</b>
PAR Die funktionale Eignung DARF WEDER dem Prüfling COSa noch dem Prüfling COSb mit der Begründung verwehrt werden die geschützte Übertragung der Sequenz würde<br>a. unterstützt<br>b. nicht unterstützt. <b>[<=]</b>


PAR Abbildung 6, CosA_a81: Sequenzdiagramm symmetrische Sessionkey-Aushandlung
PAR Hinweis CosH_399: Aus Gründen der Übersichtlichkeit wurden in Abbildung 6 kürzere Bezeichnungen verwendet, als bei der Beschreibung der Kommandos in Kapitel 14. Die Bedeutung der Bezeichnungen ergibt sich aus dem jeweiligen Kontext.
PAR -HEADING(ids=15.4.2)15.4.2 CosK_580 Sessionkeys mittels symmetrischer Kartenverbindungsobjekte
PAR Für den Fall, dass eine gegenseitige Authentisierung mittels symmetrischer Kartenverbindungsobjekte durchzuführen ist und dabei Sessionkeys ausgehandelt werden, ist folgende Sequenz zu wählen (vergleiche CosA_8da):
REQ(ids=G2_N106.540)<b>G2_N106.540 - (N106.540) K_COS, Option_kontaktlose_Schnittstelle oder Option_PACE_PCD</b>
PAR Das COS MUSS das PACE-Protokoll in der Version 2 gemäß [BSI-TR-03110-2#3.2] und [BSI-TR-03110-3] für OID aus folgender Menge unterstützen:<br>a. id-PACE-ECDH-GM-AES-CBC-CMAC-128 mit brainpoolP256r1<br>b. id-PACE-ECDH-GM-AES-CBC-CMAC-192 mit brainpoolP384r1<br>c. id-PACE-ECDH-GM-AES-CBC-CMAC-256 mit brainpoolP512r1 <b>[<=]</b>

REQ(ids=G2_N106.545)<b>G2_N106.545 - (N106.545)a K_COS, Option_kontaktlose_Schnittstelle</b>
PAR Das COS MUSS die PACE-Varianten aus (N106.540) in der Rolle "MRTD Chip (PICC)" unterstützen. <b>[<=]</b>

REQ(ids=G2_N106.545.b)<b>G2_N106.545.b - (N106.545)b K_COS, Option_PACE_PCD</b>
PAR Das COS MUSS die PACE-Varianten aus (N106.540) in der Rolle "Terminal (PCD)" unterstützen. <b>[<=]</b>

PAR Hinweis CosH_01a: In (N106.545)b ist absichtlich nur die Option_PACE_PCD enthalten, nicht aber die Option_kontaktlose_Schnittstelle.
REQ(ids=A_15911)<b>A_15911 - (N106.547) K_TST</b>
PAR Die funktionale Eignung DARF dem Prüfling NICHT mit der Begründung verwehrt werden die geschützte Übertragung der Sequenz würde<br>a. unterstützt<br>b. nicht unterstützt. <b>[<=]</b>

REQ(ids=G2_N106.550.a)<b>G2_N106.550.a - (N106.550)a K_externeWelt {K_Karte}</b>
PAR Im ersten Schritt MUSS zur Komponente COSa ein GENERAL AUTHENTICATE-Kommando gemäß (N085.001) geschickt werden. Die Antwortdaten enthalten das Kryptogramm z, welches im zweiten Schritt auf Seiten der Komponente COSb benötigt wird. <b>[<=]</b>

REQ(ids=G2_N106.550.b)<b>G2_N106.550.b - (N106.550)b K_externeWelt {K_Karte}</b>
PAR Im ersten Schritt MUSS zur Komponente COSb ein GENERAL AUTHENTICATE-Kommando gemäß (N085.031) geschickt werden. Die Antwortdaten enthalten den ephemeren öffentlichen Schlüssel ~PK1<sub>PCD</sub>, der im zweiten Schritt auf Seiten der Komponente COSa benötigt wird. <b>[<=]</b>

REQ(ids=G2_N106.552.a)<b>G2_N106.552.a - (N106.552)a K_externeWelt {K_Karte}</b>
PAR Im zweiten Schritt MUSS zur Komponente COSa ein GENERAL AUTHENTICATE-Kommando mit ~PK1<sub>PCD</sub> aus (N106.550)b gemäß (N085.003) geschickt werden. Die Antwortdaten enthalten den ephemeren öffentlichen Schlüssel ~PK1<sub>PICC</sub> welcher im dritten Schritt auf Seiten der Komponente COSb benötigt wird. <b>[<=]</b>

REQ(ids=A_15912)<b>A_15912 - (N106.552)b K_externeWelt {K_Karte}</b>
PAR Im zweiten Schritt MUSS zur Komponente COSb ein GENERAL AUTHENTICATE-Kommando mit z aus (N106.550)a gemäß (N085.033) geschickt werden. Die Antwortnachricht enthält kein Datenfeld. <b>[<=]</b>

REQ(ids=G2_N106.554)<b>G2_N106.554 - (N106.554) K_externeWelt {K_Karte}</b>
PAR Im dritten Schritt MUSS zum COSb ein GENERAL AUTHENTICATE-Kommando mit ~PK1<sub>PICC</sub> aus (N106.552)a gemäß (N085.035) geschickt werden. Die Antwortdaten enthalten den ephemeren öffentlichen Schlüssel ~PK2<sub>PCD</sub> welcher im vierten Schritt auf Seiten der Komponente COSa benötigt wird. <b>[<=]</b>

REQ(ids=G2_N106.556)<b>G2_N106.556 - (N106.556) K_externeWelt {K_Karte}</b>
PAR Im vierten Schritt MUSS zum COSa ein GENERAL AUTHENTICATE-Kommando mit ~PK2<sub>PCD</sub> aus (N106.554) gemäß (N085.005) geschickt werden. Die Antwortdaten enthalten den ephemeren öffentlichen Schlüssel ~PK2<sub>PICC</sub> welcher im fünften Schritt auf Seiten der Komponente COSb benötigt wird. <b>[<=]</b>

REQ(ids=G2_N106.558)<b>G2_N106.558 - (N106.558) K_externeWelt {K_Karte}</b>
PAR Im fünften Schritt MUSS zum COSb ein GENERAL AUTHENTICATE-Kommando mit ~PK2<sub>PICC</sub> aus (N106.556) gemäß (N085.037) geschickt werden. Die Antwortdaten enthalten einen CMAC T<sub>PCD</sub> über ~PK2<sub>PICC</sub> welcher im sechsten Schritt auf Seiten der Komponente COSa benötigt wird. <b>[<=]</b>

REQ(ids=G2_N106.560)<b>G2_N106.560 - (N106.560) K_externeWelt {K_Karte}</b>
PAR Im sechsten Schritt MUSS zum COSa ein GENERAL AUTHENTICATE-Kommando mit T<sub>PCD</sub> aus (N106.558) gemäß (N085.007) geschickt werden. Die Antwortdaten enthalten einen CMAC T<sub>PICC</sub> über ~PK2<sub>PCD</sub> welcher im siebten Schritt auf Seiten der Komponente COSb benötigt wird. <b>[<=]</b>

REQ(ids=G2_N106.562)<b>G2_N106.562 - (N106.562) K_externeWelt {K_Karte}</b>
PAR Im siebten Schritt MUSS zum COSb ein GENERAL AUTHENTICATE-Kommando mit T<sub>PICC</sub> aus (N106.560) gemäß (N085.039) geschickt werden. Die Antwortnachricht enthält kein Datenfeld. <b>[<=]</b>


PAR Abbildung 7, CosA_8da: Sequenzdiagramm PACE Authentisierung
PAR Hinweis CosH_c4c: Aus Gründen der Übersichtlichkeit wurden in CosA_8da kürzere Bezeichnungen verwendet, als bei der Beschreibung der Kommandos in CosK_72e. Die Bedeutung der Bezeichnungen ergibt sich aus dem jeweiligen Kontext.
PAR Hinweis CosH_afe: Aus Performanzgründen ist es für die Steuersoftware ratsam die Kommandos des ersten Schrittes zeitlich parallel an die Komponenten schicken. Analog ist es ratsam die Kommandos des zweiten Schrittes zeitlich parallel an die Komponenten zu schicken.
PAR -HEADING(ids=15.4.3)15.4.3 CosK_2da Sessionkeyaushandlung mittels RSA-Schlüssel, Option_DES
PAR Die folgenden Anforderungen sind absichtlich leer: (N106.600), (N106.700), (N106.800), (N106.900), (N107.000), (N107.100), (N107.200).
PAR Für den Fall, dass eine gegenseitige Authentisierung mittels asymmetrischer RSA-Schlüssel durchzuführen ist und dabei Sessionkeys ausgehandelt werden, ist folgende Sequenz zu wählen (vergleiche CosA_b19):
REQ(ids=G2_N106.600)<b>G2_N106.600 - (N106.600) K_externeWelt {K_Karte}, Option_DES</b>
PAR Das erste Kommando MUSS zum CosA_ gesendet werden und MUSS GET CHALLENGE gemäß CosK_77f sein. Die dabei vom CosA_ erzeugten Antwortdaten werden mit rspData.1 bezeichnet. <b>[<=]</b>

REQ(ids=G2_N106.700)<b>G2_N106.700 - (N106.700) K_externeWelt {K_Karte}, Option_DES</b>
PAR Das zweite Kommando MUSS zum COSb gesendet werden und MUSS ein INTERNAL AUTHENTICATE gemäß CosK_f9b mit algId gleich rsaSessionkey4SM sein. Dabei MUSS cmdData.2 = rspData.1 || ICCSN8.User gelten mit ICCSN8.User gleich iccsn8 (siehe (N019.900)c) aus CosA_. Wie die Instanz, welche die Kommando-APDU sendet, Kenntnis von ICCSN8.User erhält, ist nicht Gegenstand dieses Dokumentes. Die korrespondierenden Antwortdaten des COSb werden mit rspData.2 bezeichnet. <b>[<=]</b>

REQ(ids=G2_N106.800)<b>G2_N106.800 - (N106.800) K_externeWelt {K_Karte}, Option_DES</b>
PAR Das dritte Kommando MUSS zum CosA_ gesendet werden. Es MUSS ein EXTERNAL AUTHENTICATE gemäß CosK_021 mit algId gleich rsaSessionkey4TC sein. Als Kommandodaten MÜSSEN rspData.2 verwendet werden. <b>[<=]</b>

REQ(ids=G2_N106.900)<b>G2_N106.900 - (N106.900) K_externeWelt {K_Karte}, Option_DES</b>
PAR Das vierte Kommando MUSS zum COSb gesendet werden und MUSS GET CHALLENGE gemäß CosK_77f sein. Die dabei vom COSb erzeugten Antwortdaten werden mit rspData.4 bezeichnet. <b>[<=]</b>

REQ(ids=G2_N107.000)<b>G2_N107.000 - (N107.000) K_externeWelt {K_Karte}, Option_DES</b>
PAR Das fünfte Kommando MUSS zum CosA_ gesendet werden und MUSS ein INTERNAL AUTHENTICATE gemäß CosK_f9b mit algId gleich rsaSessionkey4TC sein. Dabei MUSS cmdData.5 = rspData.4 || ICCSN8.COS gelten mit ICCSN8.COS gleich iccsn8 (siehe (N019.900)c) aus COSb. Wie die Instanz, welche die Kommando-APDU sendet, Kenntnis von ICCSN8.COS erhält, ist nicht Gegenstand dieses Dokumentes. Die korrespondierenden Antwortdaten vom CosA_ werden mit rspData.5 bezeichnet. <b>[<=]</b>

REQ(ids=G2_N107.100)<b>G2_N107.100 - (N107.100) K_externeWelt {K_Karte}, Option_DES</b>
PAR Das sechste Kommando ist das letzte der Sequenz und MUSS zum COSb gesendet werden. Es MUSS ein ein EXTERNAL AUTHENTICATE gemäß CosK_021 mit algId gleich rsaSessionkey4SM sein. Als Kommandodaten MÜSSEN rspData.5 verwendet werden. <b>[<=]</b>

REQ(ids=A_15913)<b>A_15913 - (N107.200) K_TST, Option_DES</b>
PAR Die funktionale Eignung DARF WEDER dem Prüfling CosA_ noch dem Prüfling COSb mit der Begründung verwehrt werden die geschützte Übertragung der Sequenz würde<br>a. unterstützt<br>b. nicht unterstützt. <b>[<=]</b>


PAR Abbildung 8, CosA_b19: Sequenzdiagramm RSA-Sessionkey-Aushandlung
PAR Hinweis CosH_d37: Aus Gründen der Übersichtlichkeit wurden in CosA_b19 kürzere Bezeichnungen verwendet, als bei der Beschreibung der Kommandos in CosK_327. Die Bedeutung der Bezeichnungen ergibt sich aus dem jeweiligen Kontext.
PAR -HEADING(ids=15.4.4)15.4.4 CosK_2ed Sessionkeys mittels ELC-Schlüssel
PAR Hinweis CosH_398: Das hier vorgestellte Protokoll geht auf einen Vorschlag zurück, der im DIN NIA 17.4 vorgestellt wurde. Ein Sicherheitsbeweis liegt bislang nicht vor.
PAR Beim hier beschriebenen Authentisierungsprotokoll authentisieren sich zwei Protokollpartner A und B gegenseitig mittels asymmetrischer Kryptographie, die auf elliptischen Kurven basiert und handeln dabei Sessionkeys aus. Die Sessionkeys haben die Verwendungszwecke "Secure Messaging" und "Trusted Channel". Das Protokoll ist so aufgebaut, dass eine erfolgreiche Nutzung der Sessionkeys nur möglich ist, wenn die Verwendungszwecke in den Protokollpartnern unterschiedlich ist. Ohne Beschränkung der Allgemeingültigkeit sei hier angenommen, dass Protokollpartner A die Sessionkeys anschließend für den Zweck "Secure Messaging" nutzt. Dann ist es für eine erfolgreiche Nutzung der Sessionkeys zwingend erforderlich, dass der andere Protokollpartner B die Sessionkeys für den anderen Zweck "Trusted Channel" nutzt. Das Protokoll geht von folgenden Voraussetzungen aus:

ORDERED-LIST->
LITEM->PAR Beide Protokollpartner A und B verfügen über einen statischen (d. h. persistent gespeicherten) privaten Schlüssel PrK.LITEM->PAR Die beiden privaten Schlüssel PrK.a und PrK.b verwenden dieselben Domainparameter D.LITEM->PAR Zu beiden privaten Schlüsseln existiert jeweils ein CV-Zertifikat, welches den korrespondierenden öffentlichen Schlüssel enthält PuK.LITEM->PAR Die öffentlichen Schlüssel PuK.a und PuK.b werden der jeweiligen Gegenseite bekanntgegeben (d. h. die CV-Zertifikate werden mittels PSO Verify Certificate importiert).LITEM->PAR In der Komponente A wird der private Schlüssel PrK.a selektiert. Als algorithmIdentifier wird dabei elcSessionkey4SM verwendet.LITEM->PAR In der Komponente B wird der private Schlüssel PrK.b selektiert. Als algorithmIdentifier wird dabei elcSessionkey4TC verwendet.
PAR Im Rahmen des Authentisierungsprotokolls werden folgende Schritte durchlaufen:

ORDERED-LIST->
LITEM->PAR Im ersten Schritt wird jede Komponente aufgefordert, den importierten öffentlichen Schlüssel zu selektieren und ein ephemeres Schlüsselpaar zu erzeugen. Die öffentlichen Schlüssel der ephemeren Schlüsselpaare werden aus den Komponenten exportiert. Im Einzelnen:
ORDERED-LIST->
LITEM->PAR In Komponente A wird
ORDERED-LIST->
LITEM->PAR PuK.b selektiert undLITEM->PAR das ephemere Schlüsselpaar SK.a, PK.a generiert undLITEM->PAR PK.a exportiert.LITEM->PAR Gleichzeitig wird in der Komponente B
ORDERED-LIST->
LITEM->PAR PuK.a selektiert undLITEM->PAR das ephemere Schlüsselpaar SK.b, PK.b generiert undLITEM->PAR PK.b exportiert.LITEM->PAR Im zweiten Schritt werden die öffentlichen Teile der ephemeren Schlüsselpaare in die jeweils andere Komponente importiert und in beiden Komponenten werden zwei gemeinsame Geheimnisse berechnet und konkateniert. Im Einzelnen:
ORDERED-LIST->
LITEM->PAR In Komponente A wird
ORDERED-LIST->
LITEM->PAR der ephemere Schlüssel PK.b importiertLITEM->PAR das erste gemeinsame Geheimnis   K1    = ECKAvalue(PrK.a, PK.b, D) berechnet.LITEM->PAR das zweite gemeinsame Geheimnis K2    = ECKAvalue(SK.a, PuK.b, D) berechnet.LITEM->PAR Komponente A bildet die Schlüsselableitungsdaten K = K1 || K2.LITEM->PAR Der Sicherheitszustand der Komponente A wird entsprechend den Informationen aus dem CV-Zertifkat zu PuK.b gesetzt.LITEM->PAR Mittels der Schlüsselableitungsdaten K werden Sessionkeys berechnet.LITEM->PAR Gleichzeitig wird in der Komponente B
ORDERED-LIST->
LITEM->PAR der ephemere Schlüssel PK.a importiertLITEM->PAR das erste gemeinsame Geheimnis   K1    = ECKAvalue(SK.b, PuK.a, D) berechnet.LITEM->PAR das zweite gemeinsame Geheimnis K2    = ECKAvalue(PrK.b, PK.a, D) berechnet.LITEM->PAR Komponente B bildet die Schlüsselableitungsdaten K = K1 || K2.LITEM->PAR Der Sicherheitszustand der Komponente B wird entsprechend den Informationen aus dem CV-Zertifkat zu PuK.a gesetzt.LITEM->PAR Mittels der Schlüsselableitungsdaten K werden Sessionkeys berechnet.
PAR Komponente A bildet K1 mittels des statischen, privaten Schlüssels PrK.a und des ephemeren, öffentlichen Schlüssels PK.b. Demgegenüber bildet Komponente B K1 mittels des ephemeren, privaten Schlüssels SK.b und des statischen, öffentlichen Schlüssels PuK.a. Diese Asymmetrie ist der Grund, weshalb eine erfolgreiche Etablierung von nutzbaren Sessionkeys nur möglich ist, wenn die algorithmIdentifier, welche A und B bei der Selektion der privaten Schlüssel übergeben wurden, anzeigen, dass die Sessionkeys in A und B unterschiedliche Verwendungszwecke haben.
PAR Der Komponente A ist es nur dann mit an Sicherheit grenzender Wahrscheinlichkeit möglich dasselbe K1 wie Komponente B zu berechnen, wenn sie über PrK.a verfügt.
PAR Der Komponente B ist es nur dann mit an Sicherheit grenzender Wahrscheinlichkeit möglich dasselbe K2 wie Komponente A zu berechnen, wenn sie über PrK.b verfügt.
PAR Falls ein Angreifer C entweder Komponente A oder B simuliert, fände trotzdem ein vollständiger Protokolldurchlauf statt. Weder die andere Komponente noch die Steuersoftware haben die Möglichkeit festzustellen, dass anstelle einer authentischen Komponente ein Angreifer am Protokoll teilnimmt. Allerdings wird der Angreifer mit an Sicherheit grenzender Wahrscheinlichkeit andere Sessionkeys berechnen, als der authentische Protokollpartner.
PAR Simuliert der Angreifer die Komponente B, so wird nach dem Protokolldurchlauf in A ein zu B gehörender Sicherheitszustand gesetzt. Da der Angreifer nicht über die korrekten Sessionkeys verfügt, wird dieser Sicherheitszustand in A spätestens mit dem nächsten Kommando entweder wegen (N031.600)a.1 oder wegen (N031.700)a.2.i zurückgesetzt.
PAR Simuliert der Angreifer die Komponente A, so wird nach dem Protokolldurchlauf in B ein zu A gehörender Sicherheitszustand gesetzt. Gemäß der derzeitigen Spezifikationslage wäre es dem Angreifer dann mittels PSO Encipher möglich beliebige Paare von "plaintext" und "ciphertext" erzeugen lassen, oder mittels PSO Compute Cryptographic Checksum beliebige Paare von Nachrichten und zugehörigem MAC. Nützlich wären diese Paare nicht. Deshalb wird hier aus Performanzgründen darauf verzichtet, von der Komponente A einen Nachweis über den Besitz der Sessionkeys zu verlangen, bevor in Komponente B der Sicherheitszustand gesetzt wird.
PAR Mit an Sicherheit grenzender Wahrscheinlichkeit sind PK.a und PK.b verschieden, wenn A und B verschieden sind. Falls ein Angreifer C die Kommunikation so manipuliert, dass A identisch zu B ist (technisch wird dabei eine Smartcard auf unterschiedlichen logischen Kanälen angesprochen), dann ist dieser Angriff durch Vergleich von PK.a und PK.b erkennbar.

PAR Abbildung 9, CosA_7f8: Sequenzdiagramm ELC-Sessionkey-Aushandlung
PAR Für den Fall, dass eine gegenseitige Authentisierung mittels asymmetrischer ELC-Schlüssel durchzuführen ist und dabei Sessionkeys ausgehandelt werden, ist folgende Sequenz zu wählen (vergleiche CosA_7f8):
REQ(ids=G2_N107.220)<b>G2_N107.220 - (N107.220) K_externeWelt {K_Karte}</b>
PAR Im ersten Schritt MUSS zu jeder der beiden Komponenten ein GENERAL AUTHENTICATE-Kommando gemäß (N085.012) geschickt werden. Die beiden Antwortdaten enthalten je einen ephemeren, öffentlichen Schlüssel. <b>[<=]</b>

REQ(ids=G2_N107.230)<b>G2_N107.230 - (N107.230) K_externeWelt {K_Karte}</b>
PAR Im zweiten und letzten Schritt dieser Sequenz MUSS zu jeder der beiden Komponente ein GENERAL AUTHENTICATE-Kommando gemäß (N085.016) geschickt werden. <b>[<=]</b>

REQ(ids=A_15914)<b>A_15914 - (N107.235) K_TST</b>
PAR Die funktionale Eignung DARF WEDER dem Prüfling CosA_ noch dem Prüfling COSb mit der Begründung verwehrt werden die geschützte Übertragung der Sequenz würde<br>a. unterstützt<br>b. nicht unterstützt. <b>[<=]</b>

PAR Hinweis CosH_055: Aus Performanzgründen ist es für die Steuersoftware ratsam die Kommandos des ersten Schrittes zeitlich parallel an die Komponenten schicken. Analog ist es ratsam die Kommandos des zweiten Schrittes zeitlich parallel an die Komponenten zu schicken.
PAR -HEADING(ids=15.5)15.5 CosK_07f Statisches Secure Messaging
PAR Dieses Kapitel behandelt die Übertragung von Sessionkeys an ein COS.

PAR Abbildung 10, CosA_397: Sequenzdiagramm zur Übertragung von Sessionkeys
PAR Hinweis CosH_167: Die Bedeutung der Bezeichnungen in CosA_397 ergibt sich aus dem jeweiligen Kontext der Kommandos gemäß CosK_72e.
PAR Für den Fall, dass eine externe Entität Sessionkeys übertragen will, ist folgende Sequenz zu wählen (vergleiche CosA_e090):
REQ(ids=G2_N107.250)<b>G2_N107.250 - (N107.250) K_externeWelt {K_Karte}</b>
PAR Das erste Kommando der Sequenz MUSS über Channel_a geschickt werden und ein GENERAL AUTHENTICATE Kommando<br>a. gemäß (N085.022) sein, falls der in (N085.051)b beschriebene Fall vorliegt, oder<br>b. gemäß CosK_4e8 sein, falls der in (N085.051)d beschriebene Fall vorliegt. <b>[<=]</b>

REQ(ids=G2_N107.252)<b>G2_N107.252 - (N107.252) K_externeWelt {K_Karte}</b>
PAR Das zweite Kommando über Channel_a ist das letzte dieser Sequenz und MUSS ein GENERAL AUTHENTICATE Kommando<br>a. gemäß (N085.026) sein, falls der in (N085.051)b beschriebene Fall vorliegt, oder<br>b. gemäß (N085.041) sein, falls der in (N085.051)d beschriebene Fall vorliegt. <b>[<=]</b>

REQ(ids=G2_N107.254)<b>G2_N107.254 - (N107.254) K_TST</b>
PAR Die funktionale Eignung DARF dem Prüfling NICHT mit der Begründung verwehrt werden die geschützte Übertragung der Sequenz würde<br>a. unterstützt<br>b. nicht unterstützt. <b>[<=]</b>

PAR Hinweis CosH_b7c: Hintergründe zu dieser Art der Sessionkeyübertragung finden sich in CosK_537.
PAR -HEADING(ids=16)16 CosK_b1b Verschiedenes (normativ)
PAR -HEADING(ids=16.1)16.1 Identifier
PAR (ids=Tabelle-340,-CosT_2a4)Tabelle 340, CosT_2a4: Generische AlgorithmIdentifier für Authentisierungszwecke

TABLE(rows=8,cols=164+158+422)->
TR-> TH(0,0/1/1)->PAR Name TH(0,1/1/2)->PAR Oberbegriff für
TR-> TD(1,0/1/1)->PAR asymClientAuthentication TD(1,1/1/1)-> TD(1,2/1/1)->PAR rsaClientAuthentication
TR-> TD(2,0/1/1)->PAR asymRoleAuthentication TD(2,1/1/1)->PAR elcRoleAuthentication TD(2,2/1/1)->PAR rsaRoleAuthentication
TR-> TD(3,0/1/1)->PAR asymRoleCheck TD(3,1/1/1)->PAR elcRoleCheck TD(3,2/1/1)->PAR rsaRoleCheck
TR-> TD(4,0/1/1)->PAR asymSessionkey4SM TD(4,1/1/1)->PAR elcSessionkey4SM TD(4,2/1/1)->PAR rsaSessionkey4SM
TR-> TD(5,0/1/1)->PAR asymSessionkey4TC TD(5,1/1/1)->PAR elcSessionkey4TC TD(5,2/1/1)->PAR rsaSessionkey4TC
TR-> TD(6,0/1/1)->PAR symSessionkey4SM TD(6,1/1/1)->PAR aesSessionkey4SM TD(6,2/1/1)->PAR desSessionkey4SM
TR-> TD(7,0/1/1)->PAR symSessionkey4TC TD(7,1/1/1)->PAR aesSessionkey4TC TD(7,2/1/1)->PAR desSessionkey4TC
PAR (ids=Tabelle-341,-CosT_7a2)Tabelle 341, CosT_7a2: Konkrete AlgorithmIdentifier für Authentisierungszwecke

TABLE(rows=13,cols=165+156+423)->
TR-> TH(0,0/1/1)->PAR Name TH(0,1/1/1)->PAR Codierung TH(0,2/1/1)->PAR Verwendung
TR-> TD(1,0/1/1)->PAR aesSessionkey4SM<br>desSessionkey4SM TD(1,1/1/1)->PAR 0101 0100<sub>2</sub> = '54' TD(1,2/1/1)->PAR Symmetrisch, MUTUAL AUTHENTICATE<br>Sessionkeys für Secure Messaging
TR-> TD(2,0/1/1)->PAR aesSessionkey4TC<br>desSessionkey4TC TD(2,1/1/1)->PAR 0111 0100<sub>2</sub> = '74' TD(2,2/1/1)->PAR EXTERNAL AUTHENTICATE, INTERNAL AUTHENTICATE, Sessionkeys für PSO-Kommandos
TR-> TD(3,0/1/1)->PAR elcAsynchronAdmin TD(3,1/1/1)->PAR 1111 0100<sub>2</sub> = 'F4' TD(3,2/1/1)->PAR Asymmetrisch, GENERAL AUTHENTICATE,<br>asynchrone Administration
TR-> TD(4,0/1/1)->PAR elcRoleAuthentication TD(4,1/2/1)->PAR 0000 0000<sub>2</sub> = '00' TD(4,2/1/1)->PAR Asymmetrisch INTERNAL AUTHENTICATE
TR-> TD(5,0/1/1)->PAR elcRoleCheck TD(5,2/1/1)->PAR Asymmetrisch EXTERNAL AUTHENTICATE
TR-> TD(6,0/1/1)->PAR elcSessionkey4SM TD(6,1/1/1)->PAR 0101 0100<sub>2</sub> = '54' TD(6,2/1/1)->PAR Asymmetrisch, GENERAL AUTHENTICATE,<br>Sessionkeys für SecureMessaging
TR-> TD(7,0/1/1)->PAR elcSessionkey4TC TD(7,1/1/1)->PAR 1101 0100<sub>2</sub> = 'D4' TD(7,2/1/1)->PAR Asymmetrisch, GENERAL AUTHENTICATE,<br>Sessionkeys für PSO-Kommandos
TR-> TD(8,0/1/1)->PAR rsaClientAuthentication TD(8,1/1/1)->PAR 0000 0101<sub>2</sub> = '05' TD(8,2/1/1)->PAR INTERNAL AUTHENTICATE
TR-> TD(9,0/1/1)->PAR rsaRoleAuthentication,<br>Option_RSA_CVC TD(9,1/1/1)->PAR 0000 0000<sub>2</sub> = '00' TD(9,2/1/1)->PAR Asymmetrisch INTERNAL AUTHENTICATE
TR-> TD(10,0/1/1)->PAR rsaRoleCheck,<br>Option_RSA_CVC TD(10,1/1/1)->PAR 0000 0000<sub>2</sub> = '00' TD(10,2/1/1)->PAR Asymmetrisch EXTERNAL AUTHENTICATE
TR-> TD(11,0/1/1)->PAR rsaSessionkey4SM,<br>Option_DES TD(11,1/1/1)->PAR 0101 0100<sub>2</sub> = '54' TD(11,2/1/1)->PAR EXTERNAL AUTHENTICATE, INTERNAL AUTHENTICATE, Sessionkeys für SecureMessaging
TR-> TD(12,0/1/1)->PAR rsaSessionkey4TC,<br>Option_DES TD(12,1/1/1)->PAR 0111 0100<sub>2</sub> = '74' TD(12,2/1/1)->PAR EXTERNAL AUTHENTICATE, INTERNAL AUTHENTICATE, Sessionkeys für-PSO-Kommandos
PAR (ids=Tabelle-342,-CosT_605)Tabelle 342, CosT_605: AlgorithmIdentifier für Ver- und Entschlüsselung

TABLE(rows=8,cols=175+147+422)->
TR-> TH(0,0/1/1)->PAR Name TH(0,1/1/1)->PAR Codierung TH(0,2/1/1)->PAR Verwendung
TR-> TD(1,0/1/1)->PAR aesSessionkey TD(1,1/2/1)->PAR 0000 0000<sub>2</sub> = '00' TD(1,2/2/1)->PAR PSO Decipher + PSO Encipher
TR-> TD(2,0/1/1)->PAR desSessionkey,<br>Option_DES
TR-> TD(3,0/1/1)->PAR rsaDecipherOaep TD(3,1/1/1)->PAR 1000 0101<sub>2</sub> = '85' TD(3,2/2/1)->PAR PSO Decipher mit RSA
TR-> TD(4,0/1/1)->PAR rsaDecipherPKCS1_V1_5 TD(4,1/1/1)->PAR 1000 0001<sub>2</sub> = '81'
TR-> TD(5,0/1/1)->PAR rsaEncipherOaep TD(5,1/1/1)->PAR 0000 0101<sub>2</sub> = '05' TD(5,2/2/1)->PAR PSO Encipher + Transcipher mit RSA, gleich AlgorithmIdentifier für Decipher mod 128
TR-> TD(6,0/1/1)->PAR rsaEncipherPKCS1_V1_5 TD(6,1/1/1)->PAR 0000 0001<sub>2</sub> = '01'
TR-> TD(7,0/1/1)->PAR elcSharedSecretCalculation TD(7,1/1/1)->PAR 0000 1011<sub>2</sub> = '0B' TD(7,2/1/1)->PAR PSO Decipher mit ELC
PAR (ids=Tabelle-343,-CosT_c40)Tabelle 343, CosT_c40: AlgorithmIdentifier für Integrität und Authentizität

TABLE(rows=8,cols=118+114+512)->
TR-> TH(0,0/1/1)->PAR Name TH(0,1/1/1)->PAR Codierung TH(0,2/1/1)->PAR Verwendung
TR-> TD(1,0/1/1)->PAR aesSessionkey TD(1,1/2/1)->PAR 0000 0000<sub>2</sub> = '00' TD(1,2/2/1)->PAR PSO Compute Cryptographic Checksum +<br>PSO Verify Cryptographic Checksum
TR-> TD(2,0/1/1)->PAR desSessionkey,<br>Option_DES
TR-> TD(3,0/1/1)->PAR sign9796_2_DS2 TD(3,1/1/1)->PAR 0000 0111<sub>2</sub> = '07' TD(3,2/1/1)->PAR PSO Compute Digital Signature
TR-> TD(4,0/1/1)->PAR signPKCS1_V1_5 TD(4,1/1/1)->PAR 0000 0010<sub>2</sub> = '02' TD(4,2/1/1)->PAR PSO Compute Digital Signature
TR-> TD(5,0/1/1)->PAR signPSS TD(5,1/1/1)->PAR 0000 0101<sub>2</sub> = '05' TD(5,2/1/1)->PAR PSO Compute Digital Signature
TR-> TD(6,0/1/1)->PAR signECDSA TD(6,1/1/1)->PAR 0000 0000<sub>2</sub> = '00' TD(6,2/1/1)->PAR PSO Compute Digital Signature
TR-> TD(7,0/1/1)->PAR verifyCertificate TD(7,1/1/1)->PAR 'XX' TD(7,2/1/1)->PAR PSO Verify Certificate, da dieser Identifier nie an der physikalischen Schnittstelle verwendet wird, wird er hier nicht festgelegt
PAR (ids=Tabelle-344,-CosT_a91)Tabelle 344, CosT_a91: Object Identifier, alphabetisch sortiert (informativ)

TABLE(rows=27,cols=258+489)->
TR-> TH(0,0/1/1)->PAR Name und Codierung TH(0,1/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR ansix9p256r1<br>{1.2.840.10045.3.1.7}<br>'2A8648CE3D030107' TD(1,1/1/1)->PAR Domainparameter einer elliptischen Kurve gemäß [ANSI X9.62#L.6.4.3]
TR-> TD(2,0/1/1)->PAR ansix9p384r1<br>{1.3.132.0.34}<br>'2B81040022' TD(2,1/1/1)->PAR Domainparameter einer elliptischen Kurve gemäß [ANSI X9.62#L.6.5.2]
TR-> TD(3,0/1/1)->PAR authS_gemSpec-COS-G2_ecc-with-sha256<br>{1.3.36.3.5.3.1}<br>'2B2403050301' TD(3,1/1/1)->PAR öffentlicher Schlüssel in einem CV-Zertifikat,<br>Verwendungszweck Authentisierung, SHA_256
TR-> TD(4,0/1/1)->PAR authS_gemSpec-COS-G2_ecc-with-sha384<br>{1.3.36.3.5.3.2}<br>'2B2403050302' TD(4,1/1/1)->PAR öffentlicher Schlüssel in einem CV-Zertifikat,<br>Verwendungszweck Authentisierung, SHA_384
TR-> TD(5,0/1/1)->PAR authS_gemSpec-COS-G2_ecc-with-sha512<br>{1.3.36.3.5.3.3}<br>'2B2403050303' TD(5,1/1/1)->PAR öffentlicher Schlüssel in einem CV-Zertifikat,<br>Verwendungszweck Authentisierung, SHA_512
TR-> TD(6,0/1/1)->PAR authS_ISO9796-2Withrsa_sha256_mutual<br>{1.3.36.3.5.2.4}, Option_RSA_CVC<br>'2B2403050204' TD(6,1/1/1)->PAR authentication scheme with RSA signature and DSI according to [ISO/IEC 9796-2] and SHA-256 for mutual authentication with or without establishment of a Trusted Channel
TR-> TD(7,0/1/1)->PAR brainpoolP256r1<br>{1.3.36.3.3.2.8.1.1.7}<br>'2B2403030208010107' TD(7,1/1/1)->PAR Domainparameter einer elliptischen Kurve gemäß [RFC5639#3.4]
TR-> TD(8,0/1/1)->PAR brainpoolP384r1<br>{1.3.36.3.3.2.8.1.1.11}<br>'2B240303020801010b' TD(8,1/1/1)->PAR Domainparameter einer elliptischen Kurve gemäß [RFC5639#3.6]
TR-> TD(9,0/1/1)->PAR brainpoolP512r1<br>{1.3.36.3.3.2.8.1.1.13}<br>'2B240303020801010d' TD(9,1/1/1)->PAR Domainparameter einer elliptischen Kurve gemäß [RFC5639#3.7]
TR-> TD(10,0/1/1)->PAR ecdsa-with-SHA256<br>{1.2.840.10045.4.3.2}<br>'2A8648CE3D040302' TD(10,1/1/1)->PAR öffentlicher Schlüssel in einem CV-Zertifikat,<br>Verwendungszweck Prüfung von CVC, SHA_256
TR-> TD(11,0/1/1)->PAR ecdsa-with-SHA384<br>{1.2.840.10045.4.3.3}<br>'2A8648CE3D040303' TD(11,1/1/1)->PAR öffentlicher Schlüssel in einem CV-Zertifikat,<br>Verwendungszweck Prüfung von CVC, SHA_384
TR-> TD(12,0/1/1)->PAR ecdsa-with-SHA512<br>{1.2.840.10045.4.3.4}<br>'2A8648CE3D040304' TD(12,1/1/1)->PAR öffentlicher Schlüssel in einem CV-Zertifikat,<br>Verwendungszweck Prüfung von CVC, SHA_512
TR-> TD(13,0/1/1)->PAR id-ELC-shared-secret-calculation TD(13,1/1/1)->PAR Verschlüsselung gemäß (N004.500)
TR-> TD(14,0/1/1)->PAR id-PACE-ECDH-GM-AES-CBC-CMAC-128<br>{0.4.0.127.0.7.2.2.4.2.2}<br>'04007f00070202040202' TD(14,1/1/1)->PAR [BSI-TR-03110-3#A.1.1.1] Authentisierungsalgorithmus wobei die ausgehandelten Sessionkeys für Secure Messaging verwendet werden.
TR-> TD(15,0/1/1)->PAR id-PACE-ECDH-GM-AES-CBC-CMAC-192<br>{0.4.0.127.0.7.2.2.4.2.3}<br>'04007f00070202040203' TD(15,1/1/1)->PAR [BSI-TR-03110-3#A.1.1.1] Authentisierungsalgorithmus wobei die ausgehandelten Sessionkeys für Secure Messaging verwendet werden.
TR-> TD(16,0/1/1)->PAR id-PACE-ECDH-GM-AES-CBC-CMAC-256<br>{0.4.0.127.0.7.2.2.4.2.4}<br>'04007f00070202040204' TD(16,1/1/1)->PAR [BSI-TR-03110-3#A.1.1.1] Authentisierungsalgorithmus wobei die ausgehandelten Sessionkeys für Secure Messaging verwendet werden.
TR-> TD(17,0/1/1)->PAR id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-128<br>{0.4.0.127.0.7.2.3.4.2.2}<br>'04007f00070203040202' TD(17,1/1/1)->PAR Authentisierungsalgorithmus wobei die ausgehandelten Sessionkeys im Rahmen von PSO-Kommandos verwendet werden.
TR-> TD(18,0/1/1)->PAR id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-192<br>{0.4.0.127.0.7.2.3.4.2.3}<br>'04007f00070203040203' TD(18,1/1/1)->PAR Authentisierungsalgorithmus wobei die ausgehandelten Sessionkeys im Rahmen von PSO-Kommandos verwendet werden.
TR-> TD(19,0/1/1)->PAR id-PACE-PCD-ECDH-GM-AES-CBC-CMAC-256<br>{0.4.0.127.0.7.2.3.4.2.4}<br>'04007f00070203040204' TD(19,1/1/1)->PAR Authentisierungsalgorithmus wobei die ausgehandelten Sessionkeys im Rahmen von PSO-Kommandos verwendet werden.
TR-> TD(20,0/1/1)->PAR id-RSAES-OAEP<br>{1.2.840.113549.1.1.7}<br>'2A864886F70d010107' TD(20,1/1/1)->PAR Verschlüsselung gemäß [PKCS#1] Kapitel 7.1.1
TR-> TD(21,0/1/1)->PAR oid_cvc_fl_cms<br>{1.2.276.0.76.4.153}<br>'2A8214004C048119' TD(21,1/1/1)->PAR Werte gemäß [gemSpec_OID#Tab_PKI_408], Interpretation der flagList gemäß [gemSpec_PKI#Tab_PKI_911]
TR-> TD(22,0/1/1)->PAR oid_cvc_fl_ti<br>{1.2.276.0.76.4.152}<br>'2A8214004C048118' TD(22,1/1/1)->PAR Werte gemäß [gemSpec_OID#Tab_PKI_408], Interpretation der flagList gemäß [gemSpec_PKI#Tab_PKI_910]
TR-> TD(23,0/1/1)->PAR rsaEncryption<br>{1.2.840.113549.1.1.1}<br>'2A864886F70d010101' TD(23,1/1/1)->PAR Verschlüsselung gemäß [PKCS#1] Kapitel 7.2.1
TR-> TD(24,0/1/1)->PAR secp256r1 TD(24,1/1/1)->PAR identisch zu ansix9p256r1, siehe dort
TR-> TD(25,0/1/1)->PAR secp384r1 TD(25,1/1/1)->PAR identisch zu ansix9p384r1, siehe dort
TR-> TD(26,0/1/1)->PAR sigS_ISO9796-2Withrsa_sha256<br>{1.3.36.3.4.2.2.4}, Option_RSA_CVC<br>'2B240304020204' TD(26,1/1/1)->PAR signature scheme with RSA signature and DSI according to [ISO/IEC 9796-2] and SHA-256
PAR -HEADING(ids=16.2)16.2 Codierungen für Trailer
PAR (ids=Tabelle-345,-CosT_7aa)Tabelle 345, CosT_7aa: Trailer -> Fehlername

TABLE(rows=65,cols=62+184+497)->
TR-> TH(0,0/1/1)->PAR Wert TH(0,1/1/1)->PAR Name TH(0,2/1/1)->PAR Bedeutung
TR-> TD(1,0/1/1)->PAR '62 00' TD(1,1/1/1)->PAR DataTruncated TD(1,2/1/1)->PAR Antwortdaten unvollständig
TR-> TD(2,0/1/1)->PAR '62 81' TD(2,1/1/1)->PAR CorruptDataWarning TD(2,2/1/1)->PAR Die Integrität der Antwortdaten ist nicht gewährleistet
TR-> TD(3,0/1/1)->PAR '62 82' TD(3,1/1/1)->PAR EndOfFileWarning TD(3,2/1/1)->PAR Es wurden mehr Daten angefordert als die Datei enthält
TR-> TD(4,0/1/1)->PAR '62 82' TD(4,1/1/1)->PAR EndOfRecordWarning TD(4,2/1/1)->PAR Es wurden mehr Daten angefordert als der Rekord enthält
TR-> TD(5,0/1/1)->PAR '62 82' TD(5,1/1/1)->PAR UnsuccessfulSearch TD(5,2/1/1)->PAR Pattern wurde in keinem der adressierten Rekords gefunden
TR-> TD(6,0/1/1)->PAR '62 83' TD(6,1/1/1)->PAR FileDeactivated TD(6,2/1/1)->PAR File, auf welches sich die Operation bezieht, ist deaktiviert
TR-> TD(7,0/1/1)->PAR '62 85' TD(7,1/1/1)->PAR FileTerminated TD(7,2/1/1)->PAR File, auf welches sich die Operation bezieht, ist terminiert
TR-> TD(8,0/1/1)->PAR '62 87' TD(8,1/1/1)->PAR RecordDeactivated TD(8,2/1/1)->PAR Rekord, auf welchen sich Operation bezieht, ist deaktiviert
TR-> TD(9,0/1/1)->PAR '62 Cx' TD(9,1/1/1)->PAR TransportStatus TD(9,2/1/1)->PAR Indikation des Transportschutzverfahrens, siehe Tabelle 144
TR-> TD(10,0/1/1)->PAR '62 D0' TD(10,1/1/1)->PAR PasswordDisabled TD(10,2/1/1)->PAR Passwortobjekt ausgeschaltet, Verifikation nicht erforderlich
TR-> TD(11,0/1/1)->PAR '63 00' TD(11,1/1/1)->PAR AuthenticationFailure TD(11,2/1/1)->PAR Authentisierung fehlgeschlagen
TR-> TD(12,0/1/1)->PAR '63 CF' TD(12,1/1/1)->PAR NoAuthentication TD(12,2/1/1)->PAR Keine Authentisierung mit dem referenzierten Schlüssel
TR-> TD(13,0/1/1)->PAR '63 Cx' TD(13,1/1/1)->PAR RetryCounter TD(13,2/1/1)->PAR Wert des Fehlbedienungszählers
TR-> TD(14,0/1/1)->PAR '63 Cx' TD(14,1/1/1)->PAR UpdateRetryWarning TD(14,2/1/1)->PAR Schreibschwierigkeiten
TR-> TD(15,0/1/1)->PAR '63 Cx' TD(15,1/1/1)->PAR WrongSecretWarning TD(15,2/1/1)->PAR Falsches Passwort in den Kommandodaten
TR-> TD(16,0/1/1)->PAR '64 00' TD(16,1/1/1)->PAR EncipherError TD(16,2/1/1)->PAR Fehlerhafte Verschlüsselungsoperation
TR-> TD(17,0/1/1)->PAR '64 00' TD(17,1/1/1)->PAR KeyInvalid TD(17,2/1/1)->PAR Schlüsseldaten fehlen, Generierung erforderlich
TR-> TD(18,0/1/1)->PAR '64 00' TD(18,1/1/1)->PAR ObjectTerminated TD(18,2/1/1)->PAR Objekt befindet sich im Zustand "Termination state"
TR-> TD(19,0/1/1)->PAR '64 00' TD(19,1/1/1)->PAR ParameterMismatch TD(19,2/1/1)->PAR Domainparameter passen nicht zusammen
TR-> TD(20,0/1/1)->PAR '65 81' TD(20,1/1/1)->PAR MemoryFailure TD(20,2/1/1)->PAR Schreibfehler
TR-> TD(21,0/1/1)->PAR '67 00' TD(21,1/1/1)->PAR WrongRecordLength TD(21,2/1/1)->PAR Falsche Rekordlänge
TR-> TD(22,0/1/1)->PAR '68 81' TD(22,1/1/1)->PAR ChannelClosed TD(22,2/1/1)->PAR Logischer Kanal nicht geöffnet
TR-> TD(23,0/1/1)->PAR '69 81' TD(23,1/1/1)->PAR NoMoreChannelsAvailable TD(23,2/1/1)->PAR kein weiterer logischer Kanal verfügbar
TR-> TD(24,0/1/1)->PAR '69 81' TD(24,1/1/1)->PAR VolatileKeyWithoutLCS TD(24,2/1/1)->PAR volatile Schlüssel werden vom Kommando nicht unterstützt
TR-> TD(25,0/1/1)->PAR '69 81' TD(25,1/1/1)->PAR WrongFileType TD(25,2/1/1)->PAR Datei unterstützt das aktuelle Kommando nicht
TR-> TD(26,0/1/1)->PAR '69 82' TD(26,1/1/1)->PAR SecurityStatusNotSatisfied TD(26,2/1/1)->PAR Zugriffsregel nicht erfüllt
TR-> TD(27,0/1/1)->PAR '69 83' TD(27,1/1/1)->PAR CommandBlocked TD(27,2/1/1)->PAR Rücksetzen des Fehlbedienungszählers nicht mehr möglich
TR-> TD(28,0/1/1)->PAR '69 83' TD(28,1/1/1)->PAR KeyExpired TD(28,2/1/1)->PAR Der Gültigkeitsbereich des Schlüssels ist abgelaufen
TR-> TD(29,0/1/1)->PAR '69 83' TD(29,1/1/1)->PAR PasswordBlocked TD(29,2/1/1)->PAR Fehlbedienungszähler abgelaufen
TR-> TD(30,0/1/1)->PAR '69 85' TD(30,1/1/1)->PAR KeyAlreadyPresent TD(30,2/1/1)->PAR Schlüsseldaten bereits gesetzt, Generierung unmöglich
TR-> TD(31,0/1/1)->PAR '69 85' TD(31,1/1/1)->PAR LongPassword TD(31,2/1/1)->PAR Neues Passwort zu lang
TR-> TD(32,0/1/1)->PAR '69 85' TD(32,1/1/1)->PAR NoKeyReference TD(32,2/1/1)->PAR Schlüsselreferenz fehlt, MSE-Set ist notwendig
TR-> TD(33,0/1/1)->PAR '69 85' TD(33,1/1/1)->PAR NoPrkReference TD(33,2/1/1)->PAR Schlüsselreferenz fehlt, MSE-Set ist notwendig
TR-> TD(34,0/1/1)->PAR '69 85' TD(34,1/1/1)->PAR NoPukReference TD(34,2/1/1)->PAR Schlüsselreferenz fehlt, MSE-Set ist notwendig
TR-> TD(35,0/1/1)->PAR '69 85' TD(35,1/1/1)->PAR NoRandom TD(35,2/1/1)->PAR Keine Zufallszahl, GET CHALLENGE ist notwendig
TR-> TD(36,0/1/1)->PAR '69 85' TD(36,1/1/1)->PAR NoRecordLifeCycleStatus TD(36,2/1/1)->PAR Datei unterstützt das aktuelle Kommando nicht
TR-> TD(37,0/1/1)->PAR '69 85' TD(37,1/1/1)->PAR PasswordNotUsable TD(37,2/1/1)->PAR Transportschutz aktiv, CHANGE REFERENCE DATA notwendig
TR-> TD(38,0/1/1)->PAR '69 85' TD(38,1/1/1)->PAR WrongRandomLength TD(38,2/1/1)->PAR Zufallszahl hat falsche Länge, GET CHALLENGE erforderlich
TR-> TD(39,0/1/1)->PAR '69 85' TD(39,1/1/1)->PAR ShortPassword TD(39,2/1/1)->PAR Neues Passwort zu kurz
TR-> TD(40,0/1/1)->PAR '69 86' TD(40,1/1/1)->PAR NoCurrentEF TD(40,2/1/1)->PAR Kommandobearbeitung unmöglich, da keine Datei selektiert
TR-> TD(41,0/1/1)->PAR '69 88' TD(41,1/1/1)->PAR IncorrectSmDo TD(41,2/1/1)->PAR Fehlerhaftes Secure Messaging
TR-> TD(42,0/1/1)->PAR '6A 80' TD(42,1/1/1)->PAR NewFileSizeWrong TD(42,2/1/1)->PAR newFileSize kein Vielfaches der Rekordlänge
TR-> TD(43,0/1/1)->PAR '6A 80' TD(43,1/1/1)->PAR NumberPreconditionWrong TD(43,2/1/1)->PAR Vorbedingung zum Laden des Scenarios nicht erfüllt
TR-> TD(44,0/1/1)->PAR '6A 80' TD(44,1/1/1)->PAR NumberScenarioWrong TD(44,2/1/1)->PAR Scenario wurde bereits geladen
TR-> TD(45,0/1/1)->PAR '6A 80' TD(45,1/1/1)->PAR VerificationError TD(45,2/1/1)->PAR Fehlerhaftes CV-Zertifikat
TR-> TD(46,0/1/1)->PAR '6A 80' TD(46,1/1/1)->PAR WrongCiphertext TD(46,2/1/1)->PAR Fehlerhaftes Chiffrat
TR-> TD(47,0/1/1)->PAR `6A 80' TD(47,1/1/1)->PAR WrongToken TD(47,2/1/1)->PAR Token ist fehlerhaft
TR-> TD(48,0/1/1)->PAR '6A 81' TD(48,1/1/1)->PAR UnsupportedFunction TD(48,2/1/1)->PAR Schlüssel unterstützt den angegeben Algorithmus nicht
TR-> TD(49,0/1/1)->PAR '6A 82' TD(49,1/1/1)->PAR FileNotFound TD(49,2/1/1)->PAR Referenzierte Datei nicht gefunden
TR-> TD(50,0/1/1)->PAR '6A 83' TD(50,1/1/1)->PAR RecordNotFound TD(50,2/1/1)->PAR Referenzierter Rekord nicht verwendbar
TR-> TD(51,0/1/1)->PAR '6A 84' TD(51,1/1/1)->PAR DataTooBig TD(51,2/1/1)->PAR Zu viele Daten
TR-> TD(52,0/1/1)->PAR '6A 84' TD(52,1/1/1)->PAR FullRecordList TD(52,2/1/1)->PAR Rekordliste bereits komplett gefüllt
TR-> TD(53,0/1/1)->PAR '6A 84' TD(53,1/1/1)->PAR MessageTooLong TD(53,2/1/1)->PAR Klartext zu lang für Verschlüsselung
TR-> TD(54,0/1/1)->PAR '6A 84' TD(54,1/1/1)->PAR OutOfMemory TD(54,2/1/1)->PAR Zu wenig Speicherplatz
TR-> TD(55,0/1/1)->PAR '6A 88' TD(55,1/1/1)->PAR InconsistentKeyReference TD(55,2/1/1)->PAR Schlüsselreferenz im CV-Zertifikat fehlerhaft
TR-> TD(56,0/1/1)->PAR '6A 88' TD(56,1/1/1)->PAR KeyNotFound TD(56,2/1/1)->PAR Referenzierten Schlüssel nicht gefunden
TR-> TD(57,0/1/1)->PAR '6A 88' TD(57,1/1/1)->PAR PasswordNotFound TD(57,2/1/1)->PAR Referenziertes Passwort nicht gefunden
TR-> TD(58,0/1/1)->PAR '6A 88' TD(58,1/1/1)->PAR PrKNotFound TD(58,2/1/1)->PAR Referenzierten Schlüssel nicht gefunden
TR-> TD(59,0/1/1)->PAR '6A 88' TD(59,1/1/1)->PAR PukNotFound TD(59,2/1/1)->PAR Referenzierten Schlüssel nicht gefunden
TR-> TD(60,0/1/1)->PAR '6A 89' TD(60,1/1/1)->PAR DuplicatedObject TD(60,2/1/1)->PAR Neu anzulegendes Objekt existiert bereits
TR-> TD(61,0/1/1)->PAR '6A 8A' TD(61,1/1/1)->PAR DfNameExists TD(61,2/1/1)->PAR Neu anzulegende Applikation existiert bereits
TR-> TD(62,0/1/1)->PAR '6B 00' TD(62,1/1/1)->PAR OffsetTooBig TD(62,2/1/1)->PAR Offset zu groß
TR-> TD(63,0/1/1)->PAR '6D 00' TD(63,1/1/1)->PAR InstructionNotSupported TD(63,2/1/1)->PAR Der im INS-Byte angezeigte Befehl wird nicht unterstützt
TR-> TD(64,0/1/1)->PAR '90 00' TD(64,1/1/1)->PAR NoError TD(64,2/1/1)->PAR Normale Kommandoausführung, kein Fehler, keine Warnung
PAR -HEADING(ids=17)17 CosK_46a Hinweise zur Sicherheitsevaluierung (informativ)
PAR Der Hauptteil des Dokumentes enthält im Wesentlichen funktionale Anforderungen. Darüber hinaus sind bei der COS-Entwicklung auch Sicherheitsanforderungen zu beachten. Grundsätzlich sind Sicherheitsanforderungen in einem Protection Profile oder Security Target zu finden. In diesem Anhang werden Aspekte aufgelistet, die im Rahmen einer Evaluierung zu prüfen sind. Die hier genannte Liste erhebt keinen Anspruch auf Vollständigkeit.

ORDERED-LIST->
LITEM->PAR Gemäß (N034.400) und (N098.800)b ist es funktional zulässig, dass ein COS das Kommando GET CHALLENGE auch für andere, insbesondere sehr kleine Werte für Ne unterstützt. Im Rahmen einer Sicherheitsbetrachtung ist dann nachzuweisen, dass die in RND.ICC gespeicherte Zufallszahl nicht weniger zufällig erzeugte Bits enthält, als die in CosK_8c2 behandelten Varianten.LITEM->PAR Dieses Dokument beschreibt in (N001.200) lediglich die funktionalen Anforderungen an einen Zufallszahlengenerator. Die dort erzeugten Zufallszahlen werden für diverse Zwecke eingesetzt. Im Rahmen einer Sicherheitsbetrachtung ist nachzuweisen, dass die Zufallszahlen die in [BSI-TR-03116-1#3.8, 3.9] geforderte Qualität aufweisen.LITEM->PAR Dieses Dokument beschreibt in CosK_e9 lediglich die funktionalen Anforderungen an die Berechnung eines Fingerprints. Im Rahmen einer Sicherheitsbetrachtung ist nachzuweisen, dass
ORDERED-LIST->
LITEM->PAR der Repräsentant M des COS tatsächlich alle Bestandteile des COS umfasst.LITEM->PAR bei der Berechnung des Fingerprints gemäß (N096.478) keine Informationen über den Objektcode des COS via Seitenkanäle die Smartcard verlassen.
PAR -HEADING(ids=18)18 CosK_9b0 Vorgaben zur Performanz
PAR -HEADING(ids=18.1)18.1 Einführung (informativ)
PAR Die Akzeptanz der Smartcards im Gesundheitswesen und der damit verbundenen Abläufe in den medizinischen Einrichtungen (Praxis, Apotheke, Krankenhaus, …) hängt stark von den Zeiten ab, die für einzelne Aktionen benötigt werden. Um im Gesamtsystem zu akzeptablen Werten zu kommen, sind für die einzelnen Komponenten Vorgaben zu treffen, die als zulassungsrelevant in die jeweiligen Spezifikationen aufgenommen werden. In diesem Dokument werden entsprechende Vorgaben für Smartcards im Gesundheitswesen festgelegt.
PAR Es werden sowohl die Randbedingungen als auch die Messparameter festgelegt, um reproduzierbare und aussagekräftige Messungen zu ermöglichen. Es werden Vorgaben für verschiedene Szenarien getroffen. Die ermittelten Messwerte werden über ein Punktesystem bewertet. Die Gesamtpunktzahl setzt sich aus einer gewichteten Addition aller Einzelpunktzahlen zusammen. Das COS wird nur dann von der gematik zugelassen, wenn es eine definierte Mindestpunktzahl (siehe (N109.700)) erreicht.
PAR -HEADING(ids=18.2)18.2 Messaufbau (normativ)
PAR Die Bearbeitungszeiten eines Kommandos werden mit dem im Folgenden beschriebenen Messaufbau durchgeführt:

PAR Abbildung 11, CosA_a56: Komponentendiagramm Performanzmessplatz
PAR Die Komponente Steuersoftware führt die Performanzmessung durch und protokolliert dabei die Messergebnisse. Diese Komponente besitzt logisch gesehen zwei Kommunikationskanäle zum Interface Device (IFD, Kartenleser). Der eine Kanal transportiert Kommando und Antwort-APDUs, die vom IFD zum Prüfling weitergeleitet werden. Der zweite Kanal dient der Steuerung des IFD sowie dem Auslesen der Laufzeiten, die vom IFD gemessen werden.
PAR Die Komponente Interface Device (IFD) transferiert APDUs gemäß der elektrischen Schnittstelle vom und zum Prüfling. Dabei ermittelt das IFD die Bearbeitungszeit eines Kommando-Antwort-APDU-Paares. Wichtig ist dabei, dass das IFD die maximale Übertragungskapazität des Prüflings unterstützt (siehe CosK_6c4).
PAR Die Komponente "Device under Test" (DuT) repräsentiert den Prüfling, dessen Performanz zu ermitteln ist.
PAR -HEADING(ids=18.3)18.3 Anforderungen an die Steuersoftware (normativ)
REQ(ids=A_16953)<b>A_16953 - (N107.300) K_Performanztest</b>
PAR Die Steuersoftware MUSS in der Lage sein, die einzelnen Schritte der Performanzmessung auszuführen, zu protokollieren und das Gesamtergebnis der Messung aus den einzelnen Resultaten zu ermitteln. <b>[<=]</b>

PAR -HEADING(ids=18.4)18.4 CosK_6c4 Anforderungen an das Interface Device (IFD) (normativ)
PAR Bezüglich der Schnittstelle des Interface Devices IFD zum Prüfling DuT gilt:
REQ(ids=A_16954)<b>A_16954 - (N107.350)a K_Performanztest {IFD}</b>
PAR Das IFD MUSS das Übertragungsprotokoll T=1 gemäß CosK_36d unterstützen. <b>[<=]</b>

REQ(ids=A_16955)<b>A_16955 - (N107.350)b K_Performanztest {IFD}</b>
PAR Das IFD SOLL das Übertragungsprotokoll [ISO/IEC 7816-12] gemäß CosK_70c unterstützen. <b>[<=]</b>

REQ(ids=A_16956)<b>A_16956 - (N107.350)c K_Performanztest {IFD}</b>
PAR Das IFD SOLL das kontaktlose Übertragungsprotokoll gemäß CosK_009 unterstützen. <b>[<=]</b>

PAR -HEADING(ids=18.4.1)18.4.1 Anforderungen an das IFD bezüglich T=1
PAR Dieses Unterkapitel enthält die Anforderungen an das IFD bezüglich des Übertragungsprotokolls T=1 gemäß CosK_36d.
REQ(ids=A_16959)<b>A_16959 - (N107.400) K_Performanztest {IFD}</b>
PAR Der Übertragungskanal TPDU_Channel des IFD SOLL die maximale Übertragungskapazität des Prüflings DuT unterstützen. Im Einzelnen bedeutet das: <b>[<=]</b>

REQ(ids=A_16960)<b>A_16960 - (N107.500) K_Performanztest {IFD}</b>
PAR Das IFD MUSS im Rahmen einer PPS-Sequenz alle Werte für PPS1 aus der Menge {'18', '95', '96', '97'} unterstützen.
PAR (ids=Tabelle-346,-CosT_719)Tabelle 346, CosT_719: Bedeutung PPS1 gemäß [ISO/IEC 7816-3#Table 7 und 8]

TABLE(rows=5,cols=59+127+143+111)->
TR-> TH(0,0/1/1)->PAR PPS1 TH(0,1/1/1)->PAR Teilerfaktor TH(0,2/1/1)->PAR f<sub>max</sub> / [MHz] TH(0,3/1/1)->PAR C / [kBaud]
TR-> TD(1,0/1/1)->PAR '18' TD(1,1/1/1)->PAR   372/12 = 31 TD(1,2/1/1)->PAR 5 TD(1,3/1/1)->PAR 161
TR-> TD(2,0/1/1)->PAR '95' TD(2,1/1/1)->PAR   512/16 = 32 TD(2,2/1/1)->PAR 5 TD(2,3/1/1)->PAR 156
TR-> TD(3,0/1/1)->PAR '96' TD(3,1/1/1)->PAR   512/32 = 16 TD(3,2/1/1)->PAR 5 TD(3,3/1/1)->PAR 313
TR-> TD(4,0/1/1)->PAR '97' TD(4,1/1/1)->PAR   512/64 =   8 TD(4,2/1/1)->PAR 5 TD(4,3/1/1)->PAR 625
PAR <b>[<=]</b>

REQ(ids=A_16961)<b>A_16961 - (N107.600) K_Performanztest {IFD}</b>
PAR Das IFD MUSS eine Versorgungsspannung U<sub>cc</sub> gemäß [ISO/IEC 7816-3#Table 1] für Class A und Class B liefern. <b>[<=]</b>

REQ(ids=A_16962)<b>A_16962 - (N107.700) K_Performanztest {IFD}</b>
PAR Das IFD MUSS einen Versorgungsstrom I<sub>cc</sub> gemäß [ISO/IEC 7816-3#Table 1] für Class A und Class B liefern. <b>[<=]</b>

REQ(ids=A_16963)<b>A_16963 - (N107.800) K_Performanztest {IFD}</b>
PAR Das IFD MUSS während der Performanzmessung ein Clocksignal mit einer Frequenz aus dem Intervall [4,95, 5,05] MHz liefern. <b>[<=]</b>

REQ(ids=A_16964)<b>A_16964 - (N107.900) K_Performanztest {IFD}</b>
PAR Das IFD MUSS "direct convention" (siehe [ISO/IEC 7816-3#8.1]) unterstützen. <b>[<=]</b>

REQ(ids=A_16965)<b>A_16965 - (N108.000) K_Performanztest {IFD}</b>
PAR Wenn das Byte TC<sub>1</sub> im ATR fehlt, dann MUSS das IFD beim Senden eine "extra guard time" von 12 etu verwenden (siehe [ISO/IEC 7816-3#8.3]). <b>[<=]</b>

REQ(ids=A_16966)<b>A_16966 - (N108.100) K_Performanztest {IFD}</b>
PAR Wenn das Byte TC<sub>1</sub> im ATR vorhanden ist, dann MUSS das IFD beim Senden eine "extra guard time" von 11 etu verwenden (siehe [ISO/IEC 7816-3#8.3 und 11.2]). <b>[<=]</b>

REQ(ids=A_16967)<b>A_16967 - (N108.200) K_Performanztest {IFD}</b>
PAR Das IFD MUSS beim Empfang eine "character guard time" von 11 etu unterstützen (siehe [ISO/IEC 7816-3#11.2]). <b>[<=]</b>

REQ(ids=A_16968)<b>A_16968 - (N108.300) K_Performanztest {IFD}</b>
PAR Das IFD MUSS BGT = 22 etu verwenden (siehe [ISO/IEC 7816-3#11.2]). <b>[<=]</b>

REQ(ids=A_16969)<b>A_16969 - (N108.400) K_Performanztest {IFD}</b>
PAR Das IFD MUSS für IFSC einen Wert von 254 unterstützen (siehe [ISO/IEC 7816-3#11.4.2]). <b>[<=]</b>

REQ(ids=A_16970)<b>A_16970 - (N108.500) K_Performanztest {IFD}</b>
PAR Das IFD MUSS für IFSD einen Wert von 254 unterstützen (siehe [ISO/IEC 7816-3#11.4.2]). <b>[<=]</b>

REQ(ids=A_16971)<b>A_16971 - (N108.600) K_Performanztest {IFD}</b>
PAR Das IFD<br>a. MUSS für eine Kommandonachricht 4096 und SOLL 32.768 als APDU Länge unterstützen.<br>b. MUSS für eine Antwortnachricht 65.638 als APDU Länge unterstützen. <b>[<=]</b>

PAR -HEADING(ids=18.4.2)18.4.2 Anforderungen an das IFD für [ISO/IEC 7816-12] Datenübertragung
PAR Dieses Unterkapitel enthält die Anforderungen an das IFD des Performanztest bezüglich einer Datenübertragung gemäß [ISO/IEC 7816-12].
PAR Hinweis CosH_f60: Die Anforderungen werden in einer späteren Dokumentenversion ergänzt.
PAR -HEADING(ids=18.4.3)18.4.3 Anforderungen an das IFD bezüglich kontaktloser Datenübertragung
PAR Dieses Unterkapitel enthält die Anforderungen an das IFD des Performanztest bezüglich des kontaktlosen Übertragungsprotokolls gemäß CosK_009.
PAR Hinweis CosH_31f: Die Anforderungen werden in einer späteren Dokumentenversion ergänzt.
PAR -HEADING(ids=18.5)18.5 Allgemeines (normativ)
PAR -HEADING(ids=18.5.1)18.5.1 Normale Zeitmessung
PAR -HEADING(ids=18.5.1.1)18.5.1.1 CosK_056 Normale Zeitmessung für das Übertragungsprotokoll T=1
PAR Hier wird die standardmäßig verwendete Zeitmessung für das Übertragungsprotokoll T=1 beschrieben. Es ist möglich, dass hiervon im Einzelfall abgewichen wird. Darauf wird gegebenenfalls explizit hingewiesen.
REQ(ids=A_16972)<b>A_16972 - (N108.700) K_Performanztest</b>
PAR Die normale Zeitmessung MUSS die Zeitspanne t<sub>Run</sub> = t<sub>End</sub> – t<sub>Start</sub> – t<sub>IO</sub> ermitteln, wobei folgende Definitionen gelten:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der Zeitpunkt t<sub>Start</sub> ist durch den Beginn des ersten Startbits des ersten Characters (siehe [ISO/IEC 7816-3#Figure 7]) der ersten TPDU (siehe [ISO/IEC 7816-3#Figure 23]) gekennzeichnet, welche zur Übertragung einer Kommando-APDU verwendet wird.LITEM->PAR Der Zeitpunkt t<sub>End</sub> ist durch das Ende des letzten Paritybits des letzten Characters der letzten TPDU gekennzeichnet, welche zur Übertragung der zugehörigen Antwort-APDU verwendet wird.LITEM->PAR Die Zeitspanne t<sub>IO</sub> berücksichtigt die Übertragungszeit von Kommando und Antwort-APDU. Sie MUSS wie folgt berechnet werden:
ORDERED-LIST->
LITEM->PAR Sei N<sub>cmd_APDU</sub> die Anzahl Oktette in der Kommando-APDU, dann gilt für die Anzahl übertragener Oktette N<sub>cmd_TPDU</sub> auf TPDU-Ebene falls N<sub>cmd_APDU</sub> größer gleich 1 ist und das Epilogue Field einen "longitudinal redundance code" enthält (siehe [ISO/IEC 7816-3#11.3.4]):    <br>          N<sub>cmd_TPDU</sub> = N<sub>cmd_APDU</sub> + 8 ceiling( N<sub>cmd_APDU</sub> / 254 ) – 4.LITEM->PAR Für die Anzahl N<sub>cmd_etu</sub> folgt unter der Vorraussetzung, dass pro Oktett 11 etu benötigt werden und eine "block guard time" von 22 etu berücksichtigt wird (siehe [ISO/IEC 7816-3#11.2]):     <br>          N<sub>cmd_etu</sub> = 11 N<sub>cmd_TPDU</sub> + 22 ceiling( N<sub>cmd</sub><sub>_APDU</sub> / 254 ).LITEM->PAR Analog gilt für die Antwort-APDU:    <br>               N<sub>rsp_TPDU</sub> = N<sub>rsp_APDU</sub> + 8 ceiling( N<sub>rsp</sub><sub>_APDU</sub> / 254 ) – 4     <br>und          N<sub>rsp_etu</sub>    = 11 N<sub>rsp_TPDU</sub> + 22 floor( N<sub>rsp_APDU</sub> / 254 ).LITEM->PAR Daraus folgt:     t<sub>IO</sub>    = ( N<sub>cmd</sub><sub>_etu</sub> + N<sub>rsp_etu</sub> ) Teilerfaktor / f<sub>max</sub> mit Teilerfaktor und f<sub>max</sub> in Abhängigkeit von PPS1 aus CosT_719.
PAR <b>[<=]</b>

PAR -HEADING(ids=18.5.1.2)18.5.1.2 Normale Zeitmessung für das Übertragungsprotokoll gemäß [ISO/IEC 7816-12]
PAR Hier wird die standardmäßig verwendete Zeitmessung für Übertragungsprotokoll gemäß [ISO/IEC 7816-12] beschrieben. Es ist möglich, dass hiervon im Einzelfall abgewichen wird. Darauf wird gegebenenfalls explizit hingewiesen.
PAR Hinweis CosH_476: Die Anforderungen werden in einer späteren Dokumentenversion ergänzt.
PAR -HEADING(ids=18.5.1.3)18.5.1.3 Normale Zeitmessung für die kontaktlose Datenübertragung
PAR Hier wird die standardmäßig verwendete Zeitmessung für die kontaktlose Übertragungsprotokoll beschrieben. Es ist möglich, dass hiervon im Einzelfall abgewichen wird. Darauf wird gegebenenfalls explizit hingewiesen.
PAR Hinweis CosH_e03: Die Anforderungen werden in einer späteren Dokumentenversion ergänzt.
PAR -HEADING(ids=18.5.2)18.5.2 Reguläre Aktivierung der Smartcard
PAR -HEADING(ids=18.5.2.1)18.5.2.1 CosK_064 Reguläre Aktivierung für das Übertragungsprotokoll T=1
PAR Hier wird die standardmäßige Aktivierung der Karte für das Übertragungsprotokoll T=1 beschrieben, die der Testvorbereitung dient. Es ist möglich, dass hiervon im Einzelfall abgewichen wird. Darauf wird gegebenenfalls explizit hingewiesen.
REQ(ids=G2_N108.800)<b>G2_N108.800 - (N108.800) K_Performanztest</b>
PAR Schritt 1: Im Rahmen der regulären Aktivierung der Smartcard MUSS zunächst eine Aktivierung gemäß (N023.920)a und (N023.920)b erfolgen. <b>[<=]</b>

REQ(ids=G2_N108.900)<b>G2_N108.900 - (N108.900) K_Performanztest</b>
PAR Schritt 2: Es MUSS eine PPS-Sequenz gemäß [ISO/IEC 7816-3] erfolgen. Die Bits b4 bis b1 in PPS0 MÜSSEN das Übertragungsprotokoll T=1 anzeigen. Als PPS1 MUSS der Wert von TA<sub>1</sub> aus dem ATR verwendet werden. <b>[<=]</b>

REQ(ids=G2_N109.000)<b>G2_N109.000 - (N109.000) K_Performanztest</b>
PAR Schritt 3: Das IFD MUSS der Smartcard den Wert von IFSD = 254 präsentieren. <b>[<=]</b>

REQ(ids=G2_N109.100)<b>G2_N109.100 - (N109.100) K_Performanztest</b>
PAR Schritt 4: Es MUSS eine beliebige Kommando-APDU bearbeitet werden. Einzige Anforderung an diese Kommando-APDU ist, dass sie so gewählt werden MUSS, dass der Trailer NoError anzeigt und der auszuführende Testfall nicht beeinflusst wird. Hier SOLL eine Selektion von root gemäß (N040.800) verwendet werden. <b>[<=]</b>

PAR Hinweis CosH_ca9: Die hier beschriebene reguläre Aktivierung hat das Ziel, die Smartcard vollständig zu booten. Typischerweise sind bei aktuellen Smartcard-Betriebssystemen die Initialisierungen so umfangreich, dass sie nicht vollständig innerhalb der Sendezeit des ATR ausführbar sind. Deshalb wird der Smartcard durch das abschließende Kommando genügend Zeit zur Verfügung gestellt, die typischerweise nicht relevant für die Performanzmessung ist.
PAR -HEADING(ids=18.5.2.2)18.5.2.2 Reguläre Aktivierung für das Übertragungsprotokoll gemäß [ISO/IEC 7816-12]
PAR Hier wird die standardmäßige Aktivierung der Karte für das Übertragungsprotokoll gemäß [ISO/IEC 7816-12] beschrieben, die der Testvorbereitung dient. Es ist möglich, dass hiervon im Einzelfall abgewichen wird. Darauf wird gegebenenfalls explizit hingewiesen.
PAR Hinweis CosH_2c0: Die Anforderungen werden in einer späteren Dokumentenversion ergänzt.
PAR -HEADING(ids=18.5.2.3)18.5.2.3 Reguläre Aktivierung für die kontaktlose Datenübertragung
PAR Hier wird die standardmäßige Aktivierung der Karte für das kontaktlose Übertragungsprotokoll beschrieben, die der Testvorbereitung dient. Es ist möglich, dass hiervon im Einzelfall abgewichen wird. Darauf wird gegebenenfalls explizit hingewiesen.
PAR Hinweis CosH_473: Die Anforderungen werden in einer späteren Dokumentenversion ergänzt.
PAR -HEADING(ids=18.5.3)18.5.3 Punkteermittlung
PAR (ids=Tabelle-347,-CosT_508)Tabelle 347, CosT_508: Definition der Funktion P = points( ... )

TABLE(rows=5,cols=73+34+411)->
TR-> TD(0,0/2/1)->PAR Input: TD(0,1/1/1)->PAR t TD(0,2/1/1)->PAR n-Tupel mit Zeiten von n Einzelmessungen
TR-> TD(1,1/1/1)->PAR T<sub>R</sub> TD(1,2/1/1)->PAR Referenzzeit
TR-> TD(2,0/1/1)->PAR Output: TD(2,1/1/1)->PAR P TD(2,2/1/1)->PAR Gewichtete Qualität der Messzeit
TR-> TD(3,0/1/1)->PAR Errors: TD(3,1/1/1)->PAR – TD(3,2/1/1)->PAR Keine
TR-> TD(4,0/1/1)->PAR Notation: TD(4,1/1/1)-> TD(4,2/1/1)->PAR P = points( t, T<sub>R</sub> )
PAR Es gelten folgende Definitionen:    <br>(N109.200) Diese Anforderung ist absichtlich leer. Ihr Inhalt wurde nach (N109.450)c verschoben.<br>(N109.300) Diese Anforderung ist absichtlich leer. Ihr Inhalt wurde nach (N109.450)d verschoben.<br>(N109.400) Diese Anforderung ist absichtlich leer. Ihr Inhalt wurde nach (N109.450)e verschoben.
REQ(ids=A_16978)<b>A_16978 - (N109.450) K_Performanztest</b>


PAR Die Funktion P besteht aus dem Faktor f<sub>1</sub> und f<sub>2</sub> und wird durch T<sub>R</sub> gewichtet. Im Faktor f<sub>2</sub> wirkt eine größere Standardabweichung über den Faktor f<sub>1</sub> wie eine verkleinerte Referenzzeit T<sub>R</sub>.
PAR Wenn die Standardabweichung null ist, dann ist der Faktor f<sub>1</sub> exakt eins. Größere Standardabweichungen führen zu kleineren Faktoren und damit zu geringeren Punktzahlen P.
PAR Der Faktor f<sub>2</sub> setzt den Mittelwert X in Relation zur Referenzzeit T<sub>R</sub>. Deshalb wird f<sub>2</sub> als Funktion von X aufgefasst, die durch T<sub>R</sub> parametrisiert wird. Trivialerweise ist es wünschenswert, dass ein kleinerer Wert von X zu einem größeren Wert von f<sub>2</sub> führt. Daraus folgt, dass f<sub>2</sub> streng monoton fallend ist, mithin also die Ableitung von f<sub>2</sub> nach X kleiner null ist. Zudem ist es ratsam, auch die zweite Ableitung von f<sub>2</sub> nach X kleiner gleich null zu wählen, weil es dann eher lohnt, schlechte Mittelwerte zu verbessern, als gute Mittelwerte weiter zu optimieren.
PAR Wenn der Mittelwert X der Messergebnisse gleich dem Referenzwert T<sub>R</sub> ist, dann ist der Faktor f<sub>2</sub> gleich 0,75, falls die Standardabweichung vernachlässigbar klein ist.
PAR Das Produkt aus f<sub>1</sub> undDer Faktor f<sub>2</sub> wird zur Ermittlung des Wertes P mit der Referenzzeit T<sub>R</sub> gewichtet. Durch diese Gewichtung korreliert das Gewicht eines Prüfpunktes mit dem Beitrag des Prüfpunkt im Rahmen zusammengesetzter Kommandosequenzen.
PAR -HEADING(ids=18.5.4)18.5.4 Gesamtbewertung
PAR Die Gesamtbewertung wird durch gewichtetes Addieren der Einzelpunktzahlen ermittelt. Die Gewichte korrelieren mit der Häufigkeit des Auftretens der Einzelpositionen im Feld.
REQ(ids=A_16979)<b>A_16979 - (N109.460) K_Performanztest</b>
PAR Der Performanztest MUSS bei der Bewertung der einzelnen Prüfpunkte für das Basisbetriebssytem die in CosT_1b9 dargestellten Werte für die Referenzzeit T<sub>Ri</sub> und die Gewichte g<sub>i</sub> zugrundelegen.
PAR Tabelle 348, CosT_1b9: Gesamtbewertung für das Basisbetriebssystem

TABLE(rows=102,cols=231+77+87+99+78+48+113)->
TR-> TH(0,0/1/1)->PAR Prüfpunkt TH(0,1/1/1)->PAR Use Case TH(0,2/1/1)->PAR Kapitel TH(0,3/1/1)->PAR Bezeichnung TH(0,4/1/1)->PAR T<sub>Ri</sub> / [ms] TH(0,5/1/1)->PAR g<sub>i</sub> TH(0,6/1/1)->PAR g<sub>i</sub> T<sub>Ri</sub> / [ms]
TR-> TD(1,0/1/1)->PAR Kanalkapazität TD(1,1/1/1)->PAR (N024.100) TD(1,2/1/1)->PAR CosK_332 TD(1,3/1/1)->PAR P<sub>IO</sub> TD(1,4/1/1)->PAR 17 TD(1,5/1/1)->PAR 50.000 TD(1,6/1/1)->PAR 850.000
TR-> TD(2,0/1/1)->PAR Karte starten TD(2,1/1/1)->PAR (N023.920) TD(2,2/1/1)->PAR CosK_081 TD(2,3/1/1)->PAR P<sub>KarteStarten</sub> TD(2,4/1/1)->PAR 50 TD(2,5/1/1)->PAR 2.000 TD(2,6/1/1)->PAR 100.000
TR-> TD(3,0/1/1)->PAR ACTIVATE Datei TD(3,1/2/1)->PAR (N034.800) TD(3,2/19/1)->PAR CosK_568 TD(3,3/1/1)->PAR P<sub>activate_EF</sub> TD(3,4/1/1)->PAR 30 TD(3,5/1/1)->PAR 100 TD(3,6/1/1)->PAR 3.000
TR-> TD(4,0/1/1)->PAR ACTIVATE Ordner TD(4,3/1/1)->PAR P<sub>activate_DF</sub> TD(4,4/1/1)->PAR 30 TD(4,5/1/1)->PAR 100 TD(4,6/1/1)->PAR 3.000
TR-> TD(5,0/1/1)->PAR ACTIVATE private Key TD(5,1/2/1)->PAR (N034.814) TD(5,3/1/1)->PAR P<sub>activate_PrK</sub> TD(5,4/1/1)->PAR 30 TD(5,5/1/1)->PAR 100 TD(5,6/1/1)->PAR 3.000
TR-> TD(6,0/1/1)->PAR ACTIVATE sym. Key TD(6,3/1/1)->PAR P<sub>activate_SK</sub> TD(6,4/1/1)->PAR 30 TD(6,5/1/1)->PAR 100 TD(6,6/1/1)->PAR 3.000
TR-> TD(7,0/1/1)->PAR ACTIVATE PuK TD(7,1/1/1)->PAR (N034.824) TD(7,3/1/1)->PAR P<sub>activate_PuK</sub> TD(7,4/1/1)->PAR 30 TD(7,5/1/1)->PAR 100 TD(7,6/1/1)->PAR 3.000
TR-> TD(8,0/1/1)->PAR ACTIVATE Pwd TD(8,1/1/1)->PAR (N034.834) TD(8,3/1/1)->PAR P<sub>activate_Pwd</sub> TD(8,4/1/1)->PAR 30 TD(8,5/1/1)->PAR 100 TD(8,6/1/1)->PAR 3.000
TR-> TD(9,0/1/1)->PAR DEACTIVATE Datei TD(9,1/2/1)->PAR (N036.000) TD(9,3/1/1)->PAR P<sub>deact</sub><sub>i</sub><sub>vate_EF</sub> TD(9,4/1/1)->PAR 30 TD(9,5/1/1)->PAR 100 TD(9,6/1/1)->PAR 3.000
TR-> TD(10,0/1/1)->PAR DEACTIVATE Ordner TD(10,3/1/1)->PAR P<sub>deact</sub><sub>i</sub><sub>vate_DF</sub> TD(10,4/1/1)->PAR 30 TD(10,5/1/1)->PAR 100 TD(10,6/1/1)->PAR 3.000
TR-> TD(11,0/1/1)->PAR DEACTIVATE private Key TD(11,1/2/1)->PAR (N036.014) TD(11,3/1/1)->PAR P<sub>deact</sub><sub>i</sub><sub>vate_PrK</sub> TD(11,4/1/1)->PAR 30 TD(11,5/1/1)->PAR 100 TD(11,6/1/1)->PAR 3.000
TR-> TD(12,0/1/1)->PAR DEACTIVATE sym. Key TD(12,3/1/1)->PAR P<sub>deact</sub><sub>i</sub><sub>vate_SK</sub> TD(12,4/1/1)->PAR 30 TD(12,5/1/1)->PAR 100 TD(12,6/1/1)->PAR 3.000
TR-> TD(13,0/1/1)->PAR DEACTIVATE PuK TD(13,1/1/1)->PAR (N036.024) TD(13,3/1/1)->PAR P<sub>deact</sub><sub>i</sub><sub>vate_PuK</sub> TD(13,4/1/1)->PAR 30 TD(13,5/1/1)->PAR 100 TD(13,6/1/1)->PAR 3.000
TR-> TD(14,0/1/1)->PAR DEACTIVATE Pwd TD(14,1/1/1)->PAR (N036.034) TD(14,3/1/1)->PAR P<sub>deact</sub><sub>i</sub><sub>vate_Pwd</sub> TD(14,4/1/1)->PAR 30 TD(14,5/1/1)->PAR 100 TD(14,6/1/1)->PAR 3.000
TR-> TD(15,0/1/1)->PAR DELETE Datei TD(15,1/2/1)->PAR (N037.100) TD(15,3/1/1)->PAR P<sub>delete_EF</sub> TD(15,4/1/1)->PAR 100 TD(15,5/1/1)->PAR 30 TD(15,6/1/1)->PAR 3.000
TR-> TD(16,0/1/1)->PAR DELETE Ordner TD(16,3/1/1)->PAR P<sub>delete_DF</sub> TD(16,4/1/1)->PAR 500 TD(16,5/1/1)->PAR 10 TD(16,6/1/1)->PAR 5.000
TR-> TD(17,0/1/1)->PAR DELETE private Key TD(17,1/2/1)->PAR (N037.114) TD(17,3/1/1)->PAR P<sub>delete_PrK</sub> TD(17,4/1/1)->PAR 60 TD(17,5/1/1)->PAR 50 TD(17,6/1/1)->PAR 3.000
TR-> TD(18,0/1/1)->PAR DELETE sym. Key TD(18,3/1/1)->PAR P<sub>delete_SK</sub> TD(18,4/1/1)->PAR 60 TD(18,5/1/1)->PAR 50 TD(18,6/1/1)->PAR 3.000
TR-> TD(19,0/1/1)->PAR DELETE PuK TD(19,1/1/1)->PAR (N037.124) TD(19,3/1/1)->PAR P<sub>delete_PuK</sub> TD(19,4/1/1)->PAR 60 TD(19,5/1/1)->PAR 50 TD(19,6/1/1)->PAR 3.000
TR-> TD(20,0/1/1)->PAR DELETE Pwd TD(20,1/1/1)->PAR (N037.134) TD(20,3/1/1)->PAR P<sub>delete_Pwd</sub> TD(20,4/1/1)->PAR 60 TD(20,5/1/1)->PAR 50 TD(20,6/1/1)->PAR 3.000
TR-> TD(21,0/1/1)->PAR LOAD APPLICATION TD(21,1/1/1)->PAR CosK_74a TD(21,3/1/1)->PAR P<sub>LoadApp</sub> TD(21,4/1/1)->PAR 1.000 TD(21,5/1/1)->PAR 10 TD(21,6/1/1)->PAR 10.000
TR-> TD(22,0/1/1)->PAR SELECT Datei TD(22,1/1/1)->PAR (N046.700) TD(22,2/1/1)->PAR CosK_dee TD(22,3/1/1)->PAR P<sub>s</sub><sub>e</sub><sub>lect_EF</sub> TD(22,4/1/1)->PAR 10 TD(22,5/1/1)->PAR 100.000 TD(22,6/1/1)->PAR 1.000.000
TR-> TD(23,0/1/1)->PAR SELECT Ordner TD(23,1/1/1)->PAR (N044.900) TD(23,2/1/1)->PAR CosK_0fc TD(23,3/1/1)->PAR P<sub>s</sub><sub>e</sub><sub>lect_DF</sub> TD(23,4/1/1)->PAR 10 TD(23,5/1/1)->PAR 25.000 TD(23,6/1/1)->PAR 250.000
TR-> TD(24,0/1/1)->PAR TERMINATE CARD USAGE TD(24,1/1/1)->PAR (N048.700) TD(24,2/1/1)->PAR CosK_713 TD(24,3/1/1)->PAR P<sub>terminat</sub><sub>e</sub><sub>Card</sub> TD(24,4/1/1)->PAR 30 TD(24,5/1/1)->PAR 100 TD(24,6/1/1)->PAR 3.000
TR-> TD(25,0/1/1)->PAR TERMINATE DF TD(25,1/1/1)->PAR (N048.800) TD(25,2/6/1)->PAR CosK_568 TD(25,3/1/1)->PAR P<sub>terminate_DF</sub> TD(25,4/1/1)->PAR 30 TD(25,5/1/1)->PAR 100 TD(25,6/1/1)->PAR 3.000
TR-> TD(26,0/1/1)->PAR TERMINATE EF TD(26,1/1/1)->PAR (N048.903) TD(26,3/1/1)->PAR P<sub>terminate_EF</sub> TD(26,4/1/1)->PAR 30 TD(26,5/1/1)->PAR 100 TD(26,6/1/1)->PAR 3.000
TR-> TD(27,0/1/1)->PAR TERMINATE privateKey TD(27,1/2/1)->PAR (N048.914) TD(27,3/1/1)->PAR P<sub>terminate_PrK</sub> TD(27,4/1/1)->PAR 30 TD(27,5/1/1)->PAR 100 TD(27,6/1/1)->PAR 3.000
TR-> TD(28,0/1/1)->PAR TERMINATE sym. Key TD(28,3/1/1)->PAR P<sub>terminate_SK</sub> TD(28,4/1/1)->PAR 30 TD(28,5/1/1)->PAR 100 TD(28,6/1/1)->PAR 3.000
TR-> TD(29,0/1/1)->PAR TERMINATE PuK TD(29,1/1/1)->PAR (N048.924) TD(29,3/1/1)->PAR P<sub>term</sub><sub>i</sub><sub>nate_PuK</sub> TD(29,4/1/1)->PAR 30 TD(29,5/1/1)->PAR 100 TD(29,6/1/1)->PAR 3.000
TR-> TD(30,0/1/1)->PAR TERMINATE Pwd TD(30,1/1/1)->PAR (N048.934) TD(30,3/1/1)->PAR P<sub>term</sub><sub>i</sub><sub>nate_Pwd</sub> TD(30,4/1/1)->PAR 30 TD(30,5/1/1)->PAR 100 TD(30,6/1/1)->PAR 3.000
TR-> TD(31,0/1/1)->PAR SET LOGICAL EOF TD(31,1/1/1)->PAR (N052.932) TD(31,2/1/1)->PAR CosK_48c TD(31,3/1/1)->PAR P<sub>SetEOF</sub> TD(31,4/1/1)->PAR 600 TD(31,5/1/1)->PAR 100 TD(31,6/1/1)->PAR 60.000
TR-> TD(32,0/1/1)->PAR ERASE BINARY wipe TD(32,1/1/1)->PAR (N049.100) TD(32,2/1/1)->PAR CosK_171 TD(32,3/1/1)->PAR P<sub>WipeBin</sub> TD(32,4/1/1)->PAR 600 TD(32,5/1/1)->PAR 100 TD(32,6/1/1)->PAR 60.000
TR-> TD(33,0/1/1)->PAR READ BINARY b TD(33,1/2/1)->PAR (N051.100) TD(33,2/2/1)->PAR CosK_759 TD(33,3/1/1)->PAR P<sub>Rea</sub><sub>d</sub><sub>Binary,b</sub> TD(33,4/1/1)->PAR 11 TD(33,5/1/1)->PAR 100.000 TD(33,6/1/1)->PAR 1.100.000
TR-> TD(34,0/1/1)->PAR READ BINARY m TD(34,3/1/1)->PAR P<sub>Rea</sub><sub>d</sub><sub>Binary,m</sub> TD(34,4/1/1)->PAR 5 TD(34,5/1/1)->PAR 200.000 TD(34,6/1/1)->PAR 1.000.000
TR-> TD(35,0/1/1)->PAR UPDATE BINARY b TD(35,1/2/1)->PAR (N053.200) TD(35,2/2/1)->PAR CosK_171 TD(35,3/1/1)->PAR P<sub>UpdateBin,b</sub> TD(35,4/1/1)->PAR 60 TD(35,5/1/1)->PAR 5.000 TD(35,6/1/1)->PAR 300.000
TR-> TD(36,0/1/1)->PAR UPDATE BINARY m TD(36,3/1/1)->PAR P<sub>UpdateBin,m</sub> TD(36,4/1/1)->PAR 60 TD(36,5/1/1)->PAR 5.000 TD(36,6/1/1)->PAR 300.000
TR-> TD(37,0/1/1)->PAR WRITE BINARY b TD(37,1/2/1)->PAR (N055.205) TD(37,2/2/1)->PAR CosK_48c TD(37,3/1/1)->PAR P<sub>wirte,b</sub> TD(37,4/1/1)->PAR 60 TD(37,5/1/1)->PAR 100 TD(37,6/1/1)->PAR 6.000
TR-> TD(38,0/1/1)->PAR WRITE BINARY m TD(38,3/1/1)->PAR P<sub>wirte,m</sub> TD(38,4/1/1)->PAR 60 TD(38,5/1/1)->PAR 100 TD(38,6/1/1)->PAR 6.000
TR-> TD(39,0/1/1)->PAR ACTIVATE RECORD TD(39,1/1/1)->PAR (N055.500) TD(39,2/12/1)->PAR CosK_43a TD(39,3/1/1)->PAR P<sub>ActivateRec</sub> TD(39,4/1/1)->PAR 30 TD(39,5/1/1)->PAR 100 TD(39,6/1/1)->PAR 3.000
TR-> TD(40,0/1/1)->PAR APPEND RECORD b TD(40,1/2/1)->PAR (N058.400) TD(40,3/1/1)->PAR P<sub>Appe</sub><sub>n</sub><sub>dRecord,b</sub> TD(40,4/1/1)->PAR 60 TD(40,5/1/1)->PAR 8.000 TD(40,6/1/1)->PAR 480.000
TR-> TD(41,0/1/1)->PAR APPEND RECORD m TD(41,3/1/1)->PAR P<sub>Appe</sub><sub>n</sub><sub>dRecord</sub><sub>,m</sub> TD(41,4/1/1)->PAR 40 TD(41,5/1/1)->PAR 10.000 TD(41,6/1/1)->PAR 400.000
TR-> TD(42,0/1/1)->PAR DEACTIVATE RECORD TD(42,1/1/1)->PAR (N060.700) TD(42,3/1/1)->PAR P<sub>Dea</sub><sub>c</sub><sub>tivateRec</sub> TD(42,4/1/1)->PAR 30 TD(42,5/1/1)->PAR 100 TD(42,6/1/1)->PAR 3.000
TR-> TD(43,0/1/1)->PAR DELETE RECORD TD(43,1/1/1)->PAR (N063.422) TD(43,3/1/1)->PAR P<sub>DeleteRec</sub> TD(43,4/1/1)->PAR 50 TD(43,5/1/1)->PAR 100 TD(43,6/1/1)->PAR 5.000
TR-> TD(44,0/1/1)->PAR ERASE RECORD wipe b TD(44,1/2/1)->PAR (N063.600) TD(44,3/1/1)->PAR P<sub>WipeRecord,b</sub> TD(44,4/1/1)->PAR 30 TD(44,5/1/1)->PAR 100 TD(44,6/1/1)->PAR 3.000
TR-> TD(45,0/1/1)->PAR ERASE RECORD wipe m TD(45,3/1/1)->PAR P<sub>WipeRecord</sub><sub>,m</sub> TD(45,4/1/1)->PAR 30 TD(45,5/1/1)->PAR 100 TD(45,6/1/1)->PAR 3.000
TR-> TD(46,0/1/1)->PAR READ RECORD b TD(46,1/2/1)->PAR (N065.700) TD(46,3/1/1)->PAR P<sub>ReadRecord,b</sub> TD(46,4/1/1)->PAR 8 TD(46,5/1/1)->PAR 150.000 TD(46,6/1/1)->PAR 1.200.000
TR-> TD(47,0/1/1)->PAR READ RECORD m TD(47,3/1/1)->PAR P<sub>ReadRecord</sub><sub>,m</sub> TD(47,4/1/1)->PAR 4 TD(47,5/1/1)->PAR 300.000 TD(47,6/1/1)->PAR 1.200.000
TR-> TD(48,0/1/1)->PAR SEARCH RECORD TD(48,1/1/1)->PAR (N067.900) TD(48,3/1/1)->PAR P<sub>SearchRec</sub> TD(48,4/1/1)->PAR 120 TD(48,5/1/1)->PAR 500 TD(48,6/1/1)->PAR 60.000
TR-> TD(49,0/1/1)->PAR UPDATE RECORD b TD(49,1/2/1)->PAR (N070.300) TD(49,3/1/1)->PAR P<sub>UpdateRe</sub><sub>c</sub><sub>ord,b</sub> TD(49,4/1/1)->PAR 30 TD(49,5/1/1)->PAR 5.000 TD(49,6/1/1)->PAR 150.000
TR-> TD(50,0/1/1)->PAR UPDATE RECORD m TD(50,3/1/1)->PAR P<sub>UpdateRe</sub><sub>c</sub><sub>ord</sub><sub>,m</sub> TD(50,4/1/1)->PAR 40 TD(50,5/1/1)->PAR 5.000 TD(50,6/1/1)->PAR 200.000
TR-> TD(51,0/1/1)->PAR CHANGE REFERENCE DATA change TD(51,1/1/1)->PAR (N073.300) TD(51,2/7/1)->PAR CosK_568 TD(51,3/1/1)->PAR P<sub>ChRefData</sub> TD(51,4/1/1)->PAR 90 TD(51,5/1/1)->PAR 250 TD(51,6/1/1)->PAR 22.500
TR-> TD(52,0/1/1)->PAR CHANGE REFERENCE DATA set TD(52,1/1/1)->PAR (N073.700) TD(52,3/1/1)->PAR P<sub>SetPIN</sub> TD(52,4/1/1)->PAR 50 TD(52,5/1/1)->PAR 50 TD(52,6/1/1)->PAR 2.500
TR-> TD(53,0/1/1)->PAR DISABLE VERIFICATION REQUIREMENT TD(53,1/1/1)->PAR (N075.386) TD(53,3/1/1)->PAR P<sub>DisablePIN</sub> TD(53,4/1/1)->PAR 50 TD(53,5/1/1)->PAR 50 TD(53,6/1/1)->PAR 2.500
TR-> TD(54,0/1/1)->PAR ENABLE VERIFICATION REQUIREMENT TD(54,1/1/1)->PAR (N078.586) TD(54,3/1/1)->PAR P<sub>EnablePIN</sub> TD(54,4/1/1)->PAR 50 TD(54,5/1/1)->PAR 50 TD(54,6/1/1)->PAR 2.500
TR-> TD(55,0/1/1)->PAR GET PIN STATUS TD(55,1/1/1)->PAR (N077.900) TD(55,3/1/1)->PAR P<sub>GetPinStatus</sub> TD(55,4/1/1)->PAR 10 TD(55,5/1/1)->PAR 50 TD(55,6/1/1)->PAR 500
TR-> TD(56,0/1/1)->PAR RESET RETRY COUNTER TD(56,1/1/1)->PAR (N079.300) TD(56,3/1/1)->PAR P<sub>ResetRC</sub> TD(56,4/1/1)->PAR 70 TD(56,5/1/1)->PAR 200 TD(56,6/1/1)->PAR 14.000
TR-> TD(57,0/1/1)->PAR VERIFY TD(57,1/1/1)->PAR (N082.200) TD(57,3/1/1)->PAR P<sub>VERIFY</sub> TD(57,4/1/1)->PAR 60 TD(57,5/1/1)->PAR 1.000 TD(57,6/1/1)->PAR 60.000
TR-> TD(58,0/3/1)->PAR EXTERNAL AUTHENTICATE TD(58,1/3/1)->PAR (N083.500) TD(58,2/1/1)->PAR CosK_04d TD(58,3/1/1)->PAR P<sub>R</sub><sub>o</sub><sub>leCheck,ELC256</sub> TD(58,4/1/1)->PAR 150 TD(58,5/1/1)->PAR 1.400 TD(58,6/1/1)->PAR 210.000
TR-> TD(59,2/1/1)->PAR CosK_d9a TD(59,3/1/1)->PAR P<sub>RoleCheck,ELC384</sub> TD(59,4/1/1)->PAR 200 TD(59,5/1/1)->PAR 100 TD(59,6/1/1)->PAR 20.000
TR-> TD(60,2/1/1)->PAR CosK_282 TD(60,3/1/1)->PAR P<sub>RoleCheck,ELC512</sub> TD(60,4/1/1)->PAR 300 TD(60,5/1/1)->PAR 50 TD(60,6/1/1)->PAR 15.000
TR-> TD(61,0/1/1)->PAR GET SECURITY STATUS KEY TD(61,1/1/1)->PAR (N085.444) TD(61,2/1/1)->PAR CosK_04d TD(61,3/1/1)->PAR P<sub>SesKey,ELC256</sub> TD(61,4/1/1)->PAR 10 TD(61,5/1/1)->PAR 100 TD(61,6/1/1)->PAR 1.000
TR-> TD(62,0/3/1)->PAR INTERNAL AUTHENTICATE TD(62,1/3/1)->PAR (N086.400) TD(62,2/3/1)->PAR CosK_63b TD(62,3/1/1)->PAR P<sub>RoleAuth,ELC256</sub> TD(62,4/1/1)->PAR 120 TD(62,5/1/1)->PAR 1.400 TD(62,6/1/1)->PAR 168.000
TR-> TD(63,3/1/1)->PAR P<sub>RoleAuth,ELC384</sub> TD(63,4/1/1)->PAR 190 TD(63,5/1/1)->PAR 100 TD(63,6/1/1)->PAR 19.000
TR-> TD(64,3/1/1)->PAR P<sub>RoleAuth,ELC512</sub> TD(64,4/1/1)->PAR 280 TD(64,5/1/1)->PAR 50 TD(64,6/1/1)->PAR 14.000
TR-> TD(65,0/6/1)->PAR Sessionkeyaushandlung für Secure Messaging TD(65,1/3/1)->PAR CosK_b47 TD(65,2/3/1)->PAR CosK_386 TD(65,3/1/1)->PAR P<sub>SK4SM,AES128</sub> TD(65,4/1/1)->PAR 140 TD(65,5/1/1)->PAR 800 TD(65,6/1/1)->PAR 112.000
TR-> TD(66,3/1/1)->PAR P<sub>SK4SM,AES192</sub> TD(66,4/1/1)->PAR 160 TD(66,5/1/1)->PAR 500 TD(66,6/1/1)->PAR 80.000
TR-> TD(67,3/1/1)->PAR P<sub>SK4SM,AES25</sub> TD(67,4/1/1)->PAR 180 TD(67,5/1/1)->PAR 100 TD(67,6/1/1)->PAR 18.000
TR-> TD(68,1/3/1)->PAR CosK_2ed TD(68,2/1/1)->PAR CosK_04d TD(68,3/1/1)->PAR P<sub>SesKey,ELC256</sub> TD(68,4/1/1)->PAR 400 TD(68,5/1/1)->PAR 1.000 TD(68,6/1/1)->PAR 400.000
TR-> TD(69,2/1/1)->PAR CosK_d9a TD(69,3/1/1)->PAR P<sub>SesKey,ELC384</sub> TD(69,4/1/1)->PAR 600 TD(69,5/1/1)->PAR 500 TD(69,6/1/1)->PAR 300.000
TR-> TD(70,2/1/1)->PAR CosK_282 TD(70,3/1/1)->PAR P<sub>SesKey,ELC512</sub> TD(70,4/1/1)->PAR 900 TD(70,5/1/1)->PAR 100 TD(70,6/1/1)->PAR 90.000
TR-> TD(71,0/5/1)->PAR PSO Compute Digital Signature TD(71,1/5/1)->PAR (N085.500) TD(71,2/2/1)->PAR CosK_3e3 TD(71,3/1/1)->PAR P<sub>signPSS,2048</sub> TD(71,4/1/1)->PAR 200 TD(71,5/1/1)->PAR 1.000 TD(71,6/1/1)->PAR 200.000
TR-> TD(72,3/1/1)->PAR P<sub>signPSS,3072</sub> TD(72,4/1/1)->PAR 750 TD(72,5/1/1)->PAR 10 TD(72,6/1/1)->PAR 7.500
TR-> TD(73,2/3/1)->PAR CosK_2e7 TD(73,3/1/1)->PAR P<sub>signECDSA,256</sub> TD(73,4/1/1)->PAR 100 TD(73,5/1/1)->PAR 2.000 TD(73,6/1/1)->PAR 200.000
TR-> TD(74,3/1/1)->PAR P<sub>signECDSA,384</sub> TD(74,4/1/1)->PAR 150 TD(74,5/1/1)->PAR 600 TD(74,6/1/1)->PAR 90.000
TR-> TD(75,3/1/1)->PAR P<sub>signECDSA,512</sub> TD(75,4/1/1)->PAR 250 TD(75,5/1/1)->PAR 100 TD(75,6/1/1)->PAR 25.000
TR-> TD(76,0/5/1)->PAR PSO Decipher TD(76,1/2/1)->PAR (N089.200) TD(76,2/2/1)->PAR CosK_cce TD(76,3/1/1)->PAR P<sub>dec,2048</sub> TD(76,4/1/1)->PAR 200 TD(76,5/1/1)->PAR 2.000 TD(76,6/1/1)->PAR 400.000
TR-> TD(77,3/1/1)->PAR P<sub>dec,3072</sub> TD(77,4/1/1)->PAR 900 TD(77,5/1/1)->PAR 100 TD(77,6/1/1)->PAR 90.000
TR-> TD(78,1/3/1)->PAR (N089.800) TD(78,2/3/1)->PAR CosK_1b8 TD(78,3/1/1)->PAR P<sub>dec,256</sub> TD(78,4/1/1)->PAR 150 TD(78,5/1/1)->PAR 2.000 TD(78,6/1/1)->PAR 300.000
TR-> TD(79,3/1/1)->PAR P<sub>dec,384</sub> TD(79,4/1/1)->PAR 180 TD(79,5/1/1)->PAR 600 TD(79,6/1/1)->PAR 108.000
TR-> TD(80,3/1/1)->PAR P<sub>dec,512</sub> TD(80,4/1/1)->PAR 270 TD(80,5/1/1)->PAR 100 TD(80,6/1/1)->PAR 27.000
TR-> TD(81,0/4/1)->PAR PSO Encipher TD(81,1/1/1)->PAR (N090.790) TD(81,2/1/1)->PAR CosK_cce TD(81,3/1/1)->PAR P<sub>enc,2048</sub> TD(81,4/1/1)->PAR 40 TD(81,5/1/1)->PAR 200 TD(81,6/1/1)->PAR 8.000
TR-> TD(82,1/3/1)->PAR (N091.400) TD(82,2/3/1)->PAR CosK_1b8 TD(82,3/1/1)->PAR P<sub>enc,256</sub> TD(82,4/1/1)->PAR 200 TD(82,5/1/1)->PAR 1.000 TD(82,6/1/1)->PAR 200.000
TR-> TD(83,3/1/1)->PAR P<sub>enc,384</sub> TD(83,4/1/1)->PAR 300 TD(83,5/1/1)->PAR 500 TD(83,6/1/1)->PAR 150.000
TR-> TD(84,3/1/1)->PAR P<sub>enc,512</sub> TD(84,4/1/1)->PAR 500 TD(84,5/1/1)->PAR 100 TD(84,6/1/1)->PAR 50.000
TR-> TD(85,0/3/1)->PAR PSO Verify Certificate TD(85,1/3/1)->PAR (N095.410) TD(85,2/1/1)->PAR CosK_04d TD(85,3/1/1)->PAR P<sub>Import</sub><sub>,ELC256</sub> TD(85,4/1/1)->PAR 300 TD(85,5/1/1)->PAR 500 TD(85,6/1/1)->PAR 150.000
TR-> TD(86,2/1/1)->PAR CosK_d9a TD(86,3/1/1)->PAR P<sub>Import,ELC384</sub> TD(86,4/1/1)->PAR 630 TD(86,5/1/1)->PAR 100 TD(86,6/1/1)->PAR 63.000
TR-> TD(87,2/1/1)->PAR CosK_282 TD(87,3/1/1)->PAR P<sub>Import,ELC512</sub> TD(87,4/1/1)->PAR 900 TD(87,5/1/1)->PAR 20 TD(87,6/1/1)->PAR 18.000
TR-> TD(88,0/3/1)->PAR PSO Verify Digital Signature TD(88,1/3/1)->PAR (N096.388) TD(88,2/3/1)->PAR CosK_2e7 TD(88,3/1/1)->PAR P<sub>verifyECDSA,256</sub> TD(88,4/1/1)->PAR 80 TD(88,5/1/1)->PAR 12 TD(88,6/1/1)->PAR 960
TR-> TD(89,3/1/1)->PAR P<sub>verifyECDSA,384</sub> TD(89,4/1/1)->PAR 140 TD(89,5/1/1)->PAR 6 TD(89,6/1/1)->PAR 840
TR-> TD(90,3/1/1)->PAR P<sub>verifyECDSA,512</sub> TD(90,4/1/1)->PAR 220 TD(90,5/1/1)->PAR 1 TD(90,6/1/1)->PAR 220
TR-> TD(91,0/1/1)->PAR FINGERPRINT TD(91,1/1/1)->PAR (N096.454) TD(91,2/1/1)->PAR CosK_e73 TD(91,3/1/1)->PAR P<sub>finge</sub><sub>r</sub><sub>print</sub> TD(91,4/1/1)->PAR 8.000 TD(91,5/1/1)->PAR 1 TD(91,6/1/1)->PAR 8.000
TR-> TD(92,0/3/1)->PAR GENERATE ASYMMETRIC KEY PAIR TD(92,1/3/1)->PAR (N097.266) TD(92,2/3/1)->PAR CosK_1b8 TD(92,3/1/1)->PAR P<sub>GAKP,256</sub> TD(92,4/1/1)->PAR 140 TD(92,5/1/1)->PAR 500 TD(92,6/1/1)->PAR 70.000
TR-> TD(93,3/1/1)->PAR P<sub>GAKP,384</sub> TD(93,4/1/1)->PAR 200 TD(93,5/1/1)->PAR 100 TD(93,6/1/1)->PAR 20.000
TR-> TD(94,3/1/1)->PAR P<sub>GAKP,512</sub> TD(94,4/1/1)->PAR 280 TD(94,5/1/1)->PAR 30 TD(94,6/1/1)->PAR 8.400
TR-> TD(95,0/1/1)->PAR GET CHALLENGE TD(95,1/1/1)->PAR (N098.625) TD(95,2/2/1)->PAR CosK_0fc TD(95,3/1/1)->PAR P<sub>cha</sub><sub>l</sub><sub>lenge</sub> TD(95,4/1/1)->PAR 10 TD(95,5/1/1)->PAR 1.000 TD(95,6/1/1)->PAR 10.000
TR-> TD(96,0/1/1)->PAR MANAGE CHANNEL reset Channel TD(96,1/1/1)->PAR (N099.524) TD(96,3/1/1)->PAR P<sub>reset_Ch</sub> TD(96,4/1/1)->PAR 5 TD(96,5/1/1)->PAR 500 TD(96,6/1/1)->PAR 2.500
TR-> TD(97,0/1/1)->PAR MANAGE SECURITY ENVIRONMENT Restore TD(97,1/1/1)->PAR (N099.900) TD(97,2/2/1)->PAR CosK_43e TD(97,3/1/1)->PAR P<sub>MSE_Restore</sub> TD(97,4/1/1)->PAR 5 TD(97,5/1/1)->PAR 500 TD(97,6/1/1)->PAR 2.500
TR-> TD(98,0/1/1)->PAR MANAGE SECURITY ENVIRONMENT Set TD(98,1/1/1)->PAR CosK_146 TD(98,3/1/1)->PAR P<sub>MSE_Set</sub> TD(98,4/1/1)->PAR 10 TD(98,5/1/1)->PAR 10.000 TD(98,6/1/1)->PAR 100.000
TR-> TD(99,0/2/1)->PAR GET RANDOM TD(99,1/2/1)->PAR (N099.322 TD(99,2/2/1)->PAR CosK_ccb TD(99,3/1/1)->PAR P<sub>Random,b</sub> TD(99,4/1/1)->PAR 4 TD(99,5/1/1)->PAR 18 TD(99,6/1/1)->PAR 72
TR-> TD(100,3/1/1)->PAR P<sub>Random,m</sub> TD(100,4/1/1)->PAR 40 TD(100,5/1/1)->PAR 2 TD(100,6/1/1)->PAR 80
TR-> TD(101,0/1/4)->PAR Spaltensummen TD(101,4/1/1)->PAR 23.589 TD(101,5/1/1)->PAR 1.000.000 TD(101,6/1/1)->PAR 12.687.572
PAR <b>[<=]</b>

REQ(ids=A_16980)<b>A_16980 - (N109.465) K_Performanztest</b>
PAR Der Performanztest MUSS bei der Bewertung der einzelnen Prüfpunkte für die Option_kontaktlose_Schnittstelle die in CosT_930 dargestellten Werte für die Referenzzeit T<sub>Ri</sub> und die Gewichte g<sub>i</sub> zugrundelegen.
PAR Tabelle 349, CosT_930: Gesamtbewertung für Option_kontaktlose_Schnittstelle

TABLE(rows=3,cols=229+84+89+97+77+52+104)->
TR-> TH(0,0/1/1)->PAR Prüfpunkt TH(0,1/1/1)->PAR Use Case TH(0,2/1/1)->PAR Kapitel TH(0,3/1/1)->PAR Bezeichnung TH(0,4/1/1)->PAR T<sub>Ri</sub> / [ms] TH(0,5/1/1)->PAR g<sub>i</sub> TH(0,6/1/1)->PAR g<sub>i</sub> T<sub>Ri</sub> / [ms]
TR-> TD(1,0/1/1)->PAR GENERAL AUTHENTICATE TD(1,1/1/1)->PAR CosK_e2b TD(1,2/1/1)->PAR CosK_eb3 TD(1,3/1/1)->PAR P<sub>PACE</sub> TD(1,4/1/1)->PAR 750 TD(1,5/1/1)->PAR 500 TD(1,6/1/1)->PAR 375.000
TR-> TD(2,0/1/4)->PAR Spaltensummen TD(2,4/1/1)->PAR 750 TD(2,5/1/1)->PAR 500 TD(2,6/1/1)->PAR 375.000
PAR <b>[<=]</b>

REQ(ids=A_16981)<b>A_16981 - (N109.470) K_Performanztest</b>
PAR Der Performanztest MUSS bei der Bewertung der einzelnen Prüfpunkte für die Option_Kryptobox die in CosT_005 dargestellten Werte für die Referenzzeit T<sub>Ri</sub> und die Gewichte g<sub>i</sub> zugrundelegen.
PAR Tabelle 350, CosT_005: Gesamtbewertung für Option_Kryptobox

TABLE(rows=29,cols=234+84+90+96+74+55+99)->
TR-> TH(0,0/1/1)->PAR Prüfpunkt TH(0,1/1/1)->PAR Use Case TH(0,2/1/1)->PAR Kapitel TH(0,3/1/1)->PAR Bezeichnung TH(0,4/1/1)->PAR T<sub>Ri</sub> / [ms] TH(0,5/1/1)->PAR g<sub>i</sub> TH(0,6/1/1)->PAR g<sub>i</sub> T<sub>Ri</sub> / [ms]
TR-> TD(1,0/3/1)->PAR Sessionkeyaushandlung für Trusted Channel TD(1,1/3/1)->PAR CosK_b47 TD(1,2/3/1)->PAR CosK_a71 TD(1,3/1/1)->PAR P<sub>SK4TC,AES128</sub> TD(1,4/1/1)->PAR 70 TD(1,5/1/1)->PAR 1.400 TD(1,6/1/1)->PAR 98.000
TR-> TD(2,3/1/1)->PAR P<sub>SK4TC,AES192</sub> TD(2,4/1/1)->PAR 90 TD(2,5/1/1)->PAR 500 TD(2,6/1/1)->PAR 450.000
TR-> TD(3,3/1/1)->PAR P<sub>SK4TC,AES256</sub> TD(3,4/1/1)->PAR 100 TD(3,5/1/1)->PAR 100 TD(3,6/1/1)->PAR 10.000
TR-> TD(4,0/6/1)->PAR PSO Compute Cryptographic Checksum TD(4,1/6/1)->PAR (N087.228) TD(4,2/24/1)->PAR CosK_f10 TD(4,3/1/1)->PAR P<sub>co</sub><sub>m</sub><sub>pute128,b</sub> TD(4,4/1/1)->PAR 10 TD(4,5/1/1)->PAR 10.000 TD(4,6/1/1)->PAR 100.000
TR-> TD(5,3/1/1)->PAR P<sub>compute128,m</sub> TD(5,4/1/1)->PAR 5 TD(5,5/1/1)->PAR 22.000 TD(5,6/1/1)->PAR 110.000
TR-> TD(6,3/1/1)->PAR P<sub>compute192,b</sub> TD(6,4/1/1)->PAR 10 TD(6,5/1/1)->PAR 6.000 TD(6,6/1/1)->PAR 60.000
TR-> TD(7,3/1/1)->PAR P<sub>compute192,m</sub> TD(7,4/1/1)->PAR 6 TD(7,5/1/1)->PAR 10.000 TD(7,6/1/1)->PAR 60.000
TR-> TD(8,3/1/1)->PAR P<sub>co</sub><sub>m</sub><sub>pute256,b</sub> TD(8,4/1/1)->PAR 10 TD(8,5/1/1)->PAR 500 TD(8,6/1/1)->PAR 5.000
TR-> TD(9,3/1/1)->PAR P<sub>co</sub><sub>m</sub><sub>pute256,m</sub> TD(9,4/1/1)->PAR 7 TD(9,5/1/1)->PAR 1.000 TD(9,6/1/1)->PAR 7.000
TR-> TD(10,0/6/1)->PAR PSO Decipher TD(10,1/6/1)->PAR (N089.845) TD(10,3/1/1)->PAR P<sub>dec128,b</sub> TD(10,4/1/1)->PAR 10 TD(10,5/1/1)->PAR 10.000 TD(10,6/1/1)->PAR 100.000
TR-> TD(11,3/1/1)->PAR P<sub>dec128,m</sub> TD(11,4/1/1)->PAR 10 TD(11,5/1/1)->PAR 22.000 TD(11,6/1/1)->PAR 220.000
TR-> TD(12,3/1/1)->PAR P<sub>dec192,b</sub> TD(12,4/1/1)->PAR 10 TD(12,5/1/1)->PAR 6.000 TD(12,6/1/1)->PAR 60.000
TR-> TD(13,3/1/1)->PAR P<sub>dec192,m</sub> TD(13,4/1/1)->PAR 12 TD(13,5/1/1)->PAR 10.000 TD(13,6/1/1)->PAR 120.000
TR-> TD(14,3/1/1)->PAR P<sub>dec256,b</sub> TD(14,4/1/1)->PAR 10 TD(14,5/1/1)->PAR 500 TD(14,6/1/1)->PAR 5.000
TR-> TD(15,3/1/1)->PAR P<sub>dec256,m</sub> TD(15,4/1/1)->PAR 14 TD(15,5/1/1)->PAR 1.000 TD(15,6/1/1)->PAR 14.000
TR-> TD(16,0/6/1)->PAR PSO Encipher TD(16,1/6/1)->PAR (N091.446) TD(16,3/1/1)->PAR P<sub>enc128,b</sub> TD(16,4/1/1)->PAR 10 TD(16,5/1/1)->PAR 10.000 TD(16,6/1/1)->PAR 100.000
TR-> TD(17,3/1/1)->PAR P<sub>enc128,m</sub> TD(17,4/1/1)->PAR 10 TD(17,5/1/1)->PAR 22.000 TD(17,6/1/1)->PAR 220.000
TR-> TD(18,3/1/1)->PAR P<sub>enc192,b</sub> TD(18,4/1/1)->PAR 10 TD(18,5/1/1)->PAR 6.000 TD(18,6/1/1)->PAR 60.000
TR-> TD(19,3/1/1)->PAR P<sub>enc192,m</sub> TD(19,4/1/1)->PAR 12 TD(19,5/1/1)->PAR 10.000 TD(19,6/1/1)->PAR 120.000
TR-> TD(20,3/1/1)->PAR P<sub>enc256,b</sub> TD(20,4/1/1)->PAR 10 TD(20,5/1/1)->PAR 500 TD(20,6/1/1)->PAR 5.000
TR-> TD(21,3/1/1)->PAR P<sub>enc256,m</sub> TD(21,4/1/1)->PAR 14 TD(21,5/1/1)->PAR 1.000 TD(21,6/1/1)->PAR 14.000
TR-> TD(22,0/6/1)->PAR PSO Verify Cryptographic Checksum TD(22,1/6/1)->PAR (N096.346) TD(22,3/1/1)->PAR P<sub>verify128,b</sub> TD(22,4/1/1)->PAR 10 TD(22,5/1/1)->PAR 10.000 TD(22,6/1/1)->PAR 100.000
TR-> TD(23,3/1/1)->PAR P<sub>verify128,m</sub> TD(23,4/1/1)->PAR 5 TD(23,5/1/1)->PAR 22.000 TD(23,6/1/1)->PAR 110.000
TR-> TD(24,3/1/1)->PAR P<sub>verify192,b</sub> TD(24,4/1/1)->PAR 10 TD(24,5/1/1)->PAR 6.000 TD(24,6/1/1)->PAR 60.000
TR-> TD(25,3/1/1)->PAR P<sub>verify192,m</sub> TD(25,4/1/1)->PAR 6 TD(25,5/1/1)->PAR 10.000 TD(25,6/1/1)->PAR 60.000
TR-> TD(26,3/1/1)->PAR P<sub>verify256,b</sub> TD(26,4/1/1)->PAR 10 TD(26,5/1/1)->PAR 500 TD(26,6/1/1)->PAR 5.000
TR-> TD(27,3/1/1)->PAR P<sub>verify256,m</sub> TD(27,4/1/1)->PAR 7 TD(27,5/1/1)->PAR 1.000 TD(27,6/1/1)->PAR 7.000
TR-> TD(28,0/1/4)->PAR Spaltensummen TD(28,4/1/1)->PAR 488 TD(28,5/1/1)->PAR 200.000 TD(28,6/1/1)->PAR 1.875.000
PAR <b>[<=]</b>

REQ(ids=A_16982)<b>A_16982 - (N109.475) K_Performanztest</b>
PAR Der Performanztest MUSS bei der Bewertung der einzelnen Prüfpunkte für die Option_logische_Kanäle die in CosT_51e dargestellten Werte für die Referenzzeit T<sub>Ri</sub> und die Gewichte g<sub>i</sub> zugrundelegen.
PAR Tabelle 351, CosT_51e: Gesamtbewertung für Option_logische_Kanäle

TABLE(rows=7,cols=239+87+84+102+73+52+95)->
TR-> TH(0,0/1/1)->PAR Prüfpunkt TH(0,1/1/1)->PAR Use Case TH(0,2/1/1)->PAR Kapitel TH(0,3/1/1)->PAR Bezeichung TH(0,4/1/1)->PAR T<sub>Ri</sub>           / [ms] TH(0,5/1/1)->PAR g<sub>i</sub> TH(0,6/1/1)->PAR g<sub>i</sub> T<sub>Ri</sub>           / [ms]
TR-> TD(1,0/2/1)->PAR GET RANDOM TD(1,1/2/1)->PAR (N099.322) TD(1,2/2/1)->PAR CosK_ccb TD(1,3/1/1)->PAR P<sub>Random,b</sub> TD(1,4/1/1)->PAR 4 TD(1,5/1/1)->PAR 1.800 TD(1,6/1/1)->PAR 7.200
TR-> TD(2,3/1/1)->PAR P<sub>Random,m</sub> TD(2,4/1/1)->PAR 40 TD(2,5/1/1)->PAR 200 TD(2,6/1/1)->PAR 8.000
TR-> TD(3,0/1/1)->PAR MANAGE CHANNEL open TD(3,1/1/1)->PAR (N099.508) TD(3,2/3/1)->PAR CosK_254 TD(3,3/1/1)->PAR P<sub>Open</sub> TD(3,4/1/1)->PAR 5 TD(3,5/1/1)->PAR 50.000 TD(3,6/1/1)->PAR 250.000
TR-> TD(4,0/1/1)->PAR MANAGE CHANNEL close TD(4,1/1/1)->PAR (N099.514) TD(4,3/1/1)->PAR P<sub>Close</sub> TD(4,4/1/1)->PAR 3 TD(4,5/1/1)->PAR 40.000 TD(4,6/1/1)->PAR 120.000
TR-> TD(5,0/1/1)->PAR MANAGE CHANNEL reset ICC TD(5,1/1/1)->PAR (N099.532) TD(5,3/1/1)->PAR P<sub>RST</sub> TD(5,4/1/1)->PAR 3 TD(5,5/1/1)->PAR 10.000 TD(5,6/1/1)->PAR 30.000
TR-> TD(6,0/1/1)->PAR Spaltensummen TD(6,1/1/1)-> TD(6,2/1/1)-> TD(6,3/1/1)-> TD(6,4/1/1)->PAR 11 TD(6,5/1/1)->PAR 100.000 TD(6,6/1/1)->PAR 400.000
PAR <b>[<=]</b>

REQ(ids=A_16983)<b>A_16983 - (N109.480) K_Performanztest</b>
PAR Der Performanztest MUSS bei der Bewertung eines Prüflings die in CosT_439 dargestellten Werte für die Zulasungsgrenze zugrundelegen.
PAR Tabelle 352, CosT_439: Gesamtbewertung je nach Kombination der Optionen

TABLE(rows=9,cols=95+79+79+73+85+168)->
TR-> TH(0,0/1/1)->PAR Basis / [ms] TH(0,1/1/1)->PAR Dual / [ms] TH(0,2/1/1)->PAR Krypto / [ms] TH(0,3/1/1)->PAR Kanal / [ms] TH(0,4/1/1)->PAR Summe / [s] TH(0,5/1/1)->PAR Zulassungsgrenze / [s]
TR-> TD(1,0/1/1)->PAR 12.687.572 TD(1,1/1/1)->PAR 375.000 TD(1,2/1/1)->PAR 1.875.000 TD(1,3/1/1)->PAR 400.000 TD(1,4/1/1)->PAR 15.337,572 TD(1,5/1/1)->PAR 6.710
TR-> TD(2,0/1/1)->PAR 12.687.572 TD(2,1/1/1)->PAR 375.000 TD(2,2/1/1)->PAR 1.875.000 TD(2,3/1/1)->PAR 0 TD(2,4/1/1)->PAR 14.937,572 TD(2,5/1/1)->PAR 6.535
TR-> TD(3,0/1/1)->PAR 12.687.572 TD(3,1/1/1)->PAR 375.000 TD(3,2/1/1)->PAR 0 TD(3,3/1/1)->PAR 400.000 TD(3,4/1/1)->PAR 13.462,672 TD(3,5/1/1)->PAR 5.890
TR-> TD(4,0/1/1)->PAR 12.687.572 TD(4,1/1/1)->PAR 375.000 TD(4,2/1/1)->PAR 0 TD(4,3/1/1)->PAR 0 TD(4,4/1/1)->PAR 13.062,572 TD(4,5/1/1)->PAR 5.715
TR-> TD(5,0/1/1)->PAR 12.687.572 TD(5,1/1/1)->PAR 0 TD(5,2/1/1)->PAR 1.875.000 TD(5,3/1/1)->PAR 400.000 TD(5,4/1/1)->PAR 14.962,572 TD(5,5/1/1)->PAR 6.546
TR-> TD(6,0/1/1)->PAR 12.687.572 TD(6,1/1/1)->PAR 0 TD(6,2/1/1)->PAR 1.875.000 TD(6,3/1/1)->PAR 0 TD(6,4/1/1)->PAR 14.562,572 TD(6,5/1/1)->PAR 6.371
TR-> TD(7,0/1/1)->PAR 12.687.572 TD(7,1/1/1)->PAR 0 TD(7,2/1/1)->PAR 0 TD(7,3/1/1)->PAR 400.000 TD(7,4/1/1)->PAR 13.087.672 TD(7,5/1/1)->PAR 5.726
TR-> TD(8,0/1/1)->PAR 12.687.572 TD(8,1/1/1)->PAR 0 TD(8,2/1/1)->PAR 0 TD(8,3/1/1)->PAR 0 TD(8,4/1/1)->PAR 12.687,572 TD(8,5/1/1)->PAR 5.551
PAR <b>[<=]</b>

PAR Hinweis CosH_d18: Bedeutung der Spaltenüberschriften in CosT_439:<br>        a. Basis:   COS, welches keines der optionalen Funktionspakete enthält<br>        b. Dual:     COS enthält Option_kontaktlose_Schnittstelle<br>        c. Krypto:  COS enthält Option_Kryptobox<br>        d. Kanal:   COS enthält Option_logische_Kanäle
REQ(ids=A_16984)<b>A_16984 - (N109.500) K_Performanztest</b>


PAR Unter den vereinfachenden Annahmen, dass die Messwerte innerhalb einer Reihe identisch sind (Standardabweichung ist null) und das Verhältnis X<sub>i</sub> / T<sub>Ri</sub> in allen Messreihen konstant ist, folgt dann für das Basisbetriebssystem, mit f<sub>2</sub> als Funktion von X<sub>i</sub> / T<sub>Ri</sub>.

PAR CosA_3de zeigt diesen Zusammenhang graphisch mit dem Verhältnis X<sub>i</sub> / T<sub>Ri</sub> als Abszisse und P<sub>gesamtEinfach</sub> als Ordinate. Demnach erreicht ein unendlich schnelles Basisbetriebssystem 12.687,572s Punkte. Eine Karte, die in allen Prüfpunkten die Referenzzeit benötigt, erreicht 9515,679s Punkte. Eine Karte, die überall die doppelte Referenzzeit benötigt, null Punkte.
REQ(ids=A_16985)<b>A_16985 - (N109.600) K_Performanztest</b>
PAR Der Performanztest MUSS es als zulassungsverhindernd werten, falls ein Prüfling in wenigstens einem Prüfpunkt das Verhältnis X<sub>i</sub> / T<sub>Ri</sub> größer als vier ist. <b>[<=]</b>

REQ(ids=A_16986)<b>A_16986 - (N109.700) K_Performanztest</b>
PAR Der Performanztest MUSS es als zulassungsverhindernd werten, falls für einen Prüfling die gemäß (N109.500) ermittelte Punktzahl kleiner ist als in CosT_439 für die Kombination von Optionen angegebene. Dies entspricht einer relativen Ausführungszeit, die 1,5-mal so groß ist wie die Referenzzeit. <b>[<=]</b>


PAR -HEADING(ids=18.6)18.6 Übertragungsgeschwindigkeit
PAR -HEADING(ids=18.6.1)18.6.1 CosK_332 Übertragungsgeschwindigkeit für das Übertragungsprotokoll T=1
PAR Dieser Prüfpunkt berücksichtigt die Kanalkapazität des Kanals TPDU_Channel für das Übertragungsprotokoll T=1 in CosA_a56. Diese wird wegen der starken Abhängigkeit von der externen Taktfrequenz des IFD nicht experimentell, sondern rechnerisch aus den Bytes TA<sub>1</sub> und TC<sub>1</sub> im ATR und der Kapazität C aus CosT_719 ermittelt. Für die (rechnerische) Übertragungszeit von 1.000 Oktett zur Karte gilt:

PAR (ids=Tabelle-353,-CosT_4ba)Tabelle 353, CosT_4ba: Character Guard Time (CGT) gemäß [ISO/IEC 7816-3#11.2]

TABLE(rows=2,cols=78+73+71+71+71+71+71+71)->
TR-> TD(0,0/1/1)->PAR TC<sub>1</sub> TD(0,1/1/1)->PAR 'FF' TD(0,2/1/1)->PAR '00' TD(0,3/1/1)->PAR '01' TD(0,4/1/1)->PAR '02' TD(0,5/1/1)->PAR … TD(0,6/1/1)->PAR 'FD' TD(0,7/1/1)->PAR 'FE'
TR-> TD(1,0/1/1)->PAR CGT TD(1,1/1/1)->PAR 11 TD(1,2/1/1)->PAR 12 TD(1,3/1/1)->PAR 13 TD(1,4/1/1)->PAR 14 TD(1,5/1/1)->PAR … TD(1,6/1/1)->PAR 265 TD(1,7/1/1)->PAR 266
REQ(ids=A_16987)<b>A_16987 - (N200.100) K_Performanztest</b>
PAR Der Performanztest MUSS die Performanzpunkte P<sub>IO</sub> wie folgt ermitteln:<br>P<sub>IO</sub> = points( (t<sub>T</sub>, t<sub>T</sub> ), T<sub>IO</sub> ). <b>[<=]</b>

PAR -HEADING(ids=18.6.2)18.6.2 Übertragungsgeschwindigkeit für das Protokoll [ISO/IEC 7816-12]
PAR Hinweis CosH_75c: Die Anforderungen werden in einer späteren Dokumentenversion ergänzt.
PAR -HEADING(ids=18.6.3)18.6.3 Übertragungsgeschwindigkeit für kontaktlose Datenübertragung
PAR Hinweis CosH_025: Die Anforderungen werden in einer späteren Dokumentenversion ergänzt.
PAR Die folgenden Anforderungen sind absichtlich leer:    <br>(N109.800), (N109.900), (N110.000), (N110.100), (N110.200), (N110.300), (N110.400), (N110.500), (N110.600), (N110.700), (N110.800), (N110.900), (N111.000), (N111.100), (N111.200), (N111.300), (N111.400), (N111.500), (N111.600), (N111.700), (N111.800), (N111.900), (N112.000), (N112.100), (N112.200), (N112.300), (N112.400), (N112.500), (N112.600), (N112.700), (N112.800), (N112.900), (N113.000), (N113.100), (N113.200), (N113.300), (N113.400), (N113.500), (N113.600), (N113.700), (N113.800), (N113.900), (N114.000), (N114.100), (N114.200), (N114.300), (N114.400), (N114.500), (N114.600), (N114.700), (N114.800), (N114.900), (N115.000), (N115.100), (N115.200), (N115.300), (N115.400), (N115.500), (N115.600), (N115.700), (N115.800), (N115.900), (N116.000), (N116.100), (N116.200), (N116.300), (N116.400), (N116.500), (N116.600), (N116.700), (N116.800), (N116.900), (N117.000), (N117.100), (N117.200), (N117.300), (N117.400), (N117.500), (N117.600), (N117.700), (N117.800), (N117.900), (N118.000), (N118.100), (N118.200), (N118.300), (N118.400), (N118.500), (N118.600), (N118.700), (N118.800), (N118.900), (N119.000), (N119.100), (N119.200), (N119.300), (N119.400), (N119.500), (N119.600), (N119.700), (N119.800), (N119.900), (N120.000), (N120.100), (N120.200), (N120.300), (N120.400), (N120.500), (N120.600), (N120.700), (N120.800), (N120.900), (N121.000), (N121.100), (N122.000), (N122.100), (N122.200), (N122.300), (N122.400), (N122.500), (N122.600), (N122.700), (N122.800), (N122.900), (N123.000), (N123.100), (N123.200), (N123.300), (N123.400), (N123.500), (N123.600), (N123.700), (N123.800), (N123.900), (N124.000), (N124.100), (N124.200), (N124.300), (N124.400), (N124.500), (N124.600), (N124.700), (N124.710), (N124.800), (N124.900), (N125.000), (N125.100), (N125.200), (N125.300), (N125.400), (N125.500), (N125.600), (N125.700), (N125.800), (N125.900), (N126.000), (N126.100), (N126.200), (N126.300), (N126.400), (N126.500), (N126.600), (N126.700), (N126.800), (N126.900)
PAR -HEADING(ids=18.7)18.7 CosK_081 Startsequenz für das Übertragungsprotokoll T=1
PAR Dieser Prüfpunkt behandelt eine Sequenz, die bei der Aktivierung einer Smartcard durchlaufen wird.
PAR Der Prüfpunkt beinhaltet:

LIST->
LITEM->PAR Die Aktivierung (Bootvorgang) des Betriebssystems,LITEM->PAR die Aushandlung einer höheren Übertragungsrate undLITEM->PAR die Aushandlung einer Puffergröße für die Datenübertragung.
PAR Testvorbereitung:
REQ(ids=A_16988)<b>A_16988 - (N200.190) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=A_16989)<b>A_16989 - (N200.195) K_Performanztest</b>
PAR Schritt 2: Der Prüfling MUSS gemäß (N023.920)f deaktiviert werden. <b>[<=]</b>

PAR Keine.
PAR Testdurchführung:
REQ(ids=G2_N200.200)<b>G2_N200.200 - (N200.200) K_Performanztest</b>
PAR Der Performanztest MUSS im Rahmen der Testdurchführung eine Schleife 100-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 1 bis 4 ausgeführt. Abweichend von den Festlegungen in CosK_056 wird hier die Zeit pro Schleifendurchlauf anders ermittelt. <b>[<=]</b>

REQ(ids=G2_N200.210)<b>G2_N200.210 - (N200.210) K_Performanztest</b>
PAR Schritt 1: Die Zeit t<sub>Start</sub> gibt den Zeitpunkt an, zu welchem die Smartcard gemäß (N108.800) aktiviert wird. Genauer, den Zeitpunkt des Wechsels von RST von L nach H (siehe [ISO/IEC 7816-3#Figure 1]). Anschließend wird der ATR empfangen. <b>[<=]</b>

REQ(ids=G2_N200.220)<b>G2_N200.220 - (N200.220) K_Performanztest</b>
PAR Schritt 2: Es MUSS eine PPS-Sequenz gemäß [ISO/IEC 7816-3] erfolgen. Die Bits 4 bis 1 in PPS0 MÜSSEN das Übertragungsprotokoll T=1 anzeigen. Als PPS1 MUSS der Wert von TA<sub>1</sub> aus dem ATR verwendet werden. <b>[<=]</b>

REQ(ids=G2_N200.230)<b>G2_N200.230 - (N200.230) K_Performanztest</b>
PAR Schritt 3: Das IFD MUSS der Smartcard den Wert von IFSD = 254 präsentieren. <b>[<=]</b>

REQ(ids=G2_N200.240)<b>G2_N200.240 - (N200.240) K_Performanztest</b>
PAR Schritt 4: Der Zeitpunkt t<sub>End</sub> ist definiert durch das Ende der letzten TPDU, welche in (N200.230) übertragen wird. Damit gilt für den i-ten Schleifendurchlauf:    <br>     t<sub>Run</sub><sub>4</sub><sub>,</sub><sub>i</sub> = t<sub>End</sub> – t<sub>Start</sub>. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_16990)<b>A_16990 - (N200.250) K_Performanztest</b>
PAR Der Performanztest MUSS die Performanzpunkte P<sub>KarteStarten</sub> wie folgt ermitteln:<br>P<sub>KarteStarten</sub> = points( (t<sub>Run4</sub><sub>,1</sub>, t<sub> Run4</sub><sub>,2</sub>, …, t<sub> Run4</sub><sub>,100</sub> ), T<sub>KarteStarten</sub> ). <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR Hinweis CosH_98e: Besser wäre es, wenn auch hier die Messung aus CosK_056 anwendbar wäre. Es ist zu prüfen, ob dafür passendes Equipment zur Verfügung steht.
PAR -HEADING(ids=18.8)18.8 Messverfahren für Einzelkommandos (normativ)
PAR -HEADING(ids=18.8.1)18.8.1 CosK_568 ACTIVATE, DEACTIVATE, DELETE, LOAD APPLICATION, TERMINATE
PAR In diesem Kapitel werden Kommandos zur Bearbeitung eines Life Cycle Status betrachtet. Dieser Prüfpunkt arbeitet mit der Anwendung / MF / DF.LCS.
PAR Testvorbereitung:
REQ(ids=G2_N201.110)<b>G2_N201.110 - (N201.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N201.120)<b>G2_N201.120 - (N201.120) K_Performanztest</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.LCS gesetzt werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N201.200)<b>G2_N201.200 - (N201.200) K_Performanztest</b>
PAR Der Performanztest MUSS im Rahmen der Testdurchführung eine Schleife 100-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 1 bis 10 ausgeführt. <b>[<=]</b>

REQ(ids=G2_N201.210)<b>G2_N201.210 - (N201.210) K_Performanztest</b>
PAR Schritt 1: Die Datei / MF / DF.LCS / EF.LCS MUSS mittels Use Case aus (N046.700) selektiert werden. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

PAR Schritt 2: LCS für Dateien
REQ(ids=G2_N201.220.a)<b>G2_N201.220.a - (N201.220)a K_Performanztest</b>
PAR Schritt 2a: currentEF MUSS mittels Use Case aus (N036.000) deaktiviert werden. Die Laufzeit t<sub>deactivate_EF</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.220.b)<b>G2_N201.220.b - (N201.220)b K_Performanztest</b>
PAR Schritt 2b: currentEF MUSS mittels Use Case aus (N034.800) aktiviert werden. Die Laufzeit t<sub>a</sub><sub>c</sub><sub>tivate_EF</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.220.c)<b>G2_N201.220.c - (N201.220)c K_Performanztest</b>
PAR Schritt 2c: currentEF MUSS mittels Use Case aus (N048.903) terminiert werden. Die Laufzeit t<sub>terminate_EF</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.220.d)<b>G2_N201.220.d - (N201.220)d K_Performanztest</b>
PAR Schritt 2d: currentEF MUSS mittels Use Case aus (N037.100) gelöscht werden. Die Laufzeit t<sub>delete_EF</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Schritt 3: Arbeiten mit Passwortobjekten:
REQ(ids=G2_N201.230.a)<b>G2_N201.230.a - (N201.230)a K_Performanztest</b>
PAR Schritt 3a: Der Status von PIN.LCS MUSS mittels Use Case aus (N077.990) abgefragt werden. Die Laufzeit t<sub>GetStatus</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.230.b)<b>G2_N201.230.b - (N201.230)b K_Performanztest</b>
PAR Schritt 3b: Der Transportschutz von PIN.LCS MUSS mittels Use Case aus (N073.700) aufgehoben werden, wobei für newSecret eine zufällig gewählte PIN verwendet werden MUSS, deren Länge gleichverteilt aus dem Bereich [6, 12] gezogen wird. Die Laufzeit t<sub>SetPIN</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.230.c)<b>G2_N201.230.c - (N201.230)c K_Performanztest</b>
PAR Schritt 3c: Das Attribut PIN.LCS.flagEnabled MUSS mittels Use Case aus (N075.386) auf den Wert False gesetzt werden. Die Laufzeit t<sub>DisablePIN</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.230.d)<b>G2_N201.230.d - (N201.230)d K_Performanztest</b>
PAR Schritt 3d: Das Attribut PIN.LCS.flagEnabled MUSS mittels Use Case aus (N076.586) auf den Wert True gesetzt werden. Die Laufzeit t<sub>EnablePIN</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.230.e)<b>G2_N201.230.e - (N201.230)e K_Performanztest</b>
PAR Schritt 3e: Das Attribut PIN.LCS.secret MUSS mittels Use Case aus (N073.300) auf einen anderen Wert gesetzt werden, wobei für newSecret eine zufällig gewählte PIN verwendet werden MUSS, deren Länge gleichverteilt aus dem Bereich [6, 12] gezogen wird. Die Laufzeit t<sub>ChRefData</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.230.f)<b>G2_N201.230.f - (N201.230)f K_Performanztest</b>
PAR Schritt 3f: VERIFY Kommando gemäß (N082.200) mit korrekten verificationData für das Objekt PIN.LCS. Die Laufzeit t<sub>VERIFY_1</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.230.g)<b>G2_N201.230.g - (N201.230)g K_Performanztest</b>
PAR Schritt 3g: VERIFY Kommando gemäß (N082.200) mit falschen verificationData für das Objekt PIN.LCS. Die Laufzeit t<sub>VERIFY_2</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.230.h)<b>G2_N201.230.h - (N201.230)h K_Performanztest</b>
PAR Schritt 3h: VERIFY Kommando gemäß (N082.200) mit falschen verificationData für das Objekt PIN.LCS. Die Laufzeit t<sub>VERIFY_3</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.230.i)<b>G2_N201.230.i - (N201.230)i K_Performanztest</b>
PAR Schritt 3i: VERIFY Kommando gemäß (N082.200) mit korrekten verificationData für das Objekt PIN.LCS. Die Laufzeit t<sub>VERIFY_4</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=A_16991)<b>A_16991 - (N201.230)j K_Performanztest</b>
PAR Schritt 3j: VERIFY Kommando gemäß (N082.200) mit falschen verificationData für das Objekt PIN.LCS. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

REQ(ids=G2_N201.230.k)<b>G2_N201.230.k - (N201.230)k K_Performanztest</b>
PAR Schritt 3k: RESET RETRY COUNTER gemäß (N079.300) mit korrekter PUK für das Objekt PIN.LCS, wobei für newSecret eine zufällig gewählte PIN verwendet werden MUSS, deren Länge gleichverteilt aus dem Bereich [6, 12] gezogen wird. Die Laufzeit t<sub>ResetRC</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Schritt 4: LCS für Passwortobjekte:
REQ(ids=G2_N201.240.a)<b>G2_N201.240.a - (N201.240)a K_Performanztest</b>
PAR Schritt 4a: PIN.LCS MUSS mittels Use Case aus (N036.034) deaktiviert werden. Die Laufzeit t<sub>deactivate_Pwd</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.240.b)<b>G2_N201.240.b - (N201.240)b K_Performanztest</b>
PAR Schritt 4b: PIN.LCS MUSS mittels Use Case aus (N034.834) aktiviert werden. Die Laufzeit t<sub>act</sub><sub>i</sub><sub>vate_Pwd</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.240.c)<b>G2_N201.240.c - (N201.240)c K_Performanztest</b>
PAR Schritt 4c: PIN.LCS MUSS mittels Use Case aus (N048.934) terminiert werden. Die Laufzeit t<sub>terminate_Pwd</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.240.d)<b>G2_N201.240.d - (N201.240)d K_Performanztest</b>
PAR Schritt 4d: PIN.LCS MUSS mittels Use Case aus (N037.134) gelöscht werden. Die Laufzeit t<sub>del</sub><sub>e</sub><sub>te_Pwd</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Schritt 5: LCS für private Schlüssel:
REQ(ids=G2_N201.250.a)<b>G2_N201.250.a - (N201.250)a K_Performanztest</b>
PAR Schritt 5a: PrK.LCS MUSS mittels Use Case aus (N036.014) deaktiviert werden. Die Laufzeit t<sub>deactivate_PrK</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.250.b)<b>G2_N201.250.b - (N201.250)b K_Performanztest</b>
PAR Schritt 5b: PrK.LCS MUSS mittels Use Case aus (N034.814) aktiviert werden. Die Laufzeit t<sub>act</sub><sub>i</sub><sub>vate_PrK</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.250.c)<b>G2_N201.250.c - (N201.250)c K_Performanztest</b>
PAR Schritt 5c: PrK.LCS MUSS mittels Use Case aus (N048.914) terminiert werden. Die Laufzeit t<sub>terminate_PrK</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.250.d)<b>G2_N201.250.d - (N201.250)d K_Performanztest</b>
PAR Schritt 5d: PrK.LCS MUSS mittels Use Case aus (N037.114) gelöscht werden. Die Laufzeit t<sub>del</sub><sub>e</sub><sub>te_PrK</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Schritt 6: LCS für öffentliche Schlüssel:
REQ(ids=G2_N201.260.a)<b>G2_N201.260.a - (N201.260)a K_Performanztest</b>
PAR Schritt 6a: PuK.LCS MUSS mittels Use Case aus (N036.024) deaktiviert werden. Die Laufzeit t<sub>deactivate_PuK</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.260.b)<b>G2_N201.260.b - (N201.260)b K_Performanztest</b>
PAR Schritt 6b: PuK.LCS MUSS mittels Use Case aus (N034.824) aktiviert werden. Die Laufzeit t<sub>act</sub><sub>i</sub><sub>vate_PuK</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.260.c)<b>G2_N201.260.c - (N201.260)c K_Performanztest</b>
PAR Schritt 6c: PuK.LCS MUSS mittels Use Case aus (N048.924) terminiert werden. Die Laufzeit t<sub>terminate_PuK</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.260.d)<b>G2_N201.260.d - (N201.260)d K_Performanztest</b>
PAR Schritt 6d: PuK.LCS MUSS mittels Use Case aus (N037.124) gelöscht werden. Die Laufzeit t<sub>delete_PuK</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Schritt 7: LCS für symmetrische Schlüssel:
REQ(ids=G2_N201.270.a)<b>G2_N201.270.a - (N201.270)a K_Performanztest</b>
PAR Schritt 7a: SK.LCS MUSS mittels Use Case aus (N036.014) deaktiviert werden. Die Laufzeit t<sub>deactivate_SyK</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.270.b)<b>G2_N201.270.b - (N201.270)b K_Performanztest</b>
PAR Schritt 7b: SK.LCS MUSS mittels Use Case aus (N034.814) aktiviert werden. Die Laufzeit t<sub>act</sub><sub>i</sub><sub>vate_SyK</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.270.c)<b>G2_N201.270.c - (N201.270)c K_Performanztest</b>
PAR Schritt 7c: SK.LCS MUSS mittels Use Case aus (N048.914) terminiert werden. Die Laufzeit t<sub>te</sub><sub>r</sub><sub>minate_SyK</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.270.d)<b>G2_N201.270.d - (N201.270)d K_Performanztest</b>
PAR Schritt 7d: SK.LCS MUSS mittels Use Case aus (N037.114) gelöscht werden. Die Laufzeit t<sub>del</sub><sub>e</sub><sub>te_SyK</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.280)<b>G2_N201.280 - (N201.280) K_Performanztest</b>
PAR Schritt 8: Der Ordner / MF / DF.LCS MUSS mittels Use Case aus (N044.900) selektiert werden. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

PAR Schritt 9: LCS für Ordner:
REQ(ids=G2_N201.290.a)<b>G2_N201.290.a - (N201.290)a K_Performanztest</b>
PAR Schritt 9a: currentFolder MUSS mittels Use Case aus (N036.000) deaktiviert werden. Die Laufzeit t<sub>deactivate_DF</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.290.b)<b>G2_N201.290.b - (N201.290)b K_Performanztest</b>
PAR Schritt 9b: currentFolder MUSS mittels Use Case aus (N034.800) aktiviert werden. Die Laufzeit t<sub>activate_DF</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.290.c)<b>G2_N201.290.c - (N201.290)c K_Performanztest</b>
PAR Schritt 9c: currentFolder MUSS mittels Use Case aus (N048.800) terminiert werden. Die Laufzeit t<sub>terminate_DF</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N201.290.d)<b>G2_N201.290.d - (N201.290)d K_Performanztest</b>
PAR Schritt 9d: currentFolder MUSS mittels Use Case aus (N037.100) gelöscht werden. Die Laufzeit t<sub>delete_DF</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Schritt 10: Laden von DF.LCS
REQ(ids=G2_N201.300.a)<b>G2_N201.300.a - (N201.300)a K_Performanztest</b>
PAR Schritt 10a: Die Anwdendung DF.LCS MUSS mittels LOAD APPLICATION in den Prüfling geladen werden. Dazu sind ein oder mehrere LOAD APPLICATION Kommandos erforderlich. Gemäß (N040.100) ist currentFolder anschließend auf DF.LCS gesetzt. <b>[<=]</b>

REQ(ids=G2_N201.300.b)<b>G2_N201.300.b - (N201.300)b K_Performanztest</b>
PAR Schritt 10b: Die Ausführungszeit jedes LOAD APPLICATION Kommandos MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=A_16992)<b>A_16992 - (N201.300)c K_Performanztest</b>
PAR Die Summe aller LOAD APPLICATION Kommandoausführungszeiten in der i-ten Schleifeniteration wird mit t<sub>LoadApp</sub><sub>,i</sub> bezeichnet. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_16993)<b>A_16993 - (N201.310) K_Performanztest</b>
PAR Der Performanztest MUSS die in CosT_3d5 genannten Performanzpunkte wie dort angegeben ermitteln:
PAR (ids=Tabelle-354,-CosT_3d5)Tabelle 354, CosT_3d5: Performanzpunkte für LCS Operationen

TABLE(rows=36,cols=103+195+132+129+107)->
TR-> TD(0,0/1/1)->PAR P<sub>activate_DF</sub> TD(0,1/1/1)->PAR = points( (t<sub>act</sub><sub>i</sub><sub>vate_DF</sub><sub>,1</sub>, TD(0,2/1/1)->PAR t<sub>activate_DF</sub><sub>,2</sub>, …, TD(0,3/1/1)->PAR t<sub>activate_DF</sub><sub>,100</sub> ), TD(0,4/1/1)->PAR T<sub>activate_DF</sub> )
TR-> TD(1,0/1/1)->PAR P<sub>activate_EF</sub> TD(1,1/1/1)->PAR = points( (t<sub>act</sub><sub>i</sub><sub>vate_EF</sub><sub>,1</sub>, TD(1,2/1/1)->PAR t<sub>activate_EF</sub><sub>,2</sub>, …, TD(1,3/1/1)->PAR t<sub>activate_EF</sub><sub>,100</sub> ), TD(1,4/1/1)->PAR T<sub>activate_EF</sub> )
TR-> TD(2,0/1/1)->PAR P<sub>activate_Pwd</sub> TD(2,1/1/1)->PAR = points( (t<sub>act</sub><sub>i</sub><sub>vate_Pwd</sub><sub>,1</sub>, TD(2,2/1/1)->PAR t<sub>activate_Pwd</sub><sub>,2</sub>, …, TD(2,3/1/1)->PAR t<sub>activate_Pwd</sub><sub>,100</sub> ), TD(2,4/1/1)->PAR T<sub>activate_Pwd</sub> )
TR-> TD(3,0/1/1)->PAR P<sub>activate_PrK</sub> TD(3,1/1/1)->PAR = points( (t<sub>act</sub><sub>i</sub><sub>vate_PrK</sub><sub>,1</sub>, TD(3,2/1/1)->PAR t<sub>activate_PrK</sub><sub>,2</sub>, …, TD(3,3/1/1)->PAR t<sub>activate_PrK</sub><sub>,100</sub> ), TD(3,4/1/1)->PAR T<sub>activate_PrK</sub> )
TR-> TD(4,0/1/1)->PAR P<sub>activate_PuK</sub> TD(4,1/1/1)->PAR = points( (t<sub>act</sub><sub>i</sub><sub>vate_PuK</sub><sub>,1</sub>, TD(4,2/1/1)->PAR t<sub>activate_PuK</sub><sub>,2</sub>, …, TD(4,3/1/1)->PAR t<sub>activate_PuK</sub><sub>,100</sub> ), TD(4,4/1/1)->PAR T<sub>activate_PuK</sub> )
TR-> TD(5,0/1/1)->PAR P<sub>activate_SK</sub> TD(5,1/1/1)->PAR = points( (t<sub>act</sub><sub>i</sub><sub>vate_SK</sub><sub>,1</sub>, TD(5,2/1/1)->PAR t<sub>activate_SK</sub><sub>,2</sub>, …, TD(5,3/1/1)->PAR t<sub>activate_SK</sub><sub>,100</sub> ), TD(5,4/1/1)->PAR T<sub>activate_SK</sub> )
TR-> TD(6,0/1/1)->PAR P<sub>deact</sub><sub>i</sub><sub>vate_DF</sub> TD(6,1/1/1)->PAR = points( (t<sub>deact</sub><sub>i</sub><sub>vate_DF</sub><sub>,1</sub>, TD(6,2/1/1)->PAR t<sub>deactivate_DF</sub><sub>,2</sub>, …, TD(6,3/1/1)->PAR t<sub>deactivate_DF</sub><sub>,100</sub> ), TD(6,4/1/1)->PAR T<sub>deactivate_DF</sub> )
TR-> TD(7,0/1/1)->PAR P<sub>deact</sub><sub>i</sub><sub>vate_EF</sub> TD(7,1/1/1)->PAR = points( (t<sub>deact</sub><sub>i</sub><sub>vate_EF</sub><sub>,1</sub>, TD(7,2/1/1)->PAR t<sub>deactivate_EF</sub><sub>,2</sub>, …, TD(7,3/1/1)->PAR t<sub>deactivate_EF</sub><sub>,100</sub> ), TD(7,4/1/1)->PAR T<sub>deactivate_EF</sub> )
TR-> TD(8,0/1/1)->PAR P<sub>deact</sub><sub>i</sub><sub>vate_Pwd</sub> TD(8,1/1/1)->PAR = points( (t<sub>deact</sub><sub>i</sub><sub>vate_Pwd</sub><sub>,1</sub>, TD(8,2/1/1)->PAR t<sub>deactivate_Pwd</sub><sub>,2</sub>, …, TD(8,3/1/1)->PAR t<sub>deactivate_Pwd</sub><sub>,100</sub> ), TD(8,4/1/1)->PAR T<sub>deactivate_Pwd</sub> )
TR-> TD(9,0/1/1)->PAR P<sub>deact</sub><sub>i</sub><sub>vate_PrK</sub> TD(9,1/1/1)->PAR = points( (t<sub>deact</sub><sub>i</sub><sub>vate_PrK</sub><sub>,1</sub>, TD(9,2/1/1)->PAR t<sub>deactivate_PrK</sub><sub>,2</sub>, …, TD(9,3/1/1)->PAR t<sub>deactivate_PrK</sub><sub>,100</sub> ), TD(9,4/1/1)->PAR T<sub>deactivate_PrK</sub> )
TR-> TD(10,0/1/1)->PAR P<sub>deact</sub><sub>i</sub><sub>vate_PuK</sub> TD(10,1/1/1)->PAR = points( (t<sub>deact</sub><sub>i</sub><sub>vate_PuK</sub><sub>,1</sub>, TD(10,2/1/1)->PAR t<sub>deactivate_PuK</sub><sub>,2</sub>, …, TD(10,3/1/1)->PAR t<sub>deactivate_PuK</sub><sub>,100</sub> ), TD(10,4/1/1)->PAR T<sub>deactivate_PuK</sub> )
TR-> TD(11,0/1/1)->PAR P<sub>deact</sub><sub>i</sub><sub>vate_SK</sub> TD(11,1/1/1)->PAR = points( (t<sub>deact</sub><sub>i</sub><sub>vate_SK</sub><sub>,1</sub>, TD(11,2/1/1)->PAR t<sub>deactivate_SK</sub><sub>,2</sub>, …, TD(11,3/1/1)->PAR t<sub>deactivate_SK</sub><sub>,100</sub> ), TD(11,4/1/1)->PAR T<sub>deactivate_SK</sub> )
TR-> TD(12,0/1/1)->PAR P<sub>delete_DF</sub> TD(12,1/1/1)->PAR = points( (t<sub>delete_DF</sub><sub>,1</sub>, TD(12,2/1/1)->PAR t<sub>delete_DF</sub><sub>,2</sub>, …, TD(12,3/1/1)->PAR t<sub>delete_DF</sub><sub>,100</sub> ), TD(12,4/1/1)->PAR T<sub>delete_DF</sub> )
TR-> TD(13,0/1/1)->PAR P<sub>delete_EF</sub> TD(13,1/1/1)->PAR = points( (t<sub>delete_EF</sub><sub>,1</sub>, TD(13,2/1/1)->PAR t<sub>delete_EF</sub><sub>,2</sub>, …, TD(13,3/1/1)->PAR t<sub>delete_EF</sub><sub>,100</sub> ), TD(13,4/1/1)->PAR T<sub>delete_EF</sub> )
TR-> TD(14,0/1/1)->PAR P<sub>delete_Pwd</sub> TD(14,1/1/1)->PAR = points( (t<sub>delete_Pwd</sub><sub>,1</sub>, TD(14,2/1/1)->PAR t<sub>delete_Pwd</sub><sub>,2</sub>, …, TD(14,3/1/1)->PAR t<sub>delete_Pwd</sub><sub>,100</sub> ), TD(14,4/1/1)->PAR T<sub>delete_Pwd</sub> )
TR-> TD(15,0/1/1)->PAR P<sub>delete_PrK</sub> TD(15,1/1/1)->PAR = points( (t<sub>delete_PrK</sub><sub>,1</sub>, TD(15,2/1/1)->PAR t<sub>delete_PrK</sub><sub>,2</sub>, …, TD(15,3/1/1)->PAR t<sub>delete_PrK</sub><sub>,100</sub> ), TD(15,4/1/1)->PAR T<sub>delete_PrK</sub> )
TR-> TD(16,0/1/1)->PAR P<sub>delete_PuK</sub> TD(16,1/1/1)->PAR = points( (t<sub>delete_PuK</sub><sub>,1</sub>, TD(16,2/1/1)->PAR t<sub>delete_PuK</sub><sub>,2</sub>, …, TD(16,3/1/1)->PAR t<sub>delete_PuK</sub><sub>,100</sub> ), TD(16,4/1/1)->PAR T<sub>delete_PuK</sub> )
TR-> TD(17,0/1/1)->PAR P<sub>delete_SK</sub> TD(17,1/1/1)->PAR = points( (t<sub>delete_SK</sub><sub>,1</sub>, TD(17,2/1/1)->PAR t<sub>delete_SK</sub><sub>,2</sub>, …, TD(17,3/1/1)->PAR t<sub>delete_SK</sub><sub>,100</sub> ), TD(17,4/1/1)->PAR T<sub>delete_SK</sub> )
TR-> TD(18,0/1/1)->PAR P<sub>terminate_DF</sub> TD(18,1/1/1)->PAR = points( (t<sub>term</sub><sub>i</sub><sub>nate_DF</sub><sub>,1</sub>, TD(18,2/1/1)->PAR t<sub>terminate_DF</sub><sub>,2</sub>, …, TD(18,3/1/1)->PAR t<sub>terminate_DF</sub><sub>,100</sub> ), TD(18,4/1/1)->PAR T<sub>terminate_DF</sub> )
TR-> TD(19,0/1/1)->PAR P<sub>terminate_EF</sub> TD(19,1/1/1)->PAR = points( (t<sub>term</sub><sub>i</sub><sub>nate_EF</sub><sub>,1</sub>, TD(19,2/1/1)->PAR t<sub>terminate_EF</sub><sub>,2</sub>, …, TD(19,3/1/1)->PAR t<sub>terminate_EF</sub><sub>,100</sub> ), TD(19,4/1/1)->PAR T<sub>terminate_EF</sub> )
TR-> TD(20,0/1/1)->PAR P<sub>term</sub><sub>i</sub><sub>nate_Pwd</sub> TD(20,1/1/1)->PAR = points( (t<sub>term</sub><sub>i</sub><sub>nate_Pwd</sub><sub>,1</sub>, TD(20,2/1/1)->PAR t<sub>terminate_Pwd</sub><sub>,2</sub>, …, TD(20,3/1/1)->PAR t<sub>terminate_Pwd</sub><sub>,100</sub> ), TD(20,4/1/1)->PAR T<sub>terminate_Pwd</sub> )
TR-> TD(21,0/1/1)->PAR P<sub>terminate_PrK</sub> TD(21,1/1/1)->PAR = points( (t<sub>term</sub><sub>i</sub><sub>nate_PrK</sub><sub>,1</sub>, TD(21,2/1/1)->PAR t<sub>terminate_PrK</sub><sub>,2</sub>, …, TD(21,3/1/1)->PAR t<sub>terminate_PrK</sub><sub>,100</sub> ), TD(21,4/1/1)->PAR T<sub>terminate_PrK</sub> )
TR-> TD(22,0/1/1)->PAR P<sub>term</sub><sub>i</sub><sub>nate_PuK</sub> TD(22,1/1/1)->PAR = points( (t<sub>term</sub><sub>i</sub><sub>nate_PuK</sub><sub>,1</sub>, TD(22,2/1/1)->PAR t<sub>terminate_PuK</sub><sub>,2</sub>, …, TD(22,3/1/1)->PAR t<sub>terminate_PuK</sub><sub>,100</sub> ), TD(22,4/1/1)->PAR T<sub>terminate_PuK</sub> )
TR-> TD(23,0/1/1)->PAR P<sub>terminate_SK</sub> TD(23,1/1/1)->PAR = points( (t<sub>term</sub><sub>i</sub><sub>nate_SK</sub><sub>,1</sub>, TD(23,2/1/1)->PAR t<sub>terminate_SK</sub><sub>,2</sub>, …, TD(23,3/1/1)->PAR t<sub>terminate_SK</sub><sub>,100</sub> ), TD(23,4/1/1)->PAR T<sub>terminate_SK</sub> )
TR-> TD(24,0/1/1)->PAR P<sub>LoadApp</sub> TD(24,1/1/1)->PAR = points( (t<sub>LoadApp</sub><sub>,1</sub>, TD(24,2/1/1)->PAR t<sub>LoadApp</sub><sub>,2</sub>, …, TD(24,3/1/1)->PAR t<sub>LoadApp</sub><sub>,100</sub> ), TD(24,4/1/1)->PAR T<sub>LoadApp</sub> )
TR-> TD(25,0/1/1)->PAR P<sub>GetPinStatus</sub> TD(25,1/1/1)->PAR = points( (t<sub>Ge</sub><sub>t</sub><sub>Status</sub><sub>,1</sub>, TD(25,2/1/1)->PAR t<sub>GetStatus</sub><sub>,2</sub>, …, TD(25,3/1/1)->PAR t<sub>GetStatus</sub><sub>,100</sub> ), TD(25,4/1/1)->PAR T<sub>GetStatus</sub> )
TR-> TD(26,0/1/1)->PAR P<sub>SetPIN</sub> TD(26,1/1/1)->PAR = points( (t<sub>Se</sub><sub>t</sub><sub>PIN</sub><sub>,1</sub>, TD(26,2/1/1)->PAR t<sub>SetPIN</sub><sub>,2</sub>, …, TD(26,3/1/1)->PAR t<sub>SetPIN</sub><sub>,100</sub> ), TD(26,4/1/1)->PAR T<sub>SetPIN</sub> )
TR-> TD(27,0/1/1)->PAR P<sub>DisablePIN</sub> TD(27,1/1/1)->PAR = points( (t<sub>Disabl</sub><sub>e</sub><sub>PIN</sub><sub>,1</sub>, TD(27,2/1/1)->PAR t<sub>DisablePIN</sub><sub>,2</sub>, …, TD(27,3/1/1)->PAR t<sub>DisablePIN</sub><sub>,100</sub> ), TD(27,4/1/1)->PAR T<sub>DisablePIN</sub> )
TR-> TD(28,0/1/1)->PAR P<sub>EnablePIN</sub> TD(28,1/1/1)->PAR = points( (t<sub>Enabl</sub><sub>e</sub><sub>PIN</sub><sub>,1</sub>, TD(28,2/1/1)->PAR t<sub>EnablePIN</sub><sub>,2</sub>, …, TD(28,3/1/1)->PAR t<sub>EnablePIN</sub><sub>,100</sub> ), TD(28,4/1/1)->PAR T<sub>EnablePIN</sub> )
TR-> TD(29,0/1/1)->PAR P<sub>ChRefData</sub> TD(29,1/1/1)->PAR = points( (t<sub>ChRe</sub><sub>f</sub><sub>Data</sub><sub>,1</sub>, TD(29,2/1/1)->PAR t<sub>ChRefData</sub><sub>,2</sub>, …, TD(29,3/1/1)->PAR t<sub>ChRefData</sub><sub>,100</sub> ), TD(29,4/1/1)->PAR T<sub>ChRefData</sub> )
TR-> TD(30,0/1/1)->PAR P<sub>VERIFY_1</sub> TD(30,1/1/1)->PAR = points( (t<sub>VERIFY_1</sub><sub>,1</sub>, TD(30,2/1/1)->PAR t<sub>VERIFY_1</sub><sub>,2</sub>, …, TD(30,3/1/1)->PAR t<sub>VERIFY_1</sub><sub>,100</sub> ), TD(30,4/1/1)->PAR 0,8 T<sub>VERIFY</sub> )
TR-> TD(31,0/1/1)->PAR P<sub>VERIFY_2</sub> TD(31,1/1/1)->PAR = points( (t<sub>VERIFY_2</sub><sub>,1</sub>, TD(31,2/1/1)->PAR t<sub>VERIFY_2</sub><sub>,2</sub>, …, TD(31,3/1/1)->PAR t<sub>VERIFY_2</sub><sub>,100</sub> ), TD(31,4/1/1)->PAR T<sub>VERIFY</sub> )
TR-> TD(32,0/1/1)->PAR P<sub>VERIFY_3</sub> TD(32,1/1/1)->PAR = points( (t<sub>VERIFY_3</sub><sub>,1</sub>, TD(32,2/1/1)->PAR t<sub>VERIFY_3</sub><sub>,2</sub>, …, TD(32,3/1/1)->PAR t<sub>VERIFY_3</sub><sub>,100</sub> ), TD(32,4/1/1)->PAR T<sub>VERIFY</sub> )
TR-> TD(33,0/1/1)->PAR P<sub>VERIFY_4</sub> TD(33,1/1/1)->PAR = points( (t<sub>VERIFY_4</sub><sub>,1</sub>, TD(33,2/1/1)->PAR t<sub>VERIFY_4</sub><sub>,2</sub>, …, TD(33,3/1/1)->PAR t<sub>VERIFY_4</sub><sub>,100</sub> ), TD(33,4/1/1)->PAR T<sub>VERIFY</sub> )
TR-> TD(34,0/1/1)->PAR P<sub>VERIFY</sub> TD(34,1/1/4)->PAR = 0,8 P<sub>VERIFY_1</sub> + 0,08 P<sub>VERIFY_2</sub> + 0,02 P<sub>VERIFY_3</sub> + 0,1 P<sub>VERIFY_4</sub>
TR-> TD(35,0/1/1)->PAR P<sub>ResetRC</sub> TD(35,1/1/1)->PAR = points( (t<sub>R</sub><sub>e</sub><sub>setRC</sub><sub>,1</sub>, TD(35,2/1/1)->PAR t<sub>ResetRC</sub><sub>,2</sub>, …, TD(35,3/1/1)->PAR t<sub>ResetRC</sub><sub>,100</sub> ), TD(35,4/1/1)->PAR T<sub>ResetRC</sub> )
PAR <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.2)18.8.2 CosK_dee SELECT Datei
PAR In diesem Kapitel wird die Selektion von Dateien betrachtet. Dieser Prüfpunkt arbeitet mit der Anwendung / MF / DF.SelectEF.
PAR Testvorbereitung:
REQ(ids=G2_N202.110)<b>G2_N202.110 - (N202.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N202.120)<b>G2_N202.120 - (N202.120) K_Performanztest</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.SelectEF gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N202.130)<b>G2_N202.130 - (N202.130) K_Performanztest</b>
PAR Schritt 3: currentEF MUSS auf / MF / DF.SelectEF / EF.00 gesetzt werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N202.200)<b>G2_N202.200 - (N202.200) K_Performanztest</b>
PAR Die Testdurchführung MUSS eine Schleife 100-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 1 bis 2 ausgeführt. <b>[<=]</b>

REQ(ids=A_16994)<b>A_16994 - (N202.210) K_Performanztest</b>
PAR Schritt 1: Aus der Menge der zu Anfang 100 in DF.SelectEF gültigen Fileidentifier MUSS ein bislang noch nicht verwendeter gezogen werden (ziehen ohne zurücklegen). <b>[<=]</b>

REQ(ids=G2_N202.220)<b>G2_N202.220 - (N202.220) K_Performanztest</b>
PAR Schritt 2: Die Datei mit dem in Schritt 1 ausgewählten Fileidentifier MUSS mittels Use Case aus (N046.700) selektiert werden. Die Laufzeit t<sub>select_EF</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_16995)<b>A_16995 - (N202.230) K_Performanztest</b>
PAR Der Performanztest MUSS die Performanzpunkte P<sub>s</sub><sub>e</sub><sub>lect_EF</sub> wie folgt ermitteln:<br>P<sub>s</sub><sub>e</sub><sub>lect_EF</sub> = points( t<sub>s</sub><sub>e</sub><sub>lect_EF</sub><sub>,1</sub>, t<sub>s</sub><sub>e</sub><sub>lect_EF</sub><sub>,2</sub>, …,  t<sub>s</sub><sub>e</sub><sub>lect_EF</sub><sub>,100</sub> ), T<sub>select_EF</sub> ) <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.3)18.8.3 CosK_e73 FINGERPRINT
PAR In diesem Abschnitt wird die Berechnung des COS Fingerprints betrachtet. Dieser Prüfpunkt arbeitet mit der Anwendung / MF.
PAR Testvorbereitung:
REQ(ids=G2_N203.110)<b>G2_N203.110 - (N203.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=A_16996)<b>A_16996 - (N203.200) K_Performanztest</b>
PAR Die Testdurchführung MUSS eine Schleife 100-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 1 bis 2 ausgeführt. <b>[<=]</b>

REQ(ids=G2_N203.210)<b>G2_N203.210 - (N203.210) K_Performanztest</b>
PAR Schritt 1: In der i–ten Schleifeniteration MUSS ein Oktettstring prefix = RAND( 128 ) erzeugt werden. <b>[<=]</b>

REQ(ids=G2_N203.220)<b>G2_N203.220 - (N203.220) K_Performanztest</b>
PAR Schritt 2: FINGERPRINT Kommando gemäß (N096.454), wobei als prefix der im vorherigen Schritt erzeugte Wert dient. Die Laufzeit t<sub>fp</sub><sub>,i</sub> dieses Kommandos MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_16997)<b>A_16997 - (N203.230) K_Performanztest</b>
PAR Der Performanztest MUSS die Performanzpunkte P<sub>finge</sub><sub>r</sub><sub>print</sub> wie folgt ermitteln:<br>P<sub>finge</sub><sub>r</sub><sub>print</sub> = points( (t<sub>fp</sub><sub>,1</sub>, t<sub>fp</sub><sub>,2</sub>, …, t<sub>fp</sub><sub>,100</sub> ), T<sub>fingerprint</sub> ) <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.4)18.8.4 CosK_713 TERMINATE CARD USAGE
PAR In diesem Kapitel wird das Terminieren einer Smartcard betrachtet.
PAR Testvorbereitung:
REQ(ids=G2_N204.110)<b>G2_N204.110 - (N204.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N204.200)<b>G2_N204.200 - (N204.200) K_Performanztest</b>
PAR Die Testdurchführung MUSS eine Schleife zehnmal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 1 bis 2 ausgeführt. <b>[<=]</b>

REQ(ids=G2_N204.210)<b>G2_N204.210 - (N204.210) K_Performanztest</b>
PAR Schritt 1: Die Smartcard MUSS mittels Use Case aus (N048.700) terminiert werden. Die Laufzeit t<sub>terminateCard</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N204.220)<b>G2_N204.220 - (N204.220) K_Performanztest</b>
PAR Schritt 2: Die Smartcard MUSS so reinitialisiert werden, dass die in CosK_cc0 definierte Kartenkonfiguration vorliegt. Die Ausführungszeit dieser Operation ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_16998)<b>A_16998 - (N204.230) K_Performanztest</b>
PAR Der Performanztest MUSS die Performanzpunkte P<sub>terminat</sub><sub>e</sub><sub>Card</sub> wie folgt ermitteln:<br>P<sub>terminat</sub><sub>e</sub><sub>Card</sub> = points((t<sub>terminat</sub><sub>e</sub><sub>Card</sub><sub>,1</sub>, t<sub>terminateCard</sub><sub>,2</sub>,…, t<sub>terminat</sub><sub>e</sub><sub>Card</sub><sub>,10</sub> ), T<sub>terminat</sub><sub>e</sub><sub>Card</sub> ) <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.5)18.8.5 CosK_48c SET LOGICAL EOF, WRITE BINARY
PAR In diesem Kapitel wird das Anfügen von Daten in transparenten EF und das Setzen des Attributes positionLogicalEndOfFile betrachtet. Dieser Prüfpunkt arbeitet mit der Datei / MF / DF.SelectEF / EF.transparent.
PAR Testvorbereitung:
REQ(ids=G2_N205.110)<b>G2_N205.110 - (N205.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N205.120)<b>G2_N205.120 - (N205.120) K_Performanztest</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.transparent gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N205.130)<b>G2_N205.130 - (N205.130) K_Performanztest</b>
PAR Schritt 3: currentEF MUSS auf / MF / DF.transparent / EF.transparent gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N205.140)<b>G2_N205.140 - (N205.140) K_Performanztest</b>
PAR Schritt 4: Es MUSS eine Menge mit den natürlichen Zahlen M<sub>Nc</sub> = {1, 2, 3, …, 1000} erstellt werden. <b>[<=]</b>

REQ(ids=G2_N205.150)<b>G2_N205.150 - (N205.150) K_Performanztest</b>
PAR Schritt 5: Es MUSS eine leere Menge M<sub>SetEOF</sub> = {} erstellt werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=A_17000)<b>A_17000 - (N205.200) K_Performanztest</b>
PAR Die Testdurchführung durchläuft eine Schleife solange, bis die Menge M<sub>Nc</sub> leer ist. In jedem Schleifendurchlauf werden die Schritte 1 bis 3 ausgeführt. Nach Abarbeitung der Schleife wird mit Schritt 4 fortgefahren. <b>[<=]</b>

REQ(ids=A_17001)<b>A_17001 - (N205.210) K_Performanztest</b>
PAR Schritt 1: Aus der Menge M<sub>Nc</sub> wird ein beliebiges Element e zufällig gezogen (ziehen ohne zurücklegen) und der Oktettstring newData = RAND( e ) erzeugt. <b>[<=]</b>

REQ(ids=G2_N205.220)<b>G2_N205.220 - (N205.220) K_Performanztest</b>
PAR Schritt 2: Der body von EF.transparent wird gemäß Use Case aus (N055.205) erweitert wobei newData als Kommandonachricht verwendet wird. Die Laufzeit t<sub>write</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N205.230)<b>G2_N205.230 - (N205.230) K_Performanztest</b>
PAR Schritt 3: Wenn das Attribute EF.transparent.positionLogicalEndOfFile nach Schritt 2 größer als '7800' = 30.720 ist, dann MUSS dieses Attribut mittels Use Case aus (N052.932) auf den Wert null gesetzt werden. Die Laufzeit t<sub>set</sub> dieses Kommandos MUSS gemäß CosK_056 gemessen und der Menge M<sub>SetEOF</sub> hinzugefügt werden. <b>[<=]</b>

REQ(ids=G2_N205.240)<b>G2_N205.240 - (N205.240) K_Performanztest</b>
PAR Schritt 4: Das Attribute EF.transparent.positionLogicalEndOfFile wird mittels Use Case aus (N052.932) auf den Wert null gesetzt. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant.Die Laufzeit t<sub>set</sub> dieses Kommandos MUSS gemäß CosK_056 gemessen und der Menge M<sub>SetEOF</sub> hinzugefügt werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17002)<b>A_17002 - (N205.250) Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:<br>Durch die Messpunkt (x, y) -> (e, t<sub>write</sub><sub>,i</sub>) wird eine Ausgleichsgerade y = m x + b gelegt.      <b>[<=]</b>

PAR Hinweis CosH_375: Die Steigung m der Ausgleichsgeraden gibt die Schreibrate in Sekunden pro Byte an. Der Faktor 1000, der in der Berechnung von P<sub>m</sub> aufgeführt ist, rechnet dies um in Sekunden pro kByte.
PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.6)18.8.6 CosK_171 ERASE BINARY, UPDATE BINARY
PAR In diesem Kapitel wird das Schreiben und Löschen von Daten in transparenten EF betrachtet. Dieser Prüfpunkt arbeitet mit der Datei / MF / DF.SelectEF / EF.transparent.
PAR Testvorbereitung:
REQ(ids=G2_N206.110)<b>G2_N206.110 - (N206.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N206.120)<b>G2_N206.120 - (N206.120) K_Performanztest</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.transparent gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N206.130)<b>G2_N206.130 - (N206.130) K_Performanztest</b>
PAR Schritt 3: currentEF MUSS auf / MF / DF.transparent / EF.transparent gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N206.140)<b>G2_N206.140 - (N206.140) K_Performanztest</b>
PAR Schritt 4: Es MUSS eine Menge mit den natürlichen Zahlen M<sub>Nc</sub> = {1, 2, 3, …, 1000} erstellt werden. <b>[<=]</b>

REQ(ids=G2_N206.150)<b>G2_N206.150 - (N206.150) K_Performanztest</b>
PAR Schritt 5: Es MUSS eine leere Menge M<sub>wipe</sub> = {} erstellt werden. <b>[<=]</b>

REQ(ids=A_17003)<b>A_17003 - (N206.160) K_Performanztest</b>
PAR Schritt 6: Das Attribute EF.transparent.positionLogicalEndOfFile wird mittels Use Case aus (N053.200) auf den Wert EF.transparent.numberOfOctet gesetzt, wobei für den Kommandoparameter newData = '00' gilt. <b>[<=]</b>

REQ(ids=A_17004)<b>A_17004 - (N206.170) K_Performanztest</b>
PAR Schritt 7: Die Variable index wird auf den Wert null gesetzt. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=A_17005)<b>A_17005 - (N206.200) K_Performanztest</b>
PAR Die Testdurchführung durchläuft eine Schleife solange, bis die Menge M<sub>Nc</sub> leer ist. In jedem Schleifendurchlauf werden die Schritte 1 bis 3 ausgeführt. Nach Abarbeitung der Schleife wird mit Schritt 4 fortgefahren. <b>[<=]</b>

REQ(ids=A_17006)<b>A_17006 - (N206.210) K_Performanztest</b>
PAR Schritt 1: Aus der Menge M<sub>Nc</sub> wird ein beliebiges Element e zufällig gezogen (ziehen ohne zurücklegen) und der Oktettstring newData = RAND( e ) erzeugt. <b>[<=]</b>

REQ(ids=G2_N206.220)<b>G2_N206.220 - (N206.220) K_Performanztest</b>
PAR Schritt 2: Der body von EF.transparent wird gemäß Use Case aus (N053.200) beschrieben, wobei newData als Kommandonachricht und index als Kommandoparameter offset verwendet wird. Die Laufzeit t<sub>update</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. Nach Kommandoausführung wird index += e gesetzt. <b>[<=]</b>

REQ(ids=G2_N206.230)<b>G2_N206.230 - (N206.230) K_Performanztest</b>
PAR Schritt 3: Wenn index nach Schritt 2 größer als '7800' = 30.720 ist, dann MUSS index auf den Wert null gesetzt werden und der Inhalt von EF.transparent mittels Use Case aus (N049.100) gelöscht werden, wobei der Kommandoparameter offset = 0 gesetzt wird. Die Laufzeit t<sub>wipe</sub> dieses Kommandos MUSS gemäß CosK_056 gemessen und der Menge M<sub>wipe</sub> hinzugefügt werden. <b>[<=]</b>

REQ(ids=G2_N206.240)<b>G2_N206.240 - (N206.240) K_Performanztest</b>
PAR Schritt 4: Der Inhalt von EF.transparent wird mittels Use Case aus (N049.100) gelöscht, wobei der Kommandoparameter offset = 0 gesetzt wird. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant.Die Laufzeit t<sub>wipe</sub> dieses Kommandos MUSS gemäß CosK_056 gemessen und der Menge M<sub>wipe</sub> hinzugefügt werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17007)<b>A_17007 - (N206.250) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:<br>Durch die Messpunkt (x, y) -> (e, t<sub>update</sub><sub>,i</sub>) wird eine Ausgleichsgerade y = m x + b gelegt.      <b>[<=]</b>

PAR Hinweis CosH_f74: Die Steigung m der Ausgleichsgeraden gibt die Schreibrate in Sekunden pro Byte an. Der Faktor 1000, der in der Berechnung von P<sub>m</sub> aufgeführt ist, rechnet dies um in Sekunden pro kByte.
PAR Testnachbereitung:
REQ(ids=A_17009)<b>A_17009 - (N206.300) K_Performanztest</b>
PAR Das Attribute EF.transparent.positionLogicalEndOfFile MUSS mittels Use Case aus (N052.932) auf den Wert null gesetzt werden. <b>[<=]</b>

PAR -HEADING(ids=18.8.7)18.8.7 CosK_759 READ BINARY
PAR In diesem Kapitel wird das Lesen von Daten in transparenten EF betrachtet. Dieser Prüfpunkt arbeitet mit der Datei / MF / DF.SelectEF / EF.transparent.
PAR Testvorbereitung:
REQ(ids=G2_N207.110)<b>G2_N207.110 - (N207.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N207.120)<b>G2_N207.120 - (N207.120) K_Performanztest</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.transparent gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N207.130)<b>G2_N207.130 - (N207.130) K_Performanztest</b>
PAR Schritt 3: currentEF MUSS auf / MF / DF.transparent / EF.transparent gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N207.140)<b>G2_N207.140 - (N207.140) K_Performanztest</b>
PAR Schritt 4: Es MUSS eine Menge mit den natürlichen Zahlen M<sub>Ne</sub>= {1, 2, 3, …, 1000} erstellt werden. <b>[<=]</b>

REQ(ids=A_17010)<b>A_17010 - (N207.150) K_Performanztest</b>
PAR Schritt 5: Das Attribute EF.transparent.body MUSS vollständig mit zufälligen Werten befüllt werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=A_17011)<b>A_17011 - (N207.200) K_Performanztest</b>
PAR Die Testdurchführung MUSS eine Schleife solange durchlaufen, bis die Menge M<sub>Ne</sub> leer ist. In jedem Schleifendurchlauf werden die Schritte 1 bis 2 ausgeführt. <b>[<=]</b>

REQ(ids=A_17012)<b>A_17012 - (N207.210) K_Performanztest</b>
PAR Schritt 1: Aus der Menge M<sub>Ne</sub> wird ein beliebiges Element e zufällig gezogen (ziehen ohne zurücklegen). <b>[<=]</b>

REQ(ids=G2_N207.220)<b>G2_N207.220 - (N207.220) K_Performanztest</b>
PAR Schritt 2: Teile von EF.transparent.body werden gemäß Use Case aus (N051.100) ausgelesen, wobei e als Kommandoparameter length und eine zufällige Zahl aus dem Bereich [0, 30.720] = ['0000', '7800'] als Kommandoparameter offset verwendet wird. Die Laufzeit t<sub>read</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17013)<b>A_17013 - (N207.230) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:<br>Durch die Messpunkt (x, y) -> (e, t<sub>read</sub><sub>,i</sub>) wird eine Ausgleichsgerade y = m x + b gelegt.      <b>[<=]</b>

PAR Hinweis CosH_8e2: Die Steigung m der Ausgleichsgeraden gibt die Leserate in Sekunden pro Byte an. Der Faktor 1000, der in der Berechnung von P<sub>m</sub> aufgeführt ist, rechnet dies um in Sekunden pro kByte.
PAR Testnachbereitung:
REQ(ids=A_17014)<b>A_17014 - (N207.300) K_Performanztest</b>
PAR Das Attribute EF.transparent.positionLogicalEndOfFile MUSS mittels Use Case aus (N052.932) auf den Wert null gesetzt werden. <b>[<=]</b>

PAR -HEADING(ids=18.8.8)18.8.8 CosK_43a Rekord orientierte Kommandos
PAR In diesem Abschnitt werden folgende Kommandos betrachtet: ACTIVATE RECORD, APPEND RECORD, DEACTIVATE RECORD, DELETE RECORD, ERASE RECORD, READ RECORD, UPDATE RECORD. Das Kommando SEARCH RECORD wird in CosK_d78 behandelt. Dieser Prüfpunkt arbeitet mit der Datei / MF / DF.strukturiert / EF.strukturiert.
PAR Testvorbereitung:
REQ(ids=G2_N208.100)<b>G2_N208.100 - (N208.100) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N208.110)<b>G2_N208.110 - (N208.110) K_Performanztest</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.strukturiert gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N208.120)<b>G2_N208.120 - (N208.120) K_Performanztest</b>
PAR Schritt 3: Die Datei / MF / DF.strukturiert / EF.strukturiert MUSS mittels Use Case aus (N46.700) selektiert werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N208.200)<b>G2_N208.200 - (N208.200) K_Performanztest</b>
PAR Die Testdurchführung MUSS eine Schleife 255 mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 1 bis 7 ausgeführt. <b>[<=]</b>

REQ(ids=G2_N208.210)<b>G2_N208.210 - (N208.210) K_Performanztest</b>
PAR Schritt 1, APPEND RECORD: Im i-ten Schleifendurchlauf wird ein Oktettstring recordData = RAND( i ) erzeugt. In currentEF MUSS mittels Use Case aus (N058.400) ein neuer Rekord angelegt werden, wobei als Datenteil der Kommandonachricht recordData verwendet wird. Die Laufzeit t<sub>append</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N208.220)<b>G2_N208.220 - (N208.220) K_Performanztest</b>
PAR Schritt 2, DEACTIVATE RECORD: Rekord 1 in currentEF MUSS mittels Use Case aus (N060.700) deaktiviert werden. Die Laufzeit t<sub>deactivate</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N208.230)<b>G2_N208.230 - (N208.230) K_Performanztest</b>
PAR Schritt 3, ACTIVATE RECORD: Rekord 1 in currentEF MUSS mittels Use Case aus (N055.500) aktiviert werden. Die Laufzeit t<sub>activate</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N208.240)<b>G2_N208.240 - (N208.240) K_Performanztest</b>
PAR Schritt 4, UPDATE RECORD: Rekord 1 in currentEF MUSS mittels Use Case aus (N070.300) auf den Wert newData = RAND( i ) werden. Die Laufzeit t<sub>update</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N208.250)<b>G2_N208.250 - (N208.250) K_Performanztest</b>
PAR Schritt 5, READ RECORD: Rekord 1 in currentEF MUSS mittels Use Case aus (N065.700) gelesen werden. Die Laufzeit t<sub>read</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N208.260)<b>G2_N208.260 - (N208.260) K_Performanztest</b>
PAR Schritt 6, ERASE RECORD wipe: Der Inhalt von Rekord 1 in currentEF MUSS mittels Use Case aus (N063.600) gelöscht werden. Die Laufzeit t<sub>wipe</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N208.270)<b>G2_N208.270 - (N208.270) K_Performanztest</b>
PAR Schritt 7, DELETE RECORD: Rekord 1 in currentEF MUSS mittels Use Case aus (N063.422) aus currentEF.recordList entfernt werden. Die Laufzeit t<sub>delete</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17015)<b>A_17015 - (N208.280) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:<br>Durch die Messpunkt (x, y) -> (i, t<sub>a</sub><sub>,i</sub>) wird eine Ausgleichsgerade y = m<sub>a</sub> x + b<sub>a</sub> gelegt.           <b>[<=]</b>

PAR Hinweis CosH_1c3: Die Steigung m der Ausgleichsgeraden gibt die Schreib- oder Leserate in Sekunden pro Byte an. Der Faktor 1000, der in der Berechnung von P<sub>a</sub><sub>,m</sub> aufgeführt ist, rechnet dies um in Sekunden pro kByte.
PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.9)18.8.9 CosK_d78 SEARCH RECORD
PAR Hier wird lediglich das Kommando SEARCH RECORD betrachtet. Die übrigen rekordorientierten Kommandos werden in CosK_43a behandelt. Dieser Prüfpunkt arbeitet mit der Datei / MF / DF.strukturiert / EF.strukturiert.
PAR Testvorbereitung:
REQ(ids=G2_N209.110)<b>G2_N209.110 - (N209.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N209.120)<b>G2_N209.120 - (N209.120) K_Performanztest</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.strukturiert gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N209.130)<b>G2_N209.130 - (N209.130) K_Performanztest</b>
PAR Schritt 3: Die Datei / MF / DF.strukturiert / EF.strukturiert MUSS mittels Use Case aus (N046.700) selektiert werden. <b>[<=]</b>

REQ(ids=G2_N209.140)<b>G2_N209.140 - (N209.140) K_Performanztest</b>
PAR Schritt 4: Das Attribut currentEF.recordList MUSS mittels Use Case aus (N058.400) wie folgt mit 254 Rekords gefüllt werden, die alle 255 Oktette lang sind:<br>a. Rekord     1 = '0100FF…FF',<br>b. Rekord     2 = 'FF0200FF…FF',<br>c. Rekord     3 = 'FFFF0300FF…FF',<br>d. …<br>e. Rekord   16 = 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1000FF…FF',<br>f. ...<br>g. Rekord 252 = 'FF…FFFC00FFFF',<br>h. Rekord 253 = 'FF…FFFD00FF',<br>i.  Rekord 254 = 'FF…FFFE00'. <b>[<=]</b>

PAR Hinweis CosH_0f3: Ein Rekord i enthält seine Rekordnummer n an der Position n. Der Rekordnummer folgt ein Oktett mit dem Wert '00'. Die übrigen Oktette besitzen den Wert 'FF'. Für ein Oktett lange Pattern gilt somit:<br>a. Pattern = '00': Dieses Pattern ist in jedem Rekord enthalten. Der offset dieses Patterns variiert mit der Rekordnummer.<br>b. Pattern = 'FF': Dieses Pattern ist in jedem Rekord im Wesentlichen am Rekordanfang enthalten.<br>c. Alle übrigen Pattern mit einer Länge von einem Oktett sind in genau einem Rekord enthalten. Der offset dieser Pattern variiert mit der Rekordnummer.
PAR Testdurchführung:
REQ(ids=G2_N209.200)<b>G2_N209.200 - (N209.200) K_Performanztest</b>
PAR Die Testdurchführung MUSS eine Schleife 254-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 1 bis 2 ausgeführt. Nach Abarbeitung der Schleife wird mit Schritt 3 fortgefahren. <b>[<=]</b>

REQ(ids=A_17016)<b>A_17016 - (N209.210) K_Performanztest</b>
PAR Schritt 1: Im i-ten Schleifendurchlauf gilt: searchString = I2OS( i, 1). <b>[<=]</b>

REQ(ids=G2_N209.220)<b>G2_N209.220 - (N209.220) K_Performanztest</b>
PAR Schritt 2: In currentEF MUSS mittels Use Case aus (N067.900) gesucht werden, wobei als Parameter recordNumber = 1 und als Datenteil der Kommandonachricht searchString aus Schritt 1 verwendet wird. Die Laufzeit t<sub>search</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N209.230)<b>G2_N209.230 - (N209.230) K_Performanztest</b>
PAR Schritt 3: In currentEF MUSS mittels Use Case aus (N067.900) gesucht werden, wobei als Parameter recordNumber = 1 und als Datenteil der Kommandonachricht searchString = '00' verwendet wird. Die Laufzeit t<sub>search</sub><sub>,255</sub> dieses Kommandos MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17017)<b>A_17017 - (N209.240) K_Performanztest</b>
PAR Der Performanztest MUSS die Performanzpunkte P<sub>terminat</sub><sub>e</sub><sub>Card</sub> wie folgt ermitteln:<br>P<sub>SearchRec</sub> = points( (t<sub>SearchRec</sub><sub>,1</sub>, t<sub>SearchRec</sub><sub>,2</sub>, …, t<sub>SearchRec</sub><sub>,255</sub> ), T<sub>SearchRec</sub> ) <b>[<=]</b>

PAR Testnachbereitung:
REQ(ids=G2_N209.300)<b>G2_N209.300 - (N209.300) K_Performanztest</b>
PAR Aus / MF / DF.strukturiert / EF.strukturiert MÜSSEN mittels Use Case aus (N063.442) alle Rekords entfernt werden. <b>[<=]</b>

PAR -HEADING(ids=18.8.10)18.8.10 CosK_386 Symmetrische Sessionkeyaushandlung für Secure Messaging
PAR In diesem Abschnitt wird lediglich die symmetrische Aushandlung von Sessionkeys für Secure Messaging betrachtet. Dieser Prüfpunkt arbeitet mit den Schlüsseln SK.AES128, SK.AES192 und SK.AES256 in der Anwendung / MF / DF.Auth.
PAR Testvorbereitung:
REQ(ids=G2_N210.110)<b>G2_N210.110 - (N210.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N210.120)<b>G2_N210.120 - (N210.120) K_Performanztest</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.Auth gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N210.130)<b>G2_N210.130 - (N210.130) K_Performanztest</b>
PAR Schritt 3: Es MUSS eine leere Menge M<sub>GetStatus</sub> = {} erstellt werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N210.200)<b>G2_N210.200 - (N210.200) K_Performanztest</b>
PAR Die Testdurchführung MUSS eine äußere Schleife durchlaufen, wobei keyRef jeden Wert keyIdentifier für die Schlüssel aus der Menge {SK.AES128, SK.AES192, SK.AES256} annimmt. In jedem Schleifendurchlauf werden die Schritte 1 bis 7 ausgeführt. <b>[<=]</b>

REQ(ids=G2_N210.210)<b>G2_N210.210 - (N210.210) K_Performanztest</b>
PAR Schritt 1: MSE Set Kommando gemäß (N102.400), wobei als keyRef die Variable der äußeren Schleife verwendet wird und algId = aesSessionkey4SM gesetzt wird. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

REQ(ids=G2_N210.220)<b>G2_N210.220 - (N210.220) K_Performanztest</b>
PAR Schritt 2: Die Testdurchführung MUSS eine innere Schleife 100-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 3 bis 5 ausgeführt. Anschließend wird mit Schritt 6 fortgefahren. <b>[<=]</b>

REQ(ids=G2_N210.230)<b>G2_N210.230 - (N210.230) K_Performanztest</b>
PAR Schritt 3: Es wird eine Zufallszahl mittels Use Case aus (N098.625) vom Prüfling abgeholt. Die Laufzeit t<sub>rand</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N210.240)<b>G2_N210.240 - (N210.240) K_Performanztest</b>
PAR Schritt 4: Es wird eine erfolgreiche gegenseitige Authentisierung gemäß Use Case aus (N083.800) und (N084.410)a durchgeführt. Die Laufzeit t<sub>Auth</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=A_17018)<b>A_17018 - (N210.250) K_Performanztest</b>
PAR Schritt 5: Die Ausführungszeiten MÜSSEN wie folgt zusammengefasst werden:<br>t<sub>SK</sub><sub>,i</sub>  = t<sub>rand,i</sub> + t<sub>Auth,i</sub>. <b>[<=]</b>

REQ(ids=G2_N210.260.a)<b>G2_N210.260.a - G2_N210.260.a</b>
PAR TODO gematik-Testabteilung: Diese Anforderung gibt es in der COS-Spec nicht, prüfen, korrigieren.<br>AFO-ID aus ReqPro: AFO2006 <b>[<=]</b>

REQ(ids=G2_N210.260.b)<b>G2_N210.260.b - G2_N210.260.b</b>
PAR TODO gematik-Testabteilung: Diese Anforderung gibt es in der COS-Spec nicht, prüfen, korrigieren.<br>AFO-ID aus ReqPro: AFO2007 <b>[<=]</b>

REQ(ids=G2_N210.260.c)<b>G2_N210.260.c - G2_N210.260.c</b>
PAR TODO gematik-Testabteilung: Diese Anforderung gibt es in der COS-Spec nicht, prüfen, korrigieren.<br>AFO-ID aus ReqPro: AFO2008 <b>[<=]</b>

PAR (N210.260) Dieser Punkt ist absichtlich leer.
REQ(ids=A_17019)<b>A_17019 - (N210.270) K_Performanztest</b>
PAR Schritt 6: MSE Restore Kommando gemäß (N099.900) mit seNo = 1, wodurch Sicherheitszustände zurückgesetzt werden. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17020)<b>A_17020 - (N210.280) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:      <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.11)18.8.11 CosK_8cf Schlüsselimport und asymmetrische Authentisierungsprotokolle
PAR In diesem Kapitel wird der Import von Authentisierungsschlüsseln mittels CV–Zertifikaten behandelt, wobei die öffentlichen Schlüssel aller verwendeten CA bei Produktion des Prüflings bekannt sind. Zudem wird die Rollenüberprüfung (eine andere Komponente authentisiert sich gegenüber der eGK) sowie die asymmetrische Aushandlung von Sessionkeys betrachtet.
PAR Der Prüfpunkt beinhaltet einerseits:

ORDERED-LIST->
LITEM->PAR Den Import eines Authentisierungsschlüssels.LITEM->PAR Eine Rollenprüfung zur Erlangung eines Sicherheitszustandes.
PAR Zudem wird hier ebenfalls geprüft:

ORDERED-LIST->
LITEM->PAR Der asymmetrische Aufbau eines Trusted–Channels zur Karte.
PAR -HEADING(ids=18.8.11.1)18.8.11.1 CosK_04d ELC 256
PAR Es werden zehn Test CA benutzt, denen von der Root–CA (siehe PuK.RCA_ELC256 in CosT_d98) folgende CV–Zertifikate zugeordnet werden:
PAR (ids=Tabelle-355,-CosT_ece)Tabelle 355, CosT_ece: ELC-256 Sub-CA CV-Zertifikate für den Performanztest

TABLE(rows=11,cols=41+555)->
TR-> TH(0,0/1/1)->PAR ID TH(0,1/1/1)->PAR CV-Zertifikat
TR-> TD(1,0/1/1)->PAR Test<br>CA0 TD(1,1/1/1)->PAR '7f2181d87f4e81915f290170420844455858586001127f494d06082a8648ce3d0403028641<br>043dc8968bf65157711a3547714230e7d80667d1451897204a9fcd91e5e53b1aeb960a4257e<br>36656f06da638d50d0a4095fbfa11c99c8481da49fe5245a47638855f200844455858586f01<br>127f4c1306082a8214004c0481185307bfffffffffffff5f25060103000902015f240602030<br>00301085f3740960632d2f613697ccbb05b3b21ae6ddb1fbb146deb5cc3f7787a28d485c2e7<br>042b5001db598eac960055c56e3489c568302ff3e638a8b5bece070995859629a9'
TR-> TD(2,0/1/1)->PAR Test<br>CA1 TD(2,1/1/1)->PAR '7f2181d87f4e81915f290170420844455858586001127f494d06082a8648ce3d0403028641<br>04068fb3f80118c9a1390b6f3d6d84a5dd5f5c1228e57268afd09297b71c5d8d451879b7097<br>be706fb9a9e6952f599ef0f7eaa13f111d9c1ec656fdc93163ed9575f200844455858586f11<br>127f4c1306082a8214004c0481185307bfffffffffffff5f25060103000902015f240602030<br>00301085f37406fc05554871d4f0cc60386b500e21975471265ca08a47b932082b596e8be8d<br>bc6e68a729051c47b38db23e16667ff4fae724e39529c7ebd8f05aab249e824c9b'
TR-> TD(3,0/1/1)->PAR Test<br>CA2 TD(3,1/1/1)->PAR '7f2181d87f4e81915f290170420844455858586001127f494d06082a8648ce3d0403028641<br>045fe0d65046d587cf0d494766ed0f4acd646f00820c7d98458df25f49aab891cd2b80e5d51<br>c18719354bf8c8f3a83a41ec8819e894a55a27b8acfe212393f4e685f200844455858586f21<br>127f4c1306082a8214004c0481185307bfffffffffffff5f25060103000902015f240602030<br>00301085f37404f73ecc1733ce8acba3c539b45ba3ba79829a65d6d1057f3f3732fd32c1920<br>ca8efb4489072cc4943b4b948421b146053f39bd51c5275d534ec395333b9f6430'
TR-> TD(4,0/1/1)->PAR Test<br>CA3 TD(4,1/1/1)->PAR '7f2181d87f4e81915f290170420844455858586001127f494d06082a8648ce3d0403028641<br>04a2f12f29f8c45da68c2d9d484ef4f764b861934f19c8ad829edad541050b1ad9323d83083<br>7144714bac3ff9ffa9b9f2ec5288e93373744ba2923c7afb72e6fde5f200844455858586f31<br>127f4c1306082a8214004c0481185307bfffffffffffff5f25060103000902015f240602030<br>00301085f374048a2a0e899ac08817249726f1f13bb983ee5728d3439869953b46b8b69c41d<br>02690ebe1be8a04a5897c82ca04eedc527a016d798f07a776d75fa99f2c7f88e7f'
TR-> TD(5,0/1/1)->PAR Test<br>CA4 TD(5,1/1/1)->PAR '7f2181d87f4e81915f290170420844455858586001127f494d06082a8648ce3d0403028641<br>04156028235673196c4d54e4b78205c9979d2bdb39362d05568ee5c11671ac9010284bb19e2<br>4444b6f174167cd50efd5e6ef9a5780788ac02312f6961dd180e9785f200844455858586f41<br>127f4c1306082a8214004c0481185307bfffffffffffff5f25060103000902015f240602030<br>00301085f374081d4965d98f35605fcb6bb6303378787810af9182d2b9fb495b22161a29e55<br>3a60ea87f7182c96153dc7ef1dfae79e32ad5dae554eca1bc244ab73f57d76cf14'
TR-> TD(6,0/1/1)->PAR Test<br>CA5 TD(6,1/1/1)->PAR '7f2181d87f4e81915f290170420844455858586001127f494d06082a8648ce3d0403028641<br>0462082556bbab7c0387eb3ee7a2767a2277beaf9a02ccdc255a07baf97bd232a74c18c5848<br>88ac8f655c05d56ac7afe399c79bfb865e6fe71ee8a76f35257ff0d5f200844455858586f51<br>127f4c1306082a8214004c0481185307bfffffffffffff5f25060103000902015f240602030<br>00301085f37408db6a883d4e575c1667edd7fc1b3e1b41e7a5d8f73c8ce81b29232f671f4b5<br>178ea62299d06eae35c09794233ad1979b2e263449dbf4c9d68d74331a9a3d94eb'
TR-> TD(7,0/1/1)->PAR Test<br>CA6 TD(7,1/1/1)->PAR '7f2181d87f4e81915f290170420844455858586001127f494d06082a8648ce3d0403028641<br>041932b906841a94133354ef5fb2878d29612e83e3f55b43aceb44d809b1eebecd6c0c515de<br>ce9c483273b5f070c3ab2924a65e26900e73506ed46d96be09bffad5f200844455858586f61<br>127f4c1306082a8214004c0481185307bfffffffffffff5f25060103000902015f240602030<br>00301085f3740948249b88e2d1db43237cdc5c814865aed1ac1f8685cfece3222c2bd169c23<br>c15fe199585d714e74fd468893299f739f80c916e57dff8ffb1747624809122fa3'
TR-> TD(8,0/1/1)->PAR Test<br>CA7 TD(8,1/1/1)->PAR '7f2181d87f4e81915f290170420844455858586001127f494d06082a8648ce3d0403028641<br>04827bc42213603730397a0d1a25981fbf3d4c4326ebf943784fba310eebd0af39153d457fb<br>56d7dacfe7d3acc0397fa29160c67f0fc11caf4d9074b79213355bc5f200844455858586f71<br>127f4c1306082a8214004c0481185307bfffffffffffff5f25060103000902015f240602030<br>00301085f37402bca5198dceee074b1a1ed84dddb52c06ea11e190aaa938636844aaba27741<br>207a66ac35471fa81fca9d04dea2e410fcf1757328fe9d8deec645e5707bdb8cad'
TR-> TD(9,0/1/1)->PAR Test<br>CA8 TD(9,1/1/1)->PAR '7f2181d87f4e81915f290170420844455858586001127f494d06082a8648ce3d0403028641<br>0427ed1d352e39fcf029f07314414df5a2070587e316f42dee798cf117e9dbfabb56a77fb65<br>169d1014b950eeb12efdcdd6e63d44e351386457b53ec58375d10c65f200844455858586f81<br>127f4c1306082a8214004c0481185307bfffffffffffff5f25060103000902015f240602030<br>00301085f3740953e492d4fcd165cf0aa658aa0c3ccecf4bf4877ec52acdb3eb1b2ba2810e8<br>f30928563f2ce1e3666dac086ef84c749c29d6dfb21b448c67b435fe85bdfd126d'
TR-> TD(10,0/1/1)->PAR Test<br>CA9 TD(10,1/1/1)->PAR '7f2181d87f4e81915f290170420844455858586001127f494d06082a8648ce3d0403028641<br>0437b7e999de3102cfab44162d204b1bcab1d495da3f3c1293db90198b2399f42920d2b716e<br>8e5fceeba0a760df6a27009b4f5b5a51a4dae74c4e0aa03d9ab16515f200844455858586f91<br>127f4c1306082a8214004c0481185307bfffffffffffff5f25060103000902015f240602030<br>00301085f374006c12b8bb2affd0e2dc64dc9a51df59ac7d0685b736c58a5af92c0e7c0147e<br>151f937657c6500bb3361c9b504ec39f3867990201ff78d238aa6e797aa74f59c7'
PAR Test:
REQ(ids=A_17021)<b>A_17021 - (N211.110) K_Performanztest</b>
PAR Der Performanztest MUSS für diesen Prüfpunkt mit folgenden Parametern arbeiten:<br>a. M<sub>CVC</sub>        = {TestCA0, TestCA1, …, TestCA9} aus CosT_ece<br>b. PuK.RCA  = / MF / DF.Auth / PuK.RCA_ELC256<br>c. PrK.Auth   = / MF / DF.Auth / PrK.Auth_ELC256 <b>[<=]</b>

REQ(ids=A_17022)<b>A_17022 - (N211.120) K_Performanztest</b>
PAR Der Performanztest MUSS die Performanzmessung für ELC-256 wie folgt durchgeführen:<br>(M<sub>Import</sub>, M<sub>RoleCheck</sub>, M<sub>SesKey</sub>, M<sub>GetSecSta</sub>) = PerformanceAuth(M<sub>CVC</sub>, PuK.RCA, PrK.Auth) <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17023)<b>A_17023 - (N211.130) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:<br> <b>[<=]</b>

PAR -HEADING(ids=18.8.11.2)18.8.11.2 CosK_d9a ELC 384
PAR Es werden zehn Test CA benutzt, denen von der Root–CA (siehe PuK.RCA_ELC384 in CosT_969) folgende CV–Zertifikate zugeordnet werden:
PAR (ids=Tabelle-356,-CosT_811)Tabelle 356, CosT_811: ELC-384 Sub-CA CV-Zertifikate für den Performanztest

TABLE(rows=11,cols=41+555)->
TR-> TH(0,0/1/1)->PAR ID TH(0,1/1/1)->PAR CV-Zertifikat
TR-> TD(1,0/1/1)->PAR Test<br>CA0 TD(1,1/1/1)->PAR '7f218201187f4e81b15f290170420844455858586002127f496d06082a8648ce3d04030386<br>610450130d536c93d3183e4e7271fd291f34be2dde0869749b19420833220f10d4d8ae61f65<br>67710c277fca109565dea64c184f6bdea3470c2082283fcf58ee436983d90f91e6325274728<br>2cbe4218c1befcfd8bf7178be5dc0d0dd9a558a999b63e5f200844455858586f02127f4c130<br>6082a8214004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f<br>37605aed2ebd167b7872df46b37644afdac7d836602365025bfdb58af88404c3986e97b0771<br>677aafc326bc46e2ae3ff6c72718ad232da064b7ff31aec2822d78dd8c4e56613e233a0e76f<br>bf92ad2bf8d6704189a11910f5e94fb45436b578b0894c'
TR-> TD(2,0/1/1)->PAR Test<br>CA1 TD(2,1/1/1)->PAR '7f218201187f4e81b15f290170420844455858586002127f496d06082a8648ce3d040303866<br>1048c24bff918480325f3556cf426460972c797e3ba9ea9c7c1ad0daccd29d3a09fcc9a4fc30<br>e7b0f23f99bb206c9a9a2722b9fa21bcd759368137edc309a31214d610cbe08ba9590215c646<br>cbb54b3548268884afc5e4f84c7fa86c8fcba091f595f200844455858586f12127f4c1306082<br>a8214004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f37603<br>48a55a41fe1624641874b5b10f31667885374ac9db23e67cc75f86895ffa279e444ecb7c0361<br>fabe13ba556056900524f309700775f9774de0fb78371c661902cc11f19bb059e8a32170afd0<br>6ce4e47c19ad6b1a59ef99b993159354d8d8f95'
TR-> TD(3,0/1/1)->PAR Test<br>CA2 TD(3,1/1/1)->PAR '7f218201187f4e81b15f290170420844455858586002127f496d06082a8648ce3d0403038661<br>047c07cbafca6624495a06ab1cc0bbc42210181cd0ba12eb687eb78dafd77a65ec8314aaafcad<br>bada5c071ef705857c7644807136b106d07befc1be5279e7b4536bd7fc70016ce20b448479594<br>441e8179ee4eeda328cc5034756b6871eede6a6c5f200844455858586f22127f4c1306082a821<br>4004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f376035f215<br>4ab00b3d4df8abbed23c261336a833fb977cc18f4dc570754bb89b91e62ffa1605609a0c687f6<br>4f88ea0bc83ad4c8c615cb76868b73f7e55bef0bb3e0db3043d386f1faf32e477a2f0803965bd<br>a9ac9a5afecf8d29ae6edfdbd4bd2c3e'
TR-> TD(4,0/1/1)->PAR Test<br>CA3 TD(4,1/1/1)->PAR '7f218201187f4e81b15f290170420844455858586002127f496d06082a8648ce3d0403038661<br>046aec3041253a998dde1b7f060abeab85939b9c6ab6dd32d7f01b03736d22154c63753c375ae<br>7783189484be4c94772bc5e39cf3b02bf35218c0b1f63bfc234485bcdea8bfe55c39e32928be7<br>ca61638321b03b5dd1912960079138166943a0645f200844455858586f32127f4c1306082a821<br>4004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f37607aeedf<br>7e06c1f2a4042c3937cd0e8110b1a21bb3526f5363451afa4ae0ba67141c3448176c301d71988<br>2e67d8d04e9115f5b6ad5ab3ade0310445a5f314c20ab46a2ee4b03bf528f688e36689749dd55<br>0ed94c8cb4a9b12ff7e76eaef14cf846'
TR-> TD(5,0/1/1)->PAR Test<br>CA4 TD(5,1/1/1)->PAR '7f218201187f4e81b15f290170420844455858586002127f496d06082a8648ce3d0403038661<br>0454d62af2abd57a84f24fd73dfbf1d42074b097549de2f50b349b321866734cad23c2b3705bd<br>fc54b51e4e5d214aa4fc753fab4c7d443af476ff1c8efd4ce6aa9db8e0b65f0f27bd8df797f36<br>dbb4cf6aade07ac21f5081fe22b497f1aefbce9f5f200844455858586f42127f4c1306082a821<br>4004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f376015369d<br>871fb8a1fc6d1ff7c0f71289a07a04df5fe1df47da24e55cf475c47687239cf438668610a76c8<br>536a0085dfb0e0d51cafe24138e4834e38c3fe4e05b387e28e0cd0f13db19ed01ac612946c317<br>47d6a2616aa01ac8b69c7f3ff1f37dc5'
TR-> TD(6,0/1/1)->PAR Test<br>CA5 TD(6,1/1/1)->PAR '7f218201187f4e81b15f290170420844455858586002127f496d06082a8648ce3d0403038661<br>044844e9c051ddb7772cd5700eb9a192382f0b1fbf4a05ffca026510a8f3b70ef26437e842564<br>3ba3b4995e6b1da512c444cc44c14533f253b2507adfbb50544d5573823a4543156bbaf052e7d<br>d54395284dded89b3829202212961c7b5e745ff95f200844455858586f52127f4c1306082a821<br>4004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f376049b34f<br>8f26d761ee83be427566481c5270e1a8a0bad98e3a1ef3492794031195e550f9358f6323feff8<br>7916ea731936b5cabb3c29e57f2b637b91e22ca5cefd6e92348319ab46ae6825acf4c6b332db6<br>296f0d00cdce82b1eb65fc65b39f7aaf'
TR-> TD(7,0/1/1)->PAR Test<br>CA6 TD(7,1/1/1)->PAR '7f218201187f4e81b15f290170420844455858586002127f496d06082a8648ce3d0403038661<br>045c9983c0ad853bc555a63f94b3245b688f2ac8de637f5426f9064d00b2f987776da4a4f7c44<br>5184dce6e76d2e5ef56a40f8d9e3c895790271923b561dfc675819457fcd9edc23093a1962171<br>310ba8a9527ed54f7cac27475f37fad1a90e2d175f200844455858586f62127f4c1306082a821<br>4004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f37607c432e<br>e2ec2640b13a6864ff201880c9392378983201c4abf8e1d55ed8a36c22ac7fd2b8bf8239f5f46<br>ac1a17d1136af2dbd3035979890828d201872af34ce07a6b862f7d5c0ed4ba8dafaa657443ecc<br>04e1b31772911c5459cf0d4c4eb51582'
TR-> TD(8,0/1/1)->PAR Test<br>CA7 TD(8,1/1/1)->PAR '7f218201187f4e81b15f290170420844455858586002127f496d06082a8648ce3d0403038661<br>045949a568bc6e923f5120d246272947cc9ae33a3095b70a95e469c0ffb1e4763b121ece59e33<br>f1275fb896f96e3e2c4752070bd62fae268693aa30bf995874302528074e32f3ba17f94433f0b<br>71576f19f05de2589b395a8bd22409e1ddc93b3a5f200844455858586f72127f4c1306082a821<br>4004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f376039cd3a<br>5d6da66dfea52e514d06ef8186e4ddcdea98185764164a469f9d5f5a3315fb383b73c490d32d1<br>b0424a9ca5c8923ac63aa349cad6620f7c8ea4611ee2724ccf5e68a90bfe7fa008931ae8f7840<br>1ee00fc37c57ce1f5a7c8a69792063a1'
TR-> TD(9,0/1/1)->PAR Test<br>CA8 TD(9,1/1/1)->PAR '7f218201187f4e81b15f290170420844455858586002127f496d06082a8648ce3d0403038661<br>0479ebc9b3c7a373818959904d9154f63a4a08767955fdb23fa6225c39b70147ba5943facaa71<br>e1852b13ba870beb27dbd4dffaeac0198f5bdcb672b4da129778fb1eac47a75f79e4f4d55df70<br>6324d2b593ef00de4e2de19093f29f046906150a5f200844455858586f82127f4c1306082a821<br>4004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f37608299ce<br>56898da0b1b584130f11b03293f05278c9a3619b84f67fa12b9a972dd4001b013c78c2260a409<br>87f813e76f6e73122767f4030c2832a7260b9d2e8a39de6164b35804735de29b65751006b0847<br>90ee68fdc08c792664ff4a89e3859cad'
TR-> TD(10,0/1/1)->PAR Test<br>CA9 TD(10,1/1/1)->PAR '7f218201187f4e81b15f290170420844455858586002127f496d06082a8648ce3d0403038661<br>041fce13dbe6187eca90441f24f69059e97741ee761c934f0954fb16abf3070d80cf974910ce8<br>51d6fcbfa50a10b78de4c5586c538dccf5633152c32e158f22d6cf60b0562e509f1b65caf5fc4<br>3641cf952917c1d6eed4736d43029a5372bb85445f200844455858586f92127f4c1306082a821<br>4004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f37602c787c<br>e37d15b432af5cf70656900958c705d0ce025bd9a56075faed3ae7fc345f0c03b865787c487b1<br>ff6730b50a7ee0b26245a89b31105641fe9c183297ac776147c5e572e271dbe3fd17d199a2bc1<br>f94f7920e1c670daf2035108089e26e8'
PAR Test:
REQ(ids=A_17024)<b>A_17024 - (N211.210) K_Performanztest</b>
PAR Der Performanztest MUSS für diesen Prüfpunkt mit folgenden Parametern arbeiten:<br>a. M<sub>CVC</sub>        = {TestCA0, TestCA1, …, TestCA9} aus CosT_811<br>b. PuK.RCA  = / MF / DF.Auth / PuK.RCA_ELC384<br>c. PrK.Auth   = / MF / DF.Auth / PrK.Auth_ELC384 <b>[<=]</b>

REQ(ids=A_17025)<b>A_17025 - (N211.220) K_Performanztest</b>
PAR Der Performanztest MUSS die Performanzmessung für ELC-384 wie folgt durchgeführen:<br>(M<sub>Import</sub>, M<sub>RoleCheck</sub>, M<sub>SesKey</sub>, M<sub>GetSecSta</sub>) = PerformanceAuth(M<sub>CVC</sub>, PuK.RCA, PrK.Auth) <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17026)<b>A_17026 - (N211.230) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:      <b>[<=]</b>

PAR Hinweis CosH_f07: Das Ergebnis M<sub>GetSecSta</sub> wird hier nicht weiter verwendet, weil dieser Prüfpunkt bereits in CosK_04d betrachtet wird.
PAR -HEADING(ids=18.8.11.3)18.8.11.3 CosK_282 ELC 512
PAR Es werden zehn Test CA benutzt, denen von der Root–CA (siehe PuK.RCA_ELC512 in CosT_1db) folgende CV–Zertifikate zugeordnet werden:
PAR (ids=Tabelle-357,-CosT_649)Tabelle 357, CosT_649: ELC-384 Sub-CA CV-Zertifikate für den Performanztest

TABLE(rows=11,cols=41+555)->
TR-> TH(0,0/1/1)->PAR ID TH(0,1/1/1)->PAR CV-Zertifikat
TR-> TD(1,0/1/1)->PAR Test<br>CA0 TD(1,1/1/1)->PAR '7f2182015b7f4e81d35f290170420844455858586003127f49818e06082a8648ce3d040304<br>8681810495fc9b7543c2ff1ed4394027ad2acb94358fb6e82654e7157fd7c53c82bee4418c1<br>f466c5c9ee3e7a10a5bb82947d97ae11690c784c216960a0ae68e300b449950ba3b9be3eb68<br>8e8c0b6d0b4fb03f5fbceacb21a00c31da9fb7f2c319e679d0d006739e18e80fca70c8702ae<br>a4cd9d986fd84896e07ee851815170d7a5c95825f200844455858586f03127f4c1306082a82<br>14004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f3781800<br>7b9a510c34a95f6fe3a5334db0145faa7678d524067a31b9817125724c5e278424dd6fa3a7b<br>e20f4f762eb0938972b76195618445cb0c12a29b2f4693865b9d84d6d813641f4911f34b5d3<br>f7b9abccde60070a2fc85b2ac0c5d7ab44051b0f959399cf49a8beef2be13f934d3f976dca3<br>877eb69e8499e4a28b5a3d0279a2da'
TR-> TD(2,0/1/1)->PAR Test<br>CA1 TD(2,1/1/1)->PAR '7f2182015b7f4e81d35f290170420844455858586003127f49818e06082a8648ce3d040304<br>868181045f9a82a8f06b6ba10e32f9a21c002c4b96fde78bf47855d26aa4f8d52194756b7ec<br>537559d6a1c6e6a9d12c0634733279e862ce8c50cb68024898dc675d4b52359fdefffbf2d39<br>7d8f7e4f0365e0f13ddb633c2d6311205a268e502921249e429b73e1defdf5d834531d352b2<br>5a47162792d4c6096682ddbe36b11e54875689e5f200844455858586f13127f4c1306082a82<br>14004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f3781804<br>e92e250b06ce31d1ace367543fe3cba02b3d9b938397112a84f8c83a70f701acedefb94a047<br>892ce60d464e3cb22ddaf0ca1ce2c964248a5b5619b7ea71f47f63e2343584b52290dbb46a3<br>c599ed7f5b2344acc3cf1bb9843999247061c0a76350585e0fb8ab14424b0fc5539c00d9999<br>1ce856a83bd1d57da069ea2b8c5a87'
TR-> TD(3,0/1/1)->PAR Test<br>CA2 TD(3,1/1/1)->PAR '7f2182015b7f4e81d35f290170420844455858586003127f49818e06082a8648ce3d040304<br>868181046038d73f8444a04b965a541af9247fef5d639be21793bb4bca616c773ac5dced51c<br>ee5b36220fdbb2a4f320fbd5143fda7700cf17a2a0b49d03c9157ec9960309331754283ef76<br>f0db10cb599397cf8da23535857bb387ba097696f07020c75df500c6521b749fc53f38a57a5<br>62f18c2b5145ded45b6dd9ce7274a60bfe9d12e5f200844455858586f23127f4c1306082a82<br>14004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f3781809<br>835527c0fa6f50056296af1dbe72c3f0836820f4be045d8f147048ba622ae785f58ead4118b<br>4d43f9c69899ca4c87d84d45c487ca309e0b50aa5d8513553d17941bd3cc90ee467347bdf0e<br>79e9db5dbb8ce16f5ad68dfb2227cdfe42b0945dde03b87394b70c32c9c51763340e2f09fa8<br>5426552d3b0a0b8104c52cef8abf15'
TR-> TD(4,0/1/1)->PAR Test<br>CA3 TD(4,1/1/1)->PAR '7f2182015b7f4e81d35f290170420844455858586003127f49818e06082a8648ce3d040304<br>8681810499ca069ab8c0228c85b4c0d0bbbf37d833d658b9ce81b0adc5b762224fd0011801f<br>321435df34677ccd21f6058832fc0b372df96b24ac4cb970681d381f5bc5c22d8a854adbe0b<br>9ddd15bb049589d1b1360816ced81c8cdf43106133b2612710a67024ae0e563f91e849aaf63<br>acc572dc48b9dcd6f87ce5cc203500dd0c638e55f200844455858586f33127f4c1306082a82<br>14004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f3781805<br>f21aae86591351d5ddca7634eaa8a9f12e69f50a87d1d8a4835c24720098e66f1371262b4ca<br>b80733a7e4ea28c9f180852eb19b4e2b0f3db0cb873ddfa92bf75acb2d072b9c810d415a7b6<br>73fd229ad16adeb23ecb2fb0fc7dca8a565fea391ff4d5b487fa3e5c37fb8d5775599586b04<br>4bae6589246b88c3215d05a1c5b309'
TR-> TD(5,0/1/1)->PAR Test<br>CA4 TD(5,1/1/1)->PAR '7f2182015b7f4e81d35f290170420844455858586003127f49818e06082a8648ce3d040304<br>8681810431a80097158da05ecfea043eba55deead39c6e0a078c76e6e668a224ac4b7717213<br>b56521df9b4d77006aff6a5ffe1499070f33bb261a31f675631d6075df9be63d9083b253189<br>1a995accadbeca7cf20dbc3db15d7b1bf545b5556d6fc7a889c0ff25c04bd2e186955d65625<br>7c936cc1e742b49de7ea1e8879b915e512cad545f200844455858586f43127f4c1306082a82<br>14004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f3781809<br>99c42b069726e175b059480e2458ae101de5b3f842187ab8e11bc9b26651b729c8eba497fbc<br>56a6dd1259794ef530db11af9022aff968d237f050e4684935a89f49a69108492e71df26176<br>3d9ba1a46ae9e41bbe205906fb602f9f6b5d3407741f6f482daaa789c2e5131e95c09544664<br>7ea8dc75e40386248012c18a915e39'
TR-> TD(6,0/1/1)->PAR Test<br>CA5 TD(6,1/1/1)->PAR '7f2182015b7f4e81d35f290170420844455858586003127f49818e06082a8648ce3d040304<br>8681810451e931e921d6d7a771bc53e6c7770ed184817b5424a9918761046f34348d45a0677<br>13c04895e68c8cefc140e0a63b49703df483ba9a39f3fb06ee5e8eb4aba651cf33120c97df1<br>4dbfa34d13639ec70b11bbc6671e7e6f756705dd4365dc22e67bcad2e09b013ff9dacaadbec<br>aef90069ca481cf9ab6e61f0f681e4ef91247845f200844455858586f53127f4c1306082a82<br>14004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f3781809<br>1fea03f291142ff6b9942ef1b9c5fa191d53769ad1f156438815dd92438e6354b00ab9447f6<br>ef79cedfbe51de1de8e4873e3982afb65261be556154059299a0058ebdb695d549213bb3d2a<br>aaecc738f92cfd9c1e561e376b098ac4ec4dfc2d24075c62688681f366dc4e7ca5bd36c8cba<br>61e8191aace6090ac83651b87bd309'
TR-> TD(7,0/1/1)->PAR Test<br>CA6 TD(7,1/1/1)->PAR '7f2182015b7f4e81d35f290170420844455858586003127f49818e06082a8648ce3d040304<br>868181042edd3f3057e2cb122862bd3999e9368136d34330739a2a667720d1ea48b45fd7050<br>b9645b099382c85759ae07074f76ea827c716d300700fd69b57dab282a4fa5bb4b1f62b19e9<br>9cccfe5a3f0d24cd6937c31d28903dfcf5bc827bf8bd8c7502607f60b510d2c893663247b0b<br>40d3f1d68bffc4e7f1aa27daeb745668ab3e0725f200844455858586f63127f4c1306082a82<br>14004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f3781808<br>c8203e3edca689def8a349e4cc0e3fad9aca951f63f4d0aa215a5333bd93b17795ccdbcf271<br>f7fa243d60472fcfe96be7b8ae7673a4b375436856d02d6df6c82afa534f533ba2831672747<br>8dabe5f4ecc215c442d4be6ac7a3e38890bbc8d758d8d75ada0d2c820c379b6b8744ecb9491<br>d5010258a5cab4d929ba9e2f5cb9ee'
TR-> TD(8,0/1/1)->PAR Test<br>CA7 TD(8,1/1/1)->PAR '7f2182015b7f4e81d35f290170420844455858586003127f49818e06082a8648ce3d040304<br>86818104140404028068847703b9ff2f2bd45927333e36da543533ff51d440cdbed8ddd5265<br>23524b89cd03320b8eb04593096c78cd0ab6ff4c3711fee04284d2e6bb003672d53f7111e05<br>a14883e93482570667e62bd10c39c9999186d8486eba560abd2308275113861b6e74cf5968c<br>c20bad34af21f74a4d54c985bcbcb3af9c88de05f200844455858586f73127f4c1306082a82<br>14004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f3781809<br>622b1a6b7be6087964877bf8d285e98a6d1f4defcb34eb48a34c7b0685fc8da3a33d8bff8b2<br>b543c9567410da87ce8233f3d56d06b2d021beb30865b1d1193d87f835d12de3b5c89fefa45<br>ca40378bc96d046f926c3d305ef888570f92d9c7ce53ffde6439a91b4e4be2a42208cfaadcb<br>4661be54ab7b6300f2e1da47fde34a'
TR-> TD(9,0/1/1)->PAR Test<br>CA8 TD(9,1/1/1)->PAR '7f2182015b7f4e81d35f290170420844455858586003127f49818e06082a8648ce3d040304<br>868181042416f09a534980a619c4a121687e82e5af1731f8de2c807c5eb00b4f458793b0ee2<br>fa2b1e134d8aad1d1437a5fbeeb4c425e7b56d90d369f214de22ce41b1d5c8ec7d75a8b2546<br>4fe7fcca3ce4e713cb5d3addfc418ef2741a37a256e0b30f231688cc6c4705827e92f995e1c<br>d9ade79129d32f570af100b7e95db030b88e7105f200844455858586f83127f4c1306082a82<br>14004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f3781802<br>717e550c4f907ad7a652904f960b3ea42eb03a689848556460e79fa60de3c8d1d8f2285b3a0<br>6a5cd17c12005ff4658194e819ac9cc715a0f56f4f7ac64e02f4073416c26a8a574a21c0826<br>2eda700036320d3492a80632c14a090a39533a8fcee7dd67c6f8a98adf04e5c1df03f14eb49<br>ace6a6621aec24937fd56fad1be374'
TR-> TD(10,0/1/1)->PAR Test<br>CA9 TD(10,1/1/1)->PAR '7f2182015b7f4e81d35f290170420844455858586003127f49818e06082a8648ce3d040304<br>868181049bdab8d4c7e9fd163c9cfcbf653909d2cef4032d1b0110990af18d14a538b30b3b7<br>ff3abde1180ba8b07094eec56deda3e044611acab2ebc52f2da9bf8a08c894b1edfcf679b4c<br>259b871dfd582588c81df4c9f0fe478bebf5d322f19ec843ae3aa704964775228ece5ad3092<br>7029f6f53cfcfc3663f48a4f4ddf7ad30f6c5125f200844455858586f93127f4c1306082a82<br>14004c0481185307bfffffffffffff5f25060103000902015f24060203000301085f378180a<br>7cd37e35558fb279ef6acaf57aea6efc5d5d120e192dab917c7824d4fe4ea8b0a0b723add67<br>1c671704d667da2f9afc91522c06a175b3577370161e1b69bb399253b362661dab2cfde3c99<br>091084a8b60b5c3132848e2c2962c1560ddc073143e2f8fec374d29f7f61c9cb621e15bfa00<br>df40be5bb202f8f85554158ac7a965'
PAR Test:
REQ(ids=A_17027)<b>A_17027 - (N211.310) K_Performanztest</b>
PAR Der Performanztest MUSS für diesen Prüfpunkt mit folgenden Parametern arbeiten:<br>a. M<sub>CVC</sub>        = {TestCA0, TestCA1, …, TestCA9} aus CosT_649<br>b. PuK.RCA  = / MF / DF.Auth / PuK.RCA_ELC512<br>c. PrK.Auth   = / MF / DF.Auth / PrK.Auth_ELC512 <b>[<=]</b>

REQ(ids=A_17028)<b>A_17028 - (N211.320) K_Performanztest</b>
PAR Der Performanztest MUSS die Performanzmessung für ELC-512 wie folgt durchgeführen:<br>(M<sub>Import</sub>, M<sub>RoleCheck</sub>, M<sub>SesKey</sub>, M<sub>GetSecSta</sub>) = PerformanceAuth(M<sub>CVC</sub>, PuK.RCA, PrK.Auth) <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17029)<b>A_17029 - (N211.330) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:      <b>[<=]</b>

PAR Hinweis CosH_58f: Das Ergebnis M<sub>GetSecSta</sub> wird hier nicht weiter verwendet, weil dieser Prüfpunkt bereits in CosK_04d betrachtet wird.
PAR -HEADING(ids=18.8.11.4)18.8.11.4 RSA 2048
PAR Dieses Kapitel ist absichtlich leer.
PAR -HEADING(ids=18.8.11.5)18.8.11.5 CosK_649 Testablauf Schlüsselimport und asymmetrische Authentisierung
PAR Dieser Abschnitt beschreibt auf generischer Ebene den Ablauf der Performanzmessung für Schlüsselimport (PSO Verify Certificate) sowie für eine asymmetrische Authentisierung mit und ohne Sessionkeyaushandlung. Der Ablauf wird für ELC Schlüssel unterschiedlicher Länge durchlaufen.
PAR (ids=Tabelle-358,-CosT_b22)Tabelle 358, CosT_b22: Definition der Funktion PerormanceAuth(...)

TABLE(rows=9,cols=63+91+550)->
TR-> TD(0,0/3/1)->PAR Input: TD(0,1/1/1)->PAR M<sub>CVC</sub> TD(0,2/1/1)->PAR Menge von CV-Zertifikaten die einer CA zugeordnet sind
TR-> TD(1,1/1/1)->PAR PuK.RCA TD(1,2/1/1)->PAR Sicherheitsanker der PKI, mit welchem sich die Zertifikate in M<sub>CVC</sub> prüfen lassen.
TR-> TD(2,1/1/1)->PAR PrK.Auth TD(2,2/1/1)->PAR privater Schlüssel des Prüflings, der im Rahmen der Sessionkeyaushandlung benötigt wird
TR-> TD(3,0/4/1)->PAR Output: TD(3,1/1/1)->PAR M<sub>Import</sub> TD(3,2/1/1)->PAR Tupel mit Ausführungszeiten zum Schlüsselimport
TR-> TD(4,1/1/1)->PAR M<sub>RoleCheck</sub> TD(4,2/1/1)->PAR Tupel mit Ausführungszeiten zur Rollenüberprüfung
TR-> TD(5,1/1/1)->PAR M<sub>SesKey</sub> TD(5,2/1/1)->PAR Tupel mit Ausführungszeiten zur Sessionkeyaushandlung
TR-> TD(6,1/1/1)->PAR M<sub>GetSecSta</sub> TD(6,2/1/1)->PAR Tupel mit Ausführungszeiten zur Abfrage Sicherheitszustand
TR-> TD(7,0/1/1)->PAR Errors: TD(7,1/1/1)->PAR - TD(7,2/1/1)->PAR keine
TR-> TD(8,0/1/1)->PAR Notation: TD(8,1/1/1)-> TD(8,2/1/1)->PAR (M<sub>Import</sub>, M<sub>RoleCheck</sub>, M<sub>SesKey</sub>, M<sub>GetSecSta</sub> ) = PerformanceAuth( M<sub>CVC</sub>, PuK.RCA, PrK.Auth )
PAR Testvorbereitung:
PAR Von jeder Test_CA aus M<sub>CVC</sub> werden zehn CV–Zertifikate erzeugt. Insgesamt ergeben sich so einhundert CV–Zertifikate für Authentisierungsschlüssel.
REQ(ids=G2_N211.510)<b>G2_N211.510 - (N211.510) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N211.520)<b>G2_N211.520 - (N211.520) K_Performanztest</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.Auth gesetzt werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N211.600)<b>G2_N211.600 - (N211.600) K_Performanztest</b>
PAR Die Testdurchführung MUSS eine Schleife 100–mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 0 bis 12 ausgeführt. <b>[<=]</b>

REQ(ids=A_17030)<b>A_17030 - (N211.602) K_Performanztest</b>
PAR Schritt 0: MANAGE SECURITY ENVIRONMENT Restore Kommando gemäß (N099.900) mit seNo = 1. Dadurch werden alle Elemente aus der Liste dfSpecificSecurityList (siehe (N029.900)) entfernt. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

REQ(ids=G2_N211.610)<b>G2_N211.610 - (N211.610) K_Performanztest</b>
PAR Schritt 1: Aus den einhundert CV–Zertifikaten mit Authentisierungsschlüssel wird ein bislang noch nicht verwendetes gezogen (ziehen ohne zurücklegen). Durch die Ziehung wird folgende CV–Zertifikatskette gebildet:<br>PuK.RCA -> CVC_Test_CAx -> CVC_ICCy.<br>Die erste Ziehung ist beliebig. Bei allen weiteren Ziehungen MUSS die Nebenbedingung beachtet werden, dass CVC_Test_CAx verschieden ist vom unmittelbar vorher verwendeten Zertifikat CVC_Test_CAx. Dann MUSS mit Schritt 4 fortgefahren werden.<br>Dann MANAGE SECURITY ENVIRONMENT Set Kommando gemäß (N103.300), wobei als keyRefder Wert CAR aus CVC_ICCy verwendet wird. Die Laufzeit dieses Kommandos in der i–ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden und wird mit t<sub>Run1</sub><sub>,i</sub> bezeichnet. Wenn dieses Kommando mit NoError beendet wird, fahre mit Schritt 5 fort, sonst mit Schritt 2. <b>[<=]</b>

REQ(ids=G2_N211.620)<b>G2_N211.620 - (N211.620) K_Performanztest</b>
PAR Schritt 2: MANAGE SECURITY ENVIRONMENT Set Kommando gemäß (N103.300), wobei als keyRef der Wert keyIdentifier aus PuK.RCA verwendet wird. Die Laufzeit dieses Kommandos in der i–ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden und wird mit t<sub>Run</sub><sub>2</sub><sub>,</sub><sub>i</sub> bezeichnet. <b>[<=]</b>

REQ(ids=G2_N211.630)<b>G2_N211.630 - (N211.630) K_Performanztest</b>
PAR Schritt 3: Wenn das im vorherigen Schritt selektierte Schlüsselobjekt ein

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR ELC Schlüssel ist, dann wird ein PSO Verify Certificate Kommando gemäß (N095.410) verwendet, wobei als Parameter certificate CVC_Test_CAx verwendet wird.LITEM->PAR Die Laufzeit dieses Kommandos in der i–ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden und wird mit t<sub>Run</sub><sub>3</sub><sub>,</sub><sub>i</sub> bezeichnet.
PAR <b>[<=]</b>

REQ(ids=G2_N211.640)<b>G2_N211.640 - (N211.640) K_Performanztest</b>
PAR Schritt 4: MANAGE SECURITY ENVIRONMENT Set Kommando gemäß (N103.300), wobei als keyRef der Wert CAR aus CVC_ICCy verwendet wird. Die Laufzeit dieses Kommandos in der i–ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden und wird mit t<sub>Run</sub><sub>4</sub><sub>,</sub><sub>i</sub> bezeichnet. Wenn dieses Kommando nicht mit NoError beendet wird, dann fahre mit Schritt 2 fort, sonst mit Schritt 5. <b>[<=]</b>

REQ(ids=G2_N211.650)<b>G2_N211.650 - (N211.650) K_Performanztest</b>
PAR Schritt 5: PSO Verify Certificate Kommando gemäß (N095.410), wobei als Parameter certificate CVC_ICCy verwendet wird. Die Laufzeit dieses Kommandos in der i–ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden und wird mit t<sub>Run</sub><sub>5</sub><sub>,</sub><sub>i</sub> bezeichnet. <b>[<=]</b>

REQ(ids=G2_N211.660)<b>G2_N211.660 - (N211.660) K_Performanztest</b>
PAR Schritt 6: MANAGE SECURITY ENVIRONMENT  Set Kommando gemäß (N101.900), wobei als keyRef der Wert CHR aus CVC_ICCy und als algId elcRoleCheck verwendet wird. Die Laufzeit dieses Kommandos in der i–ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden und wird mit t<sub>Run</sub><sub>6</sub><sub>,</sub><sub>i</sub> bezeichnet. <b>[<=]</b>

REQ(ids=G2_N211.670)<b>G2_N211.670 - (N211.670) K_Performanztest</b>
PAR Schritt 7: Wenn im vorherigen Schritt

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR elcRoleCheck verwendet wurde, dann sende ein GET CHALLENGE Kommando gemäß (N098.625).LITEM->PAR Die Laufzeit dieses Kommandos in der i–ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden und wird mit t<sub>Run</sub><sub>7</sub><sub>,</sub><sub>i</sub> bezeichnet.
PAR <b>[<=]</b>

REQ(ids=G2_N211.680)<b>G2_N211.680 - (N211.680) K_Performanztest</b>
PAR Schritt 8: EXTERNAL AUTHENTICATE Kommando gemäß (N083.500) und (N084.400)a, b}. Die Laufzeit dieses Kommandos in der i–ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden und wird mit t<sub>Run</sub><sub>8</sub><sub>,</sub><sub>i</sub> bezeichnet. <b>[<=]</b>

REQ(ids=G2_N211.690)<b>G2_N211.690 - (N211.690) K_Performanztest</b>
PAR Schritt 9: Abfrage eines Sicherheitsstatus:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Wenn M<sub>CVC</sub> ELC Schlüssel enthält, dann werden folgende Schritte ausgeführt:
ORDERED-LIST->
LITEM->PAR GET SECURITY STATUS KEY gemäß (N085.444) mit oid = oid_cvc_fl_ti und cmdData = '0FFF…FF'. Die Laufzeit dieses Kommandos in der i–ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden und wird mit t<sub>Run</sub><sub>9.1</sub><sub>,</sub><sub>i</sub> bezeichnet.LITEM->PAR GET SECURITY STATUS KEY gemäß (N085.444) mit oid = oid_cvc_fl_ti und cmdData = flagList aus CVC_ICCy. Die Laufzeit dieses Kommandos in der i–ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden und wird mit t<sub>Run</sub><sub>9.2</sub><sub>,</sub><sub>i</sub> bezeichnet.LITEM->PAR Es gilt: t<sub>GetSecStat</sub><sub>,</sub><sub>i</sub> = t<sub>Run</sub><sub>9.1,</sub><sub>i</sub> + t<sub>Run</sub><sub>9.2,</sub><sub>i</sub>.
PAR <b>[<=]</b>

REQ(ids=A_17031)<b>A_17031 - (N211.700) K_Performanztest</b>
PAR Schritt 10: MANAGE SECURITY ENVIRONMENT  Restore Kommando gemäß (N099.900) mit seNo = 1. Dadurch werden alle Elemente aus der Liste dfSpecificSecurityList entfernt. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

REQ(ids=G2_N211.710)<b>G2_N211.710 - (N211.710) K_Performanztest</b>
PAR Schritt 11: MANAGE SECURITY ENVIRONMENT Set Kommando gemäß (N100.900), wobei als keyRef der Wert keyIdentifier von PrK.Auth und als algId elcSessionkey4SM verwendet wird. Die Laufzeit dieses Kommandos in der i–ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden und wird mit t<sub>Run</sub><sub>11</sub><sub>,</sub><sub>i</sub> bezeichnet. <b>[<=]</b>

REQ(ids=G2_N211.720.a)<b>G2_N211.720.a - (N211.720)a K_Performanztest</b>
PAR Schritt 12: Aushandlung von Sessionkeys:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Wenn M<sub>CVC</sub> ELC Schlüssel enthält, dann werden folgende Schritte ausgeführt:
ORDERED-LIST->
LITEM->PAR GENERAL AUTHENTICATE gemäß (N085.012), wobei als keyRef der Wert CHR aus CVC_ICCy verwendet wird. Die Laufzeit dieses Kommandos in der i–ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden und wird mit t<sub>Run</sub><sub>12.1</sub><sub>,</sub><sub>i</sub> bezeichnet.LITEM->PAR GENERAL AUTHENTICATE gemäß (N085.016), wobei als ephemeralPK_oponent die Anttwort des vorherigen Kommandos verwendet wird. Die Laufzeit dieses Kommandos in der i–ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden und wird mit t<sub>Run</sub><sub>12.2</sub><sub>,</sub><sub>i</sub> bezeichnet.LITEM->PAR Es gilt: t<sub>Run</sub><sub>12</sub><sub>,</sub><sub>i</sub> = t<sub>Run</sub><sub>12.1,</sub><sub>i</sub> + t<sub>Run</sub><sub>12.2,</sub><sub>i</sub>.
PAR <b>[<=]</b>

REQ(ids=G2_N211.720.b)<b>G2_N211.720.b - G2_N211.720.b</b>
PAR TODO gematik-Testabteilung: Diese Anforderung gibt es in der COS-Spec nicht, prüfen, korrigieren.<br>AFO-ID aus ReqPro: AFO2023 <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17032)<b>A_17032 - (N211.730) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:<br>Bei der Bearbeitung einer Schleifeniteration sind folgende Fälle denkbar:

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR Der öffentliche Schlüssel der CA ist bereits in der Karte gespeichert, weil er bei der Kartenproduktion in persistentPublicKeyList oder durch einen früheren Zertifikatsimport in persistentCache gespeichert wurde. In diesem Fall besteht der i–te Schleifendurchlauf aus der Schrittfolge 1, 5, 6, 7, …. Die Laufzeiten der Schritte 1 und 5 werden summiert zu t<sub>Import</sub><sub>,i</sub>.LITEM->PAR Der öffentliche Schlüssel der CA ist nicht in der Karte gespeichert und dies wird bereits während der Schlüsselselektion bemerkt. Dann besteht der i–te Schleifendurchlauf aus der Schrittfolge 1, 2, 3, 4, 5, 6, 7, …. Die Laufzeiten der Schritte 1, 2, 3, 4 und 5 werden summiert zu t<sub>Import</sub><sub>,i</sub>.LITEM->PAR Die Laufzeiten der Schritte 6, 7 und 8 werden summiert zu t<sub>RoleCheck</sub><sub>,i</sub>.LITEM->PAR Die Laufzeiten der Schritte 11 und 12 werden aufsummiert zu t<sub>SK</sub>,<sub>i</sub>.LITEM->PAR Die gemessenen Zeiten werden zu folgenden Tupeln zusammengefasst:

TABLE(rows=4,cols=72+102+82+33+98)->
TR-> TD(0,0/1/1)->PAR M<sub>Import</sub> TD(0,1/1/1)->PAR = (t<sub>Import</sub><sub>,1</sub>, TD(0,2/1/1)->PAR t<sub>Import</sub><sub>,2</sub>, TD(0,3/1/1)->PAR …, TD(0,4/1/1)->PAR t<sub>Import</sub><sub>,100</sub> )
TR-> TD(1,0/1/1)->PAR M<sub>RoleCheck</sub> TD(1,1/1/1)->PAR = (t<sub>R</sub><sub>o</sub><sub>leCheck</sub><sub>,1</sub>, TD(1,2/1/1)->PAR t<sub>R</sub><sub>o</sub><sub>leCheck</sub><sub>,2</sub>, TD(1,3/1/1)->PAR …, TD(1,4/1/1)->PAR t<sub>RoleCheck</sub><sub>,100</sub> )
TR-> TD(2,0/1/1)->PAR M<sub>SesKey</sub> TD(2,1/1/1)->PAR = (t<sub>SesKey</sub><sub>,1</sub>, TD(2,2/1/1)->PAR t<sub>Se</sub><sub>s</sub><sub>Key</sub><sub>,2</sub>, TD(2,3/1/1)->PAR …, TD(2,4/1/1)->PAR t<sub>SesKey</sub><sub>,100</sub> )
TR-> TD(3,0/1/1)->PAR M<sub>GetSecStat</sub> TD(3,1/1/1)->PAR = (t<sub>GetSe</sub><sub>c</sub><sub>Stat</sub><sub>,1</sub>, TD(3,2/1/1)->PAR t<sub>GetSe</sub><sub>c</sub><sub>Stat</sub><sub>,2</sub>, TD(3,3/1/1)->PAR …, TD(3,4/1/1)->PAR t<sub>GetSecStat</sub><sub>,100</sub> )
PAR <b>[<=]</b>

PAR -HEADING(ids=18.8.12)18.8.12 CosK_63b INTERNAL AUTHENTICATE zur Rollenauthentisierung
PAR In diesem Abschnitt wird die Rollenauthentisierung mit privaten RSA und ELC Schlüsseln betrachtet. Dieser Prüfpunkt arbeitet mit den Schlüsseln PrK.Auth_ELC256, PrK.Auth_ELC384 und PrK.Auth_ELC512 in der Anwendung / MF / DF.Auth.
PAR Testvorbereitung:
REQ(ids=G2_N212.110)<b>G2_N212.110 - (N212.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N212.120)<b>G2_N212.120 - (N212.120) K_Performanztest</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.Auth gesetzt werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N212.200)<b>G2_N212.200 - (N212.200) K_Performanztest</b>
PAR Die Testdurchführung MUSS eine äußere Schleife durchlaufen, wobei keyRef jeden Wert keyIdentifier für die Schlüssel aus der Menge {PrK.Auth_ELC256, PrK.Auth_ELC384, PrK.Auth_ELC512} annimmt. In jedem Schleifendurchlauf werden die Schritte 1 bis 4 ausgeführt. <b>[<=]</b>

REQ(ids=A_17033)<b>A_17033 - (N212.210) K_Performanztest</b>
PAR Schritt 1: MANAGE SECURITY ENVIRONMENT Set Kommando gemäß (N100.900), wobei als keyRef die Variable der äußeren Schleife verwendet wird und algId = elcRoleAuthentication gesetzt wird. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

REQ(ids=G2_N212.220)<b>G2_N212.220 - (N212.220) K_Performanztest</b>
PAR Schritt 2: Die Testdurchführung MUSS eine innere Schleife 100-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 3 bis 4 ausgeführt. <b>[<=]</b>

REQ(ids=A_17034)<b>A_17034 - (N212.230) K_Performanztest</b>
PAR Schritt 3: Es wird eine Zufallszahl token = RAND(16) erzeugt. <b>[<=]</b>

REQ(ids=G2_N212.240)<b>G2_N212.240 - (N212.240) K_Performanztest</b>
PAR Schritt 4: INTERNAL AUTHENTICATE gemäß (N086.400) und (N086.900)a, c}. Die Laufzeit t<sub>Auth</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17035)<b>A_17035 - (N212.250) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:<br> <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.13)18.8.13 CosK_3e3 PSO Compute Digital Signature mittels signPSS
PAR In diesem Abschnitt wird die Signaturberechnung mit privaten RSA Schlüsseln und dem Signaturverfahren signPSS betrachtet. Dieser Prüfpunkt arbeitet mit den Schlüsseln PrK.X509_RSA2048 und PrK.X509_RSA3072 in der Anwendung / MF / DF.IAS.
PAR Testvorbereitung:
REQ(ids=G2_N213.110)<b>G2_N213.110 - (N213.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N213.120)<b>G2_N213.120 - (N213.120) K_Performanztest</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.IAS gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N213.130)<b>G2_N213.130 - (N213.130)</b>
PAR Schritt 3: Dieser Schritt enthält absichtlich keine Aktion.<br>Schritt 3: GENERATE ASYMMETRIC KEY PAIR Kommando gemäß 14.9.3.10, wobei als keyRef = '8B' aus dem Attribut keyIdentifier von PrK.X509_RSA2048 gebildet wird und operationMode = 'C0' gesetzt wird. <b>[<=]</b>

REQ(ids=G2_N213.140)<b>G2_N213.140 - (N213.140)</b>
PAR Schritt 4: Dieser Schritt enthält absichtlich keine Aktion.<br> Schritt 4: GENERATE ASYMMETRIC KEY PAIR Kommando gemäß 14.9.3.10, wobei als keyRef = '8C' aus dem Attribut keyIdentifier von PrK.X509_RSA3072 gebildet wird und operationMode = 'C0' gesetzt wird. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N213.200)<b>G2_N213.200 - (N213.200) K_Performanztest</b>
PAR Die Testdurchführung MUSS eine äußere Schleife durchlaufen, wobei keyRef jeden Wert keyIdentifier für die Schlüssel aus der Menge {PrK.X509_RSA2048, PrK.X509_RSA3072} annimmt. In jedem Schleifendurchlauf werden die Schritte 1 bis 4 ausgeführt. <b>[<=]</b>

REQ(ids=A_17036)<b>A_17036 - (N213.220) K_Performanztest</b>
PAR Schritt 1: MANAGE SECURITY ENVIRONMENT Set Kommando gemäß (N102.900), wobei als keyRef die Variable der äußeren Schleife verwendet wird und algId = signPSS gesetzt wird. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

REQ(ids=G2_N213.230)<b>G2_N213.230 - (N213.230) K_Performanztest</b>
PAR Schritt 2: Die Testdurchführung MUSS eine innere Schleife 64-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 3 bis 4 ausgeführt. <b>[<=]</b>

REQ(ids=G2_N213.240)<b>G2_N213.240 - (N213.240) K_Performanztest</b>
PAR Schritt 3: In der i–ten Schleifeniteration MUSS ein Oktettstring dataToBeSigned = RAND( i ) erzeugt werden. <b>[<=]</b>

REQ(ids=G2_N213.250)<b>G2_N213.250 - (N213.250) K_Performanztest</b>
PAR Schritt 4: PSO Compute Digital Signature gemäß (N87.500) und (N088.600)a. Die Laufzeit t<sub>run</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17037)<b>A_17037 - (N213.260) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:<br> <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.14)18.8.14 CosK_2e7 Signaturerzeugung und –verifikation mittles signECDSA
PAR In diesem Abschnitt wird die Signaturberechnung und –verifiaktion mit privaten ELC Schlüsseln betrachtet. Dieser Prüfpunkt arbeitet mit den Schlüsseln PrK.X509_ELC256, PrK.X509_ELC384 und PrK.X509_ELC512 in der Anwendung / MF / DF.IAS.
PAR Testvorbereitung:
REQ(ids=G2_N214.110)<b>G2_N214.110 - (N214.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N214.120)<b>G2_N214.120 - (N214.120) K_Performanztest</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.IAS gesetzt werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N214.200)<b>G2_N214.200 - (N214.200) K_Performanztest</b>
PAR Die Testdurchführung MUSS eine äußere Schleife durchlaufen, wobei keyRef jeden Wert keyIdentifier für die Schlüssel aus der Menge {PrK.X509_ELC256, PrK.X509_ELC384, PrK.X509_ELC512} annimmt. In jedem Schleifendurchlauf werden die Schritte 1 bis 6 ausgeführt. <b>[<=]</b>

REQ(ids=A_17038)<b>A_17038 - (N214.210) K_Performanztest</b>
PAR Schritt 1: GENERATE ASYMMETRIC KEY PAIR Kommando gemäß (N097.266), wobei als keyRef die Variable der äußeren Schleife verwendet wird und operationMode = 'C0' gesetzt wird. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

REQ(ids=A_17039)<b>A_17039 - (N214.220) K_Performanztest</b>
PAR Schritt 2: MANAGE SECURITY ENVIRONMENT Set Kommando gemäß (N102.900), wobei als keyRef die Variable der äußeren Schleife verwendet wird und algId = signECDSA gesetzt wird. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

REQ(ids=G2_N214.230)<b>G2_N214.230 - (N214.230) K_Performanztest</b>
PAR Schritt 3: Die Testdurchführung MUSS eine innere Schleife 100-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 4 bis 6 ausgeführt. <b>[<=]</b>

REQ(ids=G2_N214.240)<b>G2_N214.240 - (N214.240) K_Performanztest</b>
PAR Schritt 4: In der i–ten Schleifeniteration MUSS ein Oktettstring dataToBeSigned = RAND(domainParameter.t / 8) erzeugt werden. <b>[<=]</b>

REQ(ids=G2_N214.250)<b>G2_N214.250 - (N214.250) K_Performanztest</b>
PAR Schritt 5: PSO Compute Digital Signature gemäß (N087.500) und (N088.600)c. Die Laufzeit t<sub>sign</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N214.260)<b>G2_N214.260 - (N214.260) K_Performanztest</b>
PAR Schritt 6: PSO Verify Digital Signature gemäß (N096.388) zur erfolgreichen Verifikation der im vorherigen Schritt erzeugten Signatur. Die Laufzeit t<sub>verify</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17040)<b>A_17040 - (N214.270) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:      <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.15)18.8.15 CosK_cce PSO Encipher und PSO Decipher mittels rsaDecipherOaep
PAR In diesem Abschnitt wird die Ver- und Entschlüsselung mit privaten RSA Schlüsseln und dem Entschlüsselungsverfahren rsaDecipherOaep betrachtet. Dieser Prüfpunkt arbeitet mit den Schlüsseln PrK.X509_RSA2048 und PrK.X509_RSA3072 in der Anwendung / MF / DF.IAS.
PAR Testvorbereitung:
REQ(ids=G2_N215.110)<b>G2_N215.110 - (N215.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N215.120)<b>G2_N215.120 - (N215.120) K_Performanztest</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.IAS gesetzt werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N215.200)<b>G2_N215.200 - (N215.200) K_Performanztest</b>
PAR Die Testdurchführung MUSS eine äußere Schleife durchlaufen, wobei keyRef jeden Wert keyIdentifier für die Schlüssel aus der Menge {PrK.X509_RSA2048, PrK.X509_RSA3072} annimmt. In jedem Schleifendurchlauf werden die Schritte 1 bis 6 ausgeführt. <b>[<=]</b>

REQ(ids=A_17041)<b>A_17041 - (N215.210) K_Performanztest</b>
PAR Schritt 1: MANAGE SECURITY ENVIRONMENT Set Kommando gemäß (N103.800), wobei als keyRef die Variable der äußeren Schleife verwendet wird und algId = rsaDecipherOaep gesetzt wird. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

REQ(ids=G2_N215.220)<b>G2_N215.220 - (N215.220) K_Performanztest</b>
PAR Schritt 2: Die Testdurchführung MUSS eine innere Schleife 190-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 3 bis 5 ausgeführt. <b>[<=]</b>

REQ(ids=G2_N215.230)<b>G2_N215.230 - (N215.230) K_Performanztest</b>
PAR Schritt 3: Dieser Schritt enthält absichtlich keine Aktion.<br>GENERATE ASYMMETRIC KEY PAIR Kommando gemäß 14.9.3.10, wobei als keyRef die Variable der äußeren Schleife verwendet wird und operationMode = 'C0' gesetzt wird. Die Laufzeit t<sub>GAKP</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N215.240)<b>G2_N215.240 - (N215.240) K_Performanztest</b>
PAR Schritt 4: In der i–ten Schleifeniteration MUSS ein Oktettstring M = RAND( i ) erzeugt. <b>[<=]</b>

REQ(ids=G2_N215.250)<b>G2_N215.250 - (N215.250) K_Performanztest</b>
PAR Schritt 5: Wenn keyRef gleich dem keyIdentifier von

ORDERED-LIST->

ORDERED-LIST->
LITEM->PAR PrK.X509_RSA2048 ist, dann PSO Encipher gemäß (N090.790) und (N091.700)c, wobei PuK der öffentlich Schlüssel ist, der in Schritt 3 erzeugt wurde und algID = rsaEncipherOaep. Die Laufzeit t<sub>enc</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden.LITEM->PAR PrK.X509_RSA3072 ist, dann wird M außerhalb des Prüflings äquivalent zu PSO Encipher gemäß (N090.790) und (N091.700)c verschlüsselt, wobei PuK der öffentlich Schlüssel ist, der in Schritt 3 erzeugt wurde und algID = rsaEncipherOaep.
PAR <b>[<=]</b>

REQ(ids=G2_N215.260)<b>G2_N215.260 - (N215.260) K_Performanztest</b>
PAR Schritt 6: PSO Decipher gemäß (N089.200) und (N090.300)b. Die Laufzeit t<sub>dec</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17042)<b>A_17042 - (N215.270) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:<br> <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.16)18.8.16 CosK_1b8 PSO Encipher und PSO Decipher mittels elcSharedSecretCalculation
PAR In diesem Abschnitt wird die Ver- und Entschlüsselung mit privaten ELC Schlüsseln und dem Entschlüsselungsverfahren elcSharedSecretCalculation betrachtet. Dieser Prüfpunkt arbeitet mit den Schlüsseln PrK.X509_ELC256, PrK.X509_ELC384 und PrK.X509_ELC512 in der Anwendung / MF / DF.IAS.
PAR Testvorbereitung:
REQ(ids=G2_N216.110)<b>G2_N216.110 - (N216.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N216.120)<b>G2_N216.120 - (N216.120) K_Performanztest</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.IAS gesetzt werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N216.200)<b>G2_N216.200 - (N216.200) K_Performanztest</b>
PAR Die Testdurchführung MUSS eine äußere Schleife durchlaufen, wobei keyRef jeden Wert keyIdentifier für die Schlüssel aus der Menge {PrK.X509_ELC256, PrK.X509_ELC384, PrK.X509_ELC512} annimmt. In jedem Schleifendurchlauf werden die Schritte 1 bis 6 ausgeführt. <b>[<=]</b>

REQ(ids=A_17043)<b>A_17043 - (N216.210) K_Performanztest</b>
PAR Schritt 1: MANAGE SECURITY ENVIRONMENT Set Kommando gemäß (N103.800), wobei als keyRef die Variable der äußeren Schleife verwendet wird und algId = elcSharedSecretCalculation gesetzt wird. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

REQ(ids=G2_N216.220)<b>G2_N216.220 - (N216.220) K_Performanztest</b>
PAR Schritt 2: Die Testdurchführung MUSS eine innere Schleife 256-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 3 bis 5 ausgeführt. <b>[<=]</b>

REQ(ids=G2_N216.230)<b>G2_N216.230 - (N216.230) K_Performanztest</b>
PAR Schritt 3: GENERATE ASYMMETRIC KEY PAIR Kommando gemäß (N097.266), wobei als keyRef die Variable der äußeren Schleife verwendet wird und operationMode = 'C0' gesetzt wird. Die Laufzeit t<sub>GAKP</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N216.240)<b>G2_N216.240 - (N216.240) K_Performanztest</b>
PAR Schritt 4: In der i–ten Schleifeniteration MUSS ein Oktettstring M = RAND( i ) erzeugt. <b>[<=]</b>

REQ(ids=G2_N216.250)<b>G2_N216.250 - (N216.250) K_Performanztest</b>
PAR Schritt 5: PSO Encipher gemäß (N091.400), wobei PO<sub>B</sub> der öffentlich Schlüssel ist, der in Schritt 3 erzeugt wurde. Die Laufzeit t<sub>enc</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N216.260)<b>G2_N216.260 - (N216.260) K_Performanztest</b>
PAR Schritt 6: PSO Decipher gemäß (N089.800). Die Laufzeit t<sub>dec</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17044)<b>A_17044 - (N216.270) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:      <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.17)18.8.17 CosK_0fc Selektieren von Ordnern und Logical Channel Reset
PAR In diesem Abschnitt wird die Selektion eines Ordners und das Rücksetzen des Basiskanals betrachtet. Dieser Prüfpunkt arbeitet mit der Anwendung / MF / DF.Auth.
PAR Testvorbereitung:
REQ(ids=G2_N217.110)<b>G2_N217.110 - (N217.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N217.200)<b>G2_N217.200 - (N217.200) K_Performanztest</b>
PAR Die Testdurchführung MUSS eine Schleife 100-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 1 bis 3 ausgeführt. <b>[<=]</b>

REQ(ids=G2_N217.210)<b>G2_N217.210 - (N217.210) K_Performanztest</b>
PAR Schritt 1: currentFolder MUSS gemäß (N044.900) auf / MF / DF.Auth gesetzt werden. Die Laufzeit t<sub>select</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N217.220)<b>G2_N217.220 - (N217.220) K_Performanztest</b>
PAR Schritt 2: GET CHALLENGE wird gemäß (N098.625) ausgeführt. Die Laufzeit t<sub>rnd</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N217.230)<b>G2_N217.230 - (N217.230) K_Performanztest</b>
PAR Schritt 3: Der Basiskanal MUSS gemäß Use Case aus (N099.524) zurückgesetzt werden, wobei der Kommandoparameter logicalChannelNumber gleich null zu setzen ist. Die Laufzeit t<sub>reset</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17045)<b>A_17045 - (N217.240) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:      <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.18)18.8.18 CosK_43e MANAGE SECURITY ENVIRONMENT
PAR In diesem Abschnitt wird die Selektion kryptographishcer Objekte betrachtet. Dieser Prüfpunkt arbeitet mit der Anwendung / MF / DF.IAS.
PAR Testvorbereitung:
REQ(ids=G2_N218.110)<b>G2_N218.110 - (N218.110) K_Performanztest</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N218.120)<b>G2_N218.120 - (N218.120) K_Performanztest</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.IAS gesetzt werden. <b>[<=]</b>

REQ(ids=A_17046)<b>A_17046 - (N218.130) K_Performanztest</b>
PAR Schritt 3: Es MUSS eine leere Menge M<sub>Set</sub> = {} erstellt werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N218.200)<b>G2_N218.200 - (N218.200) K_Performanztest</b>
PAR Die Testdurchführung MUSS eine Schleife 100-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 1 bis 4 ausgeführt. <b>[<=]</b>

REQ(ids=G2_N218.210)<b>G2_N218.210 - (N218.210) K_Performanztest</b>
PAR Schritt 1: MANAGE SECURITY ENVIRONMENT Set Kommando gemäß (N100.900), wobei als keyRef PrK.X509_ELC256.keyIdentifier verwendet und algId = elcRoleAuthentication gesetzt wird. Die Laufzeit t<sub>Set</sub> dieses Kommandos MUSS gemäß CosK_056 gemessen und der Menge M<sub>Set</sub> hinzugefügt werden. <b>[<=]</b>

REQ(ids=G2_N218.220)<b>G2_N218.220 - (N218.220) K_Performanztest</b>
PAR Schritt 2: MANAGE SECURITY ENVIRONMENT Set Kommando gemäß (N102.900), wobei als keyRef PrK.X509_ELC384.keyIdentifier verwendet und algId = signECDSA gesetzt wird. Die Laufzeit t<sub>Set</sub> dieses Kommandos MUSS gemäß CosK_056 gemessen und der Menge M<sub>Set</sub> hinzugefügt werden. <b>[<=]</b>

REQ(ids=G2_N218.230)<b>G2_N218.230 - (N218.230) K_Performanztest</b>
PAR Schritt 3: MANAGE SECURITY ENVIRONMENT Set Kommando gemäß (N103.800), wobei als keyRef PrK.X509_ELC512.keyIdentifier verwendet und algId = elcSharedSecretCalculation gesetzt wird. Die Laufzeit t<sub>Set</sub> dieses Kommandos MUSS gemäß CosK_056 gemessen und der Menge M<sub>Set</sub> hinzugefügt werden. <b>[<=]</b>

REQ(ids=G2_N218.240)<b>G2_N218.240 - (N218.240) K_Performanztest</b>
PAR Schritt 4: MANAGE SECURITY ENVIRONMENT Restore Kommando gemäß (N099.900), wobei seNo = 1 gesetzt wird. Die Laufzeit t<sub>restore,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17047)<b>A_17047 - (N218.250) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:      <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.19)18.8.19 CosK_eb3 GENERAL AUTHENTICATE, PACE
PAR Dieser Prüfpunkt ist nur relevant, wenn Option_kontaktlose_Schnittstelle vorhanden ist.
PAR In diesem Abschnitt wird die Etablierung mit einem symmetrischen Kartenverbindungsobjekt betrachtet. Dieser Prüfpunkt arbeitet mit dem Objekt / MF / DF.LCS / CAN_256.
PAR Testvorbereitung:
REQ(ids=G2_N219.110)<b>G2_N219.110 - (N219.110) K_Performanztest, Option_kontaktlose_Schnittstelle</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N219.120)<b>G2_N219.120 - (N219.120) K_Performanztest, Option_kontaktlose_Schnittstelle</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.LCS gesetzt werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N219.200)<b>G2_N219.200 - (N219.200) K_Performanztest, Option_kontaktlose_Schnittstelle</b>
PAR Die Testdurchführung MUSS eine Schleife 100-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 1 bis 2 ausgeführt. <b>[<=]</b>

REQ(ids=A_17048)<b>A_17048 - (N219.210) K_Performanztest, Option_kontaktlose_Schnittstelle</b>
PAR Schritt 1: MANAGE SECURITY ENVIRONMENT Set Kommando gemäß (N102.448) zur Auswahl von CAN_256. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

REQ(ids=G2_N219.220)<b>G2_N219.220 - (N219.220) K_Performanztest, Option_kontaktlose_Schnittstelle</b>
PAR Schritt 2: Etablierung eines vertrauenswürdigen Kanals gemäß CosK_e2b. Die Laufzeit aller daran beteiligten Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden und zu t<sub>PACE</sub><sub>,i</sub> addiert werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17049)<b>A_17049 - (N219.230) K_Performanztest</b>
PAR Der Performanztest MUSS die Performanzpunkte P<sub>PACE</sub> wie folgt ermitteln:<br> P<sub>PACE</sub> = points( (t<sub>PACE</sub><sub>,1</sub>, t<sub>PACE</sub><sub>,2</sub>, …, t<sub>PACE</sub><sub>,100</sub> ), T<sub>PACE</sub> ) <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.20)18.8.20 CosK_a71 Symmetrische Sessionkeyaushandlung für Trusted Channel
PAR Dieser Prüfpunkt ist nur relevant, wenn Option_Kryptobox vorhanden ist.
PAR In diesem Abschnitt wird lediglich die symmetrische Aushandlung von Sessionkeys für Secure Messaging betrachtet. Dieser Prüfpunkt arbeitet mit den Schlüsseln TC.AES128, TC.AES192 und TC.AES256 in der Anwendung / MF / DF.Auth.
PAR Testvorbereitung:
REQ(ids=G2_N220.110)<b>G2_N220.110 - (N220.110) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N220.120)<b>G2_N220.120 - (N220.120) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.Auth gesetzt werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N220.200)<b>G2_N220.200 - (N220.200) K_Performanztest, Option_Kryptobox</b>
PAR Die Testdurchführung MUSS eine äußere Schleife durchlaufen, wobei keyRef jeden Wert keyIdentifier für die Schlüssel aus der Menge {TC.AES128, TC.AES192, TC.AES256} annimmt. In jedem Schleifendurchlauf werden die Schritte 1 bis 7 ausgeführt. <b>[<=]</b>

REQ(ids=A_17050)<b>A_17050 - (N220.210) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 1: MANAGE SECURITY ENVIRONMENT Set Kommandos gemäß (N100.400) und (N101.400), wobei als keyRef die Variable der äußeren Schleife verwendet wird und algId = aesSessionkey4TC gesetzt wird. Die Laufzeiten dieser Kommandos sind für diesen Prüfpunkt irrelevant. <b>[<=]</b>

REQ(ids=A_17051)<b>A_17051 - (N220.215) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 2: MANAGE SECURITY ENVIRONMENT Set Kommando gemäß (N101.400), wobei als keyRef die Variable der äußeren Schleife verwendet wird und algId = aesSessionkey4TC gesetzt wird. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

REQ(ids=G2_N220.220)<b>G2_N220.220 - (N220.220) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 3: Die Testdurchführung MUSS eine innere Schleife 100-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 4 bis 6 ausgeführt. Anschließend wird mit Schritt 7 fortgefahren. <b>[<=]</b>

REQ(ids=G2_N220.230)<b>G2_N220.230 - (N220.230) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 4: Es wird ein INTERNAL AUTHENTICATE Kommando gemäß (N86.400) und (N086.902)a ausgeführt. Die Laufzeit t<sub>IntAuth</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N220.240)<b>G2_N220.240 - (N220.240) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 5: Ein erfolgreiches EXTERNAL AUTHENTICATE Kommando (N083.500) und (N084.402)a wird durchgeführt. Die Laufzeit t<sub>ExtAuth</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=A_17052)<b>A_17052 - (N220.250) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 6: Die Ausführungszeiten werden wie folgt zusammengefasst:    <br>t<sub>SK</sub><sub>,i</sub>  = t<sub>IntAuth,i</sub> + t<sub>ExtAuth,i</sub>. <b>[<=]</b>

REQ(ids=A_17053)<b>A_17053 - (N220.260) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 7: MANAGE SECURITY ENVIRONMENT Restore Kommando gemäß (N099.900) mit seNo = 1, wodurch Sicherheitszustände zurückgesetzt werden. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17054)<b>A_17054 - (N220.270) K_Performanztest, Option_Kryptobox</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:      <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.21)18.8.21 CosK_f10 Sessionkeynutzung im Trusted Channel
PAR Dieser Prüfpunkt ist nur relevant, wenn Option_Kryptobox vorhanden ist.
PAR In diesem Abschnitt wird die Nutzung von Sessionkeys im Rahmen eines Trusted Channels betrachtet. Dieser Prüfpunkt arbeitet mit den Schlüsseln TC.AES128, TC.AES192 und TC.AES256 in der Anwendung / MF / DF.Auth.
PAR Testvorbereitung:
REQ(ids=G2_N221.110)<b>G2_N221.110 - (N221.110) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=G2_N221.120)<b>G2_N221.120 - (N221.120) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 2: currentFolder MUSS auf / MF / DF.Auth gesetzt werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N221.200)<b>G2_N221.200 - (N221.200) K_Performanztest, Option_Kryptobox</b>
PAR Die Testdurchführung MUSS eine äußere Schleife durchlaufen, wobei keyRef jeden Wert keyIdentifier für die Schlüssel aus der Menge {TC.AES128, TC.AES192, TC.AES256} annimmt. In jedem Schleifendurchlauf werden die Schritte 1 bis 9 ausgeführt. <b>[<=]</b>

REQ(ids=A_17055)<b>A_17055 - (N221.210) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 1: Etablierung von Sessionkeys zur Nutzung in einem Trusted Channel gemäß der Schritte (N220.210) bis (N220.240). Die Laufzeit aller dabei verwendeten Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

REQ(ids=G2_N221.220)<b>G2_N221.220 - (N221.220) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 2: Die Testdurchführung MUSS eine innere Schleife 1000-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 3 bis 8 ausgeführt. Anschließend wird mit Schritt 9 fortgefahren. <b>[<=]</b>

REQ(ids=G2_N221.230)<b>G2_N221.230 - (N221.230) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 3: In der i–ten Schleifeniteration MUSS ein Oktettstring cmdData = RAND( i ) erzeugt werden. <b>[<=]</b>

REQ(ids=G2_N221.240)<b>G2_N221.240 - (N221.240) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 4: Es wird ein PSO Encipher Kommando gemäß (N091.446) und (N091.650)c.1 ausgeführt, wobei als Kommandoparameter M der im vorherigen Schritt erzeugte Oktettstring cmdData verwendet wird. Die Laufzeit t<sub>enc</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N221.250)<b>G2_N221.250 - (N221.250) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 5: Es wird ein PSO Compute Cryptographic Checksum Kommando gemäß (N087.228) und (N087.248)a durchgeführt, wobei als Kommandoparameter data das Chiffrat cipher aus der Antwortnachricht des vorherigen Kommandos verwendet wird. Die Laufzeit t<sub>computeCC</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N221.260)<b>G2_N221.260 - (N221.260) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 6: In der i–ten Schleifeniteration MUSS ein Oktettstring rspData = RAND( i ) erzeugt werden. Diese Daten werden so verschlüsselt, dass das Chiffrat C im folgenden PSO Decipher Kommando erfolgreich entschlüsselt wird. Zum Chiffrat C wird ein MAC mac so berechnet, dass dieser im folgenden PSO Verify Cryptographic Checksum erfolgreich verifiziert wird. <b>[<=]</b>

REQ(ids=G2_N221.270)<b>G2_N221.270 - (N221.270) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 7: Es wird ein PSO Verify Cryptographic Checksum Kommando gemäß (N096.346) durchgeführt, wobei inputTemplate das Chiffrat C und den MAC mac aus dem vorherigen Schritt enthält. Die Laufzeit t<sub>verifyCC</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=G2_N221.280)<b>G2_N221.280 - (N221.280) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 8: Es wird ein PSO Decipher Kommando gemäß (N089.845) und (N090.302)a durchgeführt, wobei das Chiffrat C aus Schritt 6 als Kommandoparameter verwendet wird. Die Laufzeit t<sub>dec</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

REQ(ids=A_17056)<b>A_17056 - (N221.290) K_Performanztest, Option_Kryptobox</b>
PAR Schritt 9: MANAGE SECURITY ENVIRONMENT Restore Kommando gemäß (N099.900) mit seNo = 1, wodurch Sicherheitszustände zurückgesetzt werden. Die Laufzeit dieses Kommandos ist für diesen Prüfpunkt irrelevant. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17057)<b>A_17057 - (N221.300) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:<br>Durch die Messpunkt (x, y) -> (i, t<sub>a</sub><sub>,i</sub>) wird eine Ausgleichsgerade y = m x + b gelegt.      <b>[<=]</b>

PAR Hinweis CosH_433: Die Steigung m der Ausgleichsgeraden gibt die Verarbeitungsrate in Sekunden pro Byte an. Der Faktor 1000, der in der Berechnung von P<sub>m</sub> aufgeführt ist, rechnet dies um in Sekunden pro kByte.
PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.22)18.8.22 CosK_ccb GET RANDOM
PAR Dieser Prüfpunkt ist nur relevant, wenn Option_logische_Kanäle vorhanden ist.
PAR In diesem Abschnitt wird die Erzeugung einer sicheren Zufallszahl betrachtet. Dieser Prüfpunkt arbeitet mit der Anwendung / MF.
PAR Testvorbereitung:
REQ(ids=G2_N222.110)<b>G2_N222.110 - (N222.110) K_Performanztest, Option_logische_Kanäle</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N222.200)<b>G2_N222.200 - (N222.200) K_Performanztest, Option_logische_Kanäle</b>
PAR Die Testdurchführung MUSS eine Schleife 256-mal durchlaufen. In jedem Schleifendurchlauf wird Schritt 1 ausgeführt. <b>[<=]</b>

REQ(ids=G2_N222.210)<b>G2_N222.210 - (N222.210) K_Performanztest, Option_logische_Kanäle</b>
PAR Schritt 1: GET RANDOM wird gemäß (N099.322) ausgeführt, wobei im i-ten Schleifendurchlauf i zufällige Oktette vom Prüfling zu generieren sind. Die Laufzeit t<sub>rnd</sub><sub>,i</sub> dieses Kommandos in der i-ten Schleifeniteration MUSS gemäß CosK_056 gemessen werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17058)<b>A_17058 - (N222.220) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:<br>Durch die Messpunkt (x, y) -> (i, t<sub>rnd</sub><sub>,i</sub>) wird eine Ausgleichsgerade y = m x + b gelegt.      <b>[<=]</b>

PAR Hinweis CosH_c99: Die Steigung m der Ausgleichsgeraden gibt die Erzeugungsrate in Sekunden pro Byte an. Der Faktor 1000, der in der Berechnung von P<sub>m</sub> aufgeführt ist, rechnet dies um in Sekunden pro kByte.
PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.8.23)18.8.23 CosK_254 Öffnen und Schließen logischer Kanäle
PAR Dieser Prüfpunkt ist nur relevant, wenn Option_logische_Kanäle vorhanden ist.
PAR In diesem Abschnitt wird das Öffnen, Schließen und Rücksetzen logischer Kanäle betrachtet. Dieser Prüfpunkt arbeitet mit der Anwendung / MF.
PAR Testvorbereitung:
REQ(ids=G2_N223.110)<b>G2_N223.110 - (N223.110) K_Performanztest, Option_logische_Kanäle</b>
PAR Schritt 1: Der Prüfling MUSS gemäß CosK_064 aktiviert werden. <b>[<=]</b>

REQ(ids=A_17059)<b>A_17059 - (N223.120) K_Performanztest, Option_logische_Kanäle</b>
PAR Schritt 2: Es MÜSSEN folgende leere Mengen erstellt werden:<br>a. M<sub>Open</sub> = {},<br>b. M<sub>Close</sub> = {},<br>c. M<sub>RST</sub>   = {}. <b>[<=]</b>

PAR Testdurchführung:
REQ(ids=G2_N223.200)<b>G2_N223.200 - (N223.200) K_Performanztest, Option_logische_Kanäle</b>
PAR Die Testdurchführung MUSS eine Schleife 100-mal durchlaufen. In jedem Schleifendurchlauf werden die Schritte 1 bis 4 ausgeführt. <b>[<=]</b>

REQ(ids=G2_N223.210)<b>G2_N223.210 - (N223.210) K_Performanztest, Option_logische_Kanäle</b>
PAR Schritt 1: Zusätzlich zum Basiskanal MÜSSEN mittels MANAGE CHANNEL gemäß (N099.508) drei weitere logische Kanäle geöffnet werden. Die Laufzeit dieser drei Kommandos MUSS gemäß CosK_056 gemessen und in die Menge M<sub>Open</sub> eingestellt werden. <b>[<=]</b>

REQ(ids=G2_N223.220)<b>G2_N223.220 - (N223.220) K_Performanztest, Option_logische_Kanäle</b>
PAR Schritt 2: Die zusätzlich zum Basiskanal geöffneten logischen Kanäle MÜSSEN mittels MANAGE CHANNEL gemäß (N099.514) geschlossen werden, wobei die Reihenfolge, in welcher die Kanäle geschlossen werden zufällig bestimmt wird. Die Laufzeit dieser drei Kommandos MUSS gemäß CosK_056 gemessen und in die Menge M<sub>Close</sub> eingestellt werden. <b>[<=]</b>

REQ(ids=G2_N223.230)<b>G2_N223.230 - (N223.230) K_Performanztest, Option_logische_Kanäle</b>
PAR Schritt 3: Zusätzlich zum Basiskanal MÜSSEN mittels MANAGE CHANNEL gemäß (N099.508) drei weitere logische Kanäle geöffnet werden. Die Laufzeit dieser drei Kommandos MUSS gemäß CosK_056 gemessen und in die Menge M<sub>Open</sub> eingestellt werden. <b>[<=]</b>

REQ(ids=G2_N223.240)<b>G2_N223.240 - (N223.240) K_Performanztest, Option_logische_Kanäle</b>
PAR Schritt 4: Die Applikationsebene MUSS mittels MANAGE CHANNEL gemäß (N099.532) zurückgesetzt werden. Die Laufzeit dieses Kommandos MUSS gemäß CosK_056 gemessen und in die Menge M<sub>RST</sub> eingestellt werden. <b>[<=]</b>

PAR Testauswertung:
REQ(ids=A_17060)<b>A_17060 - (N223.250) K_Performanztest</b>
PAR Der Performanztest MUSS die in hier ermittelten Laufzeiten wie folgt in Performanzpunkte umrechnen:      <b>[<=]</b>

PAR Testnachbereitung:
PAR Keine.
PAR -HEADING(ids=18.9)18.9 CosK_cc0 Kartenkonfiguration für Performanztests (normativ)
PAR Dieser Abschnitt beschreibt die Konfiguration des Prüflings für den Performanztest. Dabei ist es zulässig, die gesamte Konfiguration so auf mehrere Images aufzuteilen, dass in den einzelnen Images einige Anwendungen fehlen. Wegen des Speicherbedarfes von DF.strukturiert und DF.transparent ist dies gegebenenfalls erforderlich.
PAR -HEADING(ids=18.9.1)18.9.1 Attribute des Objektsystems
REQ(ids=A_17061)<b>A_17061 - (N251.100) K_Personalisierung</b>
PAR Das Objektsystem gemäß (N019.900) MUSS folgende Attribute enthalten: <b>[<=]</b>

REQ(ids=G2_N251.100.a)<b>G2_N251.100.a - (N251.100)a K_Personalisierung</b>
PAR Der Wert des Attributes root MUSS die Anwendung gemäß (N253.050) sein. <b>[<=]</b>

REQ(ids=G2_N251.100.b)<b>G2_N251.100.b - (N251.100)b K_Personalisierung</b>
PAR Der Wert des Attributes answerToReset MUSS gemäß (N251.200) sein. <b>[<=]</b>

REQ(ids=G2_N251.100.c)<b>G2_N251.100.c - (N251.100)c K_Personalisierung</b>
PAR Der Wert des Attributes iccsn8 MUSS identisch zu den letzten acht Oktetten im body von / MF / EF.GDO gemäß (N253.310) sein. <b>[<=]</b>

REQ(ids=G2_N251.100.d)<b>G2_N251.100.d - (N251.100)d K_Personalisierung</b>
PAR Das Attribut applicationPublicKeyList MUSS alle Schlüssel der folgenden Menge enthalten: {    <br>   / MF / DF.Auth / PuK.RCA_ELC256 gemäß (N254.050),<br>   / MF / DF.Auth / PuK.RCA_ELC384 gemäß (N254.060),<br>   / MF / DF.Auth / PuK.RCA_ELC512 gemäß (N254.070)<br>}. <b>[<=]</b>

REQ(ids=G2_N251.100.e)<b>G2_N251.100.e - (N251.100)e K_Personalisierung</b>
PAR In persistentCache MUSS Platz für mindestens zehn CA-Schlüssel sein. <b>[<=]</b>

REQ(ids=G2_N251.100.f)<b>G2_N251.100.f - (N251.100)f K_Personalisierung</b>
PAR Das Attribut pointInTime MUSS den Wert 2012.08.22 = '010200080202' besitzen. <b>[<=]</b>

PAR -HEADING(ids=18.9.1.1)18.9.1.1 Answer To Reset
REQ(ids=A_17062)<b>A_17062 - (N251.200) K_Personalisierung</b>
PAR Für das Attribut answerToReset MUSS gelten: <b>[<=]</b>

REQ(ids=G2_N251.200.a)<b>G2_N251.200.a - (N251.200)a K_Personalisierung</b>
PAR Der answerToReset MUSS den Vorgaben aus CosT_d32 entsprechen.
PAR (ids=Tabelle-359,-CosT_d32)Tabelle 359, CosT_d32: ATR Codierung

TABLE(rows=12,cols=74+58+461)->
TR-> TH(0,0/1/1)->PAR Zeichen TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bedeutung
TR-> TD(1,0/1/1)->PAR TS TD(1,1/1/1)->PAR '3B' TD(1,2/1/1)->PAR Initial Character (direct convention)
TR-> TD(2,0/1/1)->PAR T0 TD(2,1/1/1)->PAR '9x' TD(2,2/1/1)->PAR Format Character (TA1/TD1 indication, x = no. of HB)
TR-> TD(3,0/1/1)->PAR TA1 TD(3,1/1/1)->PAR 'xx' TD(3,2/1/1)->PAR Interface Character (FI/DI, erlaubte Werte: siehe (N024.100))
TR-> TD(4,0/1/1)->PAR TD1 TD(4,1/1/1)->PAR '81' TD(4,2/1/1)->PAR Interface Character, (T=1, TD2 indication)
TR-> TD(5,0/1/1)->PAR TD2 TD(5,1/1/1)->PAR 'B1' TD(5,2/1/1)->PAR Interface Character, (T=1, TA3/TB3/TD3 indication)
TR-> TD(6,0/1/1)->PAR TA3 TD(6,1/1/1)->PAR 'FE' TD(6,2/1/1)->PAR Interface Character (IFSC coding)
TR-> TD(7,0/1/1)->PAR TB3 TD(7,1/1/1)->PAR '45' TD(7,2/1/1)->PAR Interface Character, (BWI/CWI coding)
TR-> TD(8,0/1/1)->PAR TD3 TD(8,1/1/1)->PAR '1F' TD(8,2/1/1)->PAR Interface Character, (T=15, TA4 indication)
TR-> TD(9,0/1/1)->PAR TA4 TD(9,1/1/1)->PAR 'xx' TD(9,2/1/1)->PAR Interface Character (XI/UI coding)
TR-> TD(10,0/1/1)->PAR Ti TD(10,1/1/1)->PAR HB TD(10,2/1/1)->PAR Historical Bytes (HB, imax. = 15)
TR-> TD(11,0/1/1)->PAR TCK TD(11,1/1/1)->PAR XOR TD(11,2/1/1)->PAR Check Character (exclusive OR)
PAR <b>[<=]</b>

REQ(ids=G2_N251.200.b)<b>G2_N251.200.b - (N251.200)b K_Personalisierung</b>
PAR Der ATR SOLL ein TC1 Byte mit dem Wert 'FF' enthalten. In diesem Fall MUSS T0 auf den Wert 'Dx' gesetzt werden. <b>[<=]</b>

REQ(ids=G2_N251.200.c)<b>G2_N251.200.c - (N251.200)c K_Personalisierung</b>
PAR Die Historical Bytes MÜSSEN (sofern vorhanden) gemäß [ISO/IEC 7816-4] codiert werden. <b>[<=]</b>

PAR -HEADING(ids=18.9.2)18.9.2 Allgemeine Festlegungen zu Attributstabellen
REQ(ids=G2_N252.100.a)<b>G2_N252.100.a - (N252.100)a K_Personalisierung</b>
PAR Für Zugriffsbedingungen gilt: Sofern nicht anders angegeben MUSS die Zugriffsbedingung für alle in diesem Dokument genannten Kommandos und Kommandovarianten ALWAYS sein und zwar für alle unterstützten Security Environments, alle unterstützten Schnittstellen und alle Life Cycle Status. <b>[<=]</b>

REQ(ids=A_17063)<b>A_17063 - (N252.100)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden er unterstütze weitere Kommandos oder Kommandovarianten und deren Zugriffsbedingungen seien herstellerspezifisch. <b>[<=]</b>

REQ(ids=G2_N252.200.a)<b>G2_N252.200.a - (N252.200)a K_Personalisierung</b>
PAR Alle Objekte MÜSSEN sich in SE#1 wie angegeben verwenden lassen. <b>[<=]</b>

REQ(ids=A_17064)<b>A_17064 - (N252.200)b K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden Objekte seien in anderen SE verwendbar. <b>[<=]</b>

REQ(ids=A_17065)<b>A_17065 - (N252.200)c K_Personalisierung</b>
PAR Wenn Objekte in anderen SE verwendbar sind, dann MÜSSEN sie dort dieselben Eigenschaften wie in SE#1 besitzen. <b>[<=]</b>

REQ(ids=A_17066)<b>A_17066 - (N252.300)a K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden ein Ordner, für den kein Attribut applicationIdentifier gefordert ist, enthalte einen herstellerspezifischen applicationIdentifier. <b>[<=]</b>

REQ(ids=G2_N252.300.b)<b>G2_N252.300.b - (N252.300)b K_Personalisierung</b>
PAR Enthält eine Tabelle mit Ordnerattributen einen oder mehrere AID, dann MUSS sich dieser Ordner mittels aller angegebenen AID selektieren lassen. <b>[<=]</b>

REQ(ids=G2_N252.300.c)<b>G2_N252.300.c - (N252.300)c.1 K_Personalisierung</b>
PAR Enthält eine Tabelle mit Ordnerattributen keinen fileIdentifier (FID), so DARF dieser Ordner NICHT mittels eines fileIdentifier aus dem Intervall gemäß (N006.700) selektierbar sein, es sei denn, es handelt sich um den Ordner root, dessen optionaler fileIdentifier den Wert '3F00' besitzen MUSS. <b>[<=]</b>

REQ(ids=A_17067)<b>A_17067 - (N252.300)c.2 K_TST</b>
PAR Enthält eine Tabelle mit Ordnerattributen keinen fileIdentifier (FID), dann DARF die funktionale Eignung einem Prüfling NICHT mit der Begründung verwehrt werden dem Ordner sei ein beliebiger fileIdentifier außerhalb des Intervalls gemäß (N006.700) zugeordnet. <b>[<=]</b>

REQ(ids=G2_N252.400)<b>G2_N252.400 - (N252.400) K_Personalisierung</b>
PAR Enthält eine Tabelle mit Attributen einer Datei keinen shortFileIdentifier, so DARF sich dieses EF NICHT mittels shortFileIdentifier aus dem Intervall gemäß (N007.000) selektieren lassen. <b>[<=]</b>

PAR -HEADING(ids=18.9.3)18.9.3 Root, die Wurzelapplikation
REQ(ids=G2_N253.050)<b>G2_N253.050 - (N253.050) K_Personalisierung</b>
PAR Die Anwendung root MUSS die in CosT_470 dargestellten Attribute besitzen.
PAR (ids=Tabelle-360,-CosT_470)Tabelle 360, CosT_470: Attribute / MF

TABLE(rows=6,cols=156+308+129)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR Ein Wert aus der Menge {Application, ADF} TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR applicationIdentifier TD(2,1/1/1)->PAR 'F000 0000 03' TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)" TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR fileIdentifier TD(4,1/1/1)->PAR objektType = Application  kein fileIdentifier<br>objectType = ADF  fileIdentifier = '3F 00' TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR children TD(5,1/1/1)->PAR / MF / DF.Auth          / MF / DF.IAS          / MF / DF.LCS          / MF / DF.SelectEF          / MF / DF.strukturiert          / MF / DF.transparent          / MF / EF.ATR          / MF / EF.DIR          / MF / EF.GDO TD(5,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.3.1)18.9.3.1 / MF / EF.ATR
REQ(ids=G2_N253.110)<b>G2_N253.110 - (N253.110) K_Personalisierung</b>
PAR Die Datei EF.ATR MUSS die in CosT_477 dargestellten Attribute besitzen.
PAR (ids=Tabelle-361,-CosT_477)Tabelle 361, CosT_477: Attribute / MF / EF.ATR

TABLE(rows=10,cols=158+308+129)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR transparentes Elementary File TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR fileIdentifier TD(2,1/1/1)->PAR '2F 01' TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR shortFileIdentifier TD(3,1/1/1)->PAR '1D'= 29 TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR lifeCycleStatus TD(4,1/1/1)->PAR "Operational state (active)" TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR flagTransactionMode TD(5,1/1/1)->PAR False TD(5,2/1/1)->
TR-> TD(6,0/1/1)->PAR flagChecksum TD(6,1/1/1)->PAR True TD(6,2/1/1)->
TR-> TD(7,0/1/1)->PAR numberOfOctet TD(7,1/1/1)->PAR herstellerspezifisch TD(7,2/1/1)->
TR-> TD(8,0/1/1)->PAR positionLogicalEndOfFile TD(8,1/1/1)->PAR herstellerspezifisch TD(8,2/1/1)->
TR-> TD(9,0/1/1)->PAR body TD(9,1/1/1)->PAR 'XX…YY' TD(9,2/1/1)->PAR siehe<br>a.   (N253.120),<br>b.   (N253.130) und<br>c.   (N253.140)
PAR <b>[<=]</b>

PAR Für das Attribut body gelten folgende Festlegungen:
REQ(ids=G2_N253.120)<b>G2_N253.120 - (N253.120) K_Personalisierung</b>
PAR Der Oktettstring body MUSS DER–TLV codierte Datenobjekte (DO) enthalten, welche lückenlos hintereinander konkateniert werden MÜSSEN. <b>[<=]</b>

REQ(ids=G2_N253.130)<b>G2_N253.130 - (N253.130) K_Personalisierung</b>
PAR In body MUSS an erster Stelle genau ein DO_BufferSize mit folgenden Eigenschaften enthalten sein:<br>a. Tag = 'E0'.<br>b. DO_Buffersize MUSS genau vier DO mit einem Tag '02' enthalten.<br>c. Das erste DO mit Tag '02' gibt die maximale Anzahl der Oktette in einer ungesicherten Kommando APDU an.<br>d. Das zweite DO mit Tag '02' gibt die maximale Anzahl der Oktette in einer ungesicherten Antwort an.<br>e. Das dritte DO mit Tag '02' gibt die maximale Anzahl der Oktette in einer gesicherten Kommando APDU an.<br>f. Das vierte DO mit Tag '02' gibt die maximale Anzahl der Oktette in einer gesicherten Antwort an. <b>[<=]</b>

REQ(ids=A_17068)<b>A_17068 - (N253.140) K_TST</b>
PAR Die funktionale Eignung DARF einem Prüfling NICHT mit der Begründung verwehrt werden body enthielte weitere DER–TLV codierte Datenobjekte. <b>[<=]</b>

PAR -HEADING(ids=18.9.3.2)18.9.3.2 / MF / EF.DIR
PAR Die Datei EF.DIR enthält eine Liste mit Anwendungstemplates gemäß [ISO/IEC 7816-4]. Diese Liste wird dann angepasst, wenn sich die Applikationsstruktur durch Löschen oder Anlegen von Anwendungen verändert.
REQ(ids=G2_N253.210)<b>G2_N253.210 - (N253.210) K_Personalisierung</b>
PAR Die Datei EF.DIR MUSS die in CosT_9f9 dargestellten Attribute besitzen.
PAR (ids=Tabelle-362,-CosT_9f9)Tabelle 362, CosT_9f9:Attribute / MF / EF.DIR

TABLE(rows=12,cols=162+298+132)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR linear variables Elementary File TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR fileIdentifier TD(2,1/1/1)->PAR '2F 00' TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR shortFileIdentifier TD(3,1/1/1)->PAR '1E'= 30 TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR lifeCycleStatus TD(4,1/1/1)->PAR "Operational state (active)" TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR flagTransactionMode TD(5,1/1/1)->PAR True TD(5,2/1/1)->
TR-> TD(6,0/1/1)->PAR flagChecksum TD(6,1/1/1)->PAR True TD(6,2/1/1)->
TR-> TD(7,0/1/1)->PAR maximumNumberOfRec. TD(7,1/1/1)->PAR 10 Rekord TD(7,2/1/1)->
TR-> TD(8,0/1/1)->PAR maximumRecordLength TD(8,1/1/1)->PAR 36 Oktett TD(8,2/1/1)->
TR-> TD(9,0/1/1)->PAR flagRecordLifeCycleStatus TD(9,1/1/1)->PAR False TD(9,2/1/1)->
TR-> TD(10,0/1/1)->PAR numberOfOctet TD(10,1/1/1)->PAR '00BE' Oktett = 190 Oktett TD(10,2/1/1)->
TR-> TD(11,0/1/1)->PAR recordList<br>     Rekord  1<br><br><br><br><br>     Rekord  2<br>     … TD(11,1/1/1)->PAR '61 – L<sub>61 </sub> – {<br>     4F – 05 – F000000000<br>     50 – 00<br>     53 – L<sub>53</sub> – COS_Identifier<br>}'<br>'61 – L<sub>61</sub> – {4F – L<sub>4F</sub> – AID}'<br>… TD(11,2/1/1)->PAR root, siehe (N253.050)<br><br><br><br><br>weitere Anwendungstemplates
PAR <b>[<=]</b>

PAR Hinweis CosH_4d7: Der Oktettstring COS_Identifier wird von der gematik herstellerspezifisch festgelegt.
REQ(ids=G2_N253.220)<b>G2_N253.220 - (N253.220) K_Personalisierung</b>
PAR Für jede im Objektsystem vorhandene Anwendung MUSS ein eigener Rekord in EF.DIR enthalten sein, der diese Anwendung beschreibt. <b>[<=]</b>

PAR -HEADING(ids=18.9.3.3)18.9.3.3 / MF / EF.GDO
REQ(ids=G2_N253.310)<b>G2_N253.310 - (N253.310) K_Personalisierung</b>
PAR Die Datei EF.GDO MUSS die in CosT_eed dargestellten Attribute besitzen.
PAR (ids=Tabelle-363,-CosT_eed)Tabelle 363, CosT_eed: Attribute / MF / EF.GDO

TABLE(rows=10,cols=158+308+129)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR transparentes Elementary File TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR fileIdentifier TD(2,1/1/1)->PAR '2F 02' TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR shortFileIdentifier TD(3,1/1/1)->PAR '02'= 2 TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR lifeCycleStatus TD(4,1/1/1)->PAR "Operational state (active)" TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR flagTransactionMode TD(5,1/1/1)->PAR False TD(5,2/1/1)->
TR-> TD(6,0/1/1)->PAR flagChecksum TD(6,1/1/1)->PAR True TD(6,2/1/1)->
TR-> TD(7,0/1/1)->PAR numberOfOctet TD(7,1/1/1)->PAR '000C' Oktett = 12 Oktett TD(7,2/1/1)->
TR-> TD(8,0/1/1)->PAR positionLogicalEndOfFile TD(8,1/1/1)->PAR 12 TD(8,2/1/1)->
TR-> TD(9,0/1/1)->PAR body TD(9,1/1/1)->PAR '5A – 0A – 80276…' TD(9,2/1/1)->PAR wird personalisiert
PAR <b>[<=]</b>

REQ(ids=G2_N253.320)<b>G2_N253.320 - (N253.320) K_Personalisierung</b>
PAR In body MUSS genau ein DER–TLV codiertes Datenobjekt DO_ICCSN mit folgenden Eigenschaften enthalten sein:<br>a. Tag = '5A' und Längenfeld = '0A'.<br>b. Für das Wertfeld MUSS gelten:<br>    1. Das erste Oktett MUSS den Major Industry Identifer (MII) mit dem Wert '80' enthalten.<br>    2. Die nächsten drei Nibble MÜSSEN den Country Code Deutschlands mit dem Wert '276'enthalten.<br>    3. Die nächsten fünf Nibble MÜSSEN den Issuer Identifer enthalten.<br>    4. Die restlichen fünf Oktette MÜSSEN BCD codiert eine Seriennummer enthalten. <b>[<=]</b>

PAR -HEADING(ids=18.9.4)18.9.4 Anwendung für Authentisierungsprotokolle, DF.Auth
REQ(ids=G2_N254.005)<b>G2_N254.005 - (N254.005) K_Personalisierung</b>
PAR Die Anwendung DF.Auth MUSS die in CosT_47f dargestellten Attribute besitzen.
PAR (ids=Tabelle-364,-CosT_47f)Tabelle 364, CosT_47f: Attribute / MF / DF.Auth

TABLE(rows=6,cols=155+346+94)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR Ordner TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR applicationIdentifier TD(2,1/1/1)->PAR 'F000 0000 04' TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR fileIdentifier TD(3,1/1/1)->PAR - TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR lifeCycleStatus TD(4,1/1/1)->PAR "Operational state (active)" TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR children TD(5,1/1/1)->PAR / MF / DF.Auth / PrK.Auth_ELC256          / MF / DF.Auth / PrK.Auth_ELC384          / MF / DF.Auth / PrK.Auth_ELC512          / MF / DF.Auth / PuK.RCA_ELC256          / MF / DF.Auth / PuK.RCA_ELC384          / MF / DF.Auth / PuK.RCA_ELC512          / MF / DF.Auth / SK.AES128          / MF / DF.Auth / SK.AES192          / MF / DF.Auth / SK.AES256          / MF / DF.Auth / TC.AES128          / MF / DF.Auth / TC.AES192          / MF / DF.Auth / TC.AES256 TD(5,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.4.1)18.9.4.1 / MF/ DF.Auth / PrK.Auth_ELC256
REQ(ids=G2_N254.010)<b>G2_N254.010 - (N254.010) K_Personalisierung</b>
PAR Der Schlüssel PrK.Auth_ELC256 MUSS die in CosT_010 dargestellten Attribute besitzen.
PAR (ids=Tabelle-365,-CosT_010)Tabelle 365, CosT_010: Attribute / MF / DF.Auth / PrK.Auth_ELC256

TABLE(rows=7,cols=134+462)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR privates Authentisierungsobjekt, ELC256
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '11' = 17
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)"
TR-> TD(4,0/1/1)->PAR privateKey TD(4,1/1/1)->PAR domainParameter gemäß brainpoolP256r1, privateElcKey.d =<br>'3b47afc75fafcf62ea3546efbe0b8d4a9295892e19acf562556441c34f374810'
TR-> TD(5,0/1/1)->PAR keyAvailable TD(5,1/1/1)->PAR True
TR-> TD(6,0/1/1)->PAR listAlgorithmIdentifier TD(6,1/1/1)->PAR für alle unterstützten SE:    <br> setAlgorithmIdentifier = {elcRoleAuthentication, elcSessionkey4SM}
PAR <b>[<=]</b>

PAR Hinweis CosH_5bd: Der zugehörige öffentliche Punkt gemäß P2OS(…) lautet:    <br>'040597cf45e706318271161744c8a2df37daf696c3feb0e3244de79d3a7472d8eb<br>  07d37f751e9494d4e9b12f9cea5a2105724f742d1e444a5553ec26da4e0556e9'.
PAR -HEADING(ids=18.9.4.2)18.9.4.2 / MF/ DF.Auth / PrK.Auth_ELC384
REQ(ids=G2_N254.020)<b>G2_N254.020 - (N254.020) K_Personalisierung</b>
PAR Der Schlüssel PrK.Auth_ELC384 MUSS die in CosT_f7f dargestellten Attribute besitzen.
PAR (ids=Tabelle-366,-CosT_f7f)Tabelle 366, CosT_f7f: Attribute / MF / DF.Auth / PrK.Auth_ELC384

TABLE(rows=7,cols=154+444)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR privates Authentisierungsobjekt, ELC384
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '12' = 18
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)"
TR-> TD(4,0/1/1)->PAR privateKey TD(4,1/1/1)->PAR domainParameter gemäß brainpoolP384r1, privateElcKey.d = '5055f4c2260871efbf7eac69119597bb582be3210df50756<br>29311a065d1328720f1982dc9d99ea1a4f3f4ad16c857ce8'
TR-> TD(5,0/1/1)->PAR keyAvailable TD(5,1/1/1)->PAR True
TR-> TD(6,0/1/1)->PAR listAlgorithmIdentifier TD(6,1/1/1)->PAR für alle unterstützten SE:     <br> setAlgorithmIdentifier = {elcRoleAuthentication, elcSessionkey4SM}
PAR <b>[<=]</b>

PAR Hinweis CosH_7a3: Der zugehörige öffentliche Punkt gemäß P2OS(…) lautet:<br>'04808efcb3b017f52f46bafbca6ad5860d0f378ffe260edb0cbab2eff3f57c93c006958e0648e824c8fc211b9d33d564d7<br>   0698419b30919ce79cdee85b06cd445146f254faa5df04debb56bf45355728b3e8a0d90560b002601d74c50f78d67aa6´.
PAR -HEADING(ids=18.9.4.3)18.9.4.3 / MF/ DF.Auth / PrK.Auth_ELC512
REQ(ids=G2_N254.030)<b>G2_N254.030 - (N254.030) K_Personalisierung</b>
PAR Der Schlüssel PrK.Auth_ELC512 MUSS die in CosT_c41 dargestellten Attribute besitzen.
PAR (ids=Tabelle-367,-CosT_c41)Tabelle 367, CosT_c41: Attribute / MF / DF.Auth / PrK.Auth_ELC512

TABLE(rows=7,cols=141+455)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR privates Authentisierungsobjekt, ELC512
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '13' = 19
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)"
TR-> TD(4,0/1/1)->PAR privateKey TD(4,1/1/1)->PAR domainParameter gemäß brainpoolP512r1, privateElcKey.d = '4ef41d5494649f0a214dded44a77d617d41ca1f56795038c70e1b222ab6d6d70<br> 3c61dd6a6a2fa26e79db5848dedf1208ad2180afab576b23f23b31084e03edc4'
TR-> TD(5,0/1/1)->PAR keyAvailable TD(5,1/1/1)->PAR True
TR-> TD(6,0/1/1)->PAR listAlgorithmIdentifier TD(6,1/1/1)->PAR für alle unterstützten SE:     <br> setAlgorithmIdentifier = {elcRoleAuthentication, elcSessionkey4SM}
PAR <b>[<=]</b>

PAR Hinweis CosH_3c6: Der zugehörige öffentliche Punkt gemäß P2OS(…) lautet:    <br>'048ef0a9023aae89e687c9ab56b1e16d9dc5bdb7b4773dc1f883c4f257e917fab<br>   a22c2f8f1c20f9c283aa8197d70c592b2db4abcace1acf26a0f83f8ccd71665b<br>   88d5cb73df9b8ed006cd463683e00a0bbc982c0f470543d4bf7190d13c8ecd21<br>   cc1b83db0421faa737d2fad35e0391d48ecd11b25b3584fb691e66fd8786ab78'.
PAR -HEADING(ids=18.9.4.4)18.9.4.4 / MF/ DF.Auth / PrK.Auth_RSA2048
PAR Dieses Kapitel ist absichtlich leer.
REQ(ids=G2_N254.040)<b>G2_N254.040 - (N254.040)</b>
PAR Dieser Punkt ist absichtlich leer. <b>[<=]</b>

PAR -HEADING(ids=18.9.4.5)18.9.4.5 / MF/ DF.Auth / PuK.RCA_ELC256
REQ(ids=G2_N254.050)<b>G2_N254.050 - (N254.050) K_Personalisierung</b>
PAR Der Schlüssel PuK.RCA_ELC256 MUSS die in CosT_d98 dargestellten Attribute besitzen.
PAR (ids=Tabelle-368,-CosT_d98)Tabelle 368, CosT_d98: Attribute / MF / DF.Auth / PuK.RCA_ELC256

TABLE(rows=8,cols=110+486)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR Öffentliches Signaturprüfobjekt, ELC256
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '4445585858600112'
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)"
TR-> TD(4,0/1/1)->PAR publicKey TD(4,1/1/1)->PAR domainParameter gemäß brainpoolP256r1, P = '0434dc65068c3633671828f73adeb8fbc01952e3de3511823448f15afc28ebea38<br>   29be1ac9d4d10869ce5fa675275087603e4e9fc86ff3c127b9e94a14c670164d'
TR-> TD(5,0/1/1)->PAR oid TD(5,1/1/1)->PAR ecdsa-with-SHA256
TR-> TD(6,0/1/1)->PAR CHAT TD(6,1/1/1)->PAR OID<sub>flags</sub>  = oid_cvc_fl_ti<br>flagList   = 'FF FFFF FFFF FFFF'
TR-> TD(7,0/1/1)->PAR expirationDate TD(7,1/1/1)->PAR 2023.04.15: YYMMDD = '0203 0004 0105'
PAR <b>[<=]</b>

PAR Hinweis CosH_f08: Der zugehörige private Schlüssel besitzt das Attribut privateElcKey.d =     '74320bea049777bc663c27cfb2c488b7a49b05af348d9186f86a7196c2f6bb43'.
PAR -HEADING(ids=18.9.4.6)18.9.4.6 / MF/ DF.Auth / PuK.RCA_ELC384
REQ(ids=G2_N254.060)<b>G2_N254.060 - (N254.060) K_Personalisierung</b>
PAR Der Schlüssel PuK.RCA_ELC384 MUSS die in CosT_969 dargestellten Attribute besitzen.
PAR (ids=Tabelle-369,-CosT_969)Tabelle 369, CosT_969: Attribute / MF / DF.Auth / PuK.RCA_ELC384

TABLE(rows=8,cols=151+445)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR Öffentliches Signaturprüfobjekt, ELC384
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '4445585858600212'
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)"
TR-> TD(4,0/1/1)->PAR publicKey TD(4,1/1/1)->PAR domainParameter gemäß brainpoolP384r1, P =<br> '043e84af62d1330a9a6f04a2791e0935e7cfe01eb8f7ae8d96eef77c036c056992<br>   8e53700322a28454e647c85ea9c89c1d<br>   3051ce803c21e5c27a73bd8da121524d4679ded5144368523855e522cfe9a7d1<br>   ba31e691900cd02740c399ffcc10f260'
TR-> TD(5,0/1/1)->PAR oid TD(5,1/1/1)->PAR ecdsa-with-SHA384
TR-> TD(6,0/1/1)->PAR CHAT TD(6,1/1/1)->PAR OIDflags     = oid_cvc_fl_ti<br>flagList     = 'F F FFFF FFFF FFFF'
TR-> TD(7,0/1/1)->PAR expirationDate TD(7,1/1/1)->PAR 2023.04.15: YYMMDD = '0203 0004 0105'
PAR <b>[<=]</b>

PAR HInweis CosH_172: Der zugehörige private Schlüssel besitzt das Attribut privateElcKey.d =     '3dbf52550829cec527f91de05fc3d70b47c38d1c8504623174c912afc7941afbe104b9b3d34a4eb0dd35452e2b67884a'.
PAR -HEADING(ids=18.9.4.7)18.9.4.7 / MF/ DF.Auth / PuK.RCA_ELC512
REQ(ids=G2_N254.070)<b>G2_N254.070 - (N254.070) K_Personalisierung</b>
PAR Der Schlüssel PuK.RCA_ELC512 MUSS die in CosT_1db: dargestellten Attribute besitzen.
PAR (ids=Tabelle-370,-CosT_1db)Tabelle 370, CosT_1db: Attribute / MF / DF.Auth / PuK.RCA_ELC512

TABLE(rows=8,cols=101+497)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR Öffentliches Signaturprüfobjekt, ELC512
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '4445585858600312'
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)"
TR-> TD(4,0/1/1)->PAR publicKey TD(4,1/1/1)->PAR domainParameter gemäß brainpoolP512r1, P =<br> '043b5e694c154f4dd0812a91273869d382f5c81748ef5797416369b445f60dd248<br>   0d2400d1e7dd896b054ba615d8927fb10911e02753a22b1f6ec1ba18d0c1fdaa<br>   905712f33003bec6a51c179006e7b98f8d1d1219db49944f05602b46ac511570<br>   b136907081a5f93a0e000b7f335f76a7f8c18584fc7a7d11fddc96844ff8cb5b'
TR-> TD(5,0/1/1)->PAR oid TD(5,1/1/1)->PAR ecdsa-with-SHA512
TR-> TD(6,0/1/1)->PAR CHAT TD(6,1/1/1)->PAR OIDflags = oid_cvc_fl_ti<br>flagList   = 'F F FFFF FFFF FFFF'
TR-> TD(7,0/1/1)->PAR expirationDate TD(7,1/1/1)->PAR 2023.04.15: YYMMDD = '0203 0004 0105'
PAR <b>[<=]</b>

PAR Hinweis CosH_ac0: Der zugehörige private Schlüssel besitzt das Attribut privateElcKey.d =     '285927d1d7469dc69c83d25380dd51bbbd39cc69cf74219a53700eb44d1d0827<br> 130c6881ea13836d454eae6972b5702b1da75e9ba39c6050539c5173129d2d0b'.
PAR -HEADING(ids=18.9.4.8)18.9.4.8 / MF/ DF.Auth / PuK.RCA_RSA2048
PAR Dieses Kapitel ist absichlich leer.
REQ(ids=G2_N254.080)<b>G2_N254.080 - (N254.080)</b>
PAR Dieser Punkt ist absichtlich leer. <b>[<=]</b>

PAR -HEADING(ids=18.9.4.9)18.9.4.9 / MF / DF.Auth / SK.AES128
REQ(ids=G2_N254.090)<b>G2_N254.090 - (N254.090) K_Personalisierung</b>
PAR Der Schlüssel SK.AES128 MUSS die in CosT_a24 dargestellten Attribute besitzen.
PAR (ids=Tabelle-371,-CosT_a24)Tabelle 371, CosT_a24: Attribute / MF / DF.Auth / SK.AES128

TABLE(rows=8,cols=156+310+129)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR symmetrisches Authentisierungsobjekt, AES128 TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '02' = 2 TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)" TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR encKey TD(4,1/1/1)->PAR '0102030405060708 090A0B0C0D0E0F10' TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR macKey TD(5,1/1/1)->PAR '100F0E0D0C0B0A09 0807060504030201' TD(5,2/1/1)->
TR-> TD(6,0/1/1)->PAR numberScenario TD(6,1/1/1)->PAR 0 TD(6,2/1/1)->
TR-> TD(7,0/1/1)->PAR algorithmIdentifier TD(7,1/1/1)->PAR aesSessionkey4SM TD(7,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.4.10)18.9.4.10 / MF / DF.Auth / SK.AES192
REQ(ids=G2_N254.100)<b>G2_N254.100 - (N254.100) K_Personalisierung</b>
PAR Der Schlüssel SK.AES192 MUSS die in CosT_dc7 dargestellten Attribute besitzen.
PAR (ids=Tabelle-372,-CosT_dc7)Tabelle 372, CosT_dc7: Attribute / MF / DF.Auth / SK.AES192

TABLE(rows=8,cols=157+442)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR Symmetrisches Authentisierungsobjekt, AES192
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '03' = 3
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)"
TR-> TD(4,0/1/1)->PAR encKey TD(4,1/1/1)->PAR '0102030405060708 090A0B0C0D0E0F10 1112131415161718'
TR-> TD(5,0/1/1)->PAR macKey TD(5,1/1/1)->PAR '1817161514131211 100F0E0D0C0B0A09 0807060504030201'
TR-> TD(6,0/1/1)->PAR numberScenario TD(6,1/1/1)->PAR 0
TR-> TD(7,0/1/1)->PAR algorithmIdentifier TD(7,1/1/1)->PAR aesSessionkey4SM
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.4.11)18.9.4.11 / MF / DF.Auth / SK.AES256
REQ(ids=G2_N254.110)<b>G2_N254.110 - (N254.110) K_Personalisierung</b>
PAR Der Schlüssel SK.AES256 MUSS die in CosT_f96 dargestellten Attribute besitzen.
PAR (ids=Tabelle-373,-CosT_f96)Tabelle 373, CosT_f96: Attribute / MF / DF.Auth / SK.AES256

TABLE(rows=8,cols=156+310+129)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR symmetrisches Authentisierungsobjekt, AES256 TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '04' = 4 TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)" TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR encKey TD(4,1/1/1)->PAR '0102030405060708 090A0B0C0D0E0F10<br> 1112131415161718 191A1B1C1D1E1F20' TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR macKey TD(5,1/1/1)->PAR '100F0E0D0C0B0A09 0807060504030201<br> 201F1E1D1C1B1A19 1817161514131211' TD(5,2/1/1)->
TR-> TD(6,0/1/1)->PAR numberScenario TD(6,1/1/1)->PAR 0 TD(6,2/1/1)->
TR-> TD(7,0/1/1)->PAR algorithmIdentifier TD(7,1/1/1)->PAR aesSessionkey4SM TD(7,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.4.12)18.9.4.12 / MF / DF.Auth / TC.AES128
PAR Dieses Objekt ist genau dann verfügbar, wenn Option_Kryptobox implementiert ist.
REQ(ids=G2_N254.120)<b>G2_N254.120 - (N254.120) K_Personalisierung, Option_Kryptobox</b>
PAR Der Schlüssel TC.AES128 MUSS die in CosT_96c dargestellten Attribute besitzen.
PAR (ids=Tabelle-374,-CosT_96c)Tabelle 374, CosT_96c: Attribute / MF / DF.Auth / TC.AES128

TABLE(rows=7,cols=156+310+129)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR symmetrisches Authentisierungsobjekt, AES128 TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '05' = 5 TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)" TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR encKey TD(4,1/1/1)->PAR '0102030405060708 090A0B0C0D0E0F10' TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR macKey TD(5,1/1/1)->PAR '100F0E0D0C0B0A09 0807060504030201' TD(5,2/1/1)->
TR-> TD(6,0/1/1)->PAR algorithmIdentifier TD(6,1/1/1)->PAR aesSessionkey4TC TD(6,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.4.13)18.9.4.13 / MF / DF.Auth / TC.AES192
PAR Dieses Objekt ist genau dann verfügbar, wenn Option_Kryptobox implementiert ist.
REQ(ids=G2_N254.130)<b>G2_N254.130 - (N254.130) K_Personalisierung, Option_Kryptobox</b>
PAR Der Schlüssel TC.AES192 MUSS die in CosT_bb5 dargestellten Attribute besitzen.
PAR (ids=Tabelle-375,-CosT_bb5)Tabelle 375, CosT_bb5: Attribute / MF / DF.Auth / TC.AES192

TABLE(rows=7,cols=157+442)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR Symmetrisches Authentisierungsobjekt, AES192
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '06' = 6
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)"
TR-> TD(4,0/1/1)->PAR encKey TD(4,1/1/1)->PAR '0102030405060708 090A0B0C0D0E0F10 1112131415161718'
TR-> TD(5,0/1/1)->PAR macKey TD(5,1/1/1)->PAR '1817161514131211 100F0E0D0C0B0A09 0807060504030201'
TR-> TD(6,0/1/1)->PAR algorithmIdentifier TD(6,1/1/1)->PAR aesSessionkey4TC
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.4.14)18.9.4.14 / MF / DF.Auth / TC.AES256
PAR Dieses Objekt ist genau dann verfügbar, wenn Option_Kryptobox implementiert ist.
REQ(ids=G2_N254.140)<b>G2_N254.140 - (N254.140) K_Personalisierung, Option_Kryptobox</b>
PAR Der Schlüssel TC.AES256 MUSS die in CosT_79e dargestellten Attribute besitzen.
PAR (ids=Tabelle-376,-CosT_79e)Tabelle 376, CosT_79e: Attribute / MF / DF.Auth / TC.AES256

TABLE(rows=7,cols=156+310+129)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR symmetrisches Authentisierungsobjekt, AES256 TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '07' = 7 TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)" TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR encKey TD(4,1/1/1)->PAR '0102030405060708 090A0B0C0D0E0F10<br> 1112131415161718 191A1B1C1D1E1F20' TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR macKey TD(5,1/1/1)->PAR '100F0E0D0C0B0A09 0807060504030201<br> 201F1E1D1C1B1A19 1817161514131211' TD(5,2/1/1)->
TR-> TD(6,0/1/1)->PAR algorithmIdentifier TD(6,1/1/1)->PAR aesSessionkey4TC TD(6,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.5)18.9.5 Anwendung für IAS Services, DF.IAS
REQ(ids=G2_N255.050)<b>G2_N255.050 - (N255.050) K_Personalisierung</b>
PAR Die Anwendung DF.IAS MUSS die in CosT_c20 dargestellten Attribute besitzen.
PAR (ids=Tabelle-377,-CosT_c20)Tabelle 377, CosT_c20: Attribute / MF / DF.IAS

TABLE(rows=6,cols=155+312+128)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR Ordner TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR applicationIdentifier TD(2,1/1/1)->PAR 'F000 0000 05' TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR fileIdentifier TD(3,1/1/1)->PAR - TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR lifeCycleStatus TD(4,1/1/1)->PAR "Operational state (active)" TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR children TD(5,1/1/1)->PAR / MF / DF.IAS / PrK.X509_ELC256          / MF / DF.IAS / PrK.X509_ELC384          / MF / DF.IAS / PrK.X509_ELC512          / MF / DF.IAS / PrK.X509_RSA2048          / MF / DF.IAS / PrK.X509_RSA3072 TD(5,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.5.1)18.9.5.1 / MF/ DF.IAS / PrK.X509_ELC256
REQ(ids=G2_N255.110)<b>G2_N255.110 - (N255.110) K_Personalisierung</b>
PAR Der Schlüssel PrK.X509_ELC256 MUSS die in CosT_9c2 dargestellten Attribute besitzen.
PAR (ids=Tabelle-378,-CosT_9c2)Tabelle 378, CosT_9c2: Attribute / MF / DF.IAS / PrK.X509_ELC256

TABLE(rows=7,cols=152+447)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR privates ELC Schlüsselobjekt, ELC256
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '18' = 24
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)"
TR-> TD(4,0/1/1)->PAR privateKey TD(4,1/1/1)->PAR domainParameter gemäß brainpoolP256r1, privateElcKey.d = '295fcd16a620cb6fe34f7b0326e9b059c0b5229057c04ed9a7ed13a542967ee0'
TR-> TD(5,0/1/1)->PAR keyAvailable TD(5,1/1/1)->PAR True
TR-> TD(6,0/1/1)->PAR listAlgorithmIdentifier TD(6,1/1/1)->PAR für alle unterstützten SE: setAlgorithmIdentifier =     <br>{elcRoleAuthentication, elcSharedSecretCalculation, signECDSA}
PAR <b>[<=]</b>

PAR Hinweis CosH_307: Der zugehörige öffentliche Punkt gemäß P2OS(…) lautet:     ´04855978a5c0237c53404d6de6b9626145494feca14591dcfcbdb0385097759872<br>   9ba33a5ae2dd510878c4edd669fbf6b55fddcbeffdbacfbec3b88e151fc78556´.
PAR -HEADING(ids=18.9.5.2)18.9.5.2 / MF/ DF.IAS / PrK.X509_ELC384
REQ(ids=G2_N255.120)<b>G2_N255.120 - (N255.120) K_Personalisierung</b>
PAR Der Schlüssel PrK.X509_ELC384 MUSS die in CosT_ebf dargestellten Attribute besitzen.
PAR (ids=Tabelle-379,-CosT_ebf)Tabelle 379, CosT_ebf: Attribute / MF / DF.IAS / PrK.X509_ELC384

TABLE(rows=7,cols=154+444)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR privates ELC Schlüsselobjekt, ELC384
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '19' = 25
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)"
TR-> TD(4,0/1/1)->PAR privateKey TD(4,1/1/1)->PAR domainParameter gemäß brainpoolP384r1, privateElcKey.d = '6fbeecf714222b4a6ce80f035a00d80508cce63c73f4ad77<br> 8db108f8e556f8a9f7625cce92fc6d24a2de0d8e998bee58'
TR-> TD(5,0/1/1)->PAR keyAvailable TD(5,1/1/1)->PAR True
TR-> TD(6,0/1/1)->PAR listAlgorithmIdentifier TD(6,1/1/1)->PAR für alle unterstützten SE: setAlgorithmIdentifier =     <br>{elcSharedSecretCalculation, signECDSA}
PAR <b>[<=]</b>

PAR Hinweis CosH_b80: Der zugehörige öffentliche Punkt gemäß P2OS(…) lautet:     ´0435229000a37cc393cd04d8192ef25b910720a11453600a568b7f7adf3efebe984bc4893e3782aedfa9d4deeb602e7574<br>   02e591fa8bc4cfe150e0b7a7504616f19dba2e7b55c6c11a89b6061e0b2e831a7ccefd8b306400c2a0fe6e8bc5ebff84´.
PAR -HEADING(ids=18.9.5.3)18.9.5.3 / MF/ DF.IAS / PrK.X509_ELC512
REQ(ids=G2_N255.130)<b>G2_N255.130 - (N255.130) K_Personalisierung</b>
PAR Der Schlüssel PrK.X509_ELC512 MUSS die in CosT_2bb dargestellten Attribute besitzen.
PAR (ids=Tabelle-380,-CosT_2bb)Tabelle 380, CosT_2bb: Attribute / MF / DF.IAS / PrK.X509_ELC512

TABLE(rows=7,cols=150+449)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR privates ELC Schlüsselobjekt, ELC512
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '1A' = 26
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)"
TR-> TD(4,0/1/1)->PAR privateKey TD(4,1/1/1)->PAR domainParameter gemäß brainpoolP512r1, privateElcKey.d = ´2c24d847750f8321f875880deb583a7f4afdc8ebfd1fd6f587e6876d594bffba<br> f284814019156c9efbafdac25ec426b6c842e82c5e4a657fee934c21b0447810´
TR-> TD(5,0/1/1)->PAR keyAvailable TD(5,1/1/1)->PAR True
TR-> TD(6,0/1/1)->PAR listAlgorithmIdentifier TD(6,1/1/1)->PAR für alle unterstützten SE: setAlgorithmIdentifier =     <br>{elcSharedSecretCalculation, signECDSA}
PAR <b>[<=]</b>

PAR Hinweis CosH_099: Der zugehörige öffentliche Punkt gemäß P2OS(…) lautet:     ´043e4e30df5028cdc67a4aa3b95c4803a278e6ada8dd6d37ead2816fcf9507001d<br>   03929a692137e376ee60c7318b3bb219d84f1bfb4429ed32b549c7544e006f22<br>   6c787e46f2d0ed40e15e2baec59b5f9bcd0dc8d189dc84c27c82aeb4de14183d<br>   95c5b2899f1530c8cdadddc75b262658513d5716725745f101953d10f2e8a544´.
PAR -HEADING(ids=18.9.5.4)18.9.5.4 / MF/ DF.IAS / PrK.X509_RSA2048
REQ(ids=G2_N255.140)<b>G2_N255.140 - (N255.140) K_Personalisierung</b>
PAR Der Schlüssel PrK.X509_RSA2048 MUSS die in CosT_cd0 dargestellten Attribute besitzen.
PAR (ids=Tabelle-381,-CosT_cd0)Tabelle 381, CosT_cd0: Attribute / MF / DF.IAS / PrK.X509_RSA2048

TABLE(rows=8,cols=94+643)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR privates RSA Schlüsselobjekt, RSA2048
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '0B' = 11
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)"
TR-> TD(4,0/1/1)->PAR modulusLength TD(4,1/1/1)->PAR 2048
TR-> TD(5,0/1/1)->PAR privateKey TD(5,1/1/1)->PAR '30 8204bd<br>   02 01 00<br>   30 0d<br>      06 09 2a864886f70d010101<br>      05 00<br>   04 8204a7<br>      30 8204a3<br>         02 01 00<br>         02 820101 00a20d2aa5d0241c4cadd5db90509a3030a4f24f99c6ad2604ca96fd06986345a4<br>                     8eb74f1b9c7be26e18295fd58dd1a3b6d715580ad27d2b5db93c168b8cdc261d<br>                     92e12eee344624317a20d2221cbbbcf1bd376d20126980f470ff2b48f65d686d<br>                     9cc5e0f7383dcab0881a7de198f1a7b1a2717d1c03ad86973dcefdb0425ed9bb<br>                     98344549eac891c9e25c3a02e873aafb5e2adc4afa1c526081bd1f61e75c43fb<br>                     cbf135f572073d18d1a30c69d6aac6956761c02a36d74de4fc6bb96c7529528a<br>                     60628d99dea4abcdb209da139398a68f563ab3595bd882b583097a167b590932<br>                     c9db5d47df32c10877bd5fe3cf46a31826259ef1329b5b99a2c87a40e7833459<br>         02 03 010001<br>         02 820100   34e0c8fecc394c46b51ea883a1d97e4a1138c442b072c58a20b53e214dce6ee6<br>                     306f9e4fab333d82a13db6f8cf4b0df9d69b2f5c70acc95eced7cd9f81ba4071<br>                     bc00e0b877b43f912981d62fad629157ec5f4eab7d7691ceb1a481f24ff9d0de<br>                     9b9e723719520876ac22c0dac176713ae47fd5cc3363071d08dd2728c1af83aa<br>                     4f0209fe69356338dbdff20a82cc55b8bd0096332538cc7f2357f78aff6ef73d<br>                     78d618f46773ccba18cc0b77f1258d395aecb3ba6af3e197111b08a2244cee1b<br>                     5aa5d9cd76e50db7ebbabf61e36b9251c77b3e7e91c12bc090c4c1bbd7f82952<br>                     932f6f2a3c68f492de5d00af0be71214de359ae9a78740d21e86a4804ce5a501<br>         02 8181   00c27b9a4daa01ef082498e84ced6d90bddd42c8682a7b359314cefedde7abb43a<br>                     098f93b75541d05b48d446c0fdc1c375fad17da4cf288dc6388c198739915edc<br>                     bda3d6dc4c4df2ed74626d006f73ab8acf1c8842cdd58a217a3972fab547fa37<br>                     7fcaab37dc0dc6799228e204705e8acd5f31419715703c4dde4a87ae61311af9<br>         02 8181   00d54f682555c9966346e198495568238a74dc1dc0d821224311070a3ffde4fc8b<br>                     4d61c497e9fcdc40652b16defc1c6c595999cafd3a0588a5ab890789cf9d3cf9<br>                     2cfbd518601719d456173ef4701b62062572347fe2785d57652110c30c530d1a<br>                     f561d7c36104d0165047783bcdc7db6ea69a6ccdb05132a60c79fc1d2b0adc61<br>         02 8181   00ad83a7a4990486a5e6390230f83823c631ad4eae1910ba38d27ce7c945d3dcc5<br>                     5718613b557695958c01d06a893c21ce960be8246dab09ea8b32fbe7b8c5e933<br>                     da825dc548d2d6e5624c1a62240db843ed0ad0cb81677e88e5ca71ba1a98f036<br>                     29eec119e25bebf33523029be14188673901f23a00a795360818c8bb1cfdb9c9<br>         02 8180     0217c45ad16ba7e91371f52f8b01f98f4b3439aa81b45984b4ef0fbfaefb072b<br>                     4ab811d8b7b7fe653758e3e18e31ad327739960f43f977ecc03118fcd627a1c8<br>                     84137874c3c496414a12f2502da56721ce4e3f8b9daa36a83bdac63253b5a0e4<br>                     49d20aeee4cdca48ddc2c5c03875a4868265f379552886c9b047a61c97268521<br>         02 8180     6f99aa16030050301c99ea08e9d121ba6a3f9e0a32cd265cfc00200855f64041<br>                     6e0980ea47a196ecb5c48f69e8c58aa4cd2289758f7fcd384ee744e6b87d727f<br>                     8d4585c7f9924afd197469cf9910ba847841f9f67d024de97013e3c34c61b9f3<br>                     15d5f6b5cb8bfe7316193c37b4d9a99a59b962fd3c75245227b42b325d33ccf3'
TR-> TD(6,0/1/1)->PAR keyAvailable TD(6,1/1/1)->PAR True
TR-> TD(7,0/1/1)->PAR listAlgorithmIdentifier TD(7,1/1/1)->PAR für alle unterstützten SE: setAlgorithmIdentifier = {rsaDecipherOaep, rsaDecipherPKCS1_V1_5, sign9796_2_DS2, signPSS}
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.5.5)18.9.5.5 / MF/ DF.IAS / PrK.X509_RSA3072
REQ(ids=G2_N255.150)<b>G2_N255.150 - (N255.150) K_Personalisierung</b>
PAR Der Schlüssel PrK.X509_RSA3072 MUSS die in CosT_aa3 dargestellten Attribute besitzen.
PAR (ids=Tabelle-382,-CosT_aa3)Tabelle 382, CosT_aa3: Attribute / MF / DF.IAS / PrK.X509_RSA3072

TABLE(rows=8,cols=134+613)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR privates RSA Schlüsselobjekt, RSA3072
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '0C' = 12
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)"
TR-> TD(4,0/1/1)->PAR modulusLength TD(4,1/1/1)->PAR 3072
TR-> TD(5,0/1/1)->PAR privateKey TD(5,1/1/1)->PAR '30 8206fe<br>   02 01 00<br>   30 0d<br>      06 09 2a864886f70d010101<br>      05 00<br>   04 8206e8<br>      30 8206e4<br>         02 01 00<br>         02 820181 00c50ed1db3704e8259e07d6d4433f4c2c45d0cf28a78dcb8512ebd4b09cd2a07f<br>                     0ed22410b1188eb8e5faf29c72426624c4d73deee856179eef171199d5c09ceb<br>                     b23a42b2866477e26c8ff34c8fd5a53320fd82e81abfa649b9b68bf876bd2b18<br>                     0d8886811bb6f48e64eded13286e39a74f61ff410cf1f6537ca2c7397a7a1250<br>                     7ad8b5a430ba1cd2c0c79cb550bf422ee4a75115050164c31a5784f1db433464<br>                     dbfdd8fafca3fb3e12f519eb2f92ae1c67c88e5bd4fba8f10726317dd114ff64<br>                     b644ba58b3a4cda9613219aa36d712300306b16f418c03f4ca5f66ecf640808b<br>                     98c547019d7b562a10b1f6d8ed9274a4e7159725ff5c20180434db6190235ae3<br>                     ac905e4a1981b3b488d11f78e1c586c85543be59bc2a313deb6914c14c8b4eb6<br>                     838fdf1a145805aaf026d22362fa1c2b5f7e686bf1ec35c59c15201a93c1c549<br>                     de51e79f32fe371c826fc99e2137268de8993bd0c2780123702fe62db3bbac9b<br>                     94d05b6764de631e8d1074df47a896a36fd46dc800966e3c70c09cb2de726f9d<br>         02 03 010001<br>         02 820181 008f37c11fd0b1f942f5c2fec8d0831d8a83c749f86326740728844bd57c74bc7e<br>                     fbb790ccacd98b4928a4a5553cd9b340ffeaebb14a1ce017fbeec935041c742f<br>                     fd1dc8c1d55909a47f8073b46e4939429ab48542c9c6064648fa3a6a7f69e6fb<br>                     1942e376cc3cc12b0881bfaf0fd064888bf24e40e9f6a52f724320064f548f20<br>                     fcd7a9d44631cda702c350ca9a8016cadc161aa0eb3d630d4584dc33a74705ba<br>                     5404ff8112c2df63f3053e2c272c34eca2252a09e6166d6797e99348bcffc4c9<br>                     17a402f30a61b59e870773401d11e4345892ea98c64da681089a449dceaa2f4e<br>                     4a806d08762c5084e3c040b688ddfad316889bff178541eb3a2781d37eed58fd<br>                     24ac55928ae9db7f7419e6be825638df0b87f1a104912f1f0605e718d686e186<br>                     4c7d54169d9df913cbf9ddb75a84a37640765037810f5aa74174c30ccc5aa2b9<br>                     a895cbecbefc59fcd89a070a04fdfb83e0bd4f6e4dcb540749eeb4291b553bd1<br>                     703c8f585d439930b710069a2de833fdb42070d38e7c4be6499d75699d52a781<br>         02 81c1   00d570f346bc001fe691c060f81974d33d6c1a67b5c52b82891cb15a4faf22df33<br>                     42c3b417578cea4859a835b76f22c1ee83c50a6eca1f400b19586c82f84a2f8b<br>                     1ab6489793cf24b4d717dc65d73c7269577e298011c7cc3a21acd2c886d08cba<br>                     8ecbd522f3d552b9c4ff0cba0b495e2a0ae44661f7106721c75b6abd33d3d228<br>                     025da96a4ea8c8b77743330f4cefaac73d037b008afd2422b32be64c9b4bf69a<br>                     94e6a41fb057718a5200bbcf69819efb2b68669684ddee6c3ceb8f3afe76fde1<br>         02 81c1   00ec59964e422745a2f7a850cfbcf666ec4948e5ce5b2cebb1fe927723b92235a9<br>                     4fbda6cbebe158b6efcb2cc3c5e258afca945658e82c966fc742c43c2d8b3f82<br>                     4fa395a01de92c6fd125b929fc2fc493daace672cb2f4ca9405273a12ae74955<br>                     4440e4f34ea4b4bfca973f98fe3116c765c4039391ca533273bd606a5611eebe<br>                     b61a743acc9525da1b12b4aa9db1bb74a6d690af77bf22105756883c35920ddd<br>                     7651079c2b80272dc199dfee2bde1bf3eb9406c8eaf32c19972f1c3064bc113d<br>         02 81c0     264622d9c44ca16bcf27183c651435ed05bd966b59f7fb686ae4c2b5174ac18b<br>                     87a5605def2d2db5db9df643f681dd14d03c3d2ab0c3f9d003b37f81dcd430c2<br>                     58ffe6f48764d5c837e9e773bbacf33740a136ffe83053c6f8d2ecd958937d28<br>                     d702662de65b92820d794ee6edaf325b87a87796899f3f5f27489553683fcba7<br>                     b104eaa44d86a6b77f83655c91074930811866ae2a3e4a848e6c88d7a3e1734f<br>                     34f446ea07cd26670f5d625047331f371b09959bd82793e184eb18bc13757301<br>         02 81c0     35619e931a59e85e8075219b69e0752a94fac3fcb19719bcdff490b81ece5d34<br>                     5a704945f186ba14c7602a42256594065048e49fbc00a611a4fdad78b208ab55<br>                     714b4f3614cb5f5ff9eafd414056419deb5bf5c8a39f913f00ea1e779e4b12c3<br>                     11615ed49d449216675975e1c637ac1f691ab67c14079076eab1311f93450599<br>                     4963fc307398942e08c356ceda431445aa90f7a8c9f0ff6e956b53e5d56ba17a<br>                     0d890ba0f82a3faf13f4ff20ba03b6688722adcd9f5340f89eaee33d02e37f39<br>         02 81c1   009f060963514741b1addc446bc2b499010ad8a8893ae0c43b1acb0da212f80293<br>                     a3a3c7b62f1d082ccf97fff0b8ccd9caaee64a293e5fd53372cc7cc961158e81<br>                     ba6eee86597c80d0ff890e7b7a3f5fce623548e1018b21c762a01d0aaa2aad8c<br>                     239733fe7feb421e3caf25d347a9f45b78621ed808090e73e96acdb1da572d80<br>                     f9e111125a86da90c7e7a81ec9a0124d93d5943a8c77353dda990e85b8550733<br>                     6a73c1a43293a3698f0be81fc672d824510284108e860fc16feabce2b99666c1'
TR-> TD(6,0/1/1)->PAR keyAvailable TD(6,1/1/1)->PAR True
TR-> TD(7,0/1/1)->PAR listAlgorithmIdentifier TD(7,1/1/1)->PAR für alle unterstützten SE: setAlgorithmIdentifier = {rsaDecipherOaep, rsaDecipherPKCS1_V1_5, sign9796_2_DS2, signPSS}
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.6)18.9.6 Anwendung für LCS Use Cases, DF.LCS
REQ(ids=G2_N256.050)<b>G2_N256.050 - (N256.050) K_Personalisierung</b>
PAR Die Anwendung DF.LCS MUSS die in CosT_44f dargestellten Attribute besitzen.
PAR (ids=Tabelle-383,-CosT_44f)Tabelle 383, CosT_44f: Attribute / MF / DF.LCS

TABLE(rows=6,cols=156+309+128)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR Ordner TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR applicationIdentifier TD(2,1/1/1)->PAR 'F000 0000 06' TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR fileIdentifier TD(3,1/1/1)->PAR - TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR lifeCycleStatus TD(4,1/1/1)->PAR "Operational state (active)" TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR children TD(5,1/1/1)->PAR / MF / DF.LCS / CAN_256          / MF / DF.LCS / EF.LCS          / MF / DF.LCS / PIN.LCS          / MF / DF.LCS / PrK.LCS          / MF / DF.LCS / PuK.LCS          / MF / DF.LCS / SK.LCS TD(5,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.6.1)18.9.6.1 / MF/ DF.LCS / CAN_256
PAR Dieses Objekt ist genau dann verfügbar, wenn Option_kontaktlose_Schnittstelle implementiert ist.
REQ(ids=G2_N256.100)<b>G2_N256.100 - (N256.100) K_Personalisierung, Option_kontaktlose_Schnittstelle</b>
PAR Der Schlüssel CAN_256 MUSS die in CosT_0bf dargestellten Attribute besitzen.
PAR (ids=Tabelle-384,-CosT_0bf)Tabelle 384, CosT_0bf: Attribute / MF / DF.LCS / CAN_256

TABLE(rows=6,cols=156+310+129)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR symmetrisches Kartenverbindungsobjekt TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '10' = 16 TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)" TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR can TD(4,1/1/1)->PAR 123456 TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR algorithmIdentifier TD(5,1/1/1)->PAR für alle unterstützten SE:    <br>id-PACE-ECDH-GM-AES-CBC-CMAC-256 TD(5,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.6.2)18.9.6.2 / MF / DF.LCS / EF.LCS
REQ(ids=G2_N256.200)<b>G2_N256.200 - (N256.200) K_Personalisierung</b>
PAR Die Datei EF.LCS MUSS die in CosT_96f dargestellten Attribute besitzen.
PAR (ids=Tabelle-385,-CosT_96f)Tabelle 385, CosT_96f: Attribute / MF / DF.LCS / EF.LCS

TABLE(rows=10,cols=158+308+129)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR transparentes Elementary File TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR fileIdentifier TD(2,1/1/1)->PAR 'EF 01' TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR shortFileIdentifier TD(3,1/1/1)->PAR '01'Oktett = 1 Oktett TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR lifeCycleStatus TD(4,1/1/1)->PAR "Operational state (active)" TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR flagTransactionMode TD(5,1/1/1)->PAR False TD(5,2/1/1)->
TR-> TD(6,0/1/1)->PAR flagChecksum TD(6,1/1/1)->PAR False TD(6,2/1/1)->
TR-> TD(7,0/1/1)->PAR numberOfOctet TD(7,1/1/1)->PAR '0001' = 1 TD(7,2/1/1)->
TR-> TD(8,0/1/1)->PAR positionLogicalEndOfFile TD(8,1/1/1)->PAR 1 TD(8,2/1/1)->
TR-> TD(9,0/1/1)->PAR body TD(9,1/1/1)->PAR '00' TD(9,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.6.3)18.9.6.3 / MF / DF.LCS / PIN.LCS
REQ(ids=G2_N256.300)<b>G2_N256.300 - (N256.300) K_Personalisierung</b>
PAR Das Passwortobjekt PIN.LCS MUSS die in CosT_802 dargestellten Attribute besitzen.
PAR (ids=Tabelle-386,-CosT_802)Tabelle 386, CosT_802: Attribute /  MF / DF.LCS / PIN.LCS

TABLE(rows=14,cols=156+307+131+0)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/2)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR Reguläres Passwortobjekt TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR pwdIdentifier TD(2,1/1/1)->PAR '01' = 1 TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)" TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR secret TD(4,1/1/1)->PAR irrelevant TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR minimumLength TD(5,1/1/1)->PAR   4 TD(5,2/1/1)->
TR-> TD(6,0/1/1)->PAR maximumLength TD(6,1/1/1)->PAR 12 TD(6,2/1/1)->
TR-> TD(7,0/1/1)->PAR startRetryCounter TD(7,1/1/1)->PAR   3 TD(7,2/1/1)->
TR-> TD(8,0/1/1)->PAR retryCounter TD(8,1/1/1)->PAR   3 TD(8,2/1/1)->
TR-> TD(9,0/1/1)->PAR transportStatus TD(9,1/1/1)->PAR Leer-PIN TD(9,2/1/1)->
TR-> TD(10,0/1/1)->PAR flagEnabled TD(10,1/1/1)->PAR True TD(10,2/1/1)->
TR-> TD(11,0/1/1)->PAR startSsecList TD(11,1/1/1)->PAR für alle unterstützten SE: startSsec = unendlich TD(11,2/1/1)->
TR-> TD(12,0/1/1)->PAR PUK TD(12,1/1/1)->PAR 12345678 TD(12,2/1/1)->
TR-> TD(13,0/1/1)->PAR pukUsage TD(13,1/1/1)->PAR 10 TD(13,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.6.4)18.9.6.4 / MF / DF.LCS / PrK.LCS
REQ(ids=G2_N256.400)<b>G2_N256.400 - (N256.400) K_Personalisierung</b>
PAR Der Schlüssel PrK.LCS MUSS die in CosT_cac dargestellten Attribute besitzen.
PAR (ids=Tabelle-387,-CosT_cac)Tabelle 387, CosT_cac: Attribute / MF / DF.LCS / PrK.LCS

TABLE(rows=7,cols=153+446)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR privates ELC Schlüsselobjekt, ELC256
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '11' = 17
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)"
TR-> TD(4,0/1/1)->PAR privateKey TD(4,1/1/1)->PAR domainParameter gemäß brainpoolP256r1, privateElcKey.d = '7625964fa8ca41673ac8c88a69fecfe18df90496c61f38d29310ccc4fc1484a1'
TR-> TD(5,0/1/1)->PAR keyAvailable TD(5,1/1/1)->PAR True
TR-> TD(6,0/1/1)->PAR listAlgorithmIdentifier TD(6,1/1/1)->PAR für alle unterstützten SE<br>setAlgorithmIdentifier = {elcRoleAuthentication}
PAR <b>[<=]</b>

PAR Hinweis CosH_fb8: Der zugehörige öffentliche Punkt gemäß P2OS(…) lautet:     ´044814679aa37c8c05f6c673a2b6cb621574dfb0b79835d3399e1bf1336eebdf7f<br>   67dc4670fae6fa60d456b40a0539472d5f5dcc2bf4da6872a9a3a13717dc2dfa´.
PAR -HEADING(ids=18.9.6.5)18.9.6.5 / MF / DF.LCS / PuK.LCS
REQ(ids=G2_N256.500)<b>G2_N256.500 - (N256.500) K_Personalisierung</b>
PAR Der Schlüssel PuK.LCS MUSS die in CosT_942 dargestellten Attribute besitzen.
PAR (ids=Tabelle-388,-CosT_942)Tabelle 388, CosT_942: Attribute / MF / DF.LCS / PuK.LCS

TABLE(rows=8,cols=101+495)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR Öffentliches Signaturprüfobjekt, ELC256
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '0102030405060708'
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)"
TR-> TD(4,0/1/1)->PAR publicKey TD(4,1/1/1)->PAR domainParameter gemäß brainpoolP256r1, P = ´049bbfb368605b45a6701d4e5fecbd52fbd43ee19340d802fa8792cac0a352f0e6<br>   5fd6dd301fa7866a322d74c1cd0b634eac8a8e6fc600e1cd3361063107d54b5b´
TR-> TD(5,0/1/1)->PAR oid TD(5,1/1/1)->PAR ecdsa-with-SHA256
TR-> TD(6,0/1/1)->PAR CHAT TD(6,1/1/1)->PAR OIDflags     = oid_cvc_fl_ti<br>flagList     = 'BF FFFF FFFF FFFF'
TR-> TD(7,0/1/1)->PAR expirationDate TD(7,1/1/1)->PAR 2015.03.18: YYMMDD = '0105 0003 0108'
PAR <b>[<=]</b>

PAR Hinweis CosH_e32: Der zugehörige private Schlüssel besitzt das Attribut privateElcKey.d =     '715babdef8bc5828ce2ba351e4531a1d7ae8f64c1694ff9fb07e433231f678c6'.
PAR -HEADING(ids=18.9.6.6)18.9.6.6 / MF / DF.LCS / SK.LCS
REQ(ids=G2_N256.600)<b>G2_N256.600 - (N256.600) K_Personalisierung</b>
PAR Der Schlüssel SK.LCS MUSS die in CosT_82f dargestellten Attribute besitzen.
PAR (ids=Tabelle-389,-CosT_82f)Tabelle 389, CosT_82f: Attribute / MF / DF.LCS / SK.LCS

TABLE(rows=8,cols=154+314+127)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR symmetrisches Authentisierungsobjekt, AES128 TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR keyIdentifier TD(2,1/1/1)->PAR '12' = 18 TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR lifeCycleStatus TD(3,1/1/1)->PAR "Operational state (active)" TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR encKey TD(4,1/1/1)->PAR '0102030405060708090A0B0C0D0E0F10' TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR macKey TD(5,1/1/1)->PAR '100F0E0D0C0B0A090807060504030201' TD(5,2/1/1)->
TR-> TD(6,0/1/1)->PAR numberScenario TD(6,1/1/1)->PAR 0 TD(6,2/1/1)->
TR-> TD(7,0/1/1)->PAR algorithmIdentifier TD(7,1/1/1)->PAR aesSessionkey4SM TD(7,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.7)18.9.7 Anwendung für SELECT EF Use Cases, DF.SelectEF
REQ(ids=G2_N257.050)<b>G2_N257.050 - (N257.050) K_Personalisierung</b>
PAR Die Anwendung DF.SelectEF MUSS die in CosT_d4d dargestellten Attribute besitzen.
PAR (ids=Tabelle-390,-CosT_d4d)Tabelle 390, CosT_d4d: Attribute / MF / DF.SelectEF

TABLE(rows=6,cols=156+311+129)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR Ordner TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR applicationIdentifier TD(2,1/1/1)->PAR 'F000 0000 07' TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR fileIdentifier TD(3,1/1/1)->PAR - TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR lifeCycleStatus TD(4,1/1/1)->PAR "Operational state (active)" TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR children TD(5,1/1/1)->PAR / MF / DF.SelectEF / EF.00          / MF / DF.SelectEF / EF.…          / MF / DF.SelectEF / EF.99 TD(5,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.7.1)18.9.7.1 / MF / DF.SelectEF / EF.xx
REQ(ids=G2_N257.110)<b>G2_N257.110 - (N257.110) K_Personalisierung</b>
PAR Die Dateien EF.xx MÜSSEN die in CosT_9d6 dargestellten Attribute besitzen.
PAR (ids=Tabelle-391,-CosT_9d6)Tabelle 391, CosT_9d6: Attribute / MF / DF.SelectEF / EF.xx

TABLE(rows=10,cols=176+290+130)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR transparentes Elementary File TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR fileIdentifier TD(2,1/1/1)->PAR 'EF 00' + i, mit i = 0, 1, 2, …, 99 TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR shortFileIdentifier TD(3,1/1/1)->PAR - TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR lifeCycleStatus TD(4,1/1/1)->PAR "Operational state (active)" TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR flagTransactionMode TD(5,1/1/1)->PAR False TD(5,2/1/1)->
TR-> TD(6,0/1/1)->PAR flagChecksum TD(6,1/1/1)->PAR False TD(6,2/1/1)->
TR-> TD(7,0/1/1)->PAR numberOfOctet TD(7,1/1/1)->PAR '0001' = 1 TD(7,2/1/1)->
TR-> TD(8,0/1/1)->PAR positionLogicalEndOfFile TD(8,1/1/1)->PAR 1 TD(8,2/1/1)->
TR-> TD(9,0/1/1)->PAR body TD(9,1/1/1)->PAR '00' TD(9,2/1/1)->
PAR <b>[<=]</b>

PAR Hinweis CosH_bf6: CosT_9d6 spezifiziert 100 Dateien, welche sich lediglich im Attribut fileIdentifier unterscheiden. Gemäß der Tabelle gilt für die Menge der fileIdentifier: {'EF00', 'EF01', …, EF09', 'EF0A', …, EF0F', 'EF10', …, 'EF63'}.
PAR -HEADING(ids=18.9.8)18.9.8 Anwendung für rekordorientierte Dateioperationen, DF.strukturiert
REQ(ids=G2_N258.050)<b>G2_N258.050 - (N258.050) K_Personalisierung</b>
PAR Die Anwendung DF.strukturiert MUSS die in CosT_79d dargestellten Attribute besitzen.
PAR (ids=Tabelle-392,-CosT_79d)Tabelle 392, CosT_79d: Attribute / MF / DF.strukturiert

TABLE(rows=6,cols=173+294+128)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR Ordner TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR applicationIdentifier TD(2,1/1/1)->PAR 'F000 0000 08' TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR fileIdentifier TD(3,1/1/1)->PAR - TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR lifeCycleStatus TD(4,1/1/1)->PAR "Operational state (active)" TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR children TD(5,1/1/1)->PAR / MF / DF.strukturiert / EF.strukturiert TD(5,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.8.1)18.9.8.1 / MF / DF.strukturiert / EF.strukturiert
REQ(ids=G2_N258.110)<b>G2_N258.110 - (N258.110) K_Personalisierung</b>
PAR Die Datei EF.strukturiert MUSS die in CosT_f1d dargestellten Attribute besitzen.
PAR (ids=Tabelle-393,-CosT_f1d)Tabelle 393, CosT_f1d: Attribute / MF / DF.strukturiert / EF.strukturiert

TABLE(rows=12,cols=176+290+130)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR linear variables Elementary File TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR fileIdentifier TD(2,1/1/1)->PAR 'EF 01' TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR shortFileIdentifier TD(3,1/1/1)->PAR - TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR lifeCycleStatus TD(4,1/1/1)->PAR "Operational state (active)" TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR flagTransactionMode TD(5,1/1/1)->PAR True TD(5,2/1/1)->
TR-> TD(6,0/1/1)->PAR flagChecksum TD(6,1/1/1)->PAR True TD(6,2/1/1)->
TR-> TD(7,0/1/1)->PAR maximumNumberOfRec. TD(7,1/1/1)->PAR 254 TD(7,2/1/1)->
TR-> TD(8,0/1/1)->PAR maximumRecordLength TD(8,1/1/1)->PAR 'FF'= 255 TD(8,2/1/1)->
TR-> TD(9,0/1/1)->PAR flagRecordLifeCycleStatus TD(9,1/1/1)->PAR True TD(9,2/1/1)->
TR-> TD(10,0/1/1)->PAR numberOfOctet TD(10,1/1/1)->PAR 'FD02' = 64.770 TD(10,2/1/1)->
TR-> TD(11,0/1/1)->PAR recordList TD(11,1/1/1)->PAR leere Liste TD(11,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.9)18.9.9 Anwendung für transparente Dateioperationen, DF.transparent
REQ(ids=G2_N259.050)<b>G2_N259.050 - (N259.050) K_Personalisierung</b>
PAR Die Anwendung DF.transparent MUSS die in CosT_64f dargestellten Attribute besitzen.
PAR (ids=Tabelle-394,-CosT_64f)Tabelle 394, CosT_64f: Attribute / MF / DF.transparent

TABLE(rows=6,cols=155+313+128)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR Ordner TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR applicationIdentifier TD(2,1/1/1)->PAR 'F000 0000 09' TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR fileIdentifier TD(3,1/1/1)->PAR - TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR lifeCycleStatus TD(4,1/1/1)->PAR "Operational state (active)" TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR children TD(5,1/1/1)->PAR / MF / DF.transparent / EF.transparent TD(5,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=18.9.9.1)18.9.9.1 / MF / DF.transparent / EF.transparent
REQ(ids=G2_N259.110)<b>G2_N259.110 - (N259.110) K_Personalisierung</b>
PAR Die Datei EF.transparent MUSS die in CosT_400 dargestellten Attribute besitzen.
PAR (ids=Tabelle-395,-CosT_400)Tabelle 395, CosT_400: Attribute / MF / DF.transparent / EF.transparent

TABLE(rows=10,cols=158+308+129)->
TR-> TH(0,0/1/1)->PAR Attribute TH(0,1/1/1)->PAR Wert TH(0,2/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR objectType TD(1,1/1/1)->PAR transparentes Elementary File TD(1,2/1/1)->
TR-> TD(2,0/1/1)->PAR fileIdentifier TD(2,1/1/1)->PAR 'EF 01' TD(2,2/1/1)->
TR-> TD(3,0/1/1)->PAR shortFileIdentifier TD(3,1/1/1)->PAR - TD(3,2/1/1)->
TR-> TD(4,0/1/1)->PAR lifeCycleStatus TD(4,1/1/1)->PAR "Operational state (active)" TD(4,2/1/1)->
TR-> TD(5,0/1/1)->PAR flagTransactionMode TD(5,1/1/1)->PAR True TD(5,2/1/1)->
TR-> TD(6,0/1/1)->PAR flagChecksum TD(6,1/1/1)->PAR True TD(6,2/1/1)->
TR-> TD(7,0/1/1)->PAR numberOfOctet TD(7,1/1/1)->PAR '8000' = 32.768 TD(7,2/1/1)->
TR-> TD(8,0/1/1)->PAR positionLogicalEndOfFile TD(8,1/1/1)->PAR 0 TD(8,2/1/1)->
TR-> TD(9,0/1/1)->PAR body TD(9,1/1/1)->PAR irrelevant TD(9,2/1/1)->
PAR <b>[<=]</b>

PAR -HEADING(ids=19)19 CosK_483 Domainparameter elliptischer Kurven (informativ)
PAR Dieses Kapitel enthält die Domainparameter der elliptischen Kurven, die gemäß dieser Dokumentenversion vom COS zu unterstützen sind. Die Object Identifier der hier dargestellten Kurven sind CosT_a91 entnommen.
PAR -HEADING(ids=19.1)19.1 ansix9p256r1
PAR ansix9p256r1: objectIdentifier = {1.2.840.10045.3.1.7} = '2A8648CE3D030107'
PAR Die hier dargestellten Domainparameter wurden [ANSI X9.62#L.6.4.3] entnommen und sind identisch zu [FIPS 186–4#D.1.2.3 P-256]:
PAR (ids=Tabelle-396,-CosT_f68,-Kurvenparameter-ansix9p256r1)Tabelle 396, CosT_f68, Kurvenparameter ansix9p256r1

TABLE(rows=6,cols=39+707)->
TR-> TD(0,0/1/1)->PAR p TD(0,1/1/1)->PAR 'FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFF'
TR-> TD(1,0/1/1)->PAR a TD(1,1/1/1)->PAR 'FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFC'
TR-> TD(2,0/1/1)->PAR b TD(2,1/1/1)->PAR '5AC635D8 AA3A93E7 B3EBBD55 769886BC 651D06B0 CC53B0F6 3BCE3C3E 27D2604B'
TR-> TD(3,0/1/1)->PAR G TD(3,1/1/1)->PAR in komprimierter Form:<br>'03 6B17D1F2 E12C4247 F8BCE6E5 63A440F2 77037D81 2DEB33A0 F4A13945 D898C296'<br>in Koordinatenform:<br>x<sub>g</sub>='6B17D1F2 E12C4247 F8BCE6E5 63A440F2 77037D81 2DEB33A0 F4A13945 D898C296'<br>y<sub>g</sub>='4FE342E2 FE1A7F9B 8EE7EB4A 7C0F9E16 2BCE3357 6B315ECE CBB64068 37BF51F5'
TR-> TD(4,0/1/1)->PAR n TD(4,1/1/1)->PAR 'FFFFFFFF 00000000 FFFFFFFF FFFFFFFF BCE6FAAD A7179E84 F3B9CAC2 FC632551'
TR-> TD(5,0/1/1)->PAR h TD(5,1/1/1)->PAR 1
PAR Hinweis CosH_1a4: Gegenüber der Darstellung in [FIPS 186–4#D.1.2.3] ist zu beachten das gilt: -3  ≡ a mod p.
PAR -HEADING(ids=19.2)19.2 ansix9p384r1
PAR ansix9p384r1: objectIdentifier = {1.3.132.0.34} = '2B81040022'
PAR Die hier dargestellten Domainparameter wurden [ANSI X9.62#L.6.5.2] entnommen und sind identisch zu [FIPS 186–4#D.1.2.4 P-384]::
PAR (ids=Tabelle-397,-CosT_88a)Tabelle 397, CosT_88a: Kurvenparameter ansix9p384r1

TABLE(rows=6,cols=39+707)->
TR-> TD(0,0/1/1)->PAR p TD(0,1/1/1)->PAR 'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF<br> FFFFFFFF FFFFFFFE FFFFFFFF 00000000 00000000 FFFFFFFF'
TR-> TD(1,0/1/1)->PAR a TD(1,1/1/1)->PAR 'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF<br> FFFFFFFF FFFFFFFE FFFFFFFF 00000000 00000000 FFFFFFFC'
TR-> TD(2,0/1/1)->PAR b TD(2,1/1/1)->PAR 'B3312FA7 E23EE7E4 988E056B E3F82D19 181D9C6E FE814112<br> 0314088F 5013875A C656398D 8A2ED19D 2A85C8ED D3EC2AEF'
TR-> TD(3,0/1/1)->PAR G TD(3,1/1/1)->PAR in komprimierter Form:<br>'03 AA87CA22 BE8B0537 8EB1C71E F320AD74 6E1D3B62 8BA79B98<br>    59F741E0 82542A38 5502F25D BF55296C 3A545E38 72760AB7'<br>in Koordinatenform:<br>x<sub>g</sub>='AA87CA22 BE8B0537 8EB1C71E F320AD74 6E1D3B62 8BA79B98<br>        59F741E0 82542A38 5502F25D BF55296C 3A545E38 72760AB7'<br>y<sub>g</sub>='3617DE4A 96262C6F 5D9E98BF 9292DC29 F8F41DBD 289A147C<br>        E9DA3113 B5F0B8C0 0A60B1CE 1D7E819D 7A431D7C 90EA0E5F'
TR-> TD(4,0/1/1)->PAR n TD(4,1/1/1)->PAR 'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF<br> C7634D81 F4372DDF 581A0DB2 48B0A77A ECEC196A CCC52973'
TR-> TD(5,0/1/1)->PAR h TD(5,1/1/1)->PAR 1
PAR Hinweis CosH_9a8: Gegenüber der Darstellung in [FIPS 186–4#D.1.2.3] ist zu beachten das gilt: -3  ≡ a mod p.
PAR -HEADING(ids=19.3)19.3 brainpoolP256r1
PAR brainpoolP256r1: objectIdentifier = {1.3.36.3.3.2.8.1.1.7} = '2B2403030208010107'
PAR Die hier dargestellten Domainparameter wurden [RFC5639#3.4] entnommen:
PAR (ids=Tabelle-398,-CosT_de0)Tabelle 398, CosT_de0: Kurvenparameter brainpoolP256r1

TABLE(rows=6,cols=30+564)->
TR-> TD(0,0/1/1)->PAR p TD(0,1/1/1)->PAR 'A9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5377'
TR-> TD(1,0/1/1)->PAR a TD(1,1/1/1)->PAR '7D5A0975FC2C3057EEF67530417AFFE7FB8055C126DC5C6CE94A4B44F330B5D9'
TR-> TD(2,0/1/1)->PAR b TD(2,1/1/1)->PAR '26DC5C6CE94A4B44F330B5D9BBD77CBF958416295CF7E1CE6BCCDC18FF8C07B6'
TR-> TD(3,0/1/1)->PAR G TD(3,1/1/1)->PAR in Koordinatenform:<br>x<sub>g</sub>='8BD2AEB9CB7E57CB2C4B482FFC81B7AFB9DE27E1E3BD23C23A4453BD9ACE3262'<br>y<sub>g</sub>='547EF835C3DAC4FD97F8461A14611DC9C27745132DED8E545C1D54C72F046997'
TR-> TD(4,0/1/1)->PAR n TD(4,1/1/1)->PAR 'A9FB57DBA1EEA9BC3E660A909D838D718C397AA3B561A6F7901E0E82974856A7'
TR-> TD(5,0/1/1)->PAR h TD(5,1/1/1)->PAR 1
PAR -HEADING(ids=19.4)19.4 brainpoolP384r1
PAR brainpoolP384r1: objectIdentifier = {1.3.36.3.3.2.8.1.1.11} = '2B240303020801010B'
PAR Die hier dargestellten Domainparameter wurden [RFC5639#3.6] entnommen:
PAR (ids=Tabelle-399,-CosT_62f)Tabelle 399, CosT_62f: Kurvenparameter brainpoolP384r1

TABLE(rows=6,cols=30+564)->
TR-> TD(0,0/1/1)->PAR p TD(0,1/1/1)->PAR '8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B4<br> 12B1DA197FB71123ACD3A729901D1A71874700133107EC53'
TR-> TD(1,0/1/1)->PAR a TD(1,1/1/1)->PAR '7BC382C63D8C150C3C72080ACE05AFA0C2BEA28E4FB22787<br> 139165EFBA91F90F8AA5814A503AD4EB04A8C7DD22CE2826'
TR-> TD(2,0/1/1)->PAR b TD(2,1/1/1)->PAR '04A8C7DD22CE28268B39B55416F0447C2FB77DE107DCD2A6<br> 2E880EA53EEB62D57CB4390295DBC9943AB78696FA504C11'
TR-> TD(3,0/1/1)->PAR G TD(3,1/1/1)->PAR in Koordinatenform:<br>x<sub>g</sub>='1D1C64F068CF45FFA2A63A81B7C13F6B8847A3E77EF14FE3<br>       DB7FCAFE0CBD10E8E826E03436D646AAEF87B2E247D4AF1E'<br>y<sub>g</sub>='8ABE1D7520F9C2A45CB1EB8E95CFD55262B70B29FEEC5864<br>        E19C054FF99129280E4646217791811142820341263C5315'
TR-> TD(4,0/1/1)->PAR n TD(4,1/1/1)->PAR '8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B3<br> 1F166E6CAC0425A7CF3AB6AF6B7FC3103B883202E9046565'
TR-> TD(5,0/1/1)->PAR h TD(5,1/1/1)->PAR 1
PAR -HEADING(ids=19.5)19.5 brainpoolP512r1
PAR brainpoolP512r1: objectIdentifier = {1.3.36.3.3.2.8.1.1.13} = '2B240303020801010D'
PAR Die hier dargestellten Domainparameter wurden [RFC5639#3.7] entnommen:
PAR (ids=Tabelle-400,-CosT_198)Tabelle 400, CosT_198: Kurvenparameter brainpoolP512r1

TABLE(rows=6,cols=30+564)->
TR-> TD(0,0/1/1)->PAR p TD(0,1/1/1)->PAR 'AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA70330871<br> 7D4D9B009BC66842AECDA12AE6A380E62881FF2F2D82C68528AA6056583A48F3'
TR-> TD(1,0/1/1)->PAR a TD(1,1/1/1)->PAR '7830A3318B603B89E2327145AC234CC594CBDD8D3DF91610A83441CAEA9863BC<br> 2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D77FC94CA'
TR-> TD(2,0/1/1)->PAR b TD(2,1/1/1)->PAR '3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A7<br> 2BF2C7B9E7C1AC4D77FC94CADC083E67984050B75EBAE5DD2809BD638016F723'
TR-> TD(3,0/1/1)->PAR G TD(3,1/1/1)->PAR in Koordinatenform:<br>x<sub>g</sub>='81AEE4BDD82ED9645A21322E9C4C6A9385ED9F70B5D916C1B43B62EEF4D0098E<br>       FF3B1F78E2D0D48D50D1687B93B97D5F7C6D5047406A5E688B352209BCB9F822'<br>y<sub>g</sub>='7DDE385D566332ECC0EABFA9CF7822FDF209F70024A57B1AA000C55B881F8111<br>        B2DCDE494A5F485E5BCA4BD88A2763AED1CA2B2FA8F0540678CD1E0F3AD80892'
TR-> TD(4,0/1/1)->PAR n TD(4,1/1/1)->PAR 'AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA70330870<br> 553E5C414CA92619418661197FAC10471DB1D381085DDADDB58796829CA90069'
TR-> TD(5,0/1/1)->PAR h TD(5,1/1/1)->PAR 1
PAR -HEADING(ids=20)20 CosK_b91 Erläuterungen zu Wertebereichen (informativ)
PAR Hinweis CosH_32f: Der Hauptteil des Dokumentes enthält im Wesentlichen normative Festlegungen, WIE etwas zu funktionieren hat. Dieser Abschnitt beschreibt WARUM gewisse Festlegungen so und nicht anders getroffen wurden. Derartige Begründungen und Designentscheidungen belasten damit einerseits nicht den Hauptteil und andererseits werden Entscheidungen und Begründungen nachvollziehbar.

ORDERED-LIST->
LITEM->PAR Wertebereich pwdIdentifier, siehe (N015.000): Gemäß [ISO/IEC 7816-4] wird das Attribut pwdIdentifier an der Schnittstelle zur Smartcard in den Bits b5 bis b1 des Parameters P2 codiert. Daraus ergibt sich ein Wertebereich von 1 bis 31 bzw. 0 bis 31, wenn der Wert "no information given" explizit dem Wert pwdIdentifier = 0 zugeordnet wird. In den Generationen 0 und 1 wurde lediglich der Bereich [0, 3] genutzt, um den Overhead bei der Verwaltung von Sicherheitszuständen klein zu halten. Durch Einführung von "Multireferenz-PIN" erscheint es sinnvoll, den Wertebereich, wie in (N015.000) dargestellt, zu vergrößern.LITEM->PAR Wertebereich startSsec, siehe (N015.800):
ORDERED-LIST->
LITEM->PAR Als Infimum wurde 1 gewählt, da der Wert 0 für startSsec sinnlos ist.LITEM->PAR Als Supremum wurde 250 gewählt, damit für 1-Byte-Codierungen noch genügend Codierungsmöglichkeiten für "unendlich", Escape, RFU und ähnliches vorhanden sind.LITEM->PAR Die Codierung für ShortPassword und LongPassword wurde absichtlich gleich gewählt, weil in [ISO/IEC 7816-4] nur ein begrenzter Vorrat an passenden Trailern vorhanden ist. Wenn es für notwendig erachtet wird auch an der Schnittstelle zwischen den Fällen ShortPassword und LongPassword zu unterscheiden, dann ist es sinnvoll den Trailer für LongPassword zu ändern.
PAR -HEADING(ids=21)21 CosK_229 Verzeichnisse (informativ)
PAR -HEADING(ids=21.1)21.1 Abkürzungen

TABLE(rows=22,cols=79+668)->
TR-> TH(0,0/1/1)->PAR Kürzel TH(0,1/1/1)->PAR Erläuterung
TR-> TD(1,0/1/1)->PAR AID TD(1,1/1/1)->PAR Application Identifier, siehe [ISO/IEC 7816-5], Identifikator für eine Smartcard Applikation
TR-> TD(2,0/1/1)->PAR APDU TD(2,1/1/1)->PAR Application Protocol Data Unit, siehe [ISO/IEC 7816-3], kleinste Nachrichteneinheit, die auf der Applikationsschicht mit der Smartcard ausgetauscht wird
TR-> TD(3,0/1/1)->PAR BGT TD(3,1/1/1)->PAR "block guard time", siehe [ISO/IEC 7816-3#11.2]
TR-> TD(4,0/1/1)->PAR CHAT TD(4,1/1/1)->PAR Certificate Holder Authorisation Template, Datenobjekt gemäß [gemSpec_PKI#6.7.2.5], Bestandteil eines CV-Zertifikates
TR-> TD(5,0/1/1)->PAR COS TD(5,1/1/1)->PAR Card Operating System, Betriebssystem einer Smartcard
TR-> TD(6,0/1/1)->PAR DF TD(6,1/1/1)->PAR Dedicated File, siehe [ISO/IEC 7816-4], Bezeichnung für einen Ordner innerhalb des Objektsystems einer Smartcard
TR-> TD(7,0/1/1)->PAR EF TD(7,1/1/1)->PAR Elementary File, siehe [ISO/IEC 7816-4], Bezeichnung für eine Datei innerhalb des Objektsystems einer Smartcard
TR-> TD(8,0/1/1)->PAR ELC TD(8,1/1/1)->PAR Elliptic Curve Cryptography, Kryptographie mittels elliptischer Kurven
TR-> TD(9,0/1/1)->PAR G1 TD(9,1/1/1)->PAR Abkürzung für Generation 1, bezeichnet eine frühere Version des Dokumentes, in der Regel ergänzt um den Zusatz "normativ"
TR-> TD(10,0/1/1)->PAR G2 TD(10,1/1/1)->PAR Abkürzung für Generation 2, bezeichnet diese Version dieses Dokumentes, in der Regel ergänzt um den Zusatz "normativ"
TR-> TD(11,0/1/1)->PAR IC TD(11,1/1/1)->PAR Integrated Chip, Halbleiter
TR-> TD(12,0/1/1)->PAR ICC TD(12,1/1/1)->PAR Integrated Chip Card, Smartcard
TR-> TD(13,0/1/1)->PAR IFD TD(13,1/1/1)->PAR Interface Device
TR-> TD(14,0/1/1)->PAR IFSC TD(14,1/1/1)->PAR maximum Information Field Size for the Card, siehe [ISO/IEC 7816-3#11.4.2]
TR-> TD(15,0/1/1)->PAR IFSD TD(15,1/1/1)->PAR maximum Information Field Size for the Interface Device, [ISO/IEC 7816-3#11.4.2]
TR-> TD(16,0/1/1)->PAR MAC TD(16,1/1/1)->PAR Message Authentication Code
TR-> TD(17,0/1/1)->PAR MSBit TD(17,1/1/1)->PAR Most Significant Bit
TR-> TD(18,0/1/1)->PAR MSByte TD(18,1/1/1)->PAR Most Significant Byte
TR-> TD(19,0/1/1)->PAR LSBit TD(19,1/1/1)->PAR Least Significant Bit
TR-> TD(20,0/1/1)->PAR LSByte TD(20,1/1/1)->PAR Least Significant Byte
TR-> TD(21,0/1/1)->PAR TPDU TD(21,1/1/1)->PAR Transport Protocol Data Unit, siehe [ISO/IEC 7816-3], kleinste Nachrichteneinheit, die auf dem Data Link Layer mit der Smartcard ausgetauscht wird
PAR -HEADING(ids=21.2)21.2 Glossar

TABLE(rows=5,cols=72+675)->
TR-> TH(0,0/1/1)->PAR Begriff TH(0,1/1/1)->PAR Erläuterung
TR-> TD(1,0/1/1)->PAR ephemer TD(1,1/1/1)->PAR Nur für kurze Zeit bestehend, flüchtig, ohne bleibende Bedeutung<br>(siehe http://de.wiktionary.org/wiki/ephemerhttp://de.wiktionary.org/wiki/ephemer)
TR-> TD(2,0/1/1)->PAR flagList TD(2,1/1/1)->PAR Bestandteil eines CHAT, der anzeigt, welche Zugriffsrechte durch eine erfolgreiche Authentisierung erworben werden
TR-> TD(3,0/1/1)->PAR Nibble TD(3,1/1/1)->PAR Ein Nibble oder Nybble ist eine Datenmenge, die 4 Bits umfasst, es wird auch Halbbyte, Tetrade oder Quadrupel genannt (siehe http://de.wikipedia.org/wiki/Nibblehttp://de.wikipedia.org/wiki/Nibble).
TR-> TD(4,0/1/1)->PAR schwacher DES-Schlüssel TD(4,1/1/1)->PAR Ein schwacher oder halbschwacher DES-Schlüssel senkt die Stärke einer Verschlüsselung. Zu weiteren Informationen und einer Liste schwacher und halbschwacher Schlüssel siehe:<br> Schneier, B., "Applied Cryptography, Protocols, Algorithms, and Source Code in C", 2<sup>nd</sup> edition.        RFC 2409 Appendix A        http://en.wikipedia.org/wiki/Weak_keyhttp://en.wikipedia.org/wiki/Weak_key
PAR Das Glossar wird als eigenständiges Dokument zur Verfügung gestellt.
PAR -HEADING(ids=21.3)21.3 Abbildungsverzeichnis

<PLACEHOLDER>

PAR -HEADING(ids=21.4)21.4 Tabellenverzeichnis

<PLACEHOLDER>

PAR -HEADING(ids=21.5)21.5 Referenzierte Dokumente
PAR -HEADING(ids=21.5.1)21.5.1 Dokumente der gematik
PAR Die nachfolgende Tabelle enthält die Bezeichnung der in dem vorliegenden Dokument referenzierten Dokumente der gematik zur Telematikinfrastruktur. Version und Stand der referenzierten Dokumente sind in der nachfolgenden Tabelle nicht aufgeführt. Deren zu diesem Dokument passende jeweils gültige Versionen sind in den von der gematik veröffentlichten Produkttypsteckbriefen enthalten, in denen die vorliegende Version aufgeführt wird.

TABLE(rows=8,cols=170+577)->
TR-> TH(0,0/1/1)->PAR [Quelle] TH(0,1/1/1)->PAR Herausgeber (Erscheinungsdatum): Titel
TR-> TD(1,0/1/1)->PAR [gemSpec_eGK_P1] TD(1,1/1/1)->PAR gematik: Teil 1 – Spezifikation der elektrischen Schnittstelle<br>(Vorgängerversion dieses Dokumentes für Karten der Generation 1)
TR-> TD(2,0/1/1)->PAR [gemSpec_Krypt] TD(2,1/1/1)->PAR gematik: Übergreifende Spezifikation - Verwendung kryptographischer Algorithmen in der Telematikinfrastruktur
TR-> TD(3,0/1/1)->PAR [gemSpec_eGK_ObjSys] TD(3,1/1/1)->PAR gematik: Spezifikation der elektronischen Gesundheitskarte  eGK-Objektsystem
TR-> TD(4,0/1/1)->PAR [gemSpec_HBA_ObjSys] TD(4,1/1/1)->PAR gematik: Spezifikation des elektronischen Heilberufsausweises  HBA-Objektsystem
TR-> TD(5,0/1/1)->PAR [gemSpec_OID] TD(5,1/1/1)->PAR gematik: Festlegung von OIDs
TR-> TD(6,0/1/1)->PAR [gemSpec_PKI] TD(6,1/1/1)->PAR gematik: Übergreifende Spezifikation, Spezifikation PKI
TR-> TD(7,0/1/1)->PAR [gemSpec_SMC-B_ObjSys] TD(7,1/1/1)->PAR gematik: Spezifikation der Secure Module Card SMC-B  Objektsystem
PAR -HEADING(ids=21.5.2)21.5.2 Weitere Dokumente

TABLE(rows=34,cols=113+634)->
TR-> TH(0,0/1/1)->PAR [Quelle] TH(0,1/1/1)->PAR Herausgeber (Erscheinungsdatum): Titel
TR-> TD(1,0/1/1)->PAR [ANSI X3.92] TD(1,1/1/1)->PAR American National Standard X3.92 – 1981, Data Encryption Algorithm
TR-> TD(2,0/1/1)->PAR [ANSI X9.62] TD(2,1/1/1)->PAR Public Key Cryptography for the Financial Services Industry, The Elliptic Curve Digital Signature Algorithm (ECDSA), 2005
TR-> TD(3,0/1/1)->PAR [ANSI X9.63] TD(3,1/1/1)->PAR Public Key Cryptography for the Financial Services Industry, Key Agreement and Key Transport Using Elliptic Curve Cryptography, 2001
TR-> TD(4,0/1/1)->PAR [BinPrefix] TD(4,1/1/1)->PAR Prefix for binary multiples<br>IEC INTERNATIONAL STANDARD 60027-2, Third edition, 2005-08,<br>Letter symbols to be used in electrical technology –<br>Part 2: Telecommunications and electronics, clause 3.8.3<br>http://physics.nist.gov/cuu/Units/binary.htmlhttp://physics.nist.gov/cuu/Units/binary.html<br>http://de.wikipedia.org/wiki/Bin%C3%A4rpr%C3%A4fixhttp://de.wikipedia.org/wiki/Bin%C3%A4rpr%C3%A4fix<br>http://en.wikipedia.org/wiki/Binary_prefixhttp://en.wikipedia.org/wiki/Binary_prefix
TR-> TD(5,0/1/1)->PAR [BKryA] TD(5,1/1/1)->PAR Bekanntmachung zur elektronischen Signatur nach dem Signaturgesetz und der Signaturverordnung (Übersicht über geeignete Algorithmen), Bundesnetzagentur für Elektrizität, Gas, Telekommunikation, Post und Eisenbahnen, veröffentlicht am 18. Januar 2012 im Bundesanzeiger, Nr. 10, S. 243 (auch online verfügbar: http://www.bundesnetzagentur.dehttp://www.bundesnetzagentur.de)
TR-> TD(6,0/1/1)->PAR [CMAC] TD(6,1/1/1)->PAR NIST Special Publication 800-38B,<br>Recommendation for Block, Cipher Modes of Operation: The CMAC Mode for Authentication, Morris Dworkin, May 2005,<br>http://csrc.nist.gov/publications/nistpubs/800-38B/SP_800-38B.pdfhttp://csrc.nist.gov/publications/nistpubs/800-38B/SP_800-38B.pdf
TR-> TD(7,0/1/1)->PAR [EMV<sup>®</sup>_Book-1] TD(7,1/1/1)->PAR EMV Book 1, Application Independent ICC to Terminal Interface Requirements, version 4.3, November 2011
TR-> TD(8,0/1/1)->PAR [ETSI TS 102 222] TD(8,1/1/1)->PAR ETSI TS 102 222 V7.0.0 (2006-08)<br>Integrated Circuit Cards (ICC); Administrative commands for telecommunications applications (Release 7)
TR-> TD(9,0/1/1)->PAR [FIPS 180-4] TD(9,1/1/1)->PAR Federal Information Processing Standards Publication 180-4<br>Secure Hash Standard (SHS), March 2012<br>http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdfhttp://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
TR-> TD(10,0/1/1)->PAR [FIPS 186–4] TD(10,1/1/1)->PAR FIPS PUB 186-4, FEDERAL INFORMATION PROCESSING STANDARDS PUBLICATION, July 2013 DIGITAL SIGNATURE STANDARD (DSS)<br>http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdfhttp://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
TR-> TD(11,0/1/1)->PAR [FIPS 197] TD(11,1/1/1)->PAR Federal Information Processing Standards Publication 197,<br>(FIPS–197), November 26, 2001, Announcing the<br>ADVANCED ENCRYPTION STANDARD (AES)<br>http://csrc.nist.gov/publications/fips/fips197/fips-197.pdfhttp://csrc.nist.gov/publications/fips/fips197/fips-197.pdf
TR-> TD(12,0/1/1)->PAR [HBA_P1] TD(12,1/1/1)->PAR Spezifikation des elektronischen Heilberufsausweises<br>Teil I: Kommandos, Algorithmen und Funktionen der Betriebssystemplattform, Version 2.3.2, 05.08.2009<br>(Vorgängerversion dieses Dokumentes für Karten der Generation 1)
TR-> TD(13,0/1/1)->PAR [ISO/IEC 7816-3] TD(13,1/1/1)->PAR ISO/IEC 7816-3: 2006 (2<sup>nd</sup> edition),<br>Identification cards — Integrated circuit cards with contacts —<br>Part 3: Electrical interface and transmission protocols
TR-> TD(14,0/1/1)->PAR [ISO/IEC 7816-4] TD(14,1/1/1)->PAR ISO/IEC 7816-4: 2013 (3<sup>rd</sup> edition)<br>Identification cards — Integrated circuit cards —<br>Part 4: Organization, security and commands for interchange
TR-> TD(15,0/1/1)->PAR [ISO/IEC 7816-5] TD(15,1/1/1)->PAR ISO/IEC 7816-5: 2004 (2<sup>nd</sup> edition)<br>Identification cards — Integrated circuit cards —<br>Part 5: Registration of application providers
TR-> TD(16,0/1/1)->PAR [ISO/IEC 7816-8] TD(16,1/1/1)->PAR ISO/IEC 7816-8: 2016 (3<sup>rd</sup> edition)<br>Identification cards — Integrated circuit cards —<br>Part 8: Commands and mechanisms for security operations
TR-> TD(17,0/1/1)->PAR [ISO/IEC 7816-9] TD(17,1/1/1)->PAR ISO/IEC 7816-9: 2004 (2<sup>nd</sup> edition)<br>Identification cards — Integrated circuit cards —<br>Part 9: Commands for card management
TR-> TD(18,0/1/1)->PAR [ISO/IEC 7816-12] TD(18,1/1/1)->PAR ISO/IEC 7816-12: 2005-10-04 (1<sup>st</sup> edition)<br>Identification cards — Integrated circuit cards — Part 12: Cards with contacts — USB electrical interface and operating procedures
TR-> TD(19,0/1/1)->PAR [ISO/IEC 7816-13] TD(19,1/1/1)->PAR ISO/IEC 7816-13: 2007 (1<sup>st</sup> edition)<br>Identification cards — Integrated circuit cards — Part 13: Commands for application management in a multi-application environment
TR-> TD(20,0/1/1)->PAR [ISO/IEC 9796-2] TD(20,1/1/1)->PAR ISO/IEC 9796-2: 2010-12-15 (3<sup>rd</sup> edition)<br>Information technology — Security techniques —<br>Digital signature schemes giving message recovery —<br>Part 2: Integer factorization based mechanisms
TR-> TD(21,0/1/1)->PAR [ISO/IEC 14443-1] TD(21,1/1/1)->PAR ISO/IEC 14443-1: 2016-03 (3<sup>rd</sup> edition)<br>Identification cards — Contactless integrated circuit cards —<br>Proximity cards — Part 1: Physical characteristics
TR-> TD(22,0/1/1)->PAR [ISO/IEC 14443-2] TD(22,1/1/1)->PAR ISO/IEC 14443-2: 2016-07 (3<sup>rd</sup> edition)<br>Identification cards — Contactless integrated circuit cards —<br>Proximity cards — Part 2: Radio frequency power and signal interface
TR-> TD(23,0/1/1)->PAR [ISO/IEC 14443-3] TD(23,1/1/1)->PAR ISO/IEC 14443-3: 2016-06 (3<sup>rd</sup> edition)<br>Identification cards — Contactless integrated circuit cards —<br>Proximity cards — Part 3: Initialization and anticollision
TR-> TD(24,0/1/1)->PAR [ISO/IEC 14443-4] TD(24,1/1/1)->PAR ISO/IEC 14443-4: 2016-06 (3<sup>rd</sup> edition)<br>Identification cards — Contactless integrated circuit cards —<br>Proximity cards — Part 4: Transmission protocol
TR-> TD(25,0/1/1)->PAR [ITU-T X.690] TD(25,1/1/1)->PAR ITU-T X.690, 2008-11, entspricht ISO/IEC 8825-1<br>Information technology – ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)
TR-> TD(26,0/1/1)->PAR [NIST sp800-38a] TD(26,1/1/1)->PAR Section 6.5 of NIST Special Publication 800-38A,<br>Recommendation for Block, Cipher Modes of Operation, Methods and Techniques, Morris Dworkin, December 2001 Edition,<br>http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdfhttp://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
TR-> TD(27,0/1/1)->PAR [PKCS#1] TD(27,1/1/1)->PAR PKCS #1 v2.1: RSA Cryptography Standard, RSA Laboratories, June 14, 2002, ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.pdfftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.pdf
TR-> TD(28,0/1/1)->PAR [RFC2119] TD(28,1/1/1)->PAR Key words for use in RFCs to Indicate Requirement Levels, RFC 2119, March 1997, http://tools.ietf.org/html/rfc2119http://tools.ietf.org/html/rfc2119
TR-> TD(29,0/1/1)->PAR [RFC5639] TD(29,1/1/1)->PAR Elliptic Curve Cryptography (ECC) Brainpool Standard Curves and Curve Generation, RFC 5639, March 2010, http://tools.ietf.org/html/rfc5639http://tools.ietf.org/html/rfc5639
TR-> TD(30,0/1/1)->PAR [BSI-TR-03110-2] TD(30,1/1/1)->PAR Technical Guideline TR-03110-2, Advanced Security Mechanisms for Machine Readable Travel Documents – Part 2 – Extended Access Control Version 2 (EACv2), Password Authenticated Connection Establishment (PACE), and Restricted Identification (RI), Version 2.20, 2015-02-03
TR-> TD(31,0/1/1)->PAR [BSI-TR-03110-3] TD(31,1/1/1)->PAR Technical Guideline TR-03110-3, Advanced Security Mechanisms for Machine Readable Travel Documents – Part 3 – Common Specifications<br>Version 2.20, 2015-02-03
TR-> TD(32,0/1/1)->PAR [BSI-TR-03111] TD(32,1/1/1)->PAR Technical Guideline TR-03111, Elliptic Curve Cryptography,<br>Version 2.10, 2018-06-01
TR-> TD(33,0/1/1)->PAR [BSI-TR-03116-1] TD(33,1/1/1)->PAR Technische Richtlinie BSI TR-03116-1, Kryptographische Vorgaben für Projekte der Bundesregierung, Version 3.20, Datum 21.09.2018, Status: Veröffentlichung, Fassung Semptember 2018
PAR -HEADING(ids=22)22 CosK_537 Asynchrone, gesicherte APDU-Sequenzen (informativ)
PAR -HEADING(ids=22.1)22.1 Einleitung
PAR Gemäß einer Anforderung an das COS der Generation 2 ist es einem Kartenmanagement (CMS) möglich nicht nur synchron, sondern auch asynchron mit Karten der Generation 2 zu kommunizieren. Dieses Papier beleuchtet die diesbezügliche Anforderungslage und zeigt eine technische Umsetzungsmöglichkeit.
PAR -HEADING(ids=22.2)22.2 CMS-Kommunikationsmuster
PAR Hier werden das synchrone und das asynchrone Kommunikationsmuster zwischen einem Kartenmanagement und einer Smartcard aus technischer Sicht betrachtet.
PAR -HEADING(ids=22.2.1)22.2.1 Synchrone Kommunikation zwischen CMS und Smartcard
PAR Das wesentliche Merkmal der synchronen Kommunikation ist, dass der Sender einer Nachricht auf eine Antwort wartet, bevor die nächste Nachricht versendet wird.

PAR Abbildung 13, CosA_88c: Synchrone Kommunikation zwischen CMS und Smartcard
PAR Aus technischer wie aus sicherheitstechnischer Sicht sind hier im Rahmen der synchronen Kommunikation lediglich die beiden Komponenten CMS und Smartcard relevant. Dass die Kommunikationsstrecke über Kartenleser, Router oder Internet führt, ist hier unerheblich. Für Karten der Generation 1 steht am Anfang einer CMS-Prozedur eine gegenseitige Authentisierung mit Sessionkey-Aushandlung. Da an der Sessionkey-Berechnung beide Kommunikationspartner beteiligt sind, ist es erst nach Abschluss der gegenseitigen Authentisierung möglich das vom CMS zu sendende Szenario (Abfolge von Kommando-APDU) mit den ausgehandelten Sessionkeys zu schützen.
PAR -HEADING(ids=22.2.2)22.2.2 Asynchrone Kommunikation zwischen CMS und Smartcard
PAR Das wesentliche Merkmal der asynchronen Kommunikation ist, dass der Sender einer Nachricht nicht auf eine Antwort wartet. Ein Blockieren des Senders bis zum Empfang der zugehörigen Antwort findet nicht statt.

PAR Abbildung 14, CosA_e47: Asynchrone Kommunikation zwischen CMS und Smartcard
PAR Aus technischer, wie aus sicherheitstechnischer Sicht sind hier im Rahmen der asynchronen CMS-Kommunikation drei Komponenten beteiligt:

ORDERED-LIST->
LITEM->PAR Das CMS erstellt Szenarien (Abfolgen von Kommando-APDU) und bietet diese über eine Schnittstelle an (beispielsweise zum Download).LITEM->PAR Ein Puffer besorgt sich zu einem beliebigen späteren Zeitpunkt T1 beliebige Szenarien. Zu einem beliebigen Zeitpunkt T2 (wobei im Allgemeinen T1 ungleich T2 ist) werden ein oder mehrere Szenarien vom Puffer an eine Smartcard geschickt.LITEM->PAR Die Smartcard verarbeitet die Szenarien und erstellt dabei typischerweise "Quittungen", die eine erfolgreiche Verarbeitung anzeigen. Diese "Quittungen" können vom Puffer zu einem beliebigen späteren Zeitpunkt an das CMS übertragen werden.
PAR Für die Komponente Puffer gibt es diverse Realisierungsmöglichkeiten. Im einen Extrem befindet sich der Puffer möglichst nah an der Smartcard, beispielsweise versendet das CMS per Email Szenarien etwa an einen Karteninhaber. Dann wäre "Puffer" aus Sicht des Karteninhabers ein lokales Programm. Im anderen Extrem befindet sich der Puffer möglichst nah am CMS, beispielsweise wäre der Puffer lediglich der per Internet erreichbare Online-Teil des CMS und der übrige CMS Teil (mit sensiblen, personenbezogenen Daten und Schlüsseln) wäre nicht per Internet erreichbar.
PAR -HEADING(ids=22.3)22.3 CosK_edf Anforderungen an die asynchrone Kommunikation
PAR Aus sicherheitstechnischer Sicht werden an die asynchrone Kommunikation folgende Anforderungen gestellt:

ORDERED-LIST->
LITEM->PAR Asynchrone Kommunikation: Es MUSS dem CMS möglich sein komplette Szenarien so vorzuberechnen, dass das CMS beim Einspielen der Szenarien in eine Smartcard nicht beteiligt ist.LITEM->PAR Quittungen: Es MUSS möglich sein, dass die Smartcard für einzelne oder alle Kommando-APDU eines Szenarios Quittungen so erzeugt, dass sich das CMS zweifelsfrei von einer erfolgreichen Kommandobearbeitung überzeugen kann.LITEM->PAR Authentizität: Das CMS MUSS sich zweifelsfrei als Quelle eines Szenarios und jeder einzelnen Kommando-APDU innerhalb eines Szenarios identifizieren lassen.LITEM->PAR Integrität eines Szenarios: Jede Veränderung eines Szenarios und jeder einzelnen Kommando-APDU MUSS sicher erkennbar sein. Typische Veränderungen sind:
ORDERED-LIST->
LITEM->PAR Verändern einer einzelnen Kommando-APDULITEM->PAR Hinzufügen beliebiger Kommando-APDU (auch Duplizieren von Kommando-APDU)LITEM->PAR Weglassen beliebiger Kommando-APDULITEM->PAR Verändern der Reihenfolge von Kommando-APDULITEM->PAR Vertraulichkeit: Es MUSS möglich sein, die Vertraulichkeit von Informationen zu gewährleisten, die in einem Szenario transportiert werden.LITEM->PAR Reihenfolge von Szenarien: Es MUSS möglich sein, die Reihenfolge von Szenarien vorzugeben, beispielsweise: Szenario_B nur, wenn auch Szenario_A durchgeführt wurde. Relevant wird diese Anforderung etwa dann, wenn zunächst eine Anwendung geladen wird und später die Anwendungsdaten aktualisiert werden. Eine Aktualisierung von Anwendungsdaten ist nur dann sinnvoll, wenn die Anwendung geladen wurde.LITEM->PAR Resistenz gegen Replay Attacken: Es ist auszuschließen, dass ein Szenario ein zweites Mal erfolgreich durchgeführt wird.LITEM->PAR Überspringen von Szenarien: Es MUSS dem CMS möglich sein Szenarien als obsolet zu kennzeichnen. Relevant wird diese Anforderung etwa dann, wenn sich Anwendungsdaten regelmäßig oder rasch ändern. Anstatt dann zunächst veraltete Szenarien an die Smartcard zu schicken, ist es dann möglich gleich das aktuelle Szenario auszuführen. Konkret:
ORDERED-LIST->
LITEM->PAR Regelmäßige Änderung von Anwendungsdaten: CV-Zertifikate mit Gültigkeitszeiträumen von wenigen Tagen sind regelmäßig zu aktualisieren. Nach einem mehrwöchigen Urlaub ist es sinnvoller gleich das aktuelle CV-Zertifikat zu laden und alle während des Urlaubs angefallenen Zwischenschritte der CVC-Aktualisierung zu überspringen.LITEM->PAR Rasche Änderung von Anwendungsdaten: In gewissen Situationen ändern sich die Versichertendaten möglicherweise mehrmals kurz hintereinander (etwa ändere sich durch eine Heirat zunächst der Familienstatus und durch den Bezug einer gemeinsamen Wohnung dann die Adresse, oder nach Abschluss einer Ausbildung / Studium ändert sich zunächst der Versichertenstatus und dann durch einen Wohnortwechsel im Zusammenhang mit einer Arbeitsaufnahme die Adresse, etc.). Dann erscheint es sinnvoller veraltete Szenarien zu überspringen.
PAR -HEADING(ids=22.4)22.4 Lösungskonzept
PAR Zur Umsetzung der in CosK_edf vorgeschlagenen Anforderungen wird folgendes Konzept vorgeschlagen:

ORDERED-LIST->
LITEM->PAR Kryptographisches Material: Sowohl CMS, als auch jede vom CMS betreute Smartcard verfügen über kryptographisches Material. Das CMS weist damit seine Authentizität nach (Anforderung Authentizität). Zudem wird es zum sicheren Transport von Sessionkeys hin zur Smartcard verwendet (Anforderung asynchrone Kommunikation). Sessionkeys und SendSequenceCounter schützen die Kommando-APDU (Anforderungen Authentizität, Integrität eines Szenarios, Vertraulichkeit) eines Szenarios sowie die Antwort-APDU einer Smartcard (Anforderung Quittungen).LITEM->PAR NumberScenario: Jedem Szenario wird vom CMS eine natürliche Zahl zugeordnet. Die Zuordnung zwischen Szenario und NumberScenario MUSS bijektiv (d.h. umkehrbar eindeutig) sein.LITEM->PAR NumberPrecondition: Jedem Szenario wird vom CMS eine weitere natürliche Zahl oder die null zugeordnet. Diese gibt an, welches Szenario als Vorbedingung in eine Smartcard geladen worden sein muss, damit dieses Szenario akzeptiert wird (siehe Beispiel) (Anforderung Reihenfolge von Szenarien, Überspringen von Szenarien).LITEM->PAR Die Smartcard speichert NumberScenario eines Szenarios. Szenarien MÜSSEN so an die Smartcard geschickt werden, dass ihr NumberScenario streng monoton steigt (Anforderungen Resistent gegen Replay Attacken). Zudem MUSS NumberPrecondition eines Szenarios kleiner oder gleich dem in der Smartcard gespeicherten Wert von NumberScenario sein (Anforderung Reihenfolge von Szenarien, Überspringen von Szenarien).
PAR Im folgenden Beispiel gelte folgende Notation: S<sub>NumberPrecondition</sub>(NumberScenario). Dem Szenario S wird damit die natürliche Zahl NumberScenario und die Vorbedingung NumberPrecondition zugeordnet. Die folgende Tabelle stellt eine Chronologie dar, wobei die Zeit mit der Zeilennummer zunehme. Die Spalte CMS enthält Szenarien, die vom CMS zum betrachteten Zeitpunkt bereitgestellt werden. Die Spalte Puffer enthält die dort gespeicherten Szenarien. Szenarien sind grün hinterlegt, wenn sie von einer Smartcard akzeptiert werden und rot hinterlegt, wenn sie von einer Smartcard wegen unpassender NumberPrecondition oder unpassender NumberScenario nicht akzeptiert werden. Gelb hinterlegte Szenarien werden im betrachteten Zeitpunkt an die Smartcard geschickt.
PAR (ids=Tabelle-401,-CosT_039)Tabelle 401, CosT_039: Beispiel der zeitlichen Abfolge asynchroner Administration

TABLE(rows=10,cols=34+38+127+542)->
TR-> TH(0,0/1/1)->PAR CMS TH(0,1/1/1)->PAR Puffer TH(0,2/1/1)->PAR Smartcard TH(0,3/1/1)->PAR Bemerkung
TR-> TD(1,0/1/1)->PAR - TD(1,1/1/1)->PAR - TD(1,2/1/1)->PAR NumberScenario = 0 TD(1,3/1/1)->PAR Zu einem bestimmten Zeitpunkt sei eine Smartcard im Feld und der Wert von NumberScenario sei 0.
TR-> TD(2,0/1/1)->PAR S<sub>0</sub>(1) TD(2,1/1/1)->PAR S<sub>0</sub>(1) TD(2,2/1/1)->PAR - TD(2,3/1/1)->PAR Das CMS stellt ein Szenario zur Verfügung, welches vom Puffer heruntergeladen werde. Die Smartcard ist inaktiv.
TR-> TD(3,0/1/1)->PAR S<sub>0</sub>(2) TD(3,1/1/1)->PAR S<sub>0</sub>(1)<br>S<sub>0</sub>(2) TD(3,2/1/1)->PAR - TD(3,3/1/1)->PAR Das CMS ersetzt S<sub>0</sub>(1) durch S<sub>0</sub>(2). Durch das Ersetzen und da NumberPrecondition unverändert auf 0 steht wird S<sub>0</sub>(1) als obsolet gekennzeichnet. Der Puffer lädt zusätzlich S<sub>0</sub>(2) herunter. Die Smartcard ist inaktiv.
TR-> TD(4,0/1/1)->PAR S<sub>0</sub>(2)<br>S<sub>2</sub>(3) TD(4,1/1/1)->PAR S<sub>0</sub>(1)<br>S<sub>0</sub>(2)<br>S<sub>2</sub>(3) TD(4,2/1/1)->PAR - TD(4,3/1/1)->PAR Das CMS stellt S<sub>2</sub>(3) zusätzlich zu S<sub>0</sub>(2) zur Verfügung und der Puffer lädt auch dieses herunter. NumberPrecondition in S<sub>2</sub>(3) ist so gesetzt, dass erst S<sub>0</sub>(2) eingespielt werden muss, bevor S<sub>2</sub>(3) einspeilbar ist. Die Smartcard ist weiter inaktiv.
TR-> TD(5,0/1/1)->PAR S<sub>0</sub>(2)<br>S<sub>2</sub>(4) TD(5,1/1/1)->PAR S<sub>0</sub>(1)<br>S<sub>0</sub>(2)<br>S<sub>2</sub>(3)<br>S<sub>2</sub>(4) TD(5,2/1/1)->PAR - TD(5,3/1/1)->PAR Das CMS ersetzt S<sub>2</sub>(3) durch S<sub>2</sub>(4). Durch das Ersetzen und da NumberPrecondition unverändert auf 2 steht, wird S<sub>2</sub>(3) als obsolet gekennzeichnet. Der Puffer lädt zusätzlich S<sub>2</sub>(4) herunter. Die Smartcard ist inaktiv.
TR-> TD(6,0/1/1)->PAR S<sub>0</sub>(2)<br>S<sub>2</sub>(4) TD(6,1/1/1)->PAR S<sub>0</sub>(1)<br>S<sub>0</sub>(2)<br>S<sub>2</sub>(3)<br>S<sub>2</sub>(4) TD(6,2/1/1)->PAR S<sub>0</sub>(1) zur Karte<br>NumberScenario = 1 TD(6,3/1/1)->PAR Der Puffer schicke S<sub>0</sub>(1) an die Smartcard. Dies ist suboptimal (aber unschädlich), da S<sub>0</sub>(1) durch S<sub>0</sub>(2) obsolet wurde.
TR-> TD(7,0/1/1)->PAR S<sub>0</sub>(2)<br>S<sub>2</sub>(4) TD(7,1/1/1)->PAR S<sub>0</sub>(1)<br>S<sub>0</sub>(2)<br>S<sub>2</sub>(3)<br>S<sub>2</sub>(4) TD(7,2/1/1)->PAR S<sub>0</sub>(2) zur Karte<br>NumberScenario = 2 TD(7,3/1/1)->PAR Der Puffer schicke das einzig akzeptable Szenario S<sub>0</sub>(2) an die Smartcard.<br>S<sub>0</sub>(1) ist nicht akzeptabel, weil dessen NumberScenario nicht größer ist als NumberScenario der Smartcard.<br>S<sub>2</sub>(3) ist nicht akzeptabel, da dessen NumberPrecondition nicht kleiner ist als NumberScenario der Smartcard.
TR-> TD(8,0/1/1)->PAR S<sub>0</sub>(2)<br>S<sub>2</sub>(4) TD(8,1/1/1)->PAR S<sub>0</sub>(1)<br>S<sub>0</sub>(2)<br>S<sub>2</sub>(3)<br>S<sub>2</sub>(4) TD(8,2/1/1)->PAR S<sub>2</sub>(4) zur Karte<br>NumberScenario = 4 TD(8,3/1/1)->PAR Diesmal arbeite der Puffer optimal und schicke das aktuellste akzeptable Szenario an die Smartcard.<br>Zudem schicke der Puffer nach Abschluss des Szenarios die zu S<sub>2</sub>(4) gehörende Quittung an das CMS.
TR-> TD(9,0/1/1)->PAR - TD(9,1/1/1)->PAR S<sub>0</sub>(1)<br>S<sub>0</sub>(2)<br>S<sub>2</sub>(3)<br>S<sub>2</sub>(4) TD(9,2/1/1)->PAR NumberScenario = 4 TD(9,3/1/1)->PAR Nach Empfang der Quittung können die Szenarien aus dem Downloadbereich des CMS entfernt werden.<br>Keines der bisher vom CMS bereitgestellten Szenarien ist für die Smartcard akzeptabel.
PAR -HEADING(ids=22.5)22.5 Kryptographie
PAR Zur Erfüllung der in CosK_edf genannten kryptographischen Anforderungen werden symmetrische und asymmetrische Authentisierungsschlüssel verwendet.
PAR -HEADING(ids=22.5.1)22.5.1 CMS Aktivitäten
PAR Auf Seiten des CMS ist der Ablauf wie folgt:

ORDERED-LIST->
LITEM->PAR Erstellen des gesicherten Szenarios, hierfür sind keine kartenindividuellen Informationen erforderlich:
ORDERED-LIST->
LITEM->PAR Zu Zwecken des Kartenmanagements wird eine Sequenz von ungesicherten Kommando-APDU erstellt.LITEM->PAR Das CMS erzeugt einen Seed zur Ableitung von AES-Sessionkeys und entsprechenden Werten für die SendSequenceCounter für die CMAC-Berechnung.LITEM->PAR Die ungesicherten Kommando-APDU werden mittels der Sessionkeys und SendSequenceCounter konform zu CosK_7f6 gesichert.LITEM->PAR Kartenindividuelles Szenario:
ORDERED-LIST->
LITEM->PAR Das CMS besorgt sich (aus einer Datenbank oder ähnlichem) kartenspezifische Werte für ICCSN, NumberPrecondition, NumberScenario und das Schlüsselmaterial:
ORDERED-LIST->
LITEM->PAR symmetrische Administration:      SK.CMS_ENC,          SK.CMS_MAC.LITEM->PAR asymmetrische Administration:    PuK.SmartCard.AUT,  PrK.CMS, PuK.CMS.LITEM->PAR Der Seed aus Schritt 16)b) wird verschlüsselt:
ORDERED-LIST->
LITEM->PAR symmetrische Administration:    <br>cipherText = AES_CBC_ENC( SK.CMS_ENC, ICV='00…00', Seed ).LITEM->PAR asymmetrische Administration:
ORDERED-LIST->
LITEM->PAR ( PO<sub>A</sub>, C, T )         = ELC_ENC( Seed, PuK.SmartCard.AUT, PuK.CMS.dP )LITEM->PAR Setze   oidDO        = '06 – L<sub>06 </sub>– affectedObject.domainParameter.OID'.LITEM->PAR Setze   keyDO       = '7F49 – L<sub>7F49</sub> – ( 86 – L<sub>86</sub> – PO<sub>A</sub> )'.LITEM->PAR Setze   cipherDO   = '86 – L<sub>86</sub> – ( 02   ||   C )'.LITEM->PAR Setze   macDO      = '8E – L<sub>8E</sub> – T '.LITEM->PAR Setze   cipherText  = 'A6 – L<sub>A6</sub> – ( oidDO || keyDO || cipherDO || macDO ) '.LITEM->PAR Es wird eine Nachricht M wie folgt zusammengestellt:    <br>M   =   NumberPrecondition   ||   NumberScenario   ||   cipherText.LITEM->PAR Für die Nachricht M werden Authentisierungsdaten berechnet:
ORDERED-LIST->
LITEM->PAR symmetrische Administration: Es wird ein CMAC für M berechnet:    <br>CMAC = CalculateCMAC_IsoPadding( SK.CMS_MAC, M ).LITEM->PAR asymmetrische Administration: Es wird eine Signatur für M berechnet:
ORDERED-LIST->
LITEM->PAR Wenn PrK.CMS.dP = brainpool256   =>   hash = SHA_256( M ).LITEM->PAR Wenn PrK.CMS.dP = brainpool384   =>   hash = SHA_384( M ).LITEM->PAR Wenn PrK.CMS.dP = brainpool512   =>   hash = SHA_512( M ).LITEM->PAR ( R, S ) = ELC_SIG( PrK.CMS, hash )LITEM->PAR SIG = R || S.LITEM->PAR Eine Authentisierungssequenz mit M und CMAC bzw. SIG wird dem Szenario aus Schritt 16)c) vorangestellt.
PAR -HEADING(ids=22.5.2)22.5.2 Puffer-Aktivitäten
PAR Auf Seiten des Puffers ist der Ablauf im Gutfall wie folgt:

ORDERED-LIST->
LITEM->PAR Der Puffer ermittelt von einer Smartcard die Werte ICCSN und NumberScenario.LITEM->PAR Der Puffer wählt ein passendes Szenario aus.LITEM->PAR Der Puffer schickt das ausgewählte Szenario an die Smartcard.LITEM->PAR Der Puffer schickt die gesicherten Antwort-APDU zusammen mit ICCSN und NumberScenario als Quittung an das CMS.
PAR -HEADING(ids=22.5.3)22.5.3 Smartcard-Aktivitäten
PAR Auf Seiten der Smartcard ist der Ablauf wie folgt:

ORDERED-LIST->
LITEM->PAR Schlüsselauswahl: Zu Beginn des Szenarios werden ein passendes Schlüsselobjekt und ein passender Algorithmus ausgewählt (etwa durch ein MANAGE SECURITY ENVIRONMENT Set-Kommando).LITEM->PAR Authentisierung: Die Authentisierungssequenz aus Schritt 17)e) folgt im Szenario als nächstes. Dabei werden M und CMAC bzw. SIG übertragen und in der Smartcard wie folgt verarbeitet:
ORDERED-LIST->
LITEM->PAR Der CMAC bzw. SIG wird überprüft. Ein unpassender CMAC oder eine fehlerhafte Signatur führt zum Kommandoabbruch.LITEM->PAR Der Nachricht M werden NumberPrecondition, NumberScenario und cipherText entnommen.
ORDERED-LIST->
LITEM->PAR Wenn NumberPrecondition in M größer als SK.CMSnumberScenario bzw. PrK.SmartCard.AUTnumberScenario ist, dann führt dies zum Kommandoabbruch.LITEM->PAR Wenn NumberScenario in M kleiner oder gleich SK.CMSnumberScenario bzw. PrK.SmartCard.AUTnumberScenario ist, dann führt dies zum Kommandoabbruch.LITEM->PAR SK.CMSnumberScenario bzw. PrK.SmartCard.AUTnumberScenario wird mit Transaktionsschutz auf den Wert von NumberScenario aus M gesetzt.LITEM->PAR cipherText wird mittels SK.CMS_ENC bzw. PrK.SmartCard.AUT entschlüsselt und Seed wird zum Berechnen von Sessionkeymaterial inklusive SendSequenceCountern verwendet.LITEM->PAR Kartenmanagementkommanods: Die übrigen, Secure Messaging gesicherten Kommando-APDU werden an die Smartcard geschickt. Secure-Messaging-Fehler führen (wie üblich) zum Kommandoabbruch.
PAR -HEADING(ids=22.6)22.6 Auswirkungen auf die Kommandoschnittstelle
PAR Das hier vorgestellte Konzept der asynchronen Kommunikation zwischen CMS und Smartcard wirkt sich an zwei Stellen auf die Smartcard aus: Zum einen muss es dem Puffer möglich sein NumberScenario aus der Smartcard auszulesen, damit das passende Szenario ausgewählt werden kann. Zum anderen gilt es den Sessionkeykontext in der Smartcard zu etablieren.

ORDERED-LIST->
LITEM->PAR RESET der SmartcardLITEM->PAR MANAGE SECURITY ENVIRONMENT Set:
ORDERED-LIST->
LITEM->PAR P1P2='81A4',LITEM->PAR keyReference = SK.CMS oder PrK.SmartCard.AUT,LITEM->PAR algID=asynchroneCMSLITEM->PAR GENERAL AUTHENTICATE Datenfeld so, dass NumberScenario von der Smartcard angefordert wird.LITEM->PAR GENERAL AUTHENTICATE Datenfeld mit M und CMAC (oder M und Signatur), ein passender CMAC (bzw. eine gültige Signatur) setzt einen Sicherheitszustand. Mit den Informationen aus M werden Sessionkeys und SendSequenceCounter eingerichtet.LITEM->PAR Der Rest des Szenarios wird mit Secure Messaging geschützt an die Smartcard geschickt.
PAR -HEADING(ids=23)23 CosK_f38 Speichern öffentlicher Schlüssel (informativ)
PAR Dieser Anhang beschreibt, wie öffentliche Schlüsselobjekte (siehe CosK_cb7) bezüglich ihrer Einordnung in ein Objektsystem in diesem Dokument betrachtet werden. Einerseits werden öffentliche Schlüsselobjekte genau so wie andere Objekte auch einem Ordner zugeordent und damit in die Objektsystemhierarchie eingeordnet wie die übrigen Objekte. Zudem werden sie aus funktionaler Sicht analog zu anderen Schlüsselobjekten mittles MANAGE SECURITY ENVIRONMENT selektiert und im Rahmen einer Kommandobearbeitung gesucht und angesprochen. Andererseits werden bestimmte öffentliche Schlüsselobjekte mittels CV-Zertifikaten dynamisch zur Laufzeit in eine Smartcard importiert und es wäre unpassend, wenn dadurch der gesamte freie Speicher verbraucht würde. Deshalb ist das Importieren mittels CV-Zertifikaten aus Sicht des Speichermanagements anders zu betrachten, als etwa das Einbringen neuer Objekte mittels LOAD APPLICATION.
PAR Dieser Anhang und die normativen Teile dieses Dokumentes beschreiben öffentliche Schlüsselobjekte aus diversen Perspektiven mit dem Ziel die Funktionalität an der äußeren Kartenschnittstelle zu verdeutlichen und normativ festzuschreiben. Hier, wie auch im Rest des Dokumentes, ist es nicht das Ziel eine bestimmte Implementierung zu fordern oder zu präferieren.
PAR -HEADING(ids=23.1)23.1 Definitionen
PAR allPublicKeyList: Ist die Vereinigungsmenge von applicationPublicKeyList und Cache.
PAR applicationPublicKeyList, (N019.900)d: Liste zur persistenten Speicherung von öffentlichen Schlüsselobjekten der Anwendungen. Im Rahmen dieser Betrachtung sind das öffentliche Schlüsselobjekte, die im Rahmen einer Initialisierung oder als Teil einer Ordnerstruktur mittels LOAD APPLICATION in die Smartcard geladen werden.
PAR Cache: Bereich zur temporären, möglicherweise persistenten Speicherung von Schlüsselobjekten, die mittels CV-Zertifikaten importiert wurden. Vereinigungsmenge von persistentCache und volatileCache.
PAR CA-Schlüssel: Öffentlicher Signaturprüfschlüssel einer CVC-Sub-CA, welcher mittels CV-Zertifikat in eine Karte importiert wird.
PAR EE-Schlüssel: Öffentlicher Authentisierungsschlüssel eines Endnutzers (End-Entity), welcher mittels CV-Zertifikat in eine Karte importiert wird.
PAR persistentCache, (N019.900)e: Teil des Cache der persistent gespeichert ist.
PAR persistentPublicKeyList: Vereinigungsmenge von applicationPublicKeyList und persistentCache.
PAR Sicherheitsanker: Öffentliches Signaturprüfobjekt, welches den öffentlichen Schlüssel einer CVC-Root-CA enthält. Typischerweise werden Sicherheitsanker im Rahmen einer Initialisierung oder Personalisierung in eine Smartcard geladen. Zusätzlich ist es möglich Sicherheitsanker mittels Link-Zertifikaten in die Karte zu importieren.
PAR volatileCache, (N019.900)g: Teil des Cache der volatil gespeichert ist.

PAR Abbildung 15, CosA_85c: Zusammenhang Schlüsselspeicher
PAR -HEADING(ids=23.2)23.2 Perspektiven
PAR Aus der Perspektive der Kommandobearbeitung wird in diversen Kommandos zunächst nach einem Objekt gesucht, auf welches sich das Kommando bezieht. Bezogen auf öffenliche Schlüsselobjekte fasst dieses Dokument alle öffentlichen Schlüsselobjekte in einer Liste allPublicKeyList zusammen.
PAR Aus der Perspektive des Nachladens von Ordnern mittels LOAD APPLICATION werden öffentliche Schlüsselobjekte, die im Ordner enthalten sind, in der Sichtweise dieses Dokumentes applicationPublicKeyList hinzugefügt. Es wird davon ausgegangen, dass applicationPublicKeyList nur eine begrenzte Kapazität hat. Deshalb ist es denkbar, dass ein LOAD APPLICATION aus Platzmangel scheitert, wenn die Menge der nachgeladenen Schlüsselobjekte die Kapazität von applicationPublicKeyList übersteigt.
PAR Aus der Perspektive des Importes mittels CV-Zertifikaten werden importiere Schlüssel dem Cache hinzugefügt. Es wird davon ausgegangen, dass der Cache nur eine begrenzte Kapazität hat. Wenn die Menge an importierten Schlüsseln die Kapazität des Cache übersteigt, dann werden "unwichtige" Einträge aus dem Cache entfernt um Platz für den importierten Schlüssel zu schaffen.
